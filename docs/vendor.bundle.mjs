var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all2) => {
  for (var name5 in all2)
    __defProp(target, name5, { get: all2[name5], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod2, secondTarget) => (__copyProps(target, mod2, "default"), secondTarget && __copyProps(secondTarget, mod2, "default"));
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet(obj, member, value2, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});

// ../../node_modules/denque/index.js
var require_denque = __commonJS({
  "../../node_modules/denque/index.js"(exports, module) {
    "use strict";
    function Denque2(array, options2) {
      var options2 = options2 || {};
      this._capacity = options2.capacity;
      this._head = 0;
      this._tail = 0;
      if (Array.isArray(array)) {
        this._fromArray(array);
      } else {
        this._capacityMask = 3;
        this._list = new Array(4);
      }
    }
    Denque2.prototype.peekAt = function peekAt(index) {
      var i2 = index;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i2 >= len || i2 < -len) return void 0;
      if (i2 < 0) i2 += len;
      i2 = this._head + i2 & this._capacityMask;
      return this._list[i2];
    };
    Denque2.prototype.get = function get(i2) {
      return this.peekAt(i2);
    };
    Denque2.prototype.peek = function peek() {
      if (this._head === this._tail) return void 0;
      return this._list[this._head];
    };
    Denque2.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque2.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque2.prototype, "length", {
      get: function length4() {
        return this.size();
      }
    });
    Denque2.prototype.size = function size() {
      if (this._head === this._tail) return 0;
      if (this._head < this._tail) return this._tail - this._head;
      else return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.unshift = function unshift(item) {
      if (arguments.length === 0) return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head) this._growArray();
      if (this._capacity && this.size() > this._capacity) this.pop();
      if (this._head < this._tail) return this._tail - this._head;
      else return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail) return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2) this._shrinkArray();
      return item;
    };
    Denque2.prototype.push = function push(item) {
      if (arguments.length === 0) return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail) return this._tail - this._head;
      else return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque2.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head) return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2) this._shrinkArray();
      return item;
    };
    Denque2.prototype.removeOne = function removeOne(index) {
      var i2 = index;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      if (this._head === this._tail) return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i2 >= size || i2 < -size) return void 0;
      if (i2 < 0) i2 += size;
      i2 = this._head + i2 & this._capacityMask;
      var item = this._list[i2];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i2] = this._list[i2 = i2 - 1 + len & this._capacityMask];
        }
        this._list[i2] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i2] = this._list[i2 = i2 + 1 + len & this._capacityMask];
        }
        this._list[i2] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque2.prototype.remove = function remove(index, count) {
      var i2 = index;
      var removed;
      var del_count = count;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      if (this._head === this._tail) return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i2 >= size || i2 < -size || count < 1) return void 0;
      if (i2 < 0) i2 += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i2);
        return removed;
      }
      if (i2 === 0 && i2 + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i2 + count > size) count = size - i2;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i2 + k & this._capacityMask];
      }
      i2 = this._head + i2 & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i2 < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i2 = i2 - 1 + len & this._capacityMask]);
        }
        i2 = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i2 = i2 - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0) this._tail = i2;
      } else {
        this._tail = i2;
        i2 = i2 + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i2++]);
        }
        i2 = this._tail;
        while (del_count > 0) {
          this._list[i2 = i2 + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2) this._shrinkArray();
      return removed;
    };
    Denque2.prototype.splice = function splice(index, count) {
      var i2 = index;
      if (i2 !== (i2 | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i2 < 0) i2 += size;
      if (i2 > size) return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i2 < size / 2) {
          temp = new Array(i2);
          for (k = 0; k < i2; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i2 > 0) {
              this._head = this._head + i2 + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i2, count);
            this._head = this._head + i2 + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i2; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i2 + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i2 + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i2 != size) {
              this._tail = this._head + i2 + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i2, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i2, count);
      }
    };
    Denque2.prototype.clear = function clear() {
      this._list = new Array(this._list.length);
      this._head = 0;
      this._tail = 0;
    };
    Denque2.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque2.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque2.prototype._fromArray = function _fromArray(array) {
      var length4 = array.length;
      var capacity = this._nextPowerOf2(length4);
      this._list = new Array(capacity);
      this._capacityMask = capacity - 1;
      this._tail = length4;
      for (var i2 = 0; i2 < length4; i2++) this._list[i2] = array[i2];
    };
    Denque2.prototype._copyArray = function _copyArray(fullCopy, size) {
      var src2 = this._list;
      var capacity = src2.length;
      var length4 = this.length;
      size = size | length4;
      if (size == length4 && this._head < this._tail) {
        return this._list.slice(this._head, this._tail);
      }
      var dest = new Array(size);
      var k = 0;
      var i2;
      if (fullCopy || this._head > this._tail) {
        for (i2 = this._head; i2 < capacity; i2++) dest[k++] = src2[i2];
        for (i2 = 0; i2 < this._tail; i2++) dest[k++] = src2[i2];
      } else {
        for (i2 = this._head; i2 < this._tail; i2++) dest[k++] = src2[i2];
      }
      return dest;
    };
    Denque2.prototype._growArray = function _growArray() {
      if (this._head != 0) {
        var newList = this._copyArray(true, this._list.length << 1);
        this._tail = this._list.length;
        this._head = 0;
        this._list = newList;
      } else {
        this._tail = this._list.length;
        this._list.length <<= 1;
      }
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque2.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    Denque2.prototype._nextPowerOf2 = function _nextPowerOf2(num2) {
      var log22 = Math.log(num2) / Math.log(2);
      var nextPow2 = 1 << log22 + 1;
      return Math.max(nextPow2, 4);
    };
    module.exports = Denque2;
  }
});

// ../../node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "../../node_modules/netmask/lib/netmask.js"(exports) {
    (function() {
      var Netmask2, atob2, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a2, b, c2, d2;
        a2 = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c2 = (long & 255 << 8) >>> 8;
        d2 = long & 255;
        return [a2, b, c2, d2].join(".");
      };
      ip2long = function(ip) {
        var b, c2, i2, j, n2, ref;
        b = [];
        for (i2 = j = 0; j <= 3; i2 = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i2 > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob2(ip), n2 = ref[0], c2 = ref[1];
          ip = ip.substring(c2);
          b.push(n2);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob2 = function(s2) {
        var base3, dmax, i2, n2, start2;
        n2 = 0;
        base3 = 10;
        dmax = "9";
        i2 = 0;
        if (s2.length > 1 && s2[i2] === "0") {
          if (s2[i2 + 1] === "x" || s2[i2 + 1] === "X") {
            i2 += 2;
            base3 = 16;
          } else if ("0" <= s2[i2 + 1] && s2[i2 + 1] <= "9") {
            i2++;
            base3 = 8;
            dmax = "7";
          }
        }
        start2 = i2;
        while (i2 < s2.length) {
          if ("0" <= s2[i2] && s2[i2] <= dmax) {
            n2 = n2 * base3 + (chr(s2[i2]) - chr0) >>> 0;
          } else if (base3 === 16) {
            if ("a" <= s2[i2] && s2[i2] <= "f") {
              n2 = n2 * base3 + (10 + chr(s2[i2]) - chra) >>> 0;
            } else if ("A" <= s2[i2] && s2[i2] <= "F") {
              n2 = n2 * base3 + (10 + chr(s2[i2]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n2 > 4294967295) {
            throw new Error("too large");
          }
          i2++;
        }
        if (i2 === start2) {
          throw new Error("empty octet");
        }
        return [n2, i2];
      };
      Netmask2 = (function() {
        function Netmask3(net, mask) {
          var error, i2, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i2 = j = 32; j >= 0; i2 = --j) {
              if (this.maskLong === 4294967295 << 32 - i2 >>> 0) {
                this.bitmask = i2;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask3.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask3(ip);
          }
          if (ip instanceof Netmask3) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask3.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask3.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask3.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask3;
      })();
      exports.ip2long = ip2long;
      exports.long2ip = long2ip;
      exports.Netmask = Netmask2;
    }).call(exports);
  }
});

// ../../node_modules/p-queue/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../node_modules/p-queue/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener2(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names2 = [], events, name5;
      if (this._eventsCount === 0) return names2;
      for (name5 in events = this._events) {
        if (has.call(events, name5)) names2.push(prefix ? name5.slice(1) : name5);
      }
      if (Object.getOwnPropertySymbols) {
        return names2.concat(Object.getOwnPropertySymbols(events));
      }
      return names2;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length4 = listeners.length, j;
        for (i2 = 0; i2 < length4; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener2(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener2(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length4 = listeners.length; i2 < length4; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// ../../node_modules/@libp2p/http/node_modules/cookie/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@libp2p/http/node_modules/cookie/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCookie = parseCookie;
    exports.parse = parseCookie;
    exports.stringifyCookie = stringifyCookie;
    exports.stringifySetCookie = stringifySetCookie;
    exports.serialize = stringifySetCookie;
    exports.parseSetCookie = parseSetCookie;
    exports.stringifySetCookie = stringifySetCookie;
    exports.serialize = stringifySetCookie;
    var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
    var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
    var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
    var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
    var maxAgeRegExp = /^-?\d+$/;
    var __toString = Object.prototype.toString;
    var NullObject = /* @__PURE__ */ (() => {
      const C = function() {
      };
      C.prototype = /* @__PURE__ */ Object.create(null);
      return C;
    })();
    function parseCookie(str, options2) {
      const obj = new NullObject();
      const len = str.length;
      if (len < 2)
        return obj;
      const dec = options2?.decode || decode14;
      let index = 0;
      do {
        const eqIdx = eqIndex(str, index, len);
        if (eqIdx === -1)
          break;
        const endIdx = endIndex(str, index, len);
        if (eqIdx > endIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const key = valueSlice(str, index, eqIdx);
        if (obj[key] === void 0) {
          obj[key] = dec(valueSlice(str, eqIdx + 1, endIdx));
        }
        index = endIdx + 1;
      } while (index < len);
      return obj;
    }
    function stringifyCookie(cookie2, options2) {
      const enc = options2?.encode || encodeURIComponent;
      const cookieStrings = [];
      for (const name5 of Object.keys(cookie2)) {
        const val = cookie2[name5];
        if (val === void 0)
          continue;
        if (!cookieNameRegExp.test(name5)) {
          throw new TypeError(`cookie name is invalid: ${name5}`);
        }
        const value2 = enc(val);
        if (!cookieValueRegExp.test(value2)) {
          throw new TypeError(`cookie val is invalid: ${val}`);
        }
        cookieStrings.push(`${name5}=${value2}`);
      }
      return cookieStrings.join("; ");
    }
    function stringifySetCookie(_name, _val, _opts) {
      const cookie2 = typeof _name === "object" ? _name : { ..._opts, name: _name, value: String(_val) };
      const options2 = typeof _val === "object" ? _val : _opts;
      const enc = options2?.encode || encodeURIComponent;
      if (!cookieNameRegExp.test(cookie2.name)) {
        throw new TypeError(`argument name is invalid: ${cookie2.name}`);
      }
      const value2 = cookie2.value ? enc(cookie2.value) : "";
      if (!cookieValueRegExp.test(value2)) {
        throw new TypeError(`argument val is invalid: ${cookie2.value}`);
      }
      let str = cookie2.name + "=" + value2;
      if (cookie2.maxAge !== void 0) {
        if (!Number.isInteger(cookie2.maxAge)) {
          throw new TypeError(`option maxAge is invalid: ${cookie2.maxAge}`);
        }
        str += "; Max-Age=" + cookie2.maxAge;
      }
      if (cookie2.domain) {
        if (!domainValueRegExp.test(cookie2.domain)) {
          throw new TypeError(`option domain is invalid: ${cookie2.domain}`);
        }
        str += "; Domain=" + cookie2.domain;
      }
      if (cookie2.path) {
        if (!pathValueRegExp.test(cookie2.path)) {
          throw new TypeError(`option path is invalid: ${cookie2.path}`);
        }
        str += "; Path=" + cookie2.path;
      }
      if (cookie2.expires) {
        if (!isDate(cookie2.expires) || !Number.isFinite(cookie2.expires.valueOf())) {
          throw new TypeError(`option expires is invalid: ${cookie2.expires}`);
        }
        str += "; Expires=" + cookie2.expires.toUTCString();
      }
      if (cookie2.httpOnly) {
        str += "; HttpOnly";
      }
      if (cookie2.secure) {
        str += "; Secure";
      }
      if (cookie2.partitioned) {
        str += "; Partitioned";
      }
      if (cookie2.priority) {
        const priority = typeof cookie2.priority === "string" ? cookie2.priority.toLowerCase() : void 0;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError(`option priority is invalid: ${cookie2.priority}`);
        }
      }
      if (cookie2.sameSite) {
        const sameSite = typeof cookie2.sameSite === "string" ? cookie2.sameSite.toLowerCase() : cookie2.sameSite;
        switch (sameSite) {
          case true:
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError(`option sameSite is invalid: ${cookie2.sameSite}`);
        }
      }
      return str;
    }
    function parseSetCookie(str, options2) {
      const dec = options2?.decode || decode14;
      const len = str.length;
      const endIdx = endIndex(str, 0, len);
      const eqIdx = eqIndex(str, 0, endIdx);
      const setCookie = eqIdx === -1 ? { name: "", value: dec(valueSlice(str, 0, endIdx)) } : {
        name: valueSlice(str, 0, eqIdx),
        value: dec(valueSlice(str, eqIdx + 1, endIdx))
      };
      let index = endIdx + 1;
      while (index < len) {
        const endIdx2 = endIndex(str, index, len);
        const eqIdx2 = eqIndex(str, index, endIdx2);
        const attr = eqIdx2 === -1 ? valueSlice(str, index, endIdx2) : valueSlice(str, index, eqIdx2);
        const val = eqIdx2 === -1 ? void 0 : valueSlice(str, eqIdx2 + 1, endIdx2);
        switch (attr.toLowerCase()) {
          case "httponly":
            setCookie.httpOnly = true;
            break;
          case "secure":
            setCookie.secure = true;
            break;
          case "partitioned":
            setCookie.partitioned = true;
            break;
          case "domain":
            setCookie.domain = val;
            break;
          case "path":
            setCookie.path = val;
            break;
          case "max-age":
            if (val && maxAgeRegExp.test(val))
              setCookie.maxAge = Number(val);
            break;
          case "expires":
            if (!val)
              break;
            const date = new Date(val);
            if (Number.isFinite(date.valueOf()))
              setCookie.expires = date;
            break;
          case "priority":
            if (!val)
              break;
            const priority = val.toLowerCase();
            if (priority === "low" || priority === "medium" || priority === "high") {
              setCookie.priority = priority;
            }
            break;
          case "samesite":
            if (!val)
              break;
            const sameSite = val.toLowerCase();
            if (sameSite === "lax" || sameSite === "strict" || sameSite === "none") {
              setCookie.sameSite = sameSite;
            }
            break;
        }
        index = endIdx2 + 1;
      }
      return setCookie;
    }
    function endIndex(str, min, len) {
      const index = str.indexOf(";", min);
      return index === -1 ? len : index;
    }
    function eqIndex(str, min, max) {
      const index = str.indexOf("=", min);
      return index < max ? index : -1;
    }
    function valueSlice(str, min, max) {
      let start2 = min;
      let end = max;
      do {
        const code5 = str.charCodeAt(start2);
        if (code5 !== 32 && code5 !== 9)
          break;
      } while (++start2 < end);
      while (end > start2) {
        const code5 = str.charCodeAt(end - 1);
        if (code5 !== 32 && code5 !== 9)
          break;
        end--;
      }
      return str.slice(start2, end);
    }
    function decode14(str) {
      if (str.indexOf("%") === -1)
        return str;
      try {
        return decodeURIComponent(str);
      } catch (e2) {
        return str;
      }
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]";
    }
  }
});

// ../../node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "../../node_modules/hashlru/index.js"(exports, module) {
    module.exports = function(max) {
      if (!max) throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache3 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value2) {
        cache3[key] = value2;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache3;
          cache3 = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache3[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache3[key] !== void 0)
            cache3[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache3[key];
          if (v !== void 0) return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value2) {
          if (cache3[key] !== void 0) cache3[key] = value2;
          else update(key, value2);
        },
        clear: function() {
          cache3 = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// ../../node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS({
  "../../node_modules/reflect-metadata/Reflect.js"() {
    var Reflect2;
    (function(Reflect3) {
      (function(factory) {
        var root = typeof window === "object" ? window : typeof window === "object" ? window : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
        var exporter = makeExporter(Reflect3);
        if (typeof root.Reflect !== "undefined") {
          exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter, root);
        if (typeof root.Reflect === "undefined") {
          root.Reflect = Reflect3;
        }
        function makeExporter(target, previous) {
          return function(key, value2) {
            Object.defineProperty(target, key, { configurable: true, writable: true, value: value2 });
            if (previous)
              previous(key, value2);
          };
        }
        function functionThis() {
          try {
            return Function("return this;")();
          } catch (_) {
          }
        }
        function indirectEvalThis() {
          try {
            return (void 0, eval)("(function() { return this; })()");
          } catch (_) {
          }
        }
        function sloppyModeThis() {
          return functionThis() || indirectEvalThis();
        }
      })(function(exporter, root) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          // create an object in dictionary mode (a.k.a. "slow" mode in v8)
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map2, key) {
            return hasOwn.call(map2, key);
          } : function(map2, key) {
            return key in map2;
          },
          get: downLevel ? function(map2, key) {
            return hasOwn.call(map2, key) ? map2[key] : void 0;
          } : function(map2, key) {
            return map2[key];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var registrySymbol = supportsSymbol ? /* @__PURE__ */ Symbol.for("@reflect-metadata:registry") : void 0;
        var metadataRegistry = GetOrCreateMetadataRegistry();
        var metadataProvider = CreateMetadataProvider(metadataRegistry);
        function decorate(decorators, target, propertyKey, attributes) {
          if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsObject(target))
              throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
              throw new TypeError();
            if (IsNull(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
          } else {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsConstructor(target))
              throw new TypeError();
            return DecorateConstructor(decorators, target);
          }
        }
        exporter("decorate", decorate);
        function metadata(metadataKey, metadataValue) {
          function decorator(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          return decorator;
        }
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var provider = GetMetadataProvider(
            target,
            propertyKey,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return false;
          return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
          for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
            var decorator = decorators[i2];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsConstructor(decorated))
                throw new TypeError();
              target = decorated;
            }
          }
          return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
          for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
            var decorator = decorators[i2];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsObject(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        function OrdinaryHasMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return true;
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
          return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return false;
          return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
        }
        function OrdinaryGetMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
          return void 0;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            false
          );
          if (IsUndefined(provider))
            return;
          return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*Create*/
            true
          );
          provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
        }
        function OrdinaryMetadataKeys(O, P) {
          var ownKeys = OrdinaryOwnMetadataKeys(O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (parent === null)
            return ownKeys;
          var parentKeys = OrdinaryMetadataKeys(parent, P);
          if (parentKeys.length <= 0)
            return ownKeys;
          if (ownKeys.length <= 0)
            return parentKeys;
          var set = new _Set();
          var keys = [];
          for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          for (var _a37 = 0, parentKeys_1 = parentKeys; _a37 < parentKeys_1.length; _a37++) {
            var key = parentKeys_1[_a37];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          return keys;
        }
        function OrdinaryOwnMetadataKeys(O, P) {
          var provider = GetMetadataProvider(
            O,
            P,
            /*create*/
            false
          );
          if (!provider) {
            return [];
          }
          return provider.OrdinaryOwnMetadataKeys(O, P);
        }
        function Type2(x) {
          if (x === null)
            return 1;
          switch (typeof x) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined(x) {
          return x === void 0;
        }
        function IsNull(x) {
          return x === null;
        }
        function IsSymbol(x) {
          return typeof x === "symbol";
        }
        function IsObject(x) {
          return typeof x === "object" ? x !== null : typeof x === "function";
        }
        function ToPrimitive(input, PreferredType) {
          switch (Type2(input)) {
            case 0:
              return input;
            case 1:
              return input;
            case 2:
              return input;
            case 3:
              return input;
            case 4:
              return input;
            case 5:
              return input;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
              throw new TypeError();
            return result;
          }
          return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        function OrdinaryToPrimitive(O, hint) {
          if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
              var result = toString_1.call(O);
              if (!IsObject(result))
                return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
          } else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
              var result = toString_2.call(O);
              if (!IsObject(result))
                return result;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          var key = ToPrimitive(
            argument,
            3
            /* String */
          );
          if (IsSymbol(key))
            return key;
          return ToString(key);
        }
        function IsArray(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        function IsConstructor(argument) {
          return typeof argument === "function";
        }
        function IsPropertyKey(argument) {
          switch (Type2(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function SameValueZero(x, y) {
          return x === y || x !== x && y !== y;
        }
        function GetMethod(V3, P) {
          var func = V3[P];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject(iterator))
            throw new TypeError();
          return iterator;
        }
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        function IteratorStep(iterator) {
          var result = iterator.next();
          return result.done ? false : result;
        }
        function IteratorClose(iterator) {
          var f2 = iterator["return"];
          if (f2)
            f2.call(iterator);
        }
        function OrdinaryGetPrototypeOf(O) {
          var proto = Object.getPrototypeOf(O);
          if (typeof O !== "function" || O === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O)
            return proto;
          return constructor;
        }
        function CreateMetadataRegistry() {
          var fallback;
          if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
            fallback = CreateFallbackProvider(root.Reflect);
          }
          var first;
          var second4;
          var rest;
          var targetProviderMap = new _WeakMap();
          var registry3 = {
            registerProvider,
            getProvider,
            setProvider
          };
          return registry3;
          function registerProvider(provider) {
            if (!Object.isExtensible(registry3)) {
              throw new Error("Cannot add provider to a frozen registry.");
            }
            switch (true) {
              case fallback === provider:
                break;
              case IsUndefined(first):
                first = provider;
                break;
              case first === provider:
                break;
              case IsUndefined(second4):
                second4 = provider;
                break;
              case second4 === provider:
                break;
              default:
                if (rest === void 0)
                  rest = new _Set();
                rest.add(provider);
                break;
            }
          }
          function getProviderNoCache(O, P) {
            if (!IsUndefined(first)) {
              if (first.isProviderFor(O, P))
                return first;
              if (!IsUndefined(second4)) {
                if (second4.isProviderFor(O, P))
                  return first;
                if (!IsUndefined(rest)) {
                  var iterator = GetIterator(rest);
                  while (true) {
                    var next = IteratorStep(iterator);
                    if (!next) {
                      return void 0;
                    }
                    var provider = IteratorValue(next);
                    if (provider.isProviderFor(O, P)) {
                      IteratorClose(iterator);
                      return provider;
                    }
                  }
                }
              }
            }
            if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
              return fallback;
            }
            return void 0;
          }
          function getProvider(O, P) {
            var providerMap = targetProviderMap.get(O);
            var provider;
            if (!IsUndefined(providerMap)) {
              provider = providerMap.get(P);
            }
            if (!IsUndefined(provider)) {
              return provider;
            }
            provider = getProviderNoCache(O, P);
            if (!IsUndefined(provider)) {
              if (IsUndefined(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O, providerMap);
              }
              providerMap.set(P, provider);
            }
            return provider;
          }
          function hasProvider(provider) {
            if (IsUndefined(provider))
              throw new TypeError();
            return first === provider || second4 === provider || !IsUndefined(rest) && rest.has(provider);
          }
          function setProvider(O, P, provider) {
            if (!hasProvider(provider)) {
              throw new Error("Metadata provider not registered.");
            }
            var existingProvider = getProvider(O, P);
            if (existingProvider !== provider) {
              if (!IsUndefined(existingProvider)) {
                return false;
              }
              var providerMap = targetProviderMap.get(O);
              if (IsUndefined(providerMap)) {
                providerMap = new _Map();
                targetProviderMap.set(O, providerMap);
              }
              providerMap.set(P, provider);
            }
            return true;
          }
        }
        function GetOrCreateMetadataRegistry() {
          var metadataRegistry2;
          if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
            metadataRegistry2 = root.Reflect[registrySymbol];
          }
          if (IsUndefined(metadataRegistry2)) {
            metadataRegistry2 = CreateMetadataRegistry();
          }
          if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
            Object.defineProperty(root.Reflect, registrySymbol, {
              enumerable: false,
              configurable: false,
              writable: false,
              value: metadataRegistry2
            });
          }
          return metadataRegistry2;
        }
        function CreateMetadataProvider(registry3) {
          var metadata2 = new _WeakMap();
          var provider = {
            isProviderFor: function(O, P) {
              var targetMetadata = metadata2.get(O);
              if (IsUndefined(targetMetadata))
                return false;
              return targetMetadata.has(P);
            },
            OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
            OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
            OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
            OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
            OrdinaryDeleteMetadata
          };
          metadataRegistry.registerProvider(provider);
          return provider;
          function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = metadata2.get(O);
            var createdTargetMetadata = false;
            if (IsUndefined(targetMetadata)) {
              if (!Create)
                return void 0;
              targetMetadata = new _Map();
              metadata2.set(O, targetMetadata);
              createdTargetMetadata = true;
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
              if (!Create)
                return void 0;
              metadataMap = new _Map();
              targetMetadata.set(P, metadataMap);
              if (!registry3.setProvider(O, P, provider)) {
                targetMetadata.delete(P);
                if (createdTargetMetadata) {
                  metadata2.delete(O);
                }
                throw new Error("Wrong provider for target.");
              }
            }
            return metadataMap;
          }
          function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            return ToBoolean(metadataMap.has(MetadataKey));
          }
          function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return void 0;
            return metadataMap.get(MetadataKey);
          }
          function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              true
            );
            metadataMap.set(MetadataKey, MetadataValue);
          }
          function OrdinaryOwnMetadataKeys2(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
              var next = IteratorStep(iterator);
              if (!next) {
                keys.length = k;
                return keys;
              }
              var nextValue = IteratorValue(next);
              try {
                keys[k] = nextValue;
              } catch (e2) {
                try {
                  IteratorClose(iterator);
                } finally {
                  throw e2;
                }
              }
              k++;
            }
          }
          function OrdinaryDeleteMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(
              O,
              P,
              /*Create*/
              false
            );
            if (IsUndefined(metadataMap))
              return false;
            if (!metadataMap.delete(MetadataKey))
              return false;
            if (metadataMap.size === 0) {
              var targetMetadata = metadata2.get(O);
              if (!IsUndefined(targetMetadata)) {
                targetMetadata.delete(P);
                if (targetMetadata.size === 0) {
                  metadata2.delete(targetMetadata);
                }
              }
            }
            return true;
          }
        }
        function CreateFallbackProvider(reflect) {
          var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
          var metadataOwner = new _WeakMap();
          var provider = {
            isProviderFor: function(O, P) {
              var metadataPropertySet = metadataOwner.get(O);
              if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
                return true;
              }
              if (getOwnMetadataKeys2(O, P).length) {
                if (IsUndefined(metadataPropertySet)) {
                  metadataPropertySet = new _Set();
                  metadataOwner.set(O, metadataPropertySet);
                }
                metadataPropertySet.add(P);
                return true;
              }
              return false;
            },
            OrdinaryDefineOwnMetadata: defineMetadata2,
            OrdinaryHasOwnMetadata: hasOwnMetadata2,
            OrdinaryGetOwnMetadata: getOwnMetadata2,
            OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
            OrdinaryDeleteMetadata: deleteMetadata2
          };
          return provider;
        }
        function GetMetadataProvider(O, P, Create) {
          var registeredProvider = metadataRegistry.getProvider(O, P);
          if (!IsUndefined(registeredProvider)) {
            return registeredProvider;
          }
          if (Create) {
            if (metadataRegistry.setProvider(O, P, metadataProvider)) {
              return metadataProvider;
            }
            throw new Error("Illegal state.");
          }
          return void 0;
        }
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = (
            /** @class */
            (function() {
              function MapIterator2(keys, values, selector) {
                this._index = 0;
                this._keys = keys;
                this._values = values;
                this._selector = selector;
              }
              MapIterator2.prototype["@@iterator"] = function() {
                return this;
              };
              MapIterator2.prototype[iteratorSymbol] = function() {
                return this;
              };
              MapIterator2.prototype.next = function() {
                var index = this._index;
                if (index >= 0 && index < this._keys.length) {
                  var result = this._selector(this._keys[index], this._values[index]);
                  if (index + 1 >= this._keys.length) {
                    this._index = -1;
                    this._keys = arraySentinel;
                    this._values = arraySentinel;
                  } else {
                    this._index++;
                  }
                  return { value: result, done: false };
                }
                return { value: void 0, done: true };
              };
              MapIterator2.prototype.throw = function(error) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                throw error;
              };
              MapIterator2.prototype.return = function(value2) {
                if (this._index >= 0) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                }
                return { value: value2, done: true };
              };
              return MapIterator2;
            })()
          );
          var Map2 = (
            /** @class */
            (function() {
              function Map3() {
                this._keys = [];
                this._values = [];
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              Object.defineProperty(Map3.prototype, "size", {
                get: function() {
                  return this._keys.length;
                },
                enumerable: true,
                configurable: true
              });
              Map3.prototype.has = function(key) {
                return this._find(
                  key,
                  /*insert*/
                  false
                ) >= 0;
              };
              Map3.prototype.get = function(key) {
                var index = this._find(
                  key,
                  /*insert*/
                  false
                );
                return index >= 0 ? this._values[index] : void 0;
              };
              Map3.prototype.set = function(key, value2) {
                var index = this._find(
                  key,
                  /*insert*/
                  true
                );
                this._values[index] = value2;
                return this;
              };
              Map3.prototype.delete = function(key) {
                var index = this._find(
                  key,
                  /*insert*/
                  false
                );
                if (index >= 0) {
                  var size = this._keys.length;
                  for (var i2 = index + 1; i2 < size; i2++) {
                    this._keys[i2 - 1] = this._keys[i2];
                    this._values[i2 - 1] = this._values[i2];
                  }
                  this._keys.length--;
                  this._values.length--;
                  if (SameValueZero(key, this._cacheKey)) {
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                  }
                  return true;
                }
                return false;
              };
              Map3.prototype.clear = function() {
                this._keys.length = 0;
                this._values.length = 0;
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              };
              Map3.prototype.keys = function() {
                return new MapIterator(this._keys, this._values, getKey);
              };
              Map3.prototype.values = function() {
                return new MapIterator(this._keys, this._values, getValue);
              };
              Map3.prototype.entries = function() {
                return new MapIterator(this._keys, this._values, getEntry);
              };
              Map3.prototype["@@iterator"] = function() {
                return this.entries();
              };
              Map3.prototype[iteratorSymbol] = function() {
                return this.entries();
              };
              Map3.prototype._find = function(key, insert) {
                if (!SameValueZero(this._cacheKey, key)) {
                  this._cacheIndex = -1;
                  for (var i2 = 0; i2 < this._keys.length; i2++) {
                    if (SameValueZero(this._keys[i2], key)) {
                      this._cacheIndex = i2;
                      break;
                    }
                  }
                }
                if (this._cacheIndex < 0 && insert) {
                  this._cacheIndex = this._keys.length;
                  this._keys.push(key);
                  this._values.push(void 0);
                }
                return this._cacheIndex;
              };
              return Map3;
            })()
          );
          return Map2;
          function getKey(key, _) {
            return key;
          }
          function getValue(_, value2) {
            return value2;
          }
          function getEntry(key, value2) {
            return [key, value2];
          }
        }
        function CreateSetPolyfill() {
          var Set2 = (
            /** @class */
            (function() {
              function Set3() {
                this._map = new _Map();
              }
              Object.defineProperty(Set3.prototype, "size", {
                get: function() {
                  return this._map.size;
                },
                enumerable: true,
                configurable: true
              });
              Set3.prototype.has = function(value2) {
                return this._map.has(value2);
              };
              Set3.prototype.add = function(value2) {
                return this._map.set(value2, value2), this;
              };
              Set3.prototype.delete = function(value2) {
                return this._map.delete(value2);
              };
              Set3.prototype.clear = function() {
                this._map.clear();
              };
              Set3.prototype.keys = function() {
                return this._map.keys();
              };
              Set3.prototype.values = function() {
                return this._map.keys();
              };
              Set3.prototype.entries = function() {
                return this._map.entries();
              };
              Set3.prototype["@@iterator"] = function() {
                return this.keys();
              };
              Set3.prototype[iteratorSymbol] = function() {
                return this.keys();
              };
              return Set3;
            })()
          );
          return Set2;
        }
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys = HashMap.create();
          var rootKey = CreateUniqueKey();
          return (
            /** @class */
            (function() {
              function WeakMap2() {
                this._key = CreateUniqueKey();
              }
              WeakMap2.prototype.has = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? HashMap.has(table, this._key) : false;
              };
              WeakMap2.prototype.get = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? HashMap.get(table, this._key) : void 0;
              };
              WeakMap2.prototype.set = function(target, value2) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  true
                );
                table[this._key] = value2;
                return this;
              };
              WeakMap2.prototype.delete = function(target) {
                var table = GetOrCreateWeakMapTable(
                  target,
                  /*create*/
                  false
                );
                return table !== void 0 ? delete table[this._key] : false;
              };
              WeakMap2.prototype.clear = function() {
                this._key = CreateUniqueKey();
              };
              return WeakMap2;
            })()
          );
          function CreateUniqueKey() {
            var key;
            do
              key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
          }
          function GetOrCreateWeakMapTable(target, create3) {
            if (!hasOwn.call(target, rootKey)) {
              if (!create3)
                return void 0;
              Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
          }
          function FillRandomBytes(buffer2, size) {
            for (var i2 = 0; i2 < size; ++i2)
              buffer2[i2] = Math.random() * 255 | 0;
            return buffer2;
          }
          function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
              var array = new Uint8Array(size);
              if (typeof crypto !== "undefined") {
                crypto.getRandomValues(array);
              } else if (typeof msCrypto !== "undefined") {
                msCrypto.getRandomValues(array);
              } else {
                FillRandomBytes(array, size);
              }
              return array;
            }
            return FillRandomBytes(new Array(size), size);
          }
          function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            data[6] = data[6] & 79 | 64;
            data[8] = data[8] & 191 | 128;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte = data[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result += "-";
              if (byte < 16)
                result += "0";
              result += byte.toString(16).toLowerCase();
            }
            return result;
          }
        }
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// dist/vendor/index.js
var index_exports = {};
__export(index_exports, {
  AbortError: () => AbortError2,
  AbstractMessageStream: () => AbstractMessageStream,
  AbstractMultiaddrConnection: () => AbstractMultiaddrConnection,
  AbstractStream: () => AbstractStream,
  AbstractStreamMuxer: () => AbstractStreamMuxer,
  AdaptiveTimeout: () => AdaptiveTimeout,
  AlreadyStartedError: () => AlreadyStartedError2,
  BaseBlockstore: () => BaseBlockstore,
  BaseDatastore: () => BaseDatastore,
  BlackHoleBlockstore: () => BlackHoleBlockstore,
  BloomFilter: () => BloomFilter,
  CODE_CERTHASH: () => CODE_CERTHASH2,
  CODE_DCCP: () => CODE_DCCP2,
  CODE_DNS: () => CODE_DNS2,
  CODE_DNS4: () => CODE_DNS42,
  CODE_DNS6: () => CODE_DNS62,
  CODE_DNSADDR: () => CODE_DNSADDR2,
  CODE_GARLIC32: () => CODE_GARLIC322,
  CODE_GARLIC64: () => CODE_GARLIC642,
  CODE_HTTP: () => CODE_HTTP2,
  CODE_HTTPS: () => CODE_HTTPS2,
  CODE_HTTP_PATH: () => CODE_HTTP_PATH2,
  CODE_IP4: () => CODE_IP42,
  CODE_IP6: () => CODE_IP62,
  CODE_IP6ZONE: () => CODE_IP6ZONE2,
  CODE_IPCIDR: () => CODE_IPCIDR2,
  CODE_MEMORY: () => CODE_MEMORY2,
  CODE_NOISE: () => CODE_NOISE2,
  CODE_ONION: () => CODE_ONION2,
  CODE_ONION3: () => CODE_ONION32,
  CODE_P2P: () => CODE_P2P2,
  CODE_P2P_CIRCUIT: () => CODE_P2P_CIRCUIT2,
  CODE_P2P_STARDUST: () => CODE_P2P_STARDUST2,
  CODE_P2P_WEBRTC_DIRECT: () => CODE_P2P_WEBRTC_DIRECT2,
  CODE_P2P_WEBRTC_STAR: () => CODE_P2P_WEBRTC_STAR2,
  CODE_P2P_WEBSOCKET_STAR: () => CODE_P2P_WEBSOCKET_STAR2,
  CODE_QUIC: () => CODE_QUIC2,
  CODE_QUIC_V1: () => CODE_QUIC_V12,
  CODE_SCTP: () => CODE_SCTP2,
  CODE_SNI: () => CODE_SNI2,
  CODE_TCP: () => CODE_TCP2,
  CODE_TLS: () => CODE_TLS2,
  CODE_UDP: () => CODE_UDP2,
  CODE_UDT: () => CODE_UDT2,
  CODE_UNIX: () => CODE_UNIX2,
  CODE_UTP: () => CODE_UTP2,
  CODE_WEBRTC: () => CODE_WEBRTC2,
  CODE_WEBRTC_DIRECT: () => CODE_WEBRTC_DIRECT2,
  CODE_WEBTRANSPORT: () => CODE_WEBTRANSPORT2,
  CODE_WS: () => CODE_WS2,
  CODE_WSS: () => CODE_WSS2,
  Circuit: () => Circuit,
  CodeError: () => CodeError,
  ConnectionClosedError: () => ConnectionClosedError2,
  ConnectionClosingError: () => ConnectionClosingError2,
  ConnectionFailedError: () => ConnectionFailedError2,
  CuckooFilter: () => CuckooFilter,
  DEFAULT_FAILURE_MULTIPLIER: () => DEFAULT_FAILURE_MULTIPLIER,
  DEFAULT_INTERVAL: () => DEFAULT_INTERVAL,
  DEFAULT_MAX_TIMEOUT: () => DEFAULT_MAX_TIMEOUT,
  DEFAULT_MIN_TIMEOUT: () => DEFAULT_MIN_TIMEOUT,
  DEFAULT_TIMEOUT_MULTIPLIER: () => DEFAULT_TIMEOUT_MULTIPLIER,
  DNS: () => DNS,
  DNS4: () => DNS4,
  DNS6: () => DNS6,
  DNSADDR: () => DNSADDR,
  DialError: () => DialError2,
  EventTypes: () => EventTypes,
  GoAwayCode: () => GoAwayCode,
  GossipSub: () => GossipSub,
  HTTP: () => HTTP,
  HTTPS: () => HTTPS,
  HTTP_PING_PROTOCOL: () => HTTP_PING_PROTOCOL,
  HTTP_PROTOCOL: () => HTTP_PROTOCOL2,
  IDBDatastore: () => IDBDatastore,
  IP: () => IP,
  IP4: () => IP4,
  IP6: () => IP6,
  IP_OR_DOMAIN: () => IP_OR_DOMAIN,
  InvalidCIDError: () => InvalidCIDError2,
  InvalidCryptoExchangeError: () => InvalidCryptoExchangeError2,
  InvalidDataLengthError: () => InvalidDataLengthError2,
  InvalidDataLengthLengthError: () => InvalidDataLengthLengthError2,
  InvalidMessageError: () => InvalidMessageError2,
  InvalidMessageLengthError: () => InvalidMessageLengthError2,
  InvalidMultiaddrError: () => InvalidMultiaddrError2,
  InvalidMultihashError: () => InvalidMultihashError2,
  InvalidParametersError: () => InvalidParametersError2,
  InvalidPeerIdError: () => InvalidPeerIdError2,
  InvalidPrivateKeyError: () => InvalidPrivateKeyError2,
  InvalidPublicKeyError: () => InvalidPublicKeyError2,
  KEEP_ALIVE: () => KEEP_ALIVE,
  KeyTransformDatastore: () => KeyTransformDatastore,
  LengthPrefixedDecoder: () => LengthPrefixedDecoder,
  LimitedConnectionError: () => LimitedConnectionError2,
  ListenError: () => ListenError2,
  MaxEarlyStreamsError: () => MaxEarlyStreamsError,
  MaxLengthError: () => MaxLengthError,
  MaxSizeError: () => MaxSizeError,
  Memory: () => Memory,
  MemoryBlockstore: () => MemoryBlockstore,
  MemoryDatastore: () => MemoryDatastore,
  MemoryStorage: () => MemoryStorage,
  MessageType: () => MessageType,
  MockStream: () => MockStream,
  MountDatastore: () => MountDatastore,
  MovingAverage: () => MovingAverage,
  MuxerClosedError: () => MuxerClosedError2,
  NamespaceDatastore: () => NamespaceDatastore,
  NoMessagesFoundError: () => NoMessagesFoundError,
  NotFoundError: () => NotFoundError2,
  NotImplementedError: () => NotImplementedError2,
  NotStartedError: () => NotStartedError2,
  P2P: () => P2P,
  PEER_ID: () => PEER_ID,
  PING_PROTOCOL: () => PING_PROTOCOL,
  ParseError: () => ParseError,
  PeerQueue: () => PeerQueue,
  PriorityQueue: () => PriorityQueue,
  ProtocolError: () => ProtocolError2,
  PubSubPeerDiscovery: () => PubSubPeerDiscovery,
  QUIC: () => QUIC,
  QUIC_V1: () => QUIC_V1,
  Queue: () => Queue,
  QueueFullError: () => QueueFullError,
  RELAY_V2_HOP_CODEC: () => RELAY_V2_HOP_CODEC,
  RELAY_V2_STOP_CODEC: () => RELAY_V2_STOP_CODEC,
  RateLimitError: () => RateLimitError,
  RateLimiter: () => RateLimiter,
  Record: () => Libp2pRecord,
  ScalableCuckooFilter: () => ScalableCuckooFilter,
  ShardingDatastore: () => ShardingDatastore,
  StreamAbortEvent: () => StreamAbortEvent,
  StreamAbortedError: () => StreamAbortedError,
  StreamBufferError: () => StreamBufferError,
  StreamCloseEvent: () => StreamCloseEvent,
  StreamClosedError: () => StreamClosedError,
  StreamMessageEvent: () => StreamMessageEvent,
  StreamResetError: () => StreamResetError2,
  StreamResetEvent: () => StreamResetEvent,
  StreamStateError: () => StreamStateError2,
  StrictNoSign: () => StrictNoSign2,
  StrictSign: () => StrictSign2,
  TCP: () => TCP,
  TOPIC: () => TOPIC,
  TieredBlockstore: () => TieredBlockstore,
  TieredDatastore: () => TieredDatastore,
  TimeoutError: () => TimeoutError2,
  TooManyInboundProtocolStreamsError: () => TooManyInboundProtocolStreamsError2,
  TooManyOutboundProtocolStreamsError: () => TooManyOutboundProtocolStreamsError2,
  TopicValidatorResult: () => TopicValidatorResult2,
  TypedEventEmitter: () => TypedEventEmitter,
  UDP: () => UDP,
  UnexpectedEOFError: () => UnexpectedEOFError2,
  UnexpectedPeerError: () => UnexpectedPeerError2,
  Unix: () => Unix,
  UnsupportedKeyTypeError: () => UnsupportedKeyTypeError2,
  UnsupportedOperationError: () => UnsupportedOperationError2,
  UnsupportedProtocolError: () => UnsupportedProtocolError2,
  UnwrappedError: () => UnwrappedError,
  V: () => V2,
  VENDOR_INFO: () => VENDOR_INFO,
  VENDOR_STATUS: () => VENDOR_STATUS,
  WELL_KNOWN_PROTOCOLS_PATH: () => WELL_KNOWN_PROTOCOLS_PATH,
  WebRTC: () => WebRTC,
  WebRTCDirect: () => WebRTCDirect,
  WebSockets: () => WebSockets,
  WebSocketsSecure: () => WebSocketsSecure,
  WebTransport: () => WebTransport,
  authenticatedRoute: () => authenticatedRoute,
  authenticatedWebSocketRoute: () => authenticatedWebSocketRoute,
  bootstrap: () => bootstrap,
  byteStream: () => byteStream,
  circuitRelayServer: () => circuitRelayServer,
  circuitRelayTransport: () => circuitRelayTransport,
  connectionSymbol: () => connectionSymbol,
  contentRoutingSymbol: () => contentRoutingSymbol,
  createBloomFilter: () => createBloomFilter,
  createCuckooFilter: () => createCuckooFilter,
  createLibp2p: () => createLibp2p,
  createScalableCuckooFilter: () => createScalableCuckooFilter,
  dcutr: () => dcutr,
  debounce: () => debounce,
  decodeMessage: () => decodeMessage,
  default: () => index_default,
  defaultLogger: () => defaultLogger,
  disable: () => disable,
  dnsaddrResolver: () => dnsaddrResolver,
  echo: () => echo,
  echoStream: () => echoStream,
  enable: () => enable,
  enabled: () => enabled,
  encodeMessage: () => encodeMessage,
  enumeration: () => enumeration,
  fetch: () => fetch2,
  floodsub: () => floodsub,
  getNetConfig: () => getNetConfig,
  getThinWaistAddresses: () => getThinWaistAddresses,
  gossipsub: () => gossipsub,
  hasDependency: () => hasDependency,
  hmac: () => index_browser_exports2,
  http: () => http,
  identify: () => identify,
  identifyPush: () => identifyPush,
  ipPortToMultiaddr: () => ipPortToMultiaddr,
  isAsyncGenerator: () => isAsyncGenerator,
  isConnection: () => isConnection,
  isGenerator: () => isGenerator,
  isGlobalUnicast: () => isGlobalUnicast,
  isGlobalUnicastIp: () => isGlobalUnicastIp,
  isLibp2p: () => isLibp2p,
  isLinkLocal: () => isLinkLocal,
  isLinkLocalIp: () => isLinkLocalIp,
  isLoopback: () => isLoopback,
  isMultiaddr: () => isMultiaddr,
  isNetworkAddress: () => isNetworkAddress,
  isPeerId: () => isPeerId2,
  isPrivate: () => isPrivate,
  isPrivateIp: () => isPrivateIp,
  isPrivateKey: () => isPrivateKey,
  isPromise: () => isPromise2,
  isPubSub: () => isPubSub2,
  isPublicKey: () => isPublicKey,
  isStartable: () => isStartable,
  kadDHT: () => kadDHT,
  keys: () => keys_exports2,
  logger: () => logger,
  lpStream: () => lpStream,
  message: () => message,
  messageStreamToDuplex: () => messageStreamToDuplex,
  mockMuxer: () => mockMuxer,
  multiaddr: () => multiaddr,
  multiaddrConnectionPair: () => multiaddrConnectionPair,
  noise: () => noise,
  passthroughMapper: () => passthroughMapper,
  pbStream: () => pbStream,
  pbkdf2: () => pbkdf22,
  peerDiscoverySymbol: () => peerDiscoverySymbol,
  peerIdFromCID: () => peerIdFromCID3,
  peerIdFromMultihash: () => peerIdFromMultihash3,
  peerIdFromPrivateKey: () => peerIdFromPrivateKey3,
  peerIdFromPublicKey: () => peerIdFromPublicKey3,
  peerIdFromString: () => peerIdFromString3,
  peerIdSymbol: () => peerIdSymbol2,
  peerLogger: () => peerLogger,
  peerRoutingSymbol: () => peerRoutingSymbol,
  persistentPeerStore: () => persistentPeerStore,
  ping: () => ping,
  pingHTTP: () => pingHTTP,
  pipe: () => pipe2,
  prefixLogger: () => prefixLogger,
  protocol: () => protocol,
  pubSubSymbol: () => pubSubSymbol2,
  pubsubPeerDiscovery: () => pubsubPeerDiscovery,
  pureJsCrypto: () => pureJsCrypto,
  randomBytes: () => randomBytes2,
  reader: () => createReader,
  registry: () => registry2,
  removePrivateAddressesMapper: () => removePrivateAddressesMapper,
  removePublicAddressesMapper: () => removePublicAddressesMapper,
  repeatingTask: () => repeatingTask,
  serviceCapabilities: () => serviceCapabilities2,
  serviceDependencies: () => serviceDependencies2,
  setMaxListeners: () => setMaxListeners,
  shard: () => shard_exports,
  start: () => start,
  stop: () => stop,
  streamPair: () => streamPair,
  symbol: () => symbol3,
  trackedList: () => trackedList,
  trackedMap: () => trackedMap,
  transportSymbol: () => transportSymbol,
  webRTC: () => webRTC,
  webRTCDirect: () => webRTCDirect,
  webSocketRoute: () => webSocketRoute,
  webSockets: () => webSockets,
  webTransport: () => webTransport,
  writer: () => createWriter,
  yamux: () => yamux
});

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/interface/dist/src/peer-id.js
var peerIdSymbol = /* @__PURE__ */ Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return Boolean(other?.[peerIdSymbol]);
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/interface/dist/src/pubsub.js
var StrictSign = "StrictSign";
var StrictNoSign = "StrictNoSign";
var TopicValidatorResult;
(function(TopicValidatorResult3) {
  TopicValidatorResult3["Accept"] = "accept";
  TopicValidatorResult3["Ignore"] = "ignore";
  TopicValidatorResult3["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));
var pubSubSymbol = /* @__PURE__ */ Symbol.for("@libp2p/pubsub");
function isPubSub(obj) {
  return Boolean(obj?.[pubSubSymbol]);
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/interface/dist/src/errors.js
var AbortError = class extends Error {
  constructor(message2 = "The operation was aborted") {
    super(message2);
    this.name = "AbortError";
  }
};
__publicField(AbortError, "name", "AbortError");
var UnexpectedPeerError = class extends Error {
  constructor(message2 = "Unexpected Peer") {
    super(message2);
    this.name = "UnexpectedPeerError";
  }
};
__publicField(UnexpectedPeerError, "name", "UnexpectedPeerError");
var InvalidCryptoExchangeError = class extends Error {
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.name = "InvalidCryptoExchangeError";
  }
};
__publicField(InvalidCryptoExchangeError, "name", "InvalidCryptoExchangeError");
var InvalidParametersError = class extends Error {
  constructor(message2 = "Invalid parameters") {
    super(message2);
    this.name = "InvalidParametersError";
  }
};
__publicField(InvalidParametersError, "name", "InvalidParametersError");
var InvalidPublicKeyError = class extends Error {
  constructor(message2 = "Invalid public key") {
    super(message2);
    this.name = "InvalidPublicKeyError";
  }
};
__publicField(InvalidPublicKeyError, "name", "InvalidPublicKeyError");
var InvalidPrivateKeyError = class extends Error {
  constructor(message2 = "Invalid private key") {
    super(message2);
    this.name = "InvalidPrivateKeyError";
  }
};
__publicField(InvalidPrivateKeyError, "name", "InvalidPrivateKeyError");
var UnsupportedOperationError = class extends Error {
  constructor(message2 = "Unsupported operation") {
    super(message2);
    this.name = "UnsupportedOperationError";
  }
};
__publicField(UnsupportedOperationError, "name", "UnsupportedOperationError");
var ConnectionClosingError = class extends Error {
  constructor(message2 = "The connection is closing") {
    super(message2);
    this.name = "ConnectionClosingError";
  }
};
__publicField(ConnectionClosingError, "name", "ConnectionClosingError");
var ConnectionClosedError = class extends Error {
  constructor(message2 = "The connection is closed") {
    super(message2);
    this.name = "ConnectionClosedError";
  }
};
__publicField(ConnectionClosedError, "name", "ConnectionClosedError");
var ConnectionFailedError = class extends Error {
  constructor(message2 = "Connection failed") {
    super(message2);
    this.name = "ConnectionFailedError";
  }
};
__publicField(ConnectionFailedError, "name", "ConnectionFailedError");
var MuxerClosedError = class extends Error {
  constructor(message2 = "The muxer is closed") {
    super(message2);
    this.name = "MuxerClosedError";
  }
};
__publicField(MuxerClosedError, "name", "MuxerClosedError");
var StreamResetError = class extends Error {
  constructor(message2 = "The stream has been reset") {
    super(message2);
    this.name = "StreamResetError";
  }
};
__publicField(StreamResetError, "name", "StreamResetError");
var StreamStateError = class extends Error {
  constructor(message2 = "The stream is in an invalid state") {
    super(message2);
    this.name = "StreamStateError";
  }
};
__publicField(StreamStateError, "name", "StreamStateError");
var NotFoundError = class extends Error {
  constructor(message2 = "Not found") {
    super(message2);
    this.name = "NotFoundError";
  }
};
__publicField(NotFoundError, "name", "NotFoundError");
var InvalidPeerIdError = class extends Error {
  constructor(message2 = "Invalid PeerID") {
    super(message2);
    this.name = "InvalidPeerIdError";
  }
};
__publicField(InvalidPeerIdError, "name", "InvalidPeerIdError");
var InvalidMultiaddrError = class extends Error {
  constructor(message2 = "Invalid multiaddr") {
    super(message2);
    this.name = "InvalidMultiaddrError";
  }
};
__publicField(InvalidMultiaddrError, "name", "InvalidMultiaddrError");
var InvalidCIDError = class extends Error {
  constructor(message2 = "Invalid CID") {
    super(message2);
    this.name = "InvalidCIDError";
  }
};
__publicField(InvalidCIDError, "name", "InvalidCIDError");
var InvalidMultihashError = class extends Error {
  constructor(message2 = "Invalid Multihash") {
    super(message2);
    this.name = "InvalidMultihashError";
  }
};
__publicField(InvalidMultihashError, "name", "InvalidMultihashError");
var UnsupportedProtocolError = class extends Error {
  constructor(message2 = "Unsupported protocol error") {
    super(message2);
    this.name = "UnsupportedProtocolError";
  }
};
__publicField(UnsupportedProtocolError, "name", "UnsupportedProtocolError");
var InvalidMessageError = class extends Error {
  constructor(message2 = "Invalid message") {
    super(message2);
    this.name = "InvalidMessageError";
  }
};
__publicField(InvalidMessageError, "name", "InvalidMessageError");
var ProtocolError = class extends Error {
  constructor(message2 = "Protocol error") {
    super(message2);
    this.name = "ProtocolError";
  }
};
__publicField(ProtocolError, "name", "ProtocolError");
var TimeoutError = class extends Error {
  constructor(message2 = "Timed out") {
    super(message2);
    this.name = "TimeoutError";
  }
};
__publicField(TimeoutError, "name", "TimeoutError");
var NotStartedError = class extends Error {
  constructor(message2 = "Not started") {
    super(message2);
    this.name = "NotStartedError";
  }
};
__publicField(NotStartedError, "name", "NotStartedError");
var AlreadyStartedError = class extends Error {
  constructor(message2 = "Already started") {
    super(message2);
    this.name = "AlreadyStartedError";
  }
};
__publicField(AlreadyStartedError, "name", "AlreadyStartedError");
var DialError = class extends Error {
  constructor(message2 = "Dial error") {
    super(message2);
    this.name = "DialError";
  }
};
__publicField(DialError, "name", "DialError");
var ListenError = class extends Error {
  constructor(message2 = "Listen error") {
    super(message2);
    this.name = "ListenError";
  }
};
__publicField(ListenError, "name", "ListenError");
var LimitedConnectionError = class extends Error {
  constructor(message2 = "Limited connection") {
    super(message2);
    this.name = "LimitedConnectionError";
  }
};
__publicField(LimitedConnectionError, "name", "LimitedConnectionError");
var TooManyInboundProtocolStreamsError = class extends Error {
  constructor(message2 = "Too many inbound protocol streams") {
    super(message2);
    this.name = "TooManyInboundProtocolStreamsError";
  }
};
__publicField(TooManyInboundProtocolStreamsError, "name", "TooManyInboundProtocolStreamsError");
var TooManyOutboundProtocolStreamsError = class extends Error {
  constructor(message2 = "Too many outbound protocol streams") {
    super(message2);
    this.name = "TooManyOutboundProtocolStreamsError";
  }
};
__publicField(TooManyOutboundProtocolStreamsError, "name", "TooManyOutboundProtocolStreamsError");
var UnsupportedKeyTypeError = class extends Error {
  constructor(message2 = "Unsupported key type") {
    super(message2);
    this.name = "UnsupportedKeyTypeError";
  }
};
__publicField(UnsupportedKeyTypeError, "name", "UnsupportedKeyTypeError");
var NotImplementedError = class extends Error {
  constructor(message2 = "Not implemented") {
    super(message2);
    this.name = "NotImplementedError";
  }
};
__publicField(NotImplementedError, "name", "NotImplementedError");

// ../../node_modules/main-event/dist/src/events.browser.js
function setMaxListeners() {
}

// ../../node_modules/main-event/dist/src/index.js
var _listeners;
var TypedEventEmitter = class extends EventTarget {
  constructor() {
    super();
    __privateAdd(this, _listeners, /* @__PURE__ */ new Map());
    setMaxListeners(Infinity, this);
  }
  listenerCount(type) {
    const listeners = __privateGet(this, _listeners).get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options2) {
    super.addEventListener(type, listener, options2);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      list = [];
      __privateGet(this, _listeners).set(type, list);
    }
    list.push({
      callback: listener,
      once: (options2 !== true && options2 !== false && options2?.once) ?? false
    });
  }
  removeEventListener(type, listener, options2) {
    super.removeEventListener(type.toString(), listener ?? null, options2);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    __privateGet(this, _listeners).set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = __privateGet(this, _listeners).get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    __privateGet(this, _listeners).set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail = {}) {
    return this.dispatchEvent(new CustomEvent(type, detail));
  }
};
_listeners = new WeakMap();

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/interface/dist/src/index.js
var serviceCapabilities = /* @__PURE__ */ Symbol.for("@libp2p/service-capabilities");
var serviceDependencies = /* @__PURE__ */ Symbol.for("@libp2p/service-dependencies");

// ../../node_modules/@libp2p/crypto/dist/src/keys/index.js
var keys_exports2 = {};
__export(keys_exports2, {
  generateEphemeralKeyPair: () => generateEphemeralKeyPair,
  generateKeyPair: () => generateKeyPair,
  generateKeyPairFromSeed: () => generateKeyPairFromSeed,
  keyStretcher: () => keyStretcher,
  privateKeyFromCryptoKeyPair: () => privateKeyFromCryptoKeyPair,
  privateKeyFromProtobuf: () => privateKeyFromProtobuf,
  privateKeyFromRaw: () => privateKeyFromRaw,
  privateKeyToCryptoKeyPair: () => privateKeyToCryptoKeyPair,
  privateKeyToProtobuf: () => privateKeyToProtobuf,
  publicKeyFromMultihash: () => publicKeyFromMultihash,
  publicKeyFromProtobuf: () => publicKeyFromProtobuf,
  publicKeyFromRaw: () => publicKeyFromRaw,
  publicKeyToProtobuf: () => publicKeyToProtobuf
});

// ../../node_modules/@libp2p/interface/dist/src/connection.js
var connectionSymbol = /* @__PURE__ */ Symbol.for("@libp2p/connection");
function isConnection(other) {
  return other != null && Boolean(other[connectionSymbol]);
}

// ../../node_modules/@libp2p/interface/dist/src/content-routing.js
var contentRoutingSymbol = /* @__PURE__ */ Symbol.for("@libp2p/content-routing");

// ../../node_modules/@libp2p/interface/dist/src/errors.js
var AbortError2 = class extends Error {
  constructor(message2 = "The operation was aborted") {
    super(message2);
    this.name = "AbortError";
  }
};
__publicField(AbortError2, "name", "AbortError");
var UnexpectedPeerError2 = class extends Error {
  constructor(message2 = "Unexpected Peer") {
    super(message2);
    this.name = "UnexpectedPeerError";
  }
};
__publicField(UnexpectedPeerError2, "name", "UnexpectedPeerError");
var InvalidCryptoExchangeError2 = class extends Error {
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.name = "InvalidCryptoExchangeError";
  }
};
__publicField(InvalidCryptoExchangeError2, "name", "InvalidCryptoExchangeError");
var InvalidParametersError2 = class extends Error {
  constructor(message2 = "Invalid parameters") {
    super(message2);
    this.name = "InvalidParametersError";
  }
};
__publicField(InvalidParametersError2, "name", "InvalidParametersError");
var InvalidPublicKeyError2 = class extends Error {
  constructor(message2 = "Invalid public key") {
    super(message2);
    this.name = "InvalidPublicKeyError";
  }
};
__publicField(InvalidPublicKeyError2, "name", "InvalidPublicKeyError");
var InvalidPrivateKeyError2 = class extends Error {
  constructor(message2 = "Invalid private key") {
    super(message2);
    this.name = "InvalidPrivateKeyError";
  }
};
__publicField(InvalidPrivateKeyError2, "name", "InvalidPrivateKeyError");
var UnsupportedOperationError2 = class extends Error {
  constructor(message2 = "Unsupported operation") {
    super(message2);
    this.name = "UnsupportedOperationError";
  }
};
__publicField(UnsupportedOperationError2, "name", "UnsupportedOperationError");
var ConnectionClosingError2 = class extends Error {
  constructor(message2 = "The connection is closing") {
    super(message2);
    this.name = "ConnectionClosingError";
  }
};
__publicField(ConnectionClosingError2, "name", "ConnectionClosingError");
var ConnectionClosedError2 = class extends Error {
  constructor(message2 = "The connection is closed") {
    super(message2);
    this.name = "ConnectionClosedError";
  }
};
__publicField(ConnectionClosedError2, "name", "ConnectionClosedError");
var ConnectionFailedError2 = class extends Error {
  constructor(message2 = "Connection failed") {
    super(message2);
    this.name = "ConnectionFailedError";
  }
};
__publicField(ConnectionFailedError2, "name", "ConnectionFailedError");
var MuxerClosedError2 = class extends Error {
  constructor(message2 = "The muxer is closed") {
    super(message2);
    this.name = "MuxerClosedError";
  }
};
__publicField(MuxerClosedError2, "name", "MuxerClosedError");
var StreamResetError2 = class extends Error {
  constructor(message2 = "The stream has been reset") {
    super(message2);
    this.name = "StreamResetError";
  }
};
__publicField(StreamResetError2, "name", "StreamResetError");
var StreamAbortedError = class extends Error {
  constructor(message2 = "The stream has been aborted") {
    super(message2);
    this.name = "StreamAbortedError";
  }
};
__publicField(StreamAbortedError, "name", "StreamAbortedError");
var StreamStateError2 = class extends Error {
  constructor(message2 = "The stream is in an invalid state") {
    super(message2);
    this.name = "StreamStateError";
  }
};
__publicField(StreamStateError2, "name", "StreamStateError");
var StreamBufferError = class extends Error {
  constructor(message2 = "The stream buffer was full") {
    super(message2);
    this.name = "StreamBufferError";
  }
};
__publicField(StreamBufferError, "name", "StreamBufferError");
var NotFoundError2 = class extends Error {
  constructor(message2 = "Not found") {
    super(message2);
    this.name = "NotFoundError";
  }
};
__publicField(NotFoundError2, "name", "NotFoundError");
var InvalidPeerIdError2 = class extends Error {
  constructor(message2 = "Invalid PeerID") {
    super(message2);
    this.name = "InvalidPeerIdError";
  }
};
__publicField(InvalidPeerIdError2, "name", "InvalidPeerIdError");
var InvalidMultiaddrError2 = class extends Error {
  constructor(message2 = "Invalid multiaddr") {
    super(message2);
    this.name = "InvalidMultiaddrError";
  }
};
__publicField(InvalidMultiaddrError2, "name", "InvalidMultiaddrError");
var InvalidCIDError2 = class extends Error {
  constructor(message2 = "Invalid CID") {
    super(message2);
    this.name = "InvalidCIDError";
  }
};
__publicField(InvalidCIDError2, "name", "InvalidCIDError");
var InvalidMultihashError2 = class extends Error {
  constructor(message2 = "Invalid Multihash") {
    super(message2);
    this.name = "InvalidMultihashError";
  }
};
__publicField(InvalidMultihashError2, "name", "InvalidMultihashError");
var UnsupportedProtocolError2 = class extends Error {
  constructor(message2 = "Unsupported protocol error") {
    super(message2);
    this.name = "UnsupportedProtocolError";
  }
};
__publicField(UnsupportedProtocolError2, "name", "UnsupportedProtocolError");
var InvalidMessageError2 = class extends Error {
  constructor(message2 = "Invalid message") {
    super(message2);
    this.name = "InvalidMessageError";
  }
};
__publicField(InvalidMessageError2, "name", "InvalidMessageError");
var ProtocolError2 = class extends Error {
  constructor(message2 = "Protocol error") {
    super(message2);
    this.name = "ProtocolError";
  }
};
__publicField(ProtocolError2, "name", "ProtocolError");
var TimeoutError2 = class extends Error {
  constructor(message2 = "Timed out") {
    super(message2);
    this.name = "TimeoutError";
  }
};
__publicField(TimeoutError2, "name", "TimeoutError");
var NotStartedError2 = class extends Error {
  constructor(message2 = "Not started") {
    super(message2);
    this.name = "NotStartedError";
  }
};
__publicField(NotStartedError2, "name", "NotStartedError");
var AlreadyStartedError2 = class extends Error {
  constructor(message2 = "Already started") {
    super(message2);
    this.name = "AlreadyStartedError";
  }
};
__publicField(AlreadyStartedError2, "name", "AlreadyStartedError");
var DialError2 = class extends Error {
  constructor(message2 = "Dial error") {
    super(message2);
    this.name = "DialError";
  }
};
__publicField(DialError2, "name", "DialError");
var ListenError2 = class extends Error {
  constructor(message2 = "Listen error") {
    super(message2);
    this.name = "ListenError";
  }
};
__publicField(ListenError2, "name", "ListenError");
var LimitedConnectionError2 = class extends Error {
  constructor(message2 = "Limited connection") {
    super(message2);
    this.name = "LimitedConnectionError";
  }
};
__publicField(LimitedConnectionError2, "name", "LimitedConnectionError");
var TooManyInboundProtocolStreamsError2 = class extends Error {
  constructor(message2 = "Too many inbound protocol streams") {
    super(message2);
    this.name = "TooManyInboundProtocolStreamsError";
  }
};
__publicField(TooManyInboundProtocolStreamsError2, "name", "TooManyInboundProtocolStreamsError");
var TooManyOutboundProtocolStreamsError2 = class extends Error {
  constructor(message2 = "Too many outbound protocol streams") {
    super(message2);
    this.name = "TooManyOutboundProtocolStreamsError";
  }
};
__publicField(TooManyOutboundProtocolStreamsError2, "name", "TooManyOutboundProtocolStreamsError");
var UnsupportedKeyTypeError2 = class extends Error {
  constructor(message2 = "Unsupported key type") {
    super(message2);
    this.name = "UnsupportedKeyTypeError";
  }
};
__publicField(UnsupportedKeyTypeError2, "name", "UnsupportedKeyTypeError");
var NotImplementedError2 = class extends Error {
  constructor(message2 = "Not implemented") {
    super(message2);
    this.name = "NotImplementedError";
  }
};
__publicField(NotImplementedError2, "name", "NotImplementedError");

// ../../node_modules/@libp2p/interface/dist/src/events.js
var StreamMessageEvent = class extends Event {
  constructor(data, eventInitDict) {
    super("message", eventInitDict);
    __publicField(this, "data");
    this.data = data;
  }
};
var StreamCloseEvent = class extends Event {
  constructor(local, error, eventInitDict) {
    super("close", eventInitDict);
    __publicField(this, "error");
    __publicField(this, "local");
    this.error = error;
    this.local = local;
  }
};
var StreamAbortEvent = class extends StreamCloseEvent {
  constructor(error, eventInitDict) {
    super(true, error, eventInitDict);
  }
};
var StreamResetEvent = class extends StreamCloseEvent {
  constructor(error, eventInitDict) {
    super(false, error, eventInitDict);
  }
};

// ../../node_modules/@libp2p/interface/dist/src/keys.js
function isPublicKey(key) {
  if (key == null) {
    return false;
  }
  return (key.type === "RSA" || key.type === "Ed25519" || key.type === "secp256k1" || key.type === "ECDSA") && key.raw instanceof Uint8Array && typeof key.equals === "function" && typeof key.toMultihash === "function" && typeof key.toCID === "function" && typeof key.verify === "function";
}
function isPrivateKey(key) {
  if (key == null) {
    return false;
  }
  return (key.type === "RSA" || key.type === "Ed25519" || key.type === "secp256k1" || key.type === "ECDSA") && isPublicKey(key.publicKey) && key.raw instanceof Uint8Array && typeof key.equals === "function" && typeof key.sign === "function";
}

// ../../node_modules/@libp2p/interface/dist/src/peer-discovery.js
var peerDiscoverySymbol = /* @__PURE__ */ Symbol.for("@libp2p/peer-discovery");

// ../../node_modules/@libp2p/interface/dist/src/peer-id.js
var peerIdSymbol2 = /* @__PURE__ */ Symbol.for("@libp2p/peer-id");
function isPeerId2(other) {
  return Boolean(other?.[peerIdSymbol2]);
}

// ../../node_modules/@libp2p/interface/dist/src/peer-routing.js
var peerRoutingSymbol = /* @__PURE__ */ Symbol.for("@libp2p/peer-routing");

// ../../node_modules/@libp2p/interface/dist/src/peer-store.js
var KEEP_ALIVE = "keep-alive";

// ../../node_modules/@libp2p/interface/dist/src/startable.js
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
async function start(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s2) => {
    if (s2.beforeStart != null) {
      await s2.beforeStart();
    }
  }));
  await Promise.all(startables.map(async (s2) => {
    await s2.start();
  }));
  await Promise.all(startables.map(async (s2) => {
    if (s2.afterStart != null) {
      await s2.afterStart();
    }
  }));
}
async function stop(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s2) => {
    if (s2.beforeStop != null) {
      await s2.beforeStop();
    }
  }));
  await Promise.all(startables.map(async (s2) => {
    await s2.stop();
  }));
  await Promise.all(startables.map(async (s2) => {
    if (s2.afterStop != null) {
      await s2.afterStop();
    }
  }));
}

// ../../node_modules/@libp2p/interface/dist/src/transport.js
var transportSymbol = /* @__PURE__ */ Symbol.for("@libp2p/transport");
function isTransport(other) {
  return other != null && Boolean(other[transportSymbol]);
}
var FaultTolerance;
(function(FaultTolerance3) {
  FaultTolerance3[FaultTolerance3["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance3[FaultTolerance3["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// ../../node_modules/@libp2p/interface/dist/src/index.js
var serviceCapabilities2 = /* @__PURE__ */ Symbol.for("@libp2p/service-capabilities");
var serviceDependencies2 = /* @__PURE__ */ Symbol.for("@libp2p/service-dependencies");

// ../../node_modules/multiformats/dist/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});

// ../../node_modules/multiformats/dist/src/bytes.js
var bytes_exports = {};
__export(bytes_exports, {
  coerce: () => coerce,
  empty: () => empty,
  equals: () => equals,
  fromHex: () => fromHex,
  fromString: () => fromString,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString
});
var empty = new Uint8Array(0);
function toHex(d2) {
  return d2.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
}
function fromHex(hex) {
  const hexes3 = hex.match(/../g);
  return hexes3 != null ? new Uint8Array(hexes3.map((b) => parseInt(b, 16))) : empty;
}
function equals(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce(o2) {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array") {
    return o2;
  }
  if (o2 instanceof ArrayBuffer) {
    return new Uint8Array(o2);
  }
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function isBinary(o2) {
  return o2 instanceof ArrayBuffer || ArrayBuffer.isView(o2);
}
function fromString(str) {
  return new TextEncoder().encode(str);
}
function toString(b) {
  return new TextDecoder().decode(b);
}

// ../../node_modules/multiformats/dist/src/vendor/base-x.js
function base(ALPHABET, name5) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode13(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length4) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      pbegin++;
    }
    var it2 = size - length4;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length4) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length4;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode14(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name5} character`);
  }
  return {
    encode: encode13,
    decodeUnsafe,
    decode: decode14
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// ../../node_modules/multiformats/dist/src/bases/base.js
var Encoder = class {
  constructor(name5, prefix, baseEncode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseEncode");
    this.name = name5;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name5, prefix, baseDecode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseDecode");
    __publicField(this, "prefixCodePoint");
    this.name = name5;
    this.prefix = prefix;
    const prefixCodePoint = prefix.codePointAt(0);
    if (prefixCodePoint === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefixCodePoint;
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders4) {
    __publicField(this, "decoders");
    this.decoders = decoders4;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder != null) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
function or(left, right) {
  return new ComposedDecoder({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
var Codec = class {
  constructor(name5, prefix, baseEncode, baseDecode) {
    __publicField(this, "name");
    __publicField(this, "prefix");
    __publicField(this, "baseEncode");
    __publicField(this, "baseDecode");
    __publicField(this, "encoder");
    __publicField(this, "decoder");
    this.name = name5;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name5, prefix, baseEncode);
    this.decoder = new Decoder(name5, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
function from({ name: name5, prefix, encode: encode13, decode: decode14 }) {
  return new Codec(name5, prefix, encode13, decode14);
}
function baseX({ name: name5, prefix, alphabet: alphabet2 }) {
  const { encode: encode13, decode: decode14 } = base_x_default(alphabet2, name5);
  return from({
    prefix,
    name: name5,
    encode: encode13,
    decode: (text) => coerce(decode14(text))
  });
}
function decode(string2, alphabetIdx, bitsPerChar, name5) {
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = alphabetIdx[string2[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name5} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value2;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer2 << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode(data, alphabet2, bitsPerChar) {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx(alphabet2) {
  const alphabetIdx = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    alphabetIdx[alphabet2[i2]] = i2;
  }
  return alphabetIdx;
}
function rfc4648({ name: name5, prefix, bitsPerChar, alphabet: alphabet2 }) {
  const alphabetIdx = createAlphabetIdx(alphabet2);
  return from({
    prefix,
    name: name5,
    encode(input) {
      return encode(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabetIdx, bitsPerChar, name5);
    }
  });
}

// ../../node_modules/multiformats/dist/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// ../../node_modules/multiformats/dist/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// ../../node_modules/multiformats/dist/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// ../../node_modules/multiformats/dist/src/hashes/digest.js
var digest_exports = {};
__export(digest_exports, {
  Digest: () => Digest,
  create: () => create,
  decode: () => decode4,
  equals: () => equals2,
  hasCode: () => hasCode
});

// ../../node_modules/multiformats/dist/src/varint.js
var varint_exports = {};
__export(varint_exports, {
  decode: () => decode3,
  encodeTo: () => encodeTo,
  encodingLength: () => encodingLength
});

// ../../node_modules/multiformats/dist/src/vendor/varint.js
var encode_1 = encode2;
var MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode2(num2, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num2 >= INT) {
    out[offset++] = num2 & 255 | MSB;
    num2 /= 128;
  }
  while (num2 & MSBALL) {
    out[offset++] = num2 & 255 | MSB;
    num2 >>>= 7;
  }
  out[offset] = num2 | 0;
  encode2.bytes = offset - oldOffset + 1;
  return out;
}
var decode2 = read;
var MSB$1 = 128, REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value2) {
  return value2 < N1 ? 1 : value2 < N2 ? 2 : value2 < N3 ? 3 : value2 < N4 ? 4 : value2 < N5 ? 5 : value2 < N6 ? 6 : value2 < N7 ? 7 : value2 < N8 ? 8 : value2 < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode2,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// ../../node_modules/multiformats/dist/src/varint.js
function decode3(data, offset = 0) {
  const code5 = varint_default.decode(data, offset);
  return [code5, varint_default.decode.bytes];
}
function encodeTo(int, target, offset = 0) {
  varint_default.encode(int, target, offset);
  return target;
}
function encodingLength(int) {
  return varint_default.encodingLength(int);
}

// ../../node_modules/multiformats/dist/src/hashes/digest.js
function create(code5, digest2) {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength(code5);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code5, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest2, digestOffset);
  return new Digest(code5, size, digest2, bytes);
}
function decode4(multihash) {
  const bytes = coerce(multihash);
  const [code5, sizeOffset] = decode3(bytes);
  const [size, digestOffset] = decode3(bytes.subarray(sizeOffset));
  const digest2 = bytes.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code5, size, digest2, bytes);
}
function equals2(a2, b) {
  if (a2 === b) {
    return true;
  } else {
    const data = b;
    return a2.code === data.code && a2.size === data.size && data.bytes instanceof Uint8Array && equals(a2.bytes, data.bytes);
  }
}
var Digest = class {
  /**
   * Creates a multihash digest.
   */
  constructor(code5, size, digest2, bytes) {
    __publicField(this, "code");
    __publicField(this, "size");
    __publicField(this, "digest");
    __publicField(this, "bytes");
    this.code = code5;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes;
  }
};
function hasCode(digest2, code5) {
  return digest2.code === code5;
}

// ../../node_modules/multiformats/dist/src/cid.js
var _a;
function format(link, base3) {
  const { bytes, version: version2 } = link;
  switch (version2) {
    case 0:
      return toStringV0(bytes, baseCache(link), base3 ?? base58btc.encoder);
    default:
      return toStringV1(bytes, baseCache(link), base3 ?? base32.encoder);
  }
}
function toJSON(link) {
  return {
    "/": format(link)
  };
}
function fromJSON(json) {
  return CID.parse(json["/"]);
}
var cache = /* @__PURE__ */ new WeakMap();
function baseCache(cid) {
  const baseCache2 = cache.get(cid);
  if (baseCache2 == null) {
    const baseCache3 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache3);
    return baseCache3;
  }
  return baseCache2;
}
var CID = class _CID {
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param multihash - (Multi)hash of the of the content.
   */
  constructor(version2, code5, multihash, bytes) {
    __publicField(this, "code");
    __publicField(this, "version");
    __publicField(this, "multihash");
    __publicField(this, "bytes");
    __publicField(this, "/");
    __publicField(this, _a, "CID");
    this.code = code5;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes;
    this["/"] = bytes;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      case 1: {
        const { code: code5, multihash } = this;
        if (code5 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code5, digest: digest2 } = this.multihash;
        const multihash = create(code5, digest2);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return _CID.equals(this, other);
  }
  static equals(self2, other) {
    const unknown = other;
    return unknown != null && self2.code === unknown.code && self2.version === unknown.version && equals2(self2.multihash, unknown.multihash);
  }
  toString(base3) {
    return format(this, base3);
  }
  toJSON() {
    return { "/": format(this) };
  }
  link() {
    return this;
  }
  // Legacy
  [(_a = Symbol.toStringTag, /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom"))]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   */
  static asCID(input) {
    if (input == null) {
      return null;
    }
    const value2 = input;
    if (value2 instanceof _CID) {
      return value2;
    } else if (value2["/"] != null && value2["/"] === value2.bytes || value2.asCID === value2) {
      const { version: version2, code: code5, multihash, bytes } = value2;
      return new _CID(version2, code5, multihash, bytes ?? encodeCID(version2, code5, multihash.bytes));
    } else if (value2[cidSymbol] === true) {
      const { version: version2, multihash, code: code5 } = value2;
      const digest2 = decode4(multihash);
      return _CID.create(version2, code5, digest2);
    } else {
      return null;
    }
  }
  /**
   * @param version - Version of the CID
   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param digest - (Multi)hash of the of the content.
   */
  static create(version2, code5, digest2) {
    if (typeof code5 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    if (!(digest2.bytes instanceof Uint8Array)) {
      throw new Error("Invalid digest");
    }
    switch (version2) {
      case 0: {
        if (code5 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version2, code5, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version2, code5, digest2.bytes);
        return new _CID(version2, code5, digest2, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   */
  static createV0(digest2) {
    return _CID.create(0, DAG_PB_CODE, digest2);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @param code - Content encoding format code.
   * @param digest - Multihash of the content.
   */
  static createV1(code5, digest2) {
    return _CID.create(1, code5, digest2);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   */
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length !== 0) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   */
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
    return [cid, bytes.subarray(specs.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   */
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length4] = decode3(initialBytes.subarray(offset));
      offset += length4;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return { version: version2, codec, multihashCode, digestSize, multihashSize, size };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   */
  static parse(source, base3) {
    const [prefix, bytes] = parseCIDtoBytes(source, base3);
    const cid = _CID.decode(bytes);
    if (cid.version === 0 && source[0] !== "Q") {
      throw Error("Version 0 CID string must not include multibase prefix");
    }
    baseCache(cid).set(prefix, source);
    return cid;
  }
};
function parseCIDtoBytes(source, base3) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder = base3 ?? base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base3 ?? base58btc;
      return [base58btc.prefix, decoder.decode(source)];
    }
    case base32.prefix: {
      const decoder = base3 ?? base32;
      return [base32.prefix, decoder.decode(source)];
    }
    case base36.prefix: {
      const decoder = base3 ?? base36;
      return [base36.prefix, decoder.decode(source)];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base3.decode(source)];
    }
  }
}
function toStringV0(bytes, cache3, base3) {
  const { prefix } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes).slice(1);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV1(bytes, cache3, base3) {
  const { prefix } = base3;
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
function encodeCID(version2, code5, multihash) {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code5);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version2, bytes, 0);
  encodeTo(code5, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cidSymbol = /* @__PURE__ */ Symbol.for("@ipld/js-cid/CID");

// ../../node_modules/multiformats/dist/src/hashes/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var code = 0;
var name = "identity";
var encode3 = coerce;
function digest(input, options2) {
  if (options2?.truncate != null && options2.truncate !== input.byteLength) {
    if (options2.truncate < 0 || options2.truncate > input.byteLength) {
      throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`);
    }
    input = input.subarray(0, options2.truncate);
  }
  return create(code, encode3(input));
}
var identity = { code, name, encode: encode3, digest };

// ../../node_modules/uint8arrays/dist/src/equals.js
function equals3(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (a2.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a2.byteLength; i2++) {
    if (a2[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/uint8arrays/dist/src/alloc.js
function alloc(size = 0) {
  return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
  return new Uint8Array(size);
}

// ../../node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array(buf2) {
  return buf2;
}

// ../../node_modules/uint8arrays/dist/src/concat.js
function concat(arrays, length4) {
  if (length4 == null) {
    length4 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length4);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}

// ../../node_modules/uint8arraylist/dist/src/index.js
var _a2;
var symbol = /* @__PURE__ */ Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index) {
  if (index == null || index < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf2 of bufs) {
    const bufEnd = offset + buf2.byteLength;
    if (index < bufEnd) {
      return {
        buf: buf2,
        index: index - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value2) {
  return Boolean(value2?.[symbol]);
}
var Uint8ArrayList = class _Uint8ArrayList {
  constructor(...data) {
    __publicField(this, "bufs");
    __publicField(this, "length");
    __publicField(this, _a2, true);
    this.bufs = [];
    this.length = 0;
    if (data.length > 0) {
      this.appendAll(data);
    }
  }
  *[(_a2 = symbol, Symbol.iterator)]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  /**
   * Add one or more `bufs` to the end of this Uint8ArrayList
   */
  append(...bufs) {
    this.appendAll(bufs);
  }
  /**
   * Add all `bufs` to the end of this Uint8ArrayList
   */
  appendAll(bufs) {
    let length4 = 0;
    for (const buf2 of bufs) {
      if (buf2 instanceof Uint8Array) {
        length4 += buf2.byteLength;
        this.bufs.push(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length4 += buf2.byteLength;
        this.bufs.push(...buf2.bufs);
      } else {
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length4;
  }
  /**
   * Add one or more `bufs` to the start of this Uint8ArrayList
   */
  prepend(...bufs) {
    this.prependAll(bufs);
  }
  /**
   * Add all `bufs` to the start of this Uint8ArrayList
   */
  prependAll(bufs) {
    let length4 = 0;
    for (const buf2 of bufs.reverse()) {
      if (buf2 instanceof Uint8Array) {
        length4 += buf2.byteLength;
        this.bufs.unshift(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length4 += buf2.byteLength;
        this.bufs.unshift(...buf2.bufs);
      } else {
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length4;
  }
  /**
   * Read the value at `index`
   */
  get(index) {
    const res = findBufAndOffset(this.bufs, index);
    return res.buf[res.index];
  }
  /**
   * Set the value at `index` to `value`
   */
  set(index, value2) {
    const res = findBufAndOffset(this.bufs, index);
    res.buf[res.index] = value2;
  }
  /**
   * Copy bytes from `buf` to the index specified by `offset`
   */
  write(buf2, offset = 0) {
    if (buf2 instanceof Uint8Array) {
      for (let i2 = 0; i2 < buf2.length; i2++) {
        this.set(offset + i2, buf2[i2]);
      }
    } else if (isUint8ArrayList(buf2)) {
      for (let i2 = 0; i2 < buf2.length; i2++) {
        this.set(offset + i2, buf2.get(i2));
      }
    } else {
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
  }
  /**
   * Remove bytes from the front of the pool
   */
  consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0) {
      return;
    }
    if (bytes === this.byteLength) {
      this.bufs = [];
      this.length = 0;
      return;
    }
    while (this.bufs.length > 0) {
      if (bytes >= this.bufs[0].byteLength) {
        bytes -= this.bufs[0].byteLength;
        this.length -= this.bufs[0].byteLength;
        this.bufs.shift();
      } else {
        this.bufs[0] = this.bufs[0].subarray(bytes);
        this.length -= bytes;
        break;
      }
    }
  }
  /**
   * Extracts a section of an array and returns a new array.
   *
   * This is a copy operation as it is with Uint8Arrays and Arrays
   * - note this is different to the behaviour of Node Buffers.
   */
  slice(beginInclusive, endExclusive) {
    const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
    return concat(bufs, length4);
  }
  /**
   * Returns a alloc from the given start and end element index.
   *
   * In the best case where the data extracted comes from a single Uint8Array
   * internally this is a no-copy operation otherwise it is a copy operation.
   */
  subarray(beginInclusive, endExclusive) {
    const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
    if (bufs.length === 1) {
      return bufs[0];
    }
    return concat(bufs, length4);
  }
  /**
   * Returns a allocList from the given start and end element index.
   *
   * This is a no-copy operation.
   */
  sublist(beginInclusive, endExclusive) {
    const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
    const list = new _Uint8ArrayList();
    list.length = length4;
    list.bufs = [...bufs];
    return list;
  }
  _subList(beginInclusive, endExclusive) {
    beginInclusive = beginInclusive ?? 0;
    endExclusive = endExclusive ?? this.length;
    if (beginInclusive < 0) {
      beginInclusive = this.length + beginInclusive;
    }
    if (endExclusive < 0) {
      endExclusive = this.length + endExclusive;
    }
    if (beginInclusive < 0 || endExclusive > this.length) {
      throw new RangeError("index is out of bounds");
    }
    if (beginInclusive === endExclusive) {
      return { bufs: [], length: 0 };
    }
    if (beginInclusive === 0 && endExclusive === this.length) {
      return { bufs: this.bufs, length: this.length };
    }
    const bufs = [];
    let offset = 0;
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      const buf2 = this.bufs[i2];
      const bufStart = offset;
      const bufEnd = bufStart + buf2.byteLength;
      offset = bufEnd;
      if (beginInclusive >= bufEnd) {
        continue;
      }
      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
      if (sliceStartInBuf && sliceEndsInBuf) {
        if (beginInclusive === bufStart && endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        const start2 = beginInclusive - bufStart;
        bufs.push(buf2.subarray(start2, start2 + (endExclusive - beginInclusive)));
        break;
      }
      if (sliceStartInBuf) {
        if (beginInclusive === 0) {
          bufs.push(buf2);
          continue;
        }
        bufs.push(buf2.subarray(beginInclusive - bufStart));
        continue;
      }
      if (sliceEndsInBuf) {
        if (endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        bufs.push(buf2.subarray(0, endExclusive - bufStart));
        break;
      }
      bufs.push(buf2);
    }
    return { bufs, length: endExclusive - beginInclusive };
  }
  indexOf(search, offset = 0) {
    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    }
    const needle = search instanceof Uint8Array ? search : search.subarray();
    offset = Number(offset ?? 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const M = needle.byteLength;
    if (M === 0) {
      throw new TypeError("search must be at least 1 byte long");
    }
    const radix = 256;
    const rightmostPositions = new Int32Array(radix);
    for (let c2 = 0; c2 < radix; c2++) {
      rightmostPositions[c2] = -1;
    }
    for (let j = 0; j < M; j++) {
      rightmostPositions[needle[j]] = j;
    }
    const right = rightmostPositions;
    const lastIndex = this.byteLength - needle.byteLength;
    const lastPatIndex = needle.byteLength - 1;
    let skip;
    for (let i2 = offset; i2 <= lastIndex; i2 += skip) {
      skip = 0;
      for (let j = lastPatIndex; j >= 0; j--) {
        const char = this.get(i2 + j);
        if (needle[j] !== char) {
          skip = Math.max(1, j - right[char]);
          break;
        }
      }
      if (skip === 0) {
        return i2;
      }
    }
    return -1;
  }
  getInt8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt8(0);
  }
  setInt8(byteOffset, value2) {
    const buf2 = allocUnsafe(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt8(0, value2);
    this.write(buf2, byteOffset);
  }
  getInt16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt16(0, littleEndian);
  }
  setInt16(byteOffset, value2, littleEndian) {
    const buf2 = alloc(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt16(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getInt32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt32(0, littleEndian);
  }
  setInt32(byteOffset, value2, littleEndian) {
    const buf2 = alloc(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigInt64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigInt64(0, littleEndian);
  }
  setBigInt64(byteOffset, value2, littleEndian) {
    const buf2 = alloc(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigInt64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint8(0);
  }
  setUint8(byteOffset, value2) {
    const buf2 = allocUnsafe(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint8(0, value2);
    this.write(buf2, byteOffset);
  }
  getUint16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint16(0, littleEndian);
  }
  setUint16(byteOffset, value2, littleEndian) {
    const buf2 = alloc(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint16(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint32(0, littleEndian);
  }
  setUint32(byteOffset, value2, littleEndian) {
    const buf2 = alloc(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigUint64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigUint64(0, littleEndian);
  }
  setBigUint64(byteOffset, value2, littleEndian) {
    const buf2 = alloc(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigUint64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat32(0, littleEndian);
  }
  setFloat32(byteOffset, value2, littleEndian) {
    const buf2 = alloc(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat32(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat64(0, littleEndian);
  }
  setFloat64(byteOffset, value2, littleEndian) {
    const buf2 = alloc(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat64(0, value2, littleEndian);
    this.write(buf2, byteOffset);
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (!(other instanceof _Uint8ArrayList)) {
      return false;
    }
    if (other.bufs.length !== this.bufs.length) {
      return false;
    }
    for (let i2 = 0; i2 < this.bufs.length; i2++) {
      if (!equals3(this.bufs[i2], other.bufs[i2])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
   * method if you know the total size of all the Uint8Arrays ahead of time.
   */
  static fromUint8Arrays(bufs, length4) {
    const list = new _Uint8ArrayList();
    list.bufs = bufs;
    if (length4 == null) {
      length4 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
    }
    list.length = length4;
    return list;
  }
};

// ../../node_modules/multiformats/dist/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// ../../node_modules/multiformats/dist/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// ../../node_modules/multiformats/dist/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// ../../node_modules/multiformats/dist/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("");
var alphabetBytesToChars = alphabet.reduce((p2, c2, i2) => {
  p2[i2] = c2;
  return p2;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p2, c2, i2) => {
  const codePoint = c2.codePointAt(0);
  if (codePoint == null) {
    throw new Error(`Invalid character: ${c2}`);
  }
  p2[codePoint] = i2;
  return p2;
}, []);
function encode4(data) {
  return data.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode5(str) {
  const byts = [];
  for (const char of str) {
    const codePoint = char.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${char}`);
    }
    const byt = alphabetCharsToBytes[codePoint];
    if (byt == null) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "",
  name: "base256emoji",
  encode: encode4,
  decode: decode5
});

// ../../node_modules/multiformats/dist/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// ../../node_modules/multiformats/dist/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// ../../node_modules/multiformats/dist/src/bases/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var identity2 = from({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString(buf2),
  decode: (str) => fromString(str)
});

// ../../node_modules/multiformats/dist/src/codecs/json.js
var json_exports = {};
__export(json_exports, {
  code: () => code2,
  decode: () => decode6,
  encode: () => encode5,
  name: () => name2
});
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var name2 = "json";
var code2 = 512;
function encode5(node) {
  return textEncoder.encode(JSON.stringify(node));
}
function decode6(data) {
  return JSON.parse(textDecoder.decode(data));
}

// ../../node_modules/multiformats/dist/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code3,
  decode: () => decode7,
  encode: () => encode6,
  name: () => name3
});
var name3 = "raw";
var code3 = 85;
function encode6(node) {
  return coerce(node);
}
function decode7(data) {
  return coerce(data);
}

// ../../node_modules/multiformats/dist/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});

// ../../node_modules/multiformats/dist/src/hashes/hasher.js
var hasher_exports = {};
__export(hasher_exports, {
  Hasher: () => Hasher,
  from: () => from2
});
var DEFAULT_MIN_DIGEST_LENGTH = 20;
function from2({ name: name5, code: code5, encode: encode13, minDigestLength, maxDigestLength }) {
  return new Hasher(name5, code5, encode13, minDigestLength, maxDigestLength);
}
var Hasher = class {
  constructor(name5, code5, encode13, minDigestLength, maxDigestLength) {
    __publicField(this, "name");
    __publicField(this, "code");
    __publicField(this, "encode");
    __publicField(this, "minDigestLength");
    __publicField(this, "maxDigestLength");
    this.name = name5;
    this.code = code5;
    this.encode = encode13;
    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH;
    this.maxDigestLength = maxDigestLength;
  }
  digest(input, options2) {
    if (options2?.truncate != null) {
      if (options2.truncate < this.minDigestLength) {
        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
      }
      if (this.maxDigestLength != null && options2.truncate > this.maxDigestLength) {
        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
      }
    }
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      if (result instanceof Uint8Array) {
        return createDigest(result, this.code, options2?.truncate);
      }
      return result.then((digest2) => createDigest(digest2, this.code, options2?.truncate));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
function createDigest(digest2, code5, truncate) {
  if (truncate != null && truncate !== digest2.byteLength) {
    if (truncate > digest2.byteLength) {
      throw new Error(`Invalid truncate option, must be less than or equal to ${digest2.byteLength}`);
    }
    digest2 = digest2.subarray(0, truncate);
  }
  return create(code5, digest2);
}

// ../../node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha(name5) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name5, data));
}
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// ../../node_modules/multiformats/dist/src/basics.js
var bases = { ...identity_exports2, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
var hashes = { ...sha2_browser_exports, ...identity_exports };
var codecs = { raw: raw_exports, json: json_exports };

// ../../node_modules/uint8arrays/dist/src/util/bases.js
function createCodec(name5, prefix, encode13, decode14) {
  return {
    name: name5,
    prefix,
    encoder: {
      name: name5,
      prefix,
      encode: encode13
    },
    decoder: {
      decode: decode14
    }
  };
}
var string = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string2 += String.fromCharCode(buf2[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// ../../node_modules/uint8arrays/dist/src/from-string.js
function fromString2(string2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (base3 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}

// ../../node_modules/uint8arrays/dist/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (base3 == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base3.encoder.encode(array).substring(1);
}

// ../../node_modules/@libp2p/crypto/dist/src/keys/rsa/der.js
var TAG_MASK = parseInt("11111", 2);
var LONG_LENGTH_MASK = parseInt("10000000", 2);
var LONG_LENGTH_BYTES_MASK = parseInt("01111111", 2);
var decoders = {
  0: readSequence,
  1: readSequence,
  2: readInteger,
  3: readBitString,
  4: readOctetString,
  5: readNull,
  6: readObjectIdentifier,
  16: readSequence,
  22: readSequence,
  48: readSequence
};
function decodeDer(buf2, context = { offset: 0 }) {
  const tag = buf2[context.offset] & TAG_MASK;
  context.offset++;
  if (decoders[tag] != null) {
    return decoders[tag](buf2, context);
  }
  throw new Error("No decoder for tag " + tag);
}
function readLength(buf2, context) {
  let length4 = 0;
  if ((buf2[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {
    const count = buf2[context.offset] & LONG_LENGTH_BYTES_MASK;
    let str = "0x";
    context.offset++;
    for (let i2 = 0; i2 < count; i2++, context.offset++) {
      str += buf2[context.offset].toString(16).padStart(2, "0");
    }
    length4 = parseInt(str, 16);
  } else {
    length4 = buf2[context.offset];
    context.offset++;
  }
  return length4;
}
function readSequence(buf2, context) {
  readLength(buf2, context);
  const entries = [];
  while (true) {
    if (context.offset >= buf2.byteLength) {
      break;
    }
    const result = decodeDer(buf2, context);
    if (result === null) {
      break;
    }
    entries.push(result);
  }
  return entries;
}
function readInteger(buf2, context) {
  const length4 = readLength(buf2, context);
  const start2 = context.offset;
  const end = context.offset + length4;
  const vals = [];
  for (let i2 = start2; i2 < end; i2++) {
    if (i2 === start2 && buf2[i2] === 0) {
      continue;
    }
    vals.push(buf2[i2]);
  }
  context.offset += length4;
  return Uint8Array.from(vals);
}
function readObjectIdentifier(buf2, context) {
  const count = readLength(buf2, context);
  const finalOffset = context.offset + count;
  const byte = buf2[context.offset];
  context.offset++;
  let val1 = 0;
  let val2 = 0;
  if (byte < 40) {
    val1 = 0;
    val2 = byte;
  } else if (byte < 80) {
    val1 = 1;
    val2 = byte - 40;
  } else {
    val1 = 2;
    val2 = byte - 80;
  }
  let oid = `${val1}.${val2}`;
  let num2 = [];
  while (context.offset < finalOffset) {
    const byte2 = buf2[context.offset];
    context.offset++;
    num2.push(byte2 & 127);
    if (byte2 < 128) {
      num2.reverse();
      let val = 0;
      for (let i2 = 0; i2 < num2.length; i2++) {
        val += num2[i2] << i2 * 7;
      }
      oid += `.${val}`;
      num2 = [];
    }
  }
  return oid;
}
function readNull(buf2, context) {
  context.offset++;
  return null;
}
function readBitString(buf2, context) {
  const length4 = readLength(buf2, context);
  const unusedBits = buf2[context.offset];
  context.offset++;
  const bytes = buf2.subarray(context.offset, context.offset + length4 - 1);
  context.offset += length4;
  if (unusedBits !== 0) {
    throw new Error("Unused bits in bit string is unimplemented");
  }
  return bytes;
}
function readOctetString(buf2, context) {
  const length4 = readLength(buf2, context);
  const bytes = buf2.subarray(context.offset, context.offset + length4);
  context.offset += length4;
  return bytes;
}
function encodeNumber(value2) {
  let number = value2.toString(16);
  if (number.length % 2 === 1) {
    number = "0" + number;
  }
  const array = new Uint8ArrayList();
  for (let i2 = 0; i2 < number.length; i2 += 2) {
    array.append(Uint8Array.from([parseInt(`${number[i2]}${number[i2 + 1]}`, 16)]));
  }
  return array;
}
function encodeLength(bytes) {
  if (bytes.byteLength < 128) {
    return Uint8Array.from([bytes.byteLength]);
  }
  const length4 = encodeNumber(bytes.byteLength);
  return new Uint8ArrayList(Uint8Array.from([
    length4.byteLength | LONG_LENGTH_MASK
  ]), length4);
}
function encodeInteger(value2) {
  const contents = new Uint8ArrayList();
  const mask = 128;
  const positive3 = (value2.subarray()[0] & mask) === mask;
  if (positive3) {
    contents.append(Uint8Array.from([0]));
  }
  contents.append(value2);
  return new Uint8ArrayList(Uint8Array.from([2]), encodeLength(contents), contents);
}
function encodeBitString(value2) {
  const unusedBits = Uint8Array.from([0]);
  const contents = new Uint8ArrayList(unusedBits, value2);
  return new Uint8ArrayList(Uint8Array.from([3]), encodeLength(contents), contents);
}
function encodeOctetString(value2) {
  return new Uint8ArrayList(Uint8Array.from([4]), encodeLength(value2), value2);
}
function encodeSequence(values, tag = 48) {
  const output = new Uint8ArrayList();
  for (const buf2 of values) {
    output.append(buf2);
  }
  return new Uint8ArrayList(Uint8Array.from([tag]), encodeLength(output), output);
}

// ../../node_modules/@libp2p/crypto/dist/src/keys/ecdsa/index.js
var ECDSA_P_256_OID = "1.2.840.10045.3.1.7";
var ECDSA_P_384_OID = "1.3.132.0.34";
var ECDSA_P_521_OID = "1.3.132.0.35";
async function generateECDSAKey(curve = "P-256") {
  const keyPair = await crypto.subtle.generateKey({
    name: "ECDSA",
    namedCurve: curve
  }, true, ["sign", "verify"]);
  return {
    publicKey: await crypto.subtle.exportKey("jwk", keyPair.publicKey),
    privateKey: await crypto.subtle.exportKey("jwk", keyPair.privateKey)
  };
}
async function hashAndSign(key, msg, options2) {
  const privateKey = await crypto.subtle.importKey("jwk", key, {
    name: "ECDSA",
    namedCurve: key.crv ?? "P-256"
  }, false, ["sign"]);
  options2?.signal?.throwIfAborted();
  const signature = await crypto.subtle.sign({
    name: "ECDSA",
    hash: {
      name: "SHA-256"
    }
  }, privateKey, msg.subarray());
  options2?.signal?.throwIfAborted();
  return new Uint8Array(signature, 0, signature.byteLength);
}
async function hashAndVerify(key, sig, msg, options2) {
  const publicKey2 = await crypto.subtle.importKey("jwk", key, {
    name: "ECDSA",
    namedCurve: key.crv ?? "P-256"
  }, false, ["verify"]);
  options2?.signal?.throwIfAborted();
  const result = await crypto.subtle.verify({
    name: "ECDSA",
    hash: {
      name: "SHA-256"
    }
  }, publicKey2, sig, msg.subarray());
  options2?.signal?.throwIfAborted();
  return result;
}

// ../../node_modules/@libp2p/crypto/dist/src/keys/ecdsa/utils.js
var OID_256 = Uint8Array.from([6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
var OID_384 = Uint8Array.from([6, 5, 43, 129, 4, 0, 34]);
var OID_521 = Uint8Array.from([6, 5, 43, 129, 4, 0, 35]);
var P_256_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-256"
};
var P_384_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-384"
};
var P_521_KEY_JWK = {
  ext: true,
  kty: "EC",
  crv: "P-521"
};
var P_256_KEY_LENGTH = 32;
var P_384_KEY_LENGTH = 48;
var P_521_KEY_LENGTH = 66;
function unmarshalECDSAPrivateKey(bytes) {
  const message2 = decodeDer(bytes);
  return pkiMessageToECDSAPrivateKey(message2);
}
function pkiMessageToECDSAPrivateKey(message2) {
  const privateKey = message2[1];
  const d2 = toString2(privateKey, "base64url");
  const coordinates = message2[2][1][0];
  const offset = 1;
  let x;
  let y;
  if (privateKey.byteLength === P_256_KEY_LENGTH) {
    x = toString2(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), "base64url");
    y = toString2(coordinates.subarray(offset + P_256_KEY_LENGTH), "base64url");
    return new ECDSAPrivateKey({
      ...P_256_KEY_JWK,
      key_ops: ["sign"],
      d: d2,
      x,
      y
    });
  }
  if (privateKey.byteLength === P_384_KEY_LENGTH) {
    x = toString2(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), "base64url");
    y = toString2(coordinates.subarray(offset + P_384_KEY_LENGTH), "base64url");
    return new ECDSAPrivateKey({
      ...P_384_KEY_JWK,
      key_ops: ["sign"],
      d: d2,
      x,
      y
    });
  }
  if (privateKey.byteLength === P_521_KEY_LENGTH) {
    x = toString2(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), "base64url");
    y = toString2(coordinates.subarray(offset + P_521_KEY_LENGTH), "base64url");
    return new ECDSAPrivateKey({
      ...P_521_KEY_JWK,
      key_ops: ["sign"],
      d: d2,
      x,
      y
    });
  }
  throw new InvalidParametersError2(`Private key length was wrong length, got ${privateKey.byteLength}, expected 32, 48 or 66`);
}
function unmarshalECDSAPublicKey(bytes) {
  const message2 = decodeDer(bytes);
  return pkiMessageToECDSAPublicKey(message2);
}
function pkiMessageToECDSAPublicKey(message2) {
  const coordinates = message2[1][1][0];
  const offset = 1;
  let x;
  let y;
  if (coordinates.byteLength === P_256_KEY_LENGTH * 2 + 1) {
    x = toString2(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), "base64url");
    y = toString2(coordinates.subarray(offset + P_256_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_256_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_384_KEY_LENGTH * 2 + 1) {
    x = toString2(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), "base64url");
    y = toString2(coordinates.subarray(offset + P_384_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_384_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  if (coordinates.byteLength === P_521_KEY_LENGTH * 2 + 1) {
    x = toString2(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), "base64url");
    y = toString2(coordinates.subarray(offset + P_521_KEY_LENGTH), "base64url");
    return new ECDSAPublicKey({
      ...P_521_KEY_JWK,
      key_ops: ["verify"],
      x,
      y
    });
  }
  throw new InvalidParametersError2(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`);
}
function privateKeyToPKIMessage(privateKey) {
  return encodeSequence([
    encodeInteger(Uint8Array.from([1])),
    // header
    encodeOctetString(fromString2(privateKey.d ?? "", "base64url")),
    // body
    encodeSequence([
      getOID(privateKey.crv)
    ], 160),
    encodeSequence([
      encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString2(privateKey.x ?? "", "base64url"), fromString2(privateKey.y ?? "", "base64url")))
    ], 161)
  ]).subarray();
}
function publicKeyToPKIMessage(publicKey2) {
  return encodeSequence([
    encodeInteger(Uint8Array.from([1])),
    // header
    encodeSequence([
      getOID(publicKey2.crv)
    ], 160),
    encodeSequence([
      encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString2(publicKey2.x ?? "", "base64url"), fromString2(publicKey2.y ?? "", "base64url")))
    ], 161)
  ]).subarray();
}
function getOID(curve) {
  if (curve === "P-256") {
    return OID_256;
  }
  if (curve === "P-384") {
    return OID_384;
  }
  if (curve === "P-521") {
    return OID_521;
  }
  throw new InvalidParametersError2(`Invalid curve ${curve}`);
}
async function generateECDSAKeyPair(curve = "P-256") {
  const key = await generateECDSAKey(curve);
  return new ECDSAPrivateKey(key.privateKey);
}
function ensureECDSAKey(key, length4) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length4) {
    throw new InvalidParametersError2(`Key must be a Uint8Array of length ${length4}, got ${key.length}`);
  }
  return key;
}

// ../../node_modules/@libp2p/crypto/dist/src/keys/ecdsa/ecdsa.js
var ECDSAPublicKey = class {
  constructor(jwk) {
    __publicField(this, "type", "ECDSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    this.jwk = jwk;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = publicKeyToPKIMessage(this.jwk);
    }
    return this._raw;
  }
  toMultihash() {
    return identity.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  async verify(data, sig, options2) {
    return hashAndVerify(this.jwk, sig, data, options2);
  }
};
var ECDSAPrivateKey = class {
  constructor(jwk) {
    __publicField(this, "type", "ECDSA");
    __publicField(this, "jwk");
    __publicField(this, "publicKey");
    __publicField(this, "_raw");
    this.jwk = jwk;
    this.publicKey = new ECDSAPublicKey({
      crv: jwk.crv,
      ext: jwk.ext,
      key_ops: ["verify"],
      kty: "EC",
      x: jwk.x,
      y: jwk.y
    });
  }
  get raw() {
    if (this._raw == null) {
      this._raw = privateKeyToPKIMessage(this.jwk);
    }
    return this._raw;
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  async sign(message2, options2) {
    return hashAndSign(this.jwk, message2, options2);
  }
};

// ../../node_modules/@noble/hashes/utils.js
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function anumber(n2, title = "") {
  if (!Number.isSafeInteger(n2) || n2 < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n2}`);
  }
}
function abytes(value2, length4, title = "") {
  const bytes = isBytes(value2);
  const len = value2?.length;
  const needsLen = length4 !== void 0;
  if (!bytes || needsLen && len !== length4) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length4}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value2}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value2;
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out, void 0, "digestInto() output");
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error('"digestInto() output" expected to be of length >=' + min);
  }
}
function u8(arr) {
  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word2, shift) {
  return word2 << 32 - shift | word2 >>> shift;
}
function rotl(word2, shift) {
  return word2 << shift | word2 >>> 32 - shift >>> 0;
}
var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word2) {
  return word2 << 24 & 4278190080 | word2 << 8 & 16711680 | word2 >>> 8 & 65280 | word2 >>> 24 & 255;
}
var swap8IfBE = isLE ? (n2) => n2 : (n2) => byteSwap(n2);
function byteSwap32(arr) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    arr[i2] = byteSwap(arr[i2]);
  }
  return arr;
}
var swap32IfBE = isLE ? (u2) => u2 : byteSwap32;
var hasHexBuiltin = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex += hexes[bytes[i2]];
  }
  return hex;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
var nextTick = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i2 = 0; i2 < iters; i2++) {
    cb(i2);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function kdfInputToBytes(data, errorTitle = "") {
  if (typeof data === "string")
    return utf8ToBytes(data);
  return abytes(data, void 0, errorTitle);
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    abytes(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad);
    pad += a2.length;
  }
  return res;
}
function checkOpts(defaults3, opts) {
  if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
    throw new Error("options must be object or undefined");
  const merged = Object.assign(defaults3, opts);
  return merged;
}
function createHasher(hashCons, info = {}) {
  const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
function randomBytes(bytesLength = 32) {
  const cr = typeof window === "object" ? window.crypto : null;
  if (typeof cr?.getRandomValues !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr.getRandomValues(new Uint8Array(bytesLength));
}
var oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});

// ../../node_modules/@noble/hashes/_md.js
function Chi(a2, b, c2) {
  return a2 & b ^ ~a2 & c2;
}
function Maj(a2, b, c2) {
  return a2 & b ^ a2 & c2 ^ b & c2;
}
var HashMD = class {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    abytes(data);
    const { view, buffer: buffer2, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        const dataView2 = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView2, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer2[i2] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE3);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length4, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length4;
    to.pos = pos;
    if (length4 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = /* @__PURE__ */ Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV = /* @__PURE__ */ Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// ../../node_modules/@noble/hashes/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    const { h, l: l2 } = fromBig(lst[i2], le);
    [Ah[i2], Al[i2]] = [h, l2];
  }
  return [Ah, Al];
}
var toBig = (h, l2) => BigInt(h >>> 0) << _32n | BigInt(l2 >>> 0);
var shrSH = (h, _l, s2) => h >>> s2;
var shrSL = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
var rotrSH = (h, l2, s2) => h >>> s2 | l2 << 32 - s2;
var rotrSL = (h, l2, s2) => h << 32 - s2 | l2 >>> s2;
var rotrBH = (h, l2, s2) => h << 64 - s2 | l2 >>> s2 - 32;
var rotrBL = (h, l2, s2) => h >>> s2 - 32 | l2 << 64 - s2;
var rotr32H = (_h, l2) => l2;
var rotr32L = (h, _l) => h;
var rotlSH = (h, l2, s2) => h << s2 | l2 >>> 32 - s2;
var rotlSL = (h, l2, s2) => l2 << s2 | h >>> 32 - s2;
var rotlBH = (h, l2, s2) => l2 << s2 - 32 | h >>> 64 - s2;
var rotlBL = (h, l2, s2) => h << s2 - 32 | l2 >>> 64 - s2;
function add(Ah, Al, Bh, Bl2) {
  const l2 = (Al >>> 0) + (Bl2 >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
var add3L = (Al, Bl2, Cl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl2, Cl, Dl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl2, Cl, Dl, El) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// ../../node_modules/@noble/hashes/sha2.js
var SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA2_32B = class extends HashMD {
  constructor(outputLen) {
    super(64, outputLen, 8, false);
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var _SHA256 = class extends SHA2_32B {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", SHA256_IV[0] | 0);
    __publicField(this, "B", SHA256_IV[1] | 0);
    __publicField(this, "C", SHA256_IV[2] | 0);
    __publicField(this, "D", SHA256_IV[3] | 0);
    __publicField(this, "E", SHA256_IV[4] | 0);
    __publicField(this, "F", SHA256_IV[5] | 0);
    __publicField(this, "G", SHA256_IV[6] | 0);
    __publicField(this, "H", SHA256_IV[7] | 0);
  }
};
var _SHA224 = class extends SHA2_32B {
  constructor() {
    super(28);
    __publicField(this, "A", SHA224_IV[0] | 0);
    __publicField(this, "B", SHA224_IV[1] | 0);
    __publicField(this, "C", SHA224_IV[2] | 0);
    __publicField(this, "D", SHA224_IV[3] | 0);
    __publicField(this, "E", SHA224_IV[4] | 0);
    __publicField(this, "F", SHA224_IV[5] | 0);
    __publicField(this, "G", SHA224_IV[6] | 0);
    __publicField(this, "H", SHA224_IV[7] | 0);
  }
};
var K512 = /* @__PURE__ */ (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA2_64B = class extends HashMD {
  constructor(outputLen) {
    super(128, outputLen, 16, false);
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl2 | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl2 ^ Al & Cl ^ Bl2 & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl2 | 0;
      Bh = Ah | 0;
      Bl2 = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl2 } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl2 | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var _SHA512 = class extends SHA2_64B {
  constructor() {
    super(64);
    __publicField(this, "Ah", SHA512_IV[0] | 0);
    __publicField(this, "Al", SHA512_IV[1] | 0);
    __publicField(this, "Bh", SHA512_IV[2] | 0);
    __publicField(this, "Bl", SHA512_IV[3] | 0);
    __publicField(this, "Ch", SHA512_IV[4] | 0);
    __publicField(this, "Cl", SHA512_IV[5] | 0);
    __publicField(this, "Dh", SHA512_IV[6] | 0);
    __publicField(this, "Dl", SHA512_IV[7] | 0);
    __publicField(this, "Eh", SHA512_IV[8] | 0);
    __publicField(this, "El", SHA512_IV[9] | 0);
    __publicField(this, "Fh", SHA512_IV[10] | 0);
    __publicField(this, "Fl", SHA512_IV[11] | 0);
    __publicField(this, "Gh", SHA512_IV[12] | 0);
    __publicField(this, "Gl", SHA512_IV[13] | 0);
    __publicField(this, "Hh", SHA512_IV[14] | 0);
    __publicField(this, "Hl", SHA512_IV[15] | 0);
  }
};
var _SHA384 = class extends SHA2_64B {
  constructor() {
    super(48);
    __publicField(this, "Ah", SHA384_IV[0] | 0);
    __publicField(this, "Al", SHA384_IV[1] | 0);
    __publicField(this, "Bh", SHA384_IV[2] | 0);
    __publicField(this, "Bl", SHA384_IV[3] | 0);
    __publicField(this, "Ch", SHA384_IV[4] | 0);
    __publicField(this, "Cl", SHA384_IV[5] | 0);
    __publicField(this, "Dh", SHA384_IV[6] | 0);
    __publicField(this, "Dl", SHA384_IV[7] | 0);
    __publicField(this, "Eh", SHA384_IV[8] | 0);
    __publicField(this, "El", SHA384_IV[9] | 0);
    __publicField(this, "Fh", SHA384_IV[10] | 0);
    __publicField(this, "Fl", SHA384_IV[11] | 0);
    __publicField(this, "Gh", SHA384_IV[12] | 0);
    __publicField(this, "Gl", SHA384_IV[13] | 0);
    __publicField(this, "Hh", SHA384_IV[14] | 0);
    __publicField(this, "Hl", SHA384_IV[15] | 0);
  }
};
var T224_IV = /* @__PURE__ */ Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV = /* @__PURE__ */ Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var _SHA512_224 = class extends SHA2_64B {
  constructor() {
    super(28);
    __publicField(this, "Ah", T224_IV[0] | 0);
    __publicField(this, "Al", T224_IV[1] | 0);
    __publicField(this, "Bh", T224_IV[2] | 0);
    __publicField(this, "Bl", T224_IV[3] | 0);
    __publicField(this, "Ch", T224_IV[4] | 0);
    __publicField(this, "Cl", T224_IV[5] | 0);
    __publicField(this, "Dh", T224_IV[6] | 0);
    __publicField(this, "Dl", T224_IV[7] | 0);
    __publicField(this, "Eh", T224_IV[8] | 0);
    __publicField(this, "El", T224_IV[9] | 0);
    __publicField(this, "Fh", T224_IV[10] | 0);
    __publicField(this, "Fl", T224_IV[11] | 0);
    __publicField(this, "Gh", T224_IV[12] | 0);
    __publicField(this, "Gl", T224_IV[13] | 0);
    __publicField(this, "Hh", T224_IV[14] | 0);
    __publicField(this, "Hl", T224_IV[15] | 0);
  }
};
var _SHA512_256 = class extends SHA2_64B {
  constructor() {
    super(32);
    __publicField(this, "Ah", T256_IV[0] | 0);
    __publicField(this, "Al", T256_IV[1] | 0);
    __publicField(this, "Bh", T256_IV[2] | 0);
    __publicField(this, "Bl", T256_IV[3] | 0);
    __publicField(this, "Ch", T256_IV[4] | 0);
    __publicField(this, "Cl", T256_IV[5] | 0);
    __publicField(this, "Dh", T256_IV[6] | 0);
    __publicField(this, "Dl", T256_IV[7] | 0);
    __publicField(this, "Eh", T256_IV[8] | 0);
    __publicField(this, "El", T256_IV[9] | 0);
    __publicField(this, "Fh", T256_IV[10] | 0);
    __publicField(this, "Fl", T256_IV[11] | 0);
    __publicField(this, "Gh", T256_IV[12] | 0);
    __publicField(this, "Gl", T256_IV[13] | 0);
    __publicField(this, "Hh", T256_IV[14] | 0);
    __publicField(this, "Hl", T256_IV[15] | 0);
  }
};
var sha2562 = /* @__PURE__ */ createHasher(
  () => new _SHA256(),
  /* @__PURE__ */ oidNist(1)
);
var sha224 = /* @__PURE__ */ createHasher(
  () => new _SHA224(),
  /* @__PURE__ */ oidNist(4)
);
var sha5122 = /* @__PURE__ */ createHasher(
  () => new _SHA512(),
  /* @__PURE__ */ oidNist(3)
);
var sha384 = /* @__PURE__ */ createHasher(
  () => new _SHA384(),
  /* @__PURE__ */ oidNist(2)
);
var sha512_256 = /* @__PURE__ */ createHasher(
  () => new _SHA512_256(),
  /* @__PURE__ */ oidNist(6)
);
var sha512_224 = /* @__PURE__ */ createHasher(
  () => new _SHA512_224(),
  /* @__PURE__ */ oidNist(5)
);

// ../../node_modules/@noble/curves/utils.js
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
function abool(value2, title = "") {
  if (typeof value2 !== "boolean") {
    const prefix = title && `"${title}" `;
    throw new Error(prefix + "expected boolean, got type=" + typeof value2);
  }
  return value2;
}
function abignumber(n2) {
  if (typeof n2 === "bigint") {
    if (!isPosBig(n2))
      throw new Error("positive bigint expected, got " + n2);
  } else
    anumber(n2);
  return n2;
}
function asafenumber(value2, title = "") {
  if (!Number.isSafeInteger(value2)) {
    const prefix = title && `"${title}" `;
    throw new Error(prefix + "expected safe integer, got type=" + typeof value2);
  }
}
function numberToHexUnpadded(num2) {
  const hex = abignumber(num2).toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n : BigInt("0x" + hex);
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  return hexToNumber(bytesToHex(copyBytes(abytes(bytes)).reverse()));
}
function numberToBytesBE(n2, len) {
  anumber(len);
  n2 = abignumber(n2);
  const res = hexToBytes(n2.toString(16).padStart(len * 2, "0"));
  if (res.length !== len)
    throw new Error("number too large");
  return res;
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(abignumber(n2)));
}
function equalBytes(a2, b) {
  if (a2.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a2.length; i2++)
    diff |= a2[i2] ^ b[i2];
  return diff === 0;
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}
function asciiToBytes(ascii2) {
  return Uint8Array.from(ascii2, (c2, i2) => {
    const charCode = c2.charCodeAt(0);
    if (c2.length !== 1 || charCode > 127) {
      throw new Error(`string contains non-ASCII character "${ascii2[i2]}" with code ${charCode} at position ${i2}`);
    }
    return charCode;
  });
}
var isPosBig = (n2) => typeof n2 === "bigint" && _0n <= n2;
function inRange(n2, min, max) {
  return isPosBig(n2) && isPosBig(min) && isPosBig(max) && min <= n2 && n2 < max;
}
function aInRange(title, n2, min, max) {
  if (!inRange(n2, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n2);
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n; n2 >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n;
}
function bitSet(n2, pos, value2) {
  return n2 | (value2 ? _1n : _0n) << BigInt(pos);
}
var bitMask = (n2) => (_1n << BigInt(n2)) - _1n;
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  anumber(hashLen, "hashLen");
  anumber(qByteLen, "qByteLen");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n = (len) => new Uint8Array(len);
  const NULL = Uint8Array.of();
  const byte0 = Uint8Array.of(0);
  const byte1 = Uint8Array.of(1);
  const _maxDrbgIters = 1e3;
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...msgs) => hmacFn(k, concatBytes(v, ...msgs));
  const reseed = (seed = NULL) => {
    k = h(byte0, seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(byte1, seed);
    v = h();
  };
  const gen = () => {
    if (i2++ >= _maxDrbgIters)
      throw new Error("drbg: tried max amount of iterations");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object, fields = {}, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === void 0)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  const iter = (f2, isOpt) => Object.entries(f2).forEach(([k, v]) => checkField(k, v, isOpt));
  iter(fields, false);
  iter(optFields, true);
}
var notImplemented = () => {
  throw new Error("not implemented");
};
function memoized(fn) {
  const map2 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map2.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map2.set(arg, computed);
    return computed;
  };
}

// ../../node_modules/@noble/curves/abstract/modular.js
var _0n2 = /* @__PURE__ */ BigInt(0), _1n2 = /* @__PURE__ */ BigInt(1), _2n = /* @__PURE__ */ BigInt(2);
var _3n = /* @__PURE__ */ BigInt(3), _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);
var _7n = /* @__PURE__ */ BigInt(7), _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9);
var _16n = /* @__PURE__ */ BigInt(16);
function mod(a2, b) {
  const result = a2 % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num2, power, modulo) {
  return FpPow(Field(modulo), num2, power);
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a2 = mod(number, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u2 = _1n2, v = _0n2;
  while (a2 !== _0n2) {
    const q = b / a2;
    const r2 = b % a2;
    const m2 = x - u2 * q;
    const n2 = y - v * q;
    b = a2, a2 = r2, x = u2, y = v, u2 = m2, v = n2;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function assertIsSquare(Fp2, root, n2) {
  if (!Fp2.eql(Fp2.sqr(root), n2))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp2, n2) {
  const p1div4 = (Fp2.ORDER + _1n2) / _4n;
  const root = Fp2.pow(n2, p1div4);
  assertIsSquare(Fp2, root, n2);
  return root;
}
function sqrt5mod8(Fp2, n2) {
  const p5div8 = (Fp2.ORDER - _5n) / _8n;
  const n22 = Fp2.mul(n2, _2n);
  const v = Fp2.pow(n22, p5div8);
  const nv = Fp2.mul(n2, v);
  const i2 = Fp2.mul(Fp2.mul(nv, _2n), v);
  const root = Fp2.mul(nv, Fp2.sub(i2, Fp2.ONE));
  assertIsSquare(Fp2, root, n2);
  return root;
}
function sqrt9mod16(P) {
  const Fp_ = Field(P);
  const tn = tonelliShanks(P);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P + _7n) / _16n;
  return (Fp2, n2) => {
    let tv1 = Fp2.pow(n2, c4);
    let tv2 = Fp2.mul(tv1, c1);
    const tv3 = Fp2.mul(tv1, c2);
    const tv4 = Fp2.mul(tv1, c3);
    const e1 = Fp2.eql(Fp2.sqr(tv2), n2);
    const e2 = Fp2.eql(Fp2.sqr(tv3), n2);
    tv1 = Fp2.cmov(tv1, tv2, e1);
    tv2 = Fp2.cmov(tv4, tv3, e2);
    const e3 = Fp2.eql(Fp2.sqr(tv2), n2);
    const root = Fp2.cmov(tv1, tv2, e3);
    assertIsSquare(Fp2, root, n2);
    return root;
  };
}
function tonelliShanks(P) {
  if (P < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.is0(n2))
      return n2;
    if (FpLegendre(Fp2, n2) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c2 = Fp2.mul(Fp2.ONE, cc);
    let t2 = Fp2.pow(n2, Q);
    let R = Fp2.pow(n2, Q1div2);
    while (!Fp2.eql(t2, Fp2.ONE)) {
      if (Fp2.is0(t2))
        return Fp2.ZERO;
      let i2 = 1;
      let t_tmp = Fp2.sqr(t2);
      while (!Fp2.eql(t_tmp, Fp2.ONE)) {
        i2++;
        t_tmp = Fp2.sqr(t_tmp);
        if (i2 === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i2 - 1);
      const b = Fp2.pow(c2, exponent);
      M = i2;
      c2 = Fp2.sqr(b);
      t2 = Fp2.mul(t2, c2);
      R = Fp2.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n)
    return sqrt3mod4;
  if (P % _8n === _5n)
    return sqrt5mod8;
  if (P % _16n === _9n)
    return sqrt9mod16(P);
  return tonelliShanks(P);
}
var isNegativeLE = (num2, modulo) => (mod(num2, modulo) & _1n2) === _1n2;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  validateObject(field, opts);
  return field;
}
function FpPow(Fp2, num2, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp2.ONE;
  if (power === _1n2)
    return num2;
  let p2 = Fp2.ONE;
  let d2 = num2;
  while (power > _0n2) {
    if (power & _1n2)
      p2 = Fp2.mul(p2, d2);
    d2 = Fp2.sqr(d2);
    power >>= _1n2;
  }
  return p2;
}
function FpInvertBatch(Fp2, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num2, i2) => {
    if (Fp2.is0(num2))
      return acc;
    inverted[i2] = acc;
    return Fp2.mul(acc, num2);
  }, Fp2.ONE);
  const invertedAcc = Fp2.inv(multipliedAcc);
  nums.reduceRight((acc, num2, i2) => {
    if (Fp2.is0(num2))
      return acc;
    inverted[i2] = Fp2.mul(acc, inverted[i2]);
    return Fp2.mul(acc, num2);
  }, invertedAcc);
  return inverted;
}
function FpDiv(Fp2, lhs, rhs) {
  return Fp2.mul(lhs, typeof rhs === "bigint" ? invert(rhs, Fp2.ORDER) : Fp2.inv(rhs));
}
function FpLegendre(Fp2, n2) {
  const p1mod2 = (Fp2.ORDER - _1n2) / _2n;
  const powered = Fp2.pow(n2, p1mod2);
  const yes = Fp2.eql(powered, Fp2.ONE);
  const zero2 = Fp2.eql(powered, Fp2.ZERO);
  const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
  if (!yes && !zero2 && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero2 ? 0 : -1;
}
function FpIsSquare(Fp2, n2) {
  const l2 = FpLegendre(Fp2, n2);
  return l2 === 1;
}
function nLength(n2, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
var _Field = class {
  constructor(ORDER, opts = {}) {
    __publicField(this, "ORDER");
    __publicField(this, "BITS");
    __publicField(this, "BYTES");
    __publicField(this, "isLE");
    __publicField(this, "ZERO", _0n2);
    __publicField(this, "ONE", _1n2);
    __publicField(this, "_lengths");
    __publicField(this, "_sqrt");
    // cached sqrt
    __publicField(this, "_mod");
    if (ORDER <= _0n2)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    this.isLE = false;
    if (opts != null && typeof opts === "object") {
      if (typeof opts.BITS === "number")
        _nbitLength = opts.BITS;
      if (typeof opts.sqrt === "function")
        this.sqrt = opts.sqrt;
      if (typeof opts.isLE === "boolean")
        this.isLE = opts.isLE;
      if (opts.allowedLengths)
        this._lengths = opts.allowedLengths?.slice();
      if (typeof opts.modFromBytes === "boolean")
        this._mod = opts.modFromBytes;
    }
    const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);
    if (nByteLength > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = ORDER;
    this.BITS = nBitLength;
    this.BYTES = nByteLength;
    this._sqrt = void 0;
    Object.preventExtensions(this);
  }
  create(num2) {
    return mod(num2, this.ORDER);
  }
  isValid(num2) {
    if (typeof num2 !== "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof num2);
    return _0n2 <= num2 && num2 < this.ORDER;
  }
  is0(num2) {
    return num2 === _0n2;
  }
  // is valid and invertible
  isValidNot0(num2) {
    return !this.is0(num2) && this.isValid(num2);
  }
  isOdd(num2) {
    return (num2 & _1n2) === _1n2;
  }
  neg(num2) {
    return mod(-num2, this.ORDER);
  }
  eql(lhs, rhs) {
    return lhs === rhs;
  }
  sqr(num2) {
    return mod(num2 * num2, this.ORDER);
  }
  add(lhs, rhs) {
    return mod(lhs + rhs, this.ORDER);
  }
  sub(lhs, rhs) {
    return mod(lhs - rhs, this.ORDER);
  }
  mul(lhs, rhs) {
    return mod(lhs * rhs, this.ORDER);
  }
  pow(num2, power) {
    return FpPow(this, num2, power);
  }
  div(lhs, rhs) {
    return mod(lhs * invert(rhs, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(num2) {
    return num2 * num2;
  }
  addN(lhs, rhs) {
    return lhs + rhs;
  }
  subN(lhs, rhs) {
    return lhs - rhs;
  }
  mulN(lhs, rhs) {
    return lhs * rhs;
  }
  inv(num2) {
    return invert(num2, this.ORDER);
  }
  sqrt(num2) {
    if (!this._sqrt)
      this._sqrt = FpSqrt(this.ORDER);
    return this._sqrt(this, num2);
  }
  toBytes(num2) {
    return this.isLE ? numberToBytesLE(num2, this.BYTES) : numberToBytesBE(num2, this.BYTES);
  }
  fromBytes(bytes, skipValidation = false) {
    abytes(bytes);
    const { _lengths: allowedLengths, BYTES, isLE: isLE3, ORDER, _mod: modFromBytes } = this;
    if (allowedLengths) {
      if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
        throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
      }
      const padded = new Uint8Array(BYTES);
      padded.set(bytes, isLE3 ? 0 : padded.length - bytes.length);
      bytes = padded;
    }
    if (bytes.length !== BYTES)
      throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
    let scalar = isLE3 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    if (modFromBytes)
      scalar = mod(scalar, ORDER);
    if (!skipValidation) {
      if (!this.isValid(scalar))
        throw new Error("invalid field element: outside of range 0..ORDER");
    }
    return scalar;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(lst) {
    return FpInvertBatch(this, lst);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(a2, b, condition) {
    return condition ? b : a2;
  }
};
function Field(ORDER, opts = {}) {
  return new _Field(ORDER, opts);
}
function FpSqrtOdd(Fp2, elm) {
  if (!Fp2.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root = Fp2.sqrt(elm);
  return Fp2.isOdd(root) ? root : Fp2.neg(root);
}
function FpSqrtEven(Fp2, elm) {
  if (!Fp2.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root = Fp2.sqrt(elm);
  return Fp2.isOdd(root) ? Fp2.neg(root) : root;
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length4 = getFieldBytesLength(fieldOrder);
  return length4 + Math.ceil(length4 / 2);
}
function mapHashToField(key, fieldOrder, isLE3 = false) {
  abytes(key);
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num2 = isLE3 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num2, fieldOrder - _1n2) + _1n2;
  return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// ../../node_modules/@noble/curves/abstract/curve.js
var _0n3 = /* @__PURE__ */ BigInt(0);
var _1n3 = /* @__PURE__ */ BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c2, points) {
  const invertedZs = FpInvertBatch(c2.Fp, points.map((p2) => p2.Z));
  return points.map((p2, i2) => c2.fromAffine(p2.toAffine(invertedZs[i2])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n2, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n2 & mask);
  let nextN = n2 >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c2) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p2, i2) => {
    if (!(p2 instanceof c2))
      throw new Error("invalid point at index " + i2);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s2, i2) => {
    if (!field.isValid(s2))
      throw new Error("invalid scalar at index " + i2);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function assert0(n2) {
  if (n2 !== _0n3)
    throw new Error("invalid wNAF");
}
var wNAF = class {
  // Parametrized with a given Point class (not individual point)
  constructor(Point, bits) {
    __publicField(this, "BASE");
    __publicField(this, "ZERO");
    __publicField(this, "Fn");
    __publicField(this, "bits");
    this.BASE = Point.BASE;
    this.ZERO = Point.ZERO;
    this.Fn = Point.Fn;
    this.bits = bits;
  }
  // non-const time multiplication ladder
  _unsafeLadder(elm, n2, p2 = this.ZERO) {
    let d2 = elm;
    while (n2 > _0n3) {
      if (n2 & _1n3)
        p2 = p2.add(d2);
      d2 = d2.double();
      n2 >>= _1n3;
    }
    return p2;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(point, W) {
    const { windows, windowSize } = calcWOpts(W, this.bits);
    const points = [];
    let p2 = point;
    let base3 = p2;
    for (let window2 = 0; window2 < windows; window2++) {
      base3 = p2;
      points.push(base3);
      for (let i2 = 1; i2 < windowSize; i2++) {
        base3 = base3.add(p2);
        points.push(base3);
      }
      p2 = base3.double();
    }
    return points;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(W, precomputes, n2) {
    if (!this.Fn.isValid(n2))
      throw new Error("invalid scalar");
    let p2 = this.ZERO;
    let f2 = this.BASE;
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        f2 = f2.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p2 = p2.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n2);
    return { p: p2, f: f2 };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(W, precomputes, n2, acc = this.ZERO) {
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0; window2 < wo.windows; window2++) {
      if (n2 === _0n3)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets(n2, window2, wo);
      n2 = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n2);
    return acc;
  }
  getPrecomputes(W, point, transform) {
    let comp = pointPrecomputes.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W);
      if (W !== 1) {
        if (typeof transform === "function")
          comp = transform(comp);
        pointPrecomputes.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform) {
    const W = getW(point);
    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
  }
  unsafe(point, scalar, transform, prev) {
    const W = getW(point);
    if (W === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(P, W) {
    validateW(W, this.bits);
    pointWindowSizes.set(P, W);
    pointPrecomputes.delete(P);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
};
function mulEndoUnsafe(Point, point, k1, k2) {
  let acc = point;
  let p1 = Point.ZERO;
  let p2 = Point.ZERO;
  while (k1 > _0n3 || k2 > _0n3) {
    if (k1 & _1n3)
      p1 = p1.add(acc);
    if (k2 & _1n3)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n3;
    k2 >>= _1n3;
  }
  return { p1, p2 };
}
function pippenger(c2, points, scalars) {
  const fieldN = c2.Fn;
  validateMSMPoints(points, c2);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero2 = c2.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero2);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero2;
  for (let i2 = lastBits; i2 >= 0; i2 -= windowSize) {
    buckets.fill(zero2);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i2) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero2;
    for (let j = buckets.length - 1, sumI = zero2; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i2 !== 0)
      for (let j = 0; j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function precomputeMSMUnsafe(c2, points, windowSize) {
  const fieldN = c2.Fn;
  validateW(windowSize, fieldN.BITS);
  validateMSMPoints(points, c2);
  const zero2 = c2.ZERO;
  const tableSize = 2 ** windowSize - 1;
  const chunks = Math.ceil(fieldN.BITS / windowSize);
  const MASK = bitMask(windowSize);
  const tables = points.map((p2) => {
    const res = [];
    for (let i2 = 0, acc = p2; i2 < tableSize; i2++) {
      res.push(acc);
      acc = acc.add(p2);
    }
    return res;
  });
  return (scalars) => {
    validateMSMScalars(scalars, fieldN);
    if (scalars.length > points.length)
      throw new Error("array of scalars must be smaller than array of points");
    let res = zero2;
    for (let i2 = 0; i2 < chunks; i2++) {
      if (res !== zero2)
        for (let j = 0; j < windowSize; j++)
          res = res.double();
      const shiftBy = BigInt(chunks * windowSize - (i2 + 1) * windowSize);
      for (let j = 0; j < scalars.length; j++) {
        const n2 = scalars[j];
        const curr = Number(n2 >> shiftBy & MASK);
        if (!curr)
          continue;
        res = res.add(tables[j][curr - 1]);
      }
    }
    return res;
  };
}
function createField(order, field, isLE3) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE: isLE3 });
  }
}
function createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
  if (FpFnLE === void 0)
    FpFnLE = type === "edwards";
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p2 of ["p", "n", "h"]) {
    const val = CURVE[p2];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p2} must be positive bigint`);
  }
  const Fp2 = createField(CURVE.p, curveOpts.Fp, FpFnLE);
  const Fn2 = createField(CURVE.n, curveOpts.Fn, FpFnLE);
  const _b26 = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b26];
  for (const p2 of params) {
    if (!Fp2.isValid(CURVE[p2]))
      throw new Error(`CURVE.${p2} must be valid field element of CURVE.Fp`);
  }
  CURVE = Object.freeze(Object.assign({}, CURVE));
  return { CURVE, Fp: Fp2, Fn: Fn2 };
}
function createKeygen(randomSecretKey, getPublicKey) {
  return function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  };
}

// ../../node_modules/@noble/curves/abstract/edwards.js
var _0n4 = BigInt(0), _1n4 = BigInt(1), _2n2 = BigInt(2), _8n2 = BigInt(8);
function isEdValidXY(Fp2, CURVE, x, y) {
  const x2 = Fp2.sqr(x);
  const y2 = Fp2.sqr(y);
  const left = Fp2.add(Fp2.mul(CURVE.a, x2), y2);
  const right = Fp2.add(Fp2.ONE, Fp2.mul(CURVE.d, Fp2.mul(x2, y2)));
  return Fp2.eql(left, right);
}
function edwards(params, extraOpts = {}) {
  const validated = createCurveFields("edwards", params, extraOpts, extraOpts.FpFnLE);
  const { Fp: Fp2, Fn: Fn2 } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor } = CURVE;
  validateObject(extraOpts, {}, { uvRatio: "function" });
  const MASK = _2n2 << BigInt(Fn2.BYTES * 8) - _1n4;
  const modP = (n2) => Fp2.create(n2);
  const uvRatio2 = extraOpts.uvRatio || ((u2, v) => {
    try {
      return { isValid: true, value: Fp2.sqrt(Fp2.div(u2, v)) };
    } catch (e2) {
      return { isValid: false, value: _0n4 };
    }
  });
  if (!isEdValidXY(Fp2, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n2, banZero = false) {
    const min = banZero ? _1n4 : _0n4;
    aInRange("coordinate " + title, n2, min, MASK);
    return n2;
  }
  function aedpoint(other) {
    if (!(other instanceof Point))
      throw new Error("EdwardsPoint expected");
  }
  const toAffineMemo = memoized((p2, iz) => {
    const { X, Y, Z } = p2;
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp2.inv(Z);
    const x = modP(X * iz);
    const y = modP(Y * iz);
    const zz = Fp2.mul(Z, iz);
    if (is0)
      return { x: _0n4, y: _1n4 };
    if (zz !== _1n4)
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p2) => {
    const { a: a2, d: d2 } = CURVE;
    if (p2.is0())
      throw new Error("bad point: ZERO");
    const { X, Y, Z, T } = p2;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a2);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  const _Point = class _Point {
    constructor(X, Y, Z, T) {
      __publicField(this, "X");
      __publicField(this, "Y");
      __publicField(this, "Z");
      __publicField(this, "T");
      this.X = acoord("x", X);
      this.Y = acoord("y", Y);
      this.Z = acoord("z", Z, true);
      this.T = acoord("t", T);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    static fromAffine(p2) {
      if (p2 instanceof _Point)
        throw new Error("extended point not allowed");
      const { x, y } = p2 || {};
      acoord("x", x);
      acoord("y", y);
      return new _Point(x, y, _1n4, modP(x * y));
    }
    // Uses algo from RFC8032 5.1.3.
    static fromBytes(bytes, zip215 = false) {
      const len = Fp2.BYTES;
      const { a: a2, d: d2 } = CURVE;
      bytes = copyBytes(abytes(bytes, len, "point"));
      abool(zip215, "zip215");
      const normed = copyBytes(bytes);
      const lastByte = bytes[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp2.ORDER;
      aInRange("point.y", y, _0n4, max);
      const y2 = modP(y * y);
      const u2 = modP(y2 - _1n4);
      const v = modP(d2 * y2 - a2);
      let { isValid: isValid2, value: x } = uvRatio2(u2, v);
      if (!isValid2)
        throw new Error("bad point: invalid y coordinate");
      const isXOdd = (x & _1n4) === _1n4;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n4 && isLastByteOdd)
        throw new Error("bad point: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return _Point.fromAffine({ x, y });
    }
    static fromHex(hex, zip215 = false) {
      return _Point.fromBytes(hexToBytes(hex), zip215);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_2n2);
      return this;
    }
    // Useful in fromAffine() - not for fromBytes(), which always created valid points.
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aedpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(_Point.ZERO);
    }
    negate() {
      return new _Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a2 } = CURVE;
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n2 * modP(Z1 * Z1));
      const D = modP(a2 * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G = D + B;
      const F = G - C;
      const H = D - B;
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new _Point(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aedpoint(other);
      const { a: a2, d: d2 } = CURVE;
      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d2 * T2);
      const D = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G = D + C;
      const H = modP(B - a2 * A);
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new _Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    // Constant-time multiplication.
    multiply(scalar) {
      if (!Fn2.isValidNot0(scalar))
        throw new Error("invalid scalar: expected 1 <= sc < curve.n");
      const { p: p2, f: f2 } = wnaf.cached(this, scalar, (p3) => normalizeZ(_Point, p3));
      return normalizeZ(_Point, [p2, f2])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = _Point.ZERO) {
      if (!Fn2.isValid(scalar))
        throw new Error("invalid scalar: expected 0 <= sc < curve.n");
      if (scalar === _0n4)
        return _Point.ZERO;
      if (this.is0() || scalar === _1n4)
        return this;
      return wnaf.unsafe(this, scalar, (p2) => normalizeZ(_Point, p2), acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafe(this, CURVE.n).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n4)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes = Fp2.toBytes(y);
      bytes[bytes.length - 1] |= x & _1n4 ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  };
  // base / generator point
  __publicField(_Point, "BASE", new _Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy)));
  // zero / infinity / identity point
  __publicField(_Point, "ZERO", new _Point(_0n4, _1n4, _1n4, _0n4));
  // 0, 1, 1, 0
  // math field
  __publicField(_Point, "Fp", Fp2);
  // scalar field
  __publicField(_Point, "Fn", Fn2);
  let Point = _Point;
  const wnaf = new wNAF(Point, Fn2.BITS);
  Point.BASE.precompute(8);
  return Point;
}
var PrimeEdwardsPoint = class {
  constructor(ep) {
    __publicField(this, "ep");
    this.ep = ep;
  }
  // Static methods that must be implemented by subclasses
  static fromBytes(_bytes2) {
    notImplemented();
  }
  static fromHex(_hex) {
    notImplemented();
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  // Common implementations
  clearCofactor() {
    return this;
  }
  assertValidity() {
    this.ep.assertValidity();
  }
  toAffine(invertedZ) {
    return this.ep.toAffine(invertedZ);
  }
  toHex() {
    return bytesToHex(this.toBytes());
  }
  toString() {
    return this.toHex();
  }
  isTorsionFree() {
    return true;
  }
  isSmallOrder() {
    return false;
  }
  add(other) {
    this.assertSame(other);
    return this.init(this.ep.add(other.ep));
  }
  subtract(other) {
    this.assertSame(other);
    return this.init(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return this.init(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return this.init(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return this.init(this.ep.double());
  }
  negate() {
    return this.init(this.ep.negate());
  }
  precompute(windowSize, isLazy) {
    return this.init(this.ep.precompute(windowSize, isLazy));
  }
};
__publicField(PrimeEdwardsPoint, "BASE");
__publicField(PrimeEdwardsPoint, "ZERO");
__publicField(PrimeEdwardsPoint, "Fp");
__publicField(PrimeEdwardsPoint, "Fn");
function eddsa(Point, cHash, eddsaOpts = {}) {
  if (typeof cHash !== "function")
    throw new Error('"hash" function param is required');
  validateObject(eddsaOpts, {}, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash } = eddsaOpts;
  const { BASE, Fp: Fp2, Fn: Fn2 } = Point;
  const randomBytes4 = eddsaOpts.randomBytes || randomBytes;
  const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    abool(phflag, "phflag");
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN_LE(hash) {
    return Fn2.create(bytesToNumberLE(hash));
  }
  function getPrivateScalar(key) {
    const len = lengths.secretKey;
    abytes(key, lengths.secretKey, "secretKey");
    const hashed = abytes(cHash(key), 2 * len, "hashedSecretKey");
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(secretKey) {
    const { head, prefix, scalar } = getPrivateScalar(secretKey);
    const point = BASE.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(secretKey) {
    return getExtendedPublicKey(secretKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, abytes(context, void 0, "context"), !!prehash)));
  }
  function sign3(msg, secretKey, options2 = {}) {
    msg = abytes(msg, void 0, "message");
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
    const r2 = hashDomainToScalar(options2.context, prefix, msg);
    const R = BASE.multiply(r2).toBytes();
    const k = hashDomainToScalar(options2.context, R, pointBytes, msg);
    const s2 = Fn2.create(r2 + k * scalar);
    if (!Fn2.isValid(s2))
      throw new Error("sign failed: invalid s");
    const rs = concatBytes(R, Fn2.toBytes(s2));
    return abytes(rs, lengths.signature, "result");
  }
  const verifyOpts = { zip215: true };
  function verify2(sig, msg, publicKey2, options2 = verifyOpts) {
    const { context, zip215 } = options2;
    const len = lengths.signature;
    sig = abytes(sig, len, "signature");
    msg = abytes(msg, void 0, "message");
    publicKey2 = abytes(publicKey2, lengths.publicKey, "publicKey");
    if (zip215 !== void 0)
      abool(zip215, "zip215");
    if (prehash)
      msg = prehash(msg);
    const mid = len / 2;
    const r2 = sig.subarray(0, mid);
    const s2 = bytesToNumberLE(sig.subarray(mid, len));
    let A, R, SB;
    try {
      A = Point.fromBytes(publicKey2, zip215);
      R = Point.fromBytes(r2, zip215);
      SB = BASE.multiplyUnsafe(s2);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  const _size = Fp2.BYTES;
  const lengths = {
    secretKey: _size,
    publicKey: _size,
    signature: 2 * _size,
    seed: _size
  };
  function randomSecretKey(seed = randomBytes4(lengths.seed)) {
    return abytes(seed, lengths.seed, "seed");
  }
  function isValidSecretKey(key) {
    return isBytes(key) && key.length === Fn2.BYTES;
  }
  function isValidPublicKey(key, zip215) {
    try {
      return !!Point.fromBytes(key, zip215);
    } catch (error) {
      return false;
    }
  }
  const utils = {
    getExtendedPublicKey,
    randomSecretKey,
    isValidSecretKey,
    isValidPublicKey,
    /**
     * Converts ed public key to x public key. Uses formula:
     * - ed25519:
     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
     * - ed448:
     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
     */
    toMontgomery(publicKey2) {
      const { y } = Point.fromBytes(publicKey2);
      const size = lengths.publicKey;
      const is25519 = size === 32;
      if (!is25519 && size !== 57)
        throw new Error("only defined for 25519 and 448");
      const u2 = is25519 ? Fp2.div(_1n4 + y, _1n4 - y) : Fp2.div(y - _1n4, y + _1n4);
      return Fp2.toBytes(u2);
    },
    toMontgomerySecret(secretKey) {
      const size = lengths.secretKey;
      abytes(secretKey, size);
      const hashed = cHash(secretKey.subarray(0, size));
      return adjustScalarBytes2(hashed).subarray(0, size);
    }
  };
  return Object.freeze({
    keygen: createKeygen(randomSecretKey, getPublicKey),
    getPublicKey,
    sign: sign3,
    verify: verify2,
    utils,
    Point,
    lengths
  });
}

// ../../node_modules/@noble/curves/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value2, length4) {
  asafenumber(value2);
  asafenumber(length4);
  if (value2 < 0 || value2 >= 1 << 8 * length4)
    throw new Error("invalid I2OSP input: " + value2);
  const res = Array.from({ length: length4 }).fill(0);
  for (let i2 = length4 - 1; i2 >= 0; i2--) {
    res[i2] = value2 & 255;
    value2 >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a2, b) {
  const arr = new Uint8Array(a2.length);
  for (let i2 = 0; i2 < a2.length; i2++) {
    arr[i2] = a2[i2] ^ b[i2];
  }
  return arr;
}
function normDST(DST) {
  if (!isBytes(DST) && typeof DST !== "string")
    throw new Error("DST must be Uint8Array or ascii string");
  return typeof DST === "string" ? asciiToBytes(DST) : DST;
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes(msg);
  asafenumber(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255)
    DST = H(concatBytes(asciiToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));
  for (let i2 = 1; i2 <= ell; i2++) {
    const args = [strxor(b_0, b[i2 - 1]), i2osp(i2 + 1, 1), DST_prime];
    b[i2] = H(concatBytes(...args));
  }
  const pseudo_random_bytes = concatBytes(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  asafenumber(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(asciiToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options2) {
  validateObject(options2, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p: p2, k, m: m2, hash, expand: expand2, DST } = options2;
  asafenumber(hash.outputLen, "valid hash");
  abytes(msg);
  asafenumber(count);
  const log2p = p2.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m2 * L;
  let prb;
  if (expand2 === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
  } else if (expand2 === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
  } else if (expand2 === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u2 = new Array(count);
  for (let i2 = 0; i2 < count; i2++) {
    const e2 = new Array(m2);
    for (let j = 0; j < m2; j++) {
      const elm_offset = L * (j + i2 * m2);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e2[j] = mod(os2ip(tv), p2);
    }
    u2[i2] = e2;
  }
  return u2;
}
function isogenyMap(field, map2) {
  const coeff = map2.map((i2) => Array.from(i2).reverse());
  return (x, y) => {
    const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x), i2)));
    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);
    x = field.mul(xn, xd_inv);
    y = field.mul(y, field.mul(yn, yd_inv));
    return { x, y };
  };
}
var _DST_scalar = asciiToBytes("HashToScalar-");
function createHasher2(Point, mapToCurve, defaults3) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map2(num2) {
    return Point.fromAffine(mapToCurve(num2));
  }
  function clear(initial) {
    const P = initial.clearCofactor();
    if (P.equals(Point.ZERO))
      return Point.ZERO;
    P.assertValidity();
    return P;
  }
  return {
    defaults: Object.freeze(defaults3),
    Point,
    hashToCurve(msg, options2) {
      const opts = Object.assign({}, defaults3, options2);
      const u2 = hash_to_field(msg, 2, opts);
      const u0 = map2(u2[0]);
      const u1 = map2(u2[1]);
      return clear(u0.add(u1));
    },
    encodeToCurve(msg, options2) {
      const optsDst = defaults3.encodeDST ? { DST: defaults3.encodeDST } : {};
      const opts = Object.assign({}, defaults3, optsDst, options2);
      const u2 = hash_to_field(msg, 1, opts);
      const u0 = map2(u2[0]);
      return clear(u0);
    },
    /** See {@link H2CHasher} */
    mapToCurve(scalars) {
      if (defaults3.m === 1) {
        if (typeof scalars !== "bigint")
          throw new Error("expected bigint (m=1)");
        return clear(map2([scalars]));
      }
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i2 of scalars)
        if (typeof i2 !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map2(scalars));
    },
    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
    hashToScalar(msg, options2) {
      const N = Point.Fn.ORDER;
      const opts = Object.assign({}, defaults3, { p: N, m: 1, DST: _DST_scalar }, options2);
      return hash_to_field(msg, 1, opts)[0][0];
    }
  };
}

// ../../node_modules/@noble/curves/abstract/montgomery.js
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n3 = BigInt(2);
function validateOpts(curve) {
  validateObject(curve, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { P, type, adjustScalarBytes: adjustScalarBytes2, powPminus2, randomBytes: rand } = CURVE;
  const is25519 = type === "x25519";
  if (!is25519 && type !== "x448")
    throw new Error("invalid type");
  const randomBytes_ = rand || randomBytes;
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n3 ** BigInt(254) : _2n3 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n3 ** BigInt(251) - _1n5 : BigInt(4) * _2n3 ** BigInt(445) - _1n5;
  const maxScalar = minScalar + maxAdded + _1n5;
  const modP = (n2) => mod(n2, P);
  const GuBytes = encodeU(Gu);
  function encodeU(u2) {
    return numberToBytesLE(modP(u2), fieldLen);
  }
  function decodeU(u2) {
    const _u = copyBytes(abytes(u2, fieldLen, "uCoordinate"));
    if (is25519)
      _u[31] &= 127;
    return modP(bytesToNumberLE(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE(adjustScalarBytes2(copyBytes(abytes(scalar, fieldLen, "scalar"))));
  }
  function scalarMult(scalar, u2) {
    const pu = montgomeryLadder(decodeU(u2), decodeScalar(scalar));
    if (pu === _0n5)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  const getPublicKey = scalarMultBase;
  const getSharedSecret = scalarMult;
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u2, scalar) {
    aInRange("u", u2, _0n5, P);
    aInRange("scalar", scalar, minScalar, maxScalar);
    const k = scalar;
    const x_1 = u2;
    let x_2 = _1n5;
    let z_2 = _0n5;
    let x_3 = u2;
    let z_3 = _1n5;
    let swap = _0n5;
    for (let t2 = BigInt(montgomeryBits - 1); t2 >= _0n5; t2--) {
      const k_t = k >> t2 & _1n5;
      swap ^= k_t;
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D = x_3 - z_3;
      const DA = modP(D * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    ({ x_2, x_3 } = cswap(swap, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  const lengths = {
    secretKey: fieldLen,
    publicKey: fieldLen,
    seed: fieldLen
  };
  const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
    abytes(seed, lengths.seed, "seed");
    return seed;
  };
  const utils = { randomSecretKey };
  return Object.freeze({
    keygen: createKeygen(randomSecretKey, getPublicKey),
    getSharedSecret,
    getPublicKey,
    scalarMult,
    scalarMultBase,
    utils,
    GuBytes: GuBytes.slice(),
    lengths
  });
}

// ../../node_modules/@noble/curves/abstract/oprf.js
function createORPF(opts) {
  validateObject(opts, {
    name: "string",
    hash: "function",
    hashToScalar: "function",
    hashToGroup: "function"
  });
  const { name: name5, Point, hash } = opts;
  const { Fn: Fn2 } = Point;
  const hashToGroup = (msg, ctx) => opts.hashToGroup(msg, {
    DST: concatBytes(asciiToBytes("HashToGroup-"), ctx)
  });
  const hashToScalarPrefixed = (msg, ctx) => opts.hashToScalar(msg, { DST: concatBytes(_DST_scalar, ctx) });
  const randomScalar = (rng = randomBytes) => {
    const t2 = mapHashToField(rng(getMinHashLength(Fn2.ORDER)), Fn2.ORDER, Fn2.isLE);
    return Fn2.isLE ? bytesToNumberLE(t2) : bytesToNumberBE(t2);
  };
  const msm = (points, scalars) => pippenger(Point, points, scalars);
  const getCtx = (mode) => concatBytes(asciiToBytes("OPRFV1-"), new Uint8Array([mode]), asciiToBytes("-" + name5));
  const ctxOPRF = getCtx(0);
  const ctxVOPRF = getCtx(1);
  const ctxPOPRF = getCtx(2);
  function encode13(...args) {
    const res = [];
    for (const a2 of args) {
      if (typeof a2 === "number")
        res.push(numberToBytesBE(a2, 2));
      else if (typeof a2 === "string")
        res.push(asciiToBytes(a2));
      else {
        abytes(a2);
        res.push(numberToBytesBE(a2.length, 2), a2);
      }
    }
    return concatBytes(...res);
  }
  const hashInput = (...bytes) => hash(encode13(...bytes, "Finalize"));
  function getTranscripts(B, C, D, ctx) {
    const Bm = B.toBytes();
    const seed = hash(encode13(Bm, concatBytes(asciiToBytes("Seed-"), ctx)));
    const res = [];
    for (let i2 = 0; i2 < C.length; i2++) {
      const Ci = C[i2].toBytes();
      const Di = D[i2].toBytes();
      const di = hashToScalarPrefixed(encode13(seed, i2, Ci, Di, "Composite"), ctx);
      res.push(di);
    }
    return res;
  }
  function computeComposites(B, C, D, ctx) {
    const T = getTranscripts(B, C, D, ctx);
    const M = msm(C, T);
    const Z = msm(D, T);
    return { M, Z };
  }
  function computeCompositesFast(k, B, C, D, ctx) {
    const T = getTranscripts(B, C, D, ctx);
    const M = msm(C, T);
    const Z = M.multiply(k);
    return { M, Z };
  }
  function challengeTranscript(B, M, Z, t2, t3, ctx) {
    const [Bm, a0, a1, a2, a3] = [B, M, Z, t2, t3].map((i2) => i2.toBytes());
    return hashToScalarPrefixed(encode13(Bm, a0, a1, a2, a3, "Challenge"), ctx);
  }
  function generateProof(ctx, k, B, C, D, rng) {
    const { M, Z } = computeCompositesFast(k, B, C, D, ctx);
    const r2 = randomScalar(rng);
    const t2 = Point.BASE.multiply(r2);
    const t3 = M.multiply(r2);
    const c2 = challengeTranscript(B, M, Z, t2, t3, ctx);
    const s2 = Fn2.sub(r2, Fn2.mul(c2, k));
    return concatBytes(...[c2, s2].map((i2) => Fn2.toBytes(i2)));
  }
  function verifyProof(ctx, B, C, D, proof) {
    abytes(proof, 2 * Fn2.BYTES);
    const { M, Z } = computeComposites(B, C, D, ctx);
    const [c2, s2] = [proof.subarray(0, Fn2.BYTES), proof.subarray(Fn2.BYTES)].map((f2) => Fn2.fromBytes(f2));
    const t2 = Point.BASE.multiply(s2).add(B.multiply(c2));
    const t3 = M.multiply(s2).add(Z.multiply(c2));
    const expectedC = challengeTranscript(B, M, Z, t2, t3, ctx);
    if (!Fn2.eql(c2, expectedC))
      throw new Error("proof verification failed");
  }
  function generateKeyPair2() {
    const skS = randomScalar();
    const pkS = Point.BASE.multiply(skS);
    return { secretKey: Fn2.toBytes(skS), publicKey: pkS.toBytes() };
  }
  function deriveKeyPair(ctx, seed, info) {
    const dst = concatBytes(asciiToBytes("DeriveKeyPair"), ctx);
    const msg = concatBytes(seed, encode13(info), Uint8Array.of(0));
    for (let counter = 0; counter <= 255; counter++) {
      msg[msg.length - 1] = counter;
      const skS = opts.hashToScalar(msg, { DST: dst });
      if (Fn2.is0(skS))
        continue;
      return { secretKey: Fn2.toBytes(skS), publicKey: Point.BASE.multiply(skS).toBytes() };
    }
    throw new Error("Cannot derive key");
  }
  function blind(ctx, input, rng = randomBytes) {
    const blind2 = randomScalar(rng);
    const inputPoint = hashToGroup(input, ctx);
    if (inputPoint.equals(Point.ZERO))
      throw new Error("Input point at infinity");
    const blinded = inputPoint.multiply(blind2);
    return { blind: Fn2.toBytes(blind2), blinded: blinded.toBytes() };
  }
  function evaluate(ctx, secretKey, input) {
    const skS = Fn2.fromBytes(secretKey);
    const inputPoint = hashToGroup(input, ctx);
    if (inputPoint.equals(Point.ZERO))
      throw new Error("Input point at infinity");
    const unblinded = inputPoint.multiply(skS).toBytes();
    return hashInput(input, unblinded);
  }
  const oprf = {
    generateKeyPair: generateKeyPair2,
    deriveKeyPair: (seed, keyInfo) => deriveKeyPair(ctxOPRF, seed, keyInfo),
    blind: (input, rng = randomBytes) => blind(ctxOPRF, input, rng),
    blindEvaluate(secretKey, blindedPoint) {
      const skS = Fn2.fromBytes(secretKey);
      const elm = Point.fromBytes(blindedPoint);
      return elm.multiply(skS).toBytes();
    },
    finalize(input, blindBytes, evaluatedBytes) {
      const blind2 = Fn2.fromBytes(blindBytes);
      const evalPoint = Point.fromBytes(evaluatedBytes);
      const unblinded = evalPoint.multiply(Fn2.inv(blind2)).toBytes();
      return hashInput(input, unblinded);
    },
    evaluate: (secretKey, input) => evaluate(ctxOPRF, secretKey, input)
  };
  const voprf = {
    generateKeyPair: generateKeyPair2,
    deriveKeyPair: (seed, keyInfo) => deriveKeyPair(ctxVOPRF, seed, keyInfo),
    blind: (input, rng = randomBytes) => blind(ctxVOPRF, input, rng),
    blindEvaluateBatch(secretKey, publicKey2, blinded, rng = randomBytes) {
      if (!Array.isArray(blinded))
        throw new Error("expected array");
      const skS = Fn2.fromBytes(secretKey);
      const pkS = Point.fromBytes(publicKey2);
      const blindedPoints = blinded.map(Point.fromBytes);
      const evaluated = blindedPoints.map((i2) => i2.multiply(skS));
      const proof = generateProof(ctxVOPRF, skS, pkS, blindedPoints, evaluated, rng);
      return { evaluated: evaluated.map((i2) => i2.toBytes()), proof };
    },
    blindEvaluate(secretKey, publicKey2, blinded, rng = randomBytes) {
      const res = this.blindEvaluateBatch(secretKey, publicKey2, [blinded], rng);
      return { evaluated: res.evaluated[0], proof: res.proof };
    },
    finalizeBatch(items, publicKey2, proof) {
      if (!Array.isArray(items))
        throw new Error("expected array");
      const pkS = Point.fromBytes(publicKey2);
      const blindedPoints = items.map((i2) => i2.blinded).map(Point.fromBytes);
      const evalPoints = items.map((i2) => i2.evaluated).map(Point.fromBytes);
      verifyProof(ctxVOPRF, pkS, blindedPoints, evalPoints, proof);
      return items.map((i2) => oprf.finalize(i2.input, i2.blind, i2.evaluated));
    },
    finalize(input, blind2, evaluated, blinded, publicKey2, proof) {
      return this.finalizeBatch([{ input, blind: blind2, evaluated, blinded }], publicKey2, proof)[0];
    },
    evaluate: (secretKey, input) => evaluate(ctxVOPRF, secretKey, input)
  };
  const poprf = (info) => {
    const m2 = hashToScalarPrefixed(encode13("Info", info), ctxPOPRF);
    const T = Point.BASE.multiply(m2);
    return {
      generateKeyPair: generateKeyPair2,
      deriveKeyPair: (seed, keyInfo) => deriveKeyPair(ctxPOPRF, seed, keyInfo),
      blind(input, publicKey2, rng = randomBytes) {
        const pkS = Point.fromBytes(publicKey2);
        const tweakedKey = T.add(pkS);
        if (tweakedKey.equals(Point.ZERO))
          throw new Error("tweakedKey point at infinity");
        const blind2 = randomScalar(rng);
        const inputPoint = hashToGroup(input, ctxPOPRF);
        if (inputPoint.equals(Point.ZERO))
          throw new Error("Input point at infinity");
        const blindedPoint = inputPoint.multiply(blind2);
        return {
          blind: Fn2.toBytes(blind2),
          blinded: blindedPoint.toBytes(),
          tweakedKey: tweakedKey.toBytes()
        };
      },
      blindEvaluateBatch(secretKey, blinded, rng = randomBytes) {
        if (!Array.isArray(blinded))
          throw new Error("expected array");
        const skS = Fn2.fromBytes(secretKey);
        const t2 = Fn2.add(skS, m2);
        const invT = Fn2.inv(t2);
        const blindedPoints = blinded.map(Point.fromBytes);
        const evalPoints = blindedPoints.map((i2) => i2.multiply(invT));
        const tweakedKey = Point.BASE.multiply(t2);
        const proof = generateProof(ctxPOPRF, t2, tweakedKey, evalPoints, blindedPoints, rng);
        return { evaluated: evalPoints.map((i2) => i2.toBytes()), proof };
      },
      blindEvaluate(secretKey, blinded, rng = randomBytes) {
        const res = this.blindEvaluateBatch(secretKey, [blinded], rng);
        return { evaluated: res.evaluated[0], proof: res.proof };
      },
      finalizeBatch(items, proof, tweakedKey) {
        if (!Array.isArray(items))
          throw new Error("expected array");
        const evalPoints = items.map((i2) => i2.evaluated).map(Point.fromBytes);
        verifyProof(ctxPOPRF, Point.fromBytes(tweakedKey), evalPoints, items.map((i2) => i2.blinded).map(Point.fromBytes), proof);
        return items.map((i2, j) => {
          const blind2 = Fn2.fromBytes(i2.blind);
          const point = evalPoints[j].multiply(Fn2.inv(blind2)).toBytes();
          return hashInput(i2.input, info, point);
        });
      },
      finalize(input, blind2, evaluated, blinded, proof, tweakedKey) {
        return this.finalizeBatch([{ input, blind: blind2, evaluated, blinded }], proof, tweakedKey)[0];
      },
      evaluate(secretKey, input) {
        const skS = Fn2.fromBytes(secretKey);
        const inputPoint = hashToGroup(input, ctxPOPRF);
        if (inputPoint.equals(Point.ZERO))
          throw new Error("Input point at infinity");
        const t2 = Fn2.add(skS, m2);
        const invT = Fn2.inv(t2);
        const unblinded = inputPoint.multiply(invT).toBytes();
        return hashInput(input, info, unblinded);
      }
    };
  };
  return Object.freeze({ name: name5, oprf, voprf, poprf, __tests: { Fn: Fn2 } });
}

// ../../node_modules/@noble/curves/ed25519.js
var _0n6 = /* @__PURE__ */ BigInt(0), _1n6 = BigInt(1), _2n4 = BigInt(2), _3n2 = /* @__PURE__ */ BigInt(3);
var _5n2 = BigInt(5), _8n3 = BigInt(8);
var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
var ed25519_CURVE = /* @__PURE__ */ (() => ({
  p: ed25519_CURVE_p,
  n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
  h: _8n3,
  a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
  d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
  Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
  Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
}))();
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ed25519_CURVE_p;
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n4, P) * b2 % P;
  const b5 = pow2(b4, _1n6, P) * x % P;
  const b10 = pow2(b5, _5n2, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n4, P) * x % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
function uvRatio(u2, v) {
  const P = ed25519_CURVE_p;
  const v3 = mod(v * v * v, P);
  const v7 = mod(v3 * v3 * v, P);
  const pow3 = ed25519_pow_2_252_3(u2 * v7).pow_p_5_8;
  let x = mod(u2 * v3 * pow3, P);
  const vx2 = mod(v * x * x, P);
  const root1 = x;
  const root2 = mod(x * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u2;
  const useRoot2 = vx2 === mod(-u2, P);
  const noRoot = vx2 === mod(-u2 * ED25519_SQRT_M1, P);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P))
    x = mod(-x, P);
  return { isValid: useRoot1 || useRoot2, value: x };
}
var ed25519_Point = /* @__PURE__ */ edwards(ed25519_CURVE, { uvRatio });
var Fp = /* @__PURE__ */ (() => ed25519_Point.Fp)();
var Fn = /* @__PURE__ */ (() => ed25519_Point.Fn)();
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(asciiToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
function ed(opts) {
  return eddsa(ed25519_Point, sha5122, Object.assign({ adjustScalarBytes }, opts));
}
var ed25519 = /* @__PURE__ */ ed({});
var ed25519ctx = /* @__PURE__ */ ed({ domain: ed25519_domain });
var ed25519ph = /* @__PURE__ */ ed({ domain: ed25519_domain, prehash: sha5122 });
var x25519 = /* @__PURE__ */ (() => {
  const P = ed25519_CURVE_p;
  return montgomery({
    P,
    type: "x25519",
    powPminus2: (x) => {
      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
      return mod(pow2(pow_p_5_8, _3n2, P) * b2, P);
    },
    adjustScalarBytes
  });
})();
var ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n2) / _8n3)();
var ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n4, ELL2_C1))();
var ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
function _map_to_curve_elligator2_curve25519(u2) {
  const ELL2_C4 = (ed25519_CURVE_p - _5n2) / _8n3;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp.sqr(u2);
  tv1 = Fp.mul(tv1, _2n4);
  let xd = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd);
  let gxd = Fp.mul(tv2, xd);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y11 = Fp.pow(tv2, ELL2_C4);
  y11 = Fp.mul(y11, tv3);
  let y12 = Fp.mul(y11, ELL2_C3);
  tv2 = Fp.sqr(y11);
  tv2 = Fp.mul(tv2, gxd);
  let e1 = Fp.eql(tv2, gx1);
  let y1 = Fp.cmov(y12, y11, e1);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y11, u2);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e2 = Fp.eql(tv2, gx2);
  let y2 = Fp.cmov(y22, y21, e2);
  tv2 = Fp.sqr(y1);
  tv2 = Fp.mul(tv2, gxd);
  let e3 = Fp.eql(tv2, gx1);
  let xn = Fp.cmov(x2n, x1n, e3);
  let y = Fp.cmov(y2, y1, e3);
  let e4 = Fp.isOdd(y);
  y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n6 };
}
var ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards25519(u2) {
  const { xMn, xMd, yMn, yMd } = _map_to_curve_elligator2_curve25519(u2);
  let xn = Fp.mul(xMn, yMd);
  xn = Fp.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp.mul(xMd, yMn);
  let yn = Fp.sub(xMn, xMd);
  let yd = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd, yd);
  let e2 = Fp.eql(tv1, Fp.ZERO);
  xn = Fp.cmov(xn, Fp.ZERO, e2);
  xd = Fp.cmov(xd, Fp.ONE, e2);
  yn = Fp.cmov(yn, Fp.ONE, e2);
  yd = Fp.cmov(yd, Fp.ONE, e2);
  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true);
  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
}
var ed25519_hasher = /* @__PURE__ */ (() => createHasher2(ed25519_Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: ed25519_CURVE_p,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha5122
}))();
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number) => uvRatio(_1n6, number);
var MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes) => Fp.create(bytesToNumberLE(bytes) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d: d2 } = ed25519_CURVE;
  const P = ed25519_CURVE_p;
  const mod2 = (n2) => Fp.create(n2);
  const r2 = mod2(SQRT_M1 * r0 * r0);
  const Ns = mod2((r2 + _1n6) * ONE_MINUS_D_SQ);
  let c2 = BigInt(-1);
  const D = mod2((c2 - d2 * r2) * mod2(r2 + d2));
  let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns, D);
  let s_ = mod2(s2 * r0);
  if (!isNegativeLE(s_, P))
    s_ = mod2(-s_);
  if (!Ns_D_is_sq)
    s2 = s_;
  if (!Ns_D_is_sq)
    c2 = r2;
  const Nt = mod2(c2 * (r2 - _1n6) * D_MINUS_ONE_SQ - D);
  const s22 = s2 * s2;
  const W0 = mod2((s2 + s2) * D);
  const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod2(_1n6 - s22);
  const W3 = mod2(_1n6 + s22);
  return new ed25519_Point(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
}
var __RistrettoPoint = class __RistrettoPoint extends PrimeEdwardsPoint {
  constructor(ep) {
    super(ep);
  }
  static fromAffine(ap) {
    return new __RistrettoPoint(ed25519_Point.fromAffine(ap));
  }
  assertSame(other) {
    if (!(other instanceof __RistrettoPoint))
      throw new Error("RistrettoPoint expected");
  }
  init(ep) {
    return new __RistrettoPoint(ep);
  }
  static fromBytes(bytes) {
    abytes(bytes, 32);
    const { a: a2, d: d2 } = ed25519_CURVE;
    const P = ed25519_CURVE_p;
    const mod2 = (n2) => Fp.create(n2);
    const s2 = bytes255ToNumberLE(bytes);
    if (!equalBytes(Fp.toBytes(s2), bytes) || isNegativeLE(s2, P))
      throw new Error("invalid ristretto255 encoding 1");
    const s22 = mod2(s2 * s2);
    const u1 = mod2(_1n6 + a2 * s22);
    const u2 = mod2(_1n6 - a2 * s22);
    const u1_2 = mod2(u1 * u1);
    const u2_2 = mod2(u2 * u2);
    const v = mod2(a2 * d2 * u1_2 - u2_2);
    const { isValid: isValid2, value: I } = invertSqrt(mod2(v * u2_2));
    const Dx = mod2(I * u2);
    const Dy = mod2(I * Dx * v);
    let x = mod2((s2 + s2) * Dx);
    if (isNegativeLE(x, P))
      x = mod2(-x);
    const y = mod2(u1 * Dy);
    const t2 = mod2(x * y);
    if (!isValid2 || isNegativeLE(t2, P) || y === _0n6)
      throw new Error("invalid ristretto255 encoding 2");
    return new __RistrettoPoint(new ed25519_Point(x, y, _1n6, t2));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex) {
    return __RistrettoPoint.fromBytes(hexToBytes(hex));
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
   */
  toBytes() {
    let { X, Y, Z, T } = this.ep;
    const P = ed25519_CURVE_p;
    const mod2 = (n2) => Fp.create(n2);
    const u1 = mod2(mod2(Z + Y) * mod2(Z - Y));
    const u2 = mod2(X * Y);
    const u2sq = mod2(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));
    const D1 = mod2(invsqrt * u1);
    const D2 = mod2(invsqrt * u2);
    const zInv = mod2(D1 * D2 * T);
    let D;
    if (isNegativeLE(T * zInv, P)) {
      let _x = mod2(Y * SQRT_M1);
      let _y = mod2(X * SQRT_M1);
      X = _x;
      Y = _y;
      D = mod2(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (isNegativeLE(X * zInv, P))
      Y = mod2(-Y);
    let s2 = mod2((Z - Y) * D);
    if (isNegativeLE(s2, P))
      s2 = mod2(-s2);
    return Fp.toBytes(s2);
  }
  /**
   * Compares two Ristretto points.
   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
   */
  equals(other) {
    this.assertSame(other);
    const { X: X1, Y: Y1 } = this.ep;
    const { X: X2, Y: Y2 } = other.ep;
    const mod2 = (n2) => Fp.create(n2);
    const one = mod2(X1 * Y2) === mod2(Y1 * X2);
    const two = mod2(Y1 * Y2) === mod2(X1 * X2);
    return one || two;
  }
  is0() {
    return this.equals(__RistrettoPoint.ZERO);
  }
};
// Do NOT change syntax: the following gymnastics is done,
// because typescript strips comments, which makes bundlers disable tree-shaking.
// prettier-ignore
__publicField(__RistrettoPoint, "BASE", /* @__PURE__ */ (() => new __RistrettoPoint(ed25519_Point.BASE))());
// prettier-ignore
__publicField(__RistrettoPoint, "ZERO", /* @__PURE__ */ (() => new __RistrettoPoint(ed25519_Point.ZERO))());
// prettier-ignore
__publicField(__RistrettoPoint, "Fp", /* @__PURE__ */ (() => Fp)());
// prettier-ignore
__publicField(__RistrettoPoint, "Fn", /* @__PURE__ */ (() => Fn)());
var _RistrettoPoint = __RistrettoPoint;
var ristretto255 = { Point: _RistrettoPoint };
var ristretto255_hasher = {
  Point: _RistrettoPoint,
  /**
  * Spec: https://www.rfc-editor.org/rfc/rfc9380.html#name-hashing-to-ristretto255. Caveats:
  * * There are no test vectors
  * * encodeToCurve / mapToCurve is undefined
  * * mapToCurve would be `calcElligatorRistrettoMap(scalars[0])`, not ristretto255_map!
  * * hashToScalar is undefined too, so we just use OPRF implementation
  * * We cannot re-use 'createHasher', because ristretto255_map is different algorithm/RFC
    (os2ip -> bytes255ToNumberLE)
  * * mapToCurve == calcElligatorRistrettoMap, hashToCurve == ristretto255_map
  * * hashToScalar is undefined in RFC9380 for ristretto, we are using version from OPRF here, using bytes255ToNumblerLE will create different result if we use bytes255ToNumberLE as os2ip
  * * current version is closest to spec.
  */
  hashToCurve(msg, options2) {
    const DST = options2?.DST || "ristretto255_XMD:SHA-512_R255MAP_RO_";
    const xmd = expand_message_xmd(msg, DST, 64, sha5122);
    return ristretto255_hasher.deriveToCurve(xmd);
  },
  hashToScalar(msg, options2 = { DST: _DST_scalar }) {
    const xmd = expand_message_xmd(msg, options2.DST, 64, sha5122);
    return Fn.create(bytesToNumberLE(xmd));
  },
  /**
   * HashToCurve-like construction based on RFC 9496 (Element Derivation).
   * Converts 64 uniform random bytes into a curve point.
   *
   * WARNING: This represents an older hash-to-curve construction, preceding the finalization of RFC 9380.
   * It was later reused as a component in the newer `hash_to_ristretto255` function defined in RFC 9380.
   */
  deriveToCurve(bytes) {
    abytes(bytes, 64);
    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
    const R2 = calcElligatorRistrettoMap(r2);
    return new _RistrettoPoint(R1.add(R2));
  }
};
var ristretto255_oprf = /* @__PURE__ */ (() => createORPF({
  name: "ristretto255-SHA512",
  Point: _RistrettoPoint,
  hash: sha5122,
  hashToGroup: ristretto255_hasher.hashToCurve,
  hashToScalar: ristretto255_hasher.hashToScalar
}))();
var ED25519_TORSION_SUBGROUP = [
  "0100000000000000000000000000000000000000000000000000000000000000",
  "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
  "0000000000000000000000000000000000000000000000000000000000000080",
  "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
  "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
  "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
  "0000000000000000000000000000000000000000000000000000000000000000",
  "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
];

// ../../node_modules/@libp2p/crypto/dist/src/errors.js
var SigningError = class extends Error {
  constructor(message2 = "An error occurred while signing a message") {
    super(message2);
    this.name = "SigningError";
  }
};
var VerificationError = class extends Error {
  constructor(message2 = "An error occurred while verifying a message") {
    super(message2);
    this.name = "VerificationError";
  }
};
var WebCryptoMissingError = class extends Error {
  constructor(message2 = "Missing Web Crypto API") {
    super(message2);
    this.name = "WebCryptoMissingError";
  }
};

// ../../node_modules/@libp2p/crypto/dist/src/webcrypto/webcrypto.browser.js
var webcrypto_browser_default = {
  get(win = window) {
    const nativeCrypto = win.crypto;
    if (nativeCrypto?.subtle == null) {
      throw new WebCryptoMissingError("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");
    }
    return nativeCrypto;
  }
};

// ../../node_modules/@libp2p/crypto/dist/src/webcrypto/index.js
var webcrypto_default = webcrypto_browser_default;

// ../../node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js
var PUBLIC_KEY_BYTE_LENGTH = 32;
var PRIVATE_KEY_BYTE_LENGTH = 64;
var KEYS_BYTE_LENGTH = 32;
var ed25519Supported;
var webCryptoEd25519SupportedPromise = (async () => {
  try {
    await webcrypto_default.get().subtle.generateKey({ name: "Ed25519" }, true, ["sign", "verify"]);
    return true;
  } catch {
    return false;
  }
})();
function generateKey() {
  const privateKeyRaw = ed25519.utils.randomSecretKey();
  const publicKey2 = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey2);
  return {
    privateKey,
    publicKey: publicKey2
  };
}
function generateKeyFromSeed(seed) {
  if (seed.length !== KEYS_BYTE_LENGTH) {
    throw new TypeError('"seed" must be 32 bytes in length.');
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
  }
  const privateKeyRaw = seed;
  const publicKey2 = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey2);
  return {
    privateKey,
    publicKey: publicKey2
  };
}
async function hashAndSignWebCrypto(privateKey, msg) {
  let privateKeyRaw;
  if (privateKey.length === PRIVATE_KEY_BYTE_LENGTH) {
    privateKeyRaw = privateKey.subarray(0, 32);
  } else {
    privateKeyRaw = privateKey;
  }
  const jwk = {
    crv: "Ed25519",
    kty: "OKP",
    x: toString2(privateKey.subarray(32), "base64url"),
    d: toString2(privateKeyRaw, "base64url"),
    ext: true,
    key_ops: ["sign"]
  };
  const key = await webcrypto_default.get().subtle.importKey("jwk", jwk, { name: "Ed25519" }, true, ["sign"]);
  const sig = await webcrypto_default.get().subtle.sign({ name: "Ed25519" }, key, msg instanceof Uint8Array ? msg : msg.subarray());
  return new Uint8Array(sig, 0, sig.byteLength);
}
function hashAndSignNoble(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return ed25519.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);
}
async function hashAndSign2(privateKey, msg) {
  if (ed25519Supported == null) {
    ed25519Supported = await webCryptoEd25519SupportedPromise;
  }
  if (ed25519Supported) {
    return hashAndSignWebCrypto(privateKey, msg);
  }
  return hashAndSignNoble(privateKey, msg);
}
async function hashAndVerifyWebCrypto(publicKey2, sig, msg) {
  if (publicKey2.buffer instanceof ArrayBuffer) {
    const key = await webcrypto_default.get().subtle.importKey("raw", publicKey2.buffer, { name: "Ed25519" }, false, ["verify"]);
    const isValid2 = await webcrypto_default.get().subtle.verify({ name: "Ed25519" }, key, sig, msg instanceof Uint8Array ? msg : msg.subarray());
    return isValid2;
  }
  throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys");
}
function hashAndVerifyNoble(publicKey2, sig, msg) {
  return ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey2);
}
async function hashAndVerify2(publicKey2, sig, msg) {
  if (ed25519Supported == null) {
    ed25519Supported = await webCryptoEd25519SupportedPromise;
  }
  if (ed25519Supported) {
    return hashAndVerifyWebCrypto(publicKey2, sig, msg);
  }
  return hashAndVerifyNoble(publicKey2, sig, msg);
}
function concatKeys(privateKeyRaw, publicKey2) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i2 = 0; i2 < KEYS_BYTE_LENGTH; i2++) {
    privateKey[i2] = privateKeyRaw[i2];
    privateKey[KEYS_BYTE_LENGTH + i2] = publicKey2[i2];
  }
  return privateKey;
}

// ../../node_modules/@libp2p/crypto/dist/src/util.js
function base64urlToBuffer(str, len) {
  let buf2 = fromString2(str, "base64urlpad");
  if (len != null) {
    if (buf2.length > len) {
      throw new Error("byte array longer than desired length");
    }
    buf2 = concat([new Uint8Array(len - buf2.length), buf2]);
  }
  return buf2;
}
function isPromise(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// ../../node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js
var Ed25519PublicKey = class {
  constructor(key) {
    __publicField(this, "type", "Ed25519");
    __publicField(this, "raw");
    this.raw = ensureEd25519Key(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  toMultihash() {
    return identity.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  verify(data, sig, options2) {
    options2?.signal?.throwIfAborted();
    const result = hashAndVerify2(this.raw, sig, data);
    if (isPromise(result)) {
      return result.then((res) => {
        options2?.signal?.throwIfAborted();
        return res;
      });
    }
    return result;
  }
};
var Ed25519PrivateKey = class {
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(key, publicKey2) {
    __publicField(this, "type", "Ed25519");
    __publicField(this, "raw");
    __publicField(this, "publicKey");
    this.raw = ensureEd25519Key(key, PRIVATE_KEY_BYTE_LENGTH);
    this.publicKey = new Ed25519PublicKey(publicKey2);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  sign(message2, options2) {
    options2?.signal?.throwIfAborted();
    const sig = hashAndSign2(this.raw, message2);
    if (isPromise(sig)) {
      return sig.then((res) => {
        options2?.signal?.throwIfAborted();
        return res;
      });
    }
    options2?.signal?.throwIfAborted();
    return sig;
  }
};

// ../../node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js
function unmarshalEd25519PrivateKey(bytes) {
  if (bytes.length > PRIVATE_KEY_BYTE_LENGTH) {
    bytes = ensureEd25519Key(bytes, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
    const privateKeyBytes2 = bytes.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
    const publicKeyBytes2 = bytes.subarray(PRIVATE_KEY_BYTE_LENGTH, bytes.length);
    return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
  }
  bytes = ensureEd25519Key(bytes, PRIVATE_KEY_BYTE_LENGTH);
  const privateKeyBytes = bytes.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
  const publicKeyBytes = bytes.subarray(PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}
function unmarshalEd25519PublicKey(bytes) {
  bytes = ensureEd25519Key(bytes, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes);
}
async function generateEd25519KeyPair() {
  const { privateKey, publicKey: publicKey2 } = generateKey();
  return new Ed25519PrivateKey(privateKey, publicKey2);
}
async function generateEd25519KeyPairFromSeed(seed) {
  const { privateKey, publicKey: publicKey2 } = generateKeyFromSeed(seed);
  return new Ed25519PrivateKey(privateKey, publicKey2);
}
function ensureEd25519Key(key, length4) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length4) {
    throw new InvalidParametersError2(`Key must be a Uint8Array of length ${length4}, got ${key.length}`);
  }
  return key;
}

// ../../node_modules/uint8-varint/dist/src/index.js
var N12 = Math.pow(2, 7);
var N22 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N62 = Math.pow(2, 42);
var N72 = Math.pow(2, 49);
var MSB2 = 128;
var REST2 = 127;
function encodingLength2(value2) {
  if (value2 < N12) {
    return 1;
  }
  if (value2 < N22) {
    return 2;
  }
  if (value2 < N32) {
    return 3;
  }
  if (value2 < N42) {
    return 4;
  }
  if (value2 < N52) {
    return 5;
  }
  if (value2 < N62) {
    return 6;
  }
  if (value2 < N72) {
    return 7;
  }
  if (Number.MAX_SAFE_INTEGER != null && value2 > Number.MAX_SAFE_INTEGER) {
    throw new RangeError("Could not encode varint");
  }
  return 8;
}
function encodeUint8Array(value2, buf2, offset = 0) {
  switch (encodingLength2(value2)) {
    case 8: {
      buf2[offset++] = value2 & 255 | MSB2;
      value2 /= 128;
    }
    case 7: {
      buf2[offset++] = value2 & 255 | MSB2;
      value2 /= 128;
    }
    case 6: {
      buf2[offset++] = value2 & 255 | MSB2;
      value2 /= 128;
    }
    case 5: {
      buf2[offset++] = value2 & 255 | MSB2;
      value2 /= 128;
    }
    case 4: {
      buf2[offset++] = value2 & 255 | MSB2;
      value2 >>>= 7;
    }
    case 3: {
      buf2[offset++] = value2 & 255 | MSB2;
      value2 >>>= 7;
    }
    case 2: {
      buf2[offset++] = value2 & 255 | MSB2;
      value2 >>>= 7;
    }
    case 1: {
      buf2[offset++] = value2 & 255;
      value2 >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf2;
}
function encodeUint8ArrayList(value2, buf2, offset = 0) {
  switch (encodingLength2(value2)) {
    case 8: {
      buf2.set(offset++, value2 & 255 | MSB2);
      value2 /= 128;
    }
    case 7: {
      buf2.set(offset++, value2 & 255 | MSB2);
      value2 /= 128;
    }
    case 6: {
      buf2.set(offset++, value2 & 255 | MSB2);
      value2 /= 128;
    }
    case 5: {
      buf2.set(offset++, value2 & 255 | MSB2);
      value2 /= 128;
    }
    case 4: {
      buf2.set(offset++, value2 & 255 | MSB2);
      value2 >>>= 7;
    }
    case 3: {
      buf2.set(offset++, value2 & 255 | MSB2);
      value2 >>>= 7;
    }
    case 2: {
      buf2.set(offset++, value2 & 255 | MSB2);
      value2 >>>= 7;
    }
    case 1: {
      buf2.set(offset++, value2 & 255);
      value2 >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf2;
}
function decodeUint8Array(buf2, offset) {
  let b = buf2[offset];
  let res = 0;
  res += b & REST2;
  if (b < MSB2) {
    return res;
  }
  b = buf2[offset + 1];
  res += (b & REST2) << 7;
  if (b < MSB2) {
    return res;
  }
  b = buf2[offset + 2];
  res += (b & REST2) << 14;
  if (b < MSB2) {
    return res;
  }
  b = buf2[offset + 3];
  res += (b & REST2) << 21;
  if (b < MSB2) {
    return res;
  }
  b = buf2[offset + 4];
  res += (b & REST2) * N42;
  if (b < MSB2) {
    return res;
  }
  b = buf2[offset + 5];
  res += (b & REST2) * N52;
  if (b < MSB2) {
    return res;
  }
  b = buf2[offset + 6];
  res += (b & REST2) * N62;
  if (b < MSB2) {
    return res;
  }
  b = buf2[offset + 7];
  res += (b & REST2) * N72;
  if (b < MSB2) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function decodeUint8ArrayList(buf2, offset) {
  let b = buf2.get(offset);
  let res = 0;
  res += b & REST2;
  if (b < MSB2) {
    return res;
  }
  b = buf2.get(offset + 1);
  res += (b & REST2) << 7;
  if (b < MSB2) {
    return res;
  }
  b = buf2.get(offset + 2);
  res += (b & REST2) << 14;
  if (b < MSB2) {
    return res;
  }
  b = buf2.get(offset + 3);
  res += (b & REST2) << 21;
  if (b < MSB2) {
    return res;
  }
  b = buf2.get(offset + 4);
  res += (b & REST2) * N42;
  if (b < MSB2) {
    return res;
  }
  b = buf2.get(offset + 5);
  res += (b & REST2) * N52;
  if (b < MSB2) {
    return res;
  }
  b = buf2.get(offset + 6);
  res += (b & REST2) * N62;
  if (b < MSB2) {
    return res;
  }
  b = buf2.get(offset + 7);
  res += (b & REST2) * N72;
  if (b < MSB2) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function encode7(value2, buf2, offset = 0) {
  if (buf2 == null) {
    buf2 = allocUnsafe(encodingLength2(value2));
  }
  if (buf2 instanceof Uint8Array) {
    return encodeUint8Array(value2, buf2, offset);
  } else {
    return encodeUint8ArrayList(value2, buf2, offset);
  }
}
function decode8(buf2, offset = 0) {
  if (buf2 instanceof Uint8Array) {
    return decodeUint8Array(buf2, offset);
  } else {
    return decodeUint8ArrayList(buf2, offset);
  }
}

// ../../node_modules/protons-runtime/dist/src/utils/float.js
var f32 = new Float32Array([-0]);
var f8b = new Uint8Array(f32.buffer);
function writeFloatLE(val, buf2, pos) {
  f32[0] = val;
  buf2[pos] = f8b[0];
  buf2[pos + 1] = f8b[1];
  buf2[pos + 2] = f8b[2];
  buf2[pos + 3] = f8b[3];
}
function writeFloatBE(val, buf2, pos) {
  f32[0] = val;
  buf2[pos] = f8b[3];
  buf2[pos + 1] = f8b[2];
  buf2[pos + 2] = f8b[1];
  buf2[pos + 3] = f8b[0];
}
function readFloatLE(buf2, pos) {
  f8b[0] = buf2[pos];
  f8b[1] = buf2[pos + 1];
  f8b[2] = buf2[pos + 2];
  f8b[3] = buf2[pos + 3];
  return f32[0];
}
function readFloatBE(buf2, pos) {
  f8b[3] = buf2[pos];
  f8b[2] = buf2[pos + 1];
  f8b[1] = buf2[pos + 2];
  f8b[0] = buf2[pos + 3];
  return f32[0];
}
var f64 = new Float64Array([-0]);
var d8b = new Uint8Array(f64.buffer);
function writeDoubleLE(val, buf2, pos) {
  f64[0] = val;
  buf2[pos] = d8b[0];
  buf2[pos + 1] = d8b[1];
  buf2[pos + 2] = d8b[2];
  buf2[pos + 3] = d8b[3];
  buf2[pos + 4] = d8b[4];
  buf2[pos + 5] = d8b[5];
  buf2[pos + 6] = d8b[6];
  buf2[pos + 7] = d8b[7];
}
function writeDoubleBE(val, buf2, pos) {
  f64[0] = val;
  buf2[pos] = d8b[7];
  buf2[pos + 1] = d8b[6];
  buf2[pos + 2] = d8b[5];
  buf2[pos + 3] = d8b[4];
  buf2[pos + 4] = d8b[3];
  buf2[pos + 5] = d8b[2];
  buf2[pos + 6] = d8b[1];
  buf2[pos + 7] = d8b[0];
}
function readDoubleLE(buf2, pos) {
  d8b[0] = buf2[pos];
  d8b[1] = buf2[pos + 1];
  d8b[2] = buf2[pos + 2];
  d8b[3] = buf2[pos + 3];
  d8b[4] = buf2[pos + 4];
  d8b[5] = buf2[pos + 5];
  d8b[6] = buf2[pos + 6];
  d8b[7] = buf2[pos + 7];
  return f64[0];
}
function readDoubleBE(buf2, pos) {
  d8b[7] = buf2[pos];
  d8b[6] = buf2[pos + 1];
  d8b[5] = buf2[pos + 2];
  d8b[4] = buf2[pos + 3];
  d8b[3] = buf2[pos + 4];
  d8b[2] = buf2[pos + 5];
  d8b[1] = buf2[pos + 6];
  d8b[0] = buf2[pos + 7];
  return f64[0];
}

// ../../node_modules/protons-runtime/dist/src/utils/longbits.js
var MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
var MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
var LongBits = class _LongBits {
  constructor(lo, hi) {
    __publicField(this, "lo");
    __publicField(this, "hi");
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  /**
   * Converts this long bits to a possibly unsafe JavaScript number
   */
  toNumber(unsigned = false) {
    if (!unsigned && this.hi >>> 31 > 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }
  /**
   * Converts this long bits to a bigint
   */
  toBigInt(unsigned = false) {
    if (unsigned) {
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    if (this.hi >>> 31 !== 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(BigInt(lo) + (BigInt(hi) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  /**
   * Converts this long bits to a string
   */
  toString(unsigned = false) {
    return this.toBigInt(unsigned).toString();
  }
  /**
   * Zig-zag encodes this long bits
   */
  zzEncode() {
    const mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Zig-zag decodes this long bits
   */
  zzDecode() {
    const mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Calculates the length of this longbits when encoded as a varint.
   */
  length() {
    const part0 = this.lo;
    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
    const part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromBigInt(value2) {
    if (value2 === 0n) {
      return zero;
    }
    if (value2 < MAX_SAFE_NUMBER_INTEGER && value2 > MIN_SAFE_NUMBER_INTEGER) {
      return this.fromNumber(Number(value2));
    }
    const negative = value2 < 0n;
    if (negative) {
      value2 = -value2;
    }
    let hi = value2 >> 32n;
    let lo = value2 - (hi << 32n);
    if (negative) {
      hi = ~hi | 0n;
      lo = ~lo | 0n;
      if (++lo > TWO_32) {
        lo = 0n;
        if (++hi > TWO_32) {
          hi = 0n;
        }
      }
    }
    return new _LongBits(Number(lo), Number(hi));
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromNumber(value2) {
    if (value2 === 0) {
      return zero;
    }
    const sign3 = value2 < 0;
    if (sign3) {
      value2 = -value2;
    }
    let lo = value2 >>> 0;
    let hi = (value2 - lo) / 4294967296 >>> 0;
    if (sign3) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295) {
          hi = 0;
        }
      }
    }
    return new _LongBits(lo, hi);
  }
  /**
   * Constructs new long bits from a number, long or string
   */
  static from(value2) {
    if (typeof value2 === "number") {
      return _LongBits.fromNumber(value2);
    }
    if (typeof value2 === "bigint") {
      return _LongBits.fromBigInt(value2);
    }
    if (typeof value2 === "string") {
      return _LongBits.fromBigInt(BigInt(value2));
    }
    return value2.low != null || value2.high != null ? new _LongBits(value2.low >>> 0, value2.high >>> 0) : zero;
  }
};
var zero = new LongBits(0, 0);
zero.toBigInt = function() {
  return 0n;
};
zero.zzEncode = zero.zzDecode = function() {
  return this;
};
zero.length = function() {
  return 1;
};
var TWO_32 = 4294967296n;

// ../../node_modules/protons-runtime/dist/src/utils/utf8.js
function length2(string2) {
  let len = 0;
  let c2 = 0;
  for (let i2 = 0; i2 < string2.length; ++i2) {
    c2 = string2.charCodeAt(i2);
    if (c2 < 128) {
      len += 1;
    } else if (c2 < 2048) {
      len += 2;
    } else if ((c2 & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
      ++i2;
      len += 4;
    } else {
      len += 3;
    }
  }
  return len;
}
function read2(buffer2, start2, end) {
  const len = end - start2;
  if (len < 1) {
    return "";
  }
  let parts;
  const chunk = [];
  let i2 = 0;
  let t2;
  while (start2 < end) {
    t2 = buffer2[start2++];
    if (t2 < 128) {
      chunk[i2++] = t2;
    } else if (t2 > 191 && t2 < 224) {
      chunk[i2++] = (t2 & 31) << 6 | buffer2[start2++] & 63;
    } else if (t2 > 239 && t2 < 365) {
      t2 = ((t2 & 7) << 18 | (buffer2[start2++] & 63) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63) - 65536;
      chunk[i2++] = 55296 + (t2 >> 10);
      chunk[i2++] = 56320 + (t2 & 1023);
    } else {
      chunk[i2++] = (t2 & 15) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63;
    }
    if (i2 > 8191) {
      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
      i2 = 0;
    }
  }
  if (parts != null) {
    if (i2 > 0) {
      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
    }
    return parts.join("");
  }
  return String.fromCharCode.apply(String, chunk.slice(0, i2));
}
function write(string2, buffer2, offset) {
  const start2 = offset;
  let c1;
  let c2;
  for (let i2 = 0; i2 < string2.length; ++i2) {
    c1 = string2.charCodeAt(i2);
    if (c1 < 128) {
      buffer2[offset++] = c1;
    } else if (c1 < 2048) {
      buffer2[offset++] = c1 >> 6 | 192;
      buffer2[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i2;
      buffer2[offset++] = c1 >> 18 | 240;
      buffer2[offset++] = c1 >> 12 & 63 | 128;
      buffer2[offset++] = c1 >> 6 & 63 | 128;
      buffer2[offset++] = c1 & 63 | 128;
    } else {
      buffer2[offset++] = c1 >> 12 | 224;
      buffer2[offset++] = c1 >> 6 & 63 | 128;
      buffer2[offset++] = c1 & 63 | 128;
    }
  }
  return offset - start2;
}

// ../../node_modules/protons-runtime/dist/src/utils/reader.js
function indexOutOfRange(reader, writeLength) {
  return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);
}
function readFixed32End(buf2, end) {
  return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
}
var Uint8ArrayReader = class {
  constructor(buffer2) {
    __publicField(this, "buf");
    __publicField(this, "pos");
    __publicField(this, "len");
    __publicField(this, "_slice", Uint8Array.prototype.subarray);
    this.buf = buffer2;
    this.pos = 0;
    this.len = buffer2.length;
  }
  /**
   * Reads a varint as an unsigned 32 bit value
   */
  uint32() {
    let value2 = 4294967295;
    value2 = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value2;
    }
    value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value2;
    }
    value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value2;
    }
    value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value2;
    }
    value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128) {
      return value2;
    }
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value2;
  }
  /**
   * Reads a varint as a signed 32 bit value
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Reads a zig-zag encoded varint as a signed 32 bit value
   */
  sint32() {
    const value2 = this.uint32();
    return value2 >>> 1 ^ -(value2 & 1) | 0;
  }
  /**
   * Reads a varint as a boolean
   */
  bool() {
    return this.uint32() !== 0;
  }
  /**
   * Reads fixed 32 bits as an unsigned 32 bit integer
   */
  fixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4);
    return res;
  }
  /**
   * Reads fixed 32 bits as a signed 32 bit integer
   */
  sfixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4) | 0;
    return res;
  }
  /**
   * Reads a float (32 bit) as a number
   */
  float() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value2 = readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value2;
  }
  /**
   * Reads a double (64 bit float) as a number
   */
  double() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value2 = readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value2;
  }
  /**
   * Reads a sequence of bytes preceded by its length as a varint
   */
  bytes() {
    const length4 = this.uint32();
    const start2 = this.pos;
    const end = this.pos + length4;
    if (end > this.len) {
      throw indexOutOfRange(this, length4);
    }
    this.pos += length4;
    return start2 === end ? new Uint8Array(0) : this.buf.subarray(start2, end);
  }
  /**
   * Reads a string preceded by its byte length as a varint
   */
  string() {
    const bytes = this.bytes();
    return read2(bytes, 0, bytes.length);
  }
  /**
   * Skips the specified number of bytes if specified, otherwise skips a varint
   */
  skip(length4) {
    if (typeof length4 === "number") {
      if (this.pos + length4 > this.len) {
        throw indexOutOfRange(this, length4);
      }
      this.pos += length4;
    } else {
      do {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
      } while ((this.buf[this.pos++] & 128) !== 0);
    }
    return this;
  }
  /**
   * Skips the next element of the specified wire type
   */
  skipType(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      /* istanbul ignore next */
      default:
        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
    }
    return this;
  }
  readLongVarint() {
    const bits = new LongBits(0, 0);
    let i2 = 0;
    if (this.len - this.pos > 4) {
      for (; i2 < 4; ++i2) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return bits;
      }
      i2 = 0;
    } else {
      for (; i2 < 3; ++i2) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (; i2 < 5; ++i2) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
    } else {
      for (; i2 < 5; ++i2) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
    }
    throw Error("invalid varint encoding");
  }
  readFixed64() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 8);
    }
    const lo = readFixed32End(this.buf, this.pos += 4);
    const hi = readFixed32End(this.buf, this.pos += 4);
    return new LongBits(lo, hi);
  }
  /**
   * Reads a varint as a signed 64 bit value
   */
  int64() {
    return this.readLongVarint().toBigInt();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  int64Number() {
    return this.readLongVarint().toNumber();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a string
   */
  int64String() {
    return this.readLongVarint().toString();
  }
  /**
   * Reads a varint as an unsigned 64 bit value
   */
  uint64() {
    return this.readLongVarint().toBigInt(true);
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  uint64Number() {
    const value2 = decodeUint8Array(this.buf, this.pos);
    this.pos += encodingLength2(value2);
    return value2;
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a string
   */
  uint64String() {
    return this.readLongVarint().toString(true);
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value
   */
  sint64() {
    return this.readLongVarint().zzDecode().toBigInt();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * possibly unsafe JavaScript number
   */
  sint64Number() {
    return this.readLongVarint().zzDecode().toNumber();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * string
   */
  sint64String() {
    return this.readLongVarint().zzDecode().toString();
  }
  /**
   * Reads fixed 64 bits
   */
  fixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
   */
  fixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads fixed 64 bits returned as a string
   */
  fixed64String() {
    return this.readFixed64().toString();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits
   */
  sfixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
   * JavaScript number
   */
  sfixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a string
   */
  sfixed64String() {
    return this.readFixed64().toString();
  }
};
function createReader(buf2) {
  return new Uint8ArrayReader(buf2 instanceof Uint8Array ? buf2 : buf2.subarray());
}

// ../../node_modules/protons-runtime/dist/src/decode.js
function decodeMessage(buf2, codec, opts) {
  const reader = createReader(buf2);
  return codec.decode(reader, void 0, opts);
}

// ../../node_modules/protons-runtime/dist/src/utils/pool.js
function pool(size) {
  const SIZE = size ?? 8192;
  const MAX = SIZE >>> 1;
  let slab;
  let offset = SIZE;
  return function poolAlloc(size2) {
    if (size2 < 1 || size2 > MAX) {
      return allocUnsafe(size2);
    }
    if (offset + size2 > SIZE) {
      slab = allocUnsafe(SIZE);
      offset = 0;
    }
    const buf2 = slab.subarray(offset, offset += size2);
    if ((offset & 7) !== 0) {
      offset = (offset | 7) + 1;
    }
    return buf2;
  };
}

// ../../node_modules/protons-runtime/dist/src/utils/writer.js
var Op = class {
  constructor(fn, len, val) {
    /**
     * Function to call
     */
    __publicField(this, "fn");
    /**
     * Value byte length
     */
    __publicField(this, "len");
    /**
     * Next operation
     */
    __publicField(this, "next");
    /**
     * Value to write
     */
    __publicField(this, "val");
    this.fn = fn;
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
};
function noop() {
}
var State = class {
  constructor(writer) {
    /**
     * Current head
     */
    __publicField(this, "head");
    /**
     * Current tail
     */
    __publicField(this, "tail");
    /**
     * Current buffer length
     */
    __publicField(this, "len");
    /**
     * Next state
     */
    __publicField(this, "next");
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
};
var bufferPool = pool();
function alloc2(size) {
  if (window.Buffer != null) {
    return allocUnsafe(size);
  }
  return bufferPool(size);
}
var Uint8ArrayWriter = class {
  constructor() {
    /**
     * Current length
     */
    __publicField(this, "len");
    /**
     * Operations head
     */
    __publicField(this, "head");
    /**
     * Operations tail
     */
    __publicField(this, "tail");
    /**
     * Linked forked states
     */
    __publicField(this, "states");
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  /**
   * Pushes a new operation to the queue
   */
  _push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  }
  /**
   * Writes an unsigned 32 bit value as a varint
   */
  uint32(value2) {
    this.len += (this.tail = this.tail.next = new VarintOp((value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5, value2)).len;
    return this;
  }
  /**
   * Writes a signed 32 bit value as a varint`
   */
  int32(value2) {
    return value2 < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value2)) : this.uint32(value2);
  }
  /**
   * Writes a 32 bit value as a varint, zig-zag encoded
   */
  sint32(value2) {
    return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64(value2) {
    const bits = LongBits.fromBigInt(value2);
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64Number(value2) {
    return this._push(encodeUint8Array, encodingLength2(value2), value2);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64String(value2) {
    return this.uint64(BigInt(value2));
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64(value2) {
    return this.uint64(value2);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64Number(value2) {
    return this.uint64Number(value2);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64String(value2) {
    return this.uint64String(value2);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64(value2) {
    const bits = LongBits.fromBigInt(value2).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64Number(value2) {
    const bits = LongBits.fromNumber(value2).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64String(value2) {
    return this.sint64(BigInt(value2));
  }
  /**
   * Writes a boolish value as a varint
   */
  bool(value2) {
    return this._push(writeByte, 1, value2 ? 1 : 0);
  }
  /**
   * Writes an unsigned 32 bit value as fixed 32 bits
   */
  fixed32(value2) {
    return this._push(writeFixed32, 4, value2 >>> 0);
  }
  /**
   * Writes a signed 32 bit value as fixed 32 bits
   */
  sfixed32(value2) {
    return this.fixed32(value2);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64(value2) {
    const bits = LongBits.fromBigInt(value2);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64Number(value2) {
    const bits = LongBits.fromNumber(value2);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64String(value2) {
    return this.fixed64(BigInt(value2));
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64(value2) {
    return this.fixed64(value2);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64Number(value2) {
    return this.fixed64Number(value2);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64String(value2) {
    return this.fixed64String(value2);
  }
  /**
   * Writes a float (32 bit)
   */
  float(value2) {
    return this._push(writeFloatLE, 4, value2);
  }
  /**
   * Writes a double (64 bit float).
   *
   * @function
   * @param {number} value - Value to write
   * @returns {Writer} `this`
   */
  double(value2) {
    return this._push(writeDoubleLE, 8, value2);
  }
  /**
   * Writes a sequence of bytes
   */
  bytes(value2) {
    const len = value2.length >>> 0;
    if (len === 0) {
      return this._push(writeByte, 1, 0);
    }
    return this.uint32(len)._push(writeBytes, len, value2);
  }
  /**
   * Writes a string
   */
  string(value2) {
    const len = length2(value2);
    return len !== 0 ? this.uint32(len)._push(write, len, value2) : this._push(writeByte, 1, 0);
  }
  /**
   * Forks this writer's state by pushing it to a stack.
   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
   */
  fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  }
  /**
   * Resets this instance to the last state
   */
  reset() {
    if (this.states != null) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  }
  /**
   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
   */
  ldelim() {
    const head = this.head;
    const tail = this.tail;
    const len = this.len;
    this.reset().uint32(len);
    if (len !== 0) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  }
  /**
   * Finishes the write operation
   */
  finish() {
    let head = this.head.next;
    const buf2 = alloc2(this.len);
    let pos = 0;
    while (head != null) {
      head.fn(head.val, buf2, pos);
      pos += head.len;
      head = head.next;
    }
    return buf2;
  }
};
function writeByte(val, buf2, pos) {
  buf2[pos] = val & 255;
}
function writeVarint32(val, buf2, pos) {
  while (val > 127) {
    buf2[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf2[pos] = val;
}
var VarintOp = class extends Op {
  constructor(len, val) {
    super(writeVarint32, len, val);
    __publicField(this, "next");
    this.next = void 0;
  }
};
function writeVarint64(val, buf2, pos) {
  while (val.hi !== 0) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf2[pos++] = val.lo;
}
function writeFixed32(val, buf2, pos) {
  buf2[pos] = val & 255;
  buf2[pos + 1] = val >>> 8 & 255;
  buf2[pos + 2] = val >>> 16 & 255;
  buf2[pos + 3] = val >>> 24;
}
function writeBytes(val, buf2, pos) {
  buf2.set(val, pos);
}
if (window.Buffer != null) {
  Uint8ArrayWriter.prototype.bytes = function(value2) {
    const len = value2.length >>> 0;
    this.uint32(len);
    if (len > 0) {
      this._push(writeBytesBuffer, len, value2);
    }
    return this;
  };
  Uint8ArrayWriter.prototype.string = function(value2) {
    const len = window.Buffer.byteLength(value2);
    this.uint32(len);
    if (len > 0) {
      this._push(writeStringBuffer, len, value2);
    }
    return this;
  };
}
function writeBytesBuffer(val, buf2, pos) {
  buf2.set(val, pos);
}
function writeStringBuffer(val, buf2, pos) {
  if (val.length < 40) {
    write(val, buf2, pos);
  } else if (buf2.utf8Write != null) {
    buf2.utf8Write(val, pos);
  } else {
    buf2.set(fromString2(val), pos);
  }
}
function createWriter() {
  return new Uint8ArrayWriter();
}

// ../../node_modules/protons-runtime/dist/src/encode.js
function encodeMessage(message2, codec) {
  const w = createWriter();
  codec.encode(message2, w, {
    lengthDelimited: false
  });
  return w.finish();
}

// ../../node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES;
(function(CODEC_TYPES2) {
  CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
  CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
  CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec2(name5, type, encode13, decode14) {
  return {
    name: name5,
    type,
    encode: encode13,
    decode: decode14
  };
}

// ../../node_modules/protons-runtime/dist/src/codecs/enum.js
function enumeration(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  const encode13 = function enumEncode(val, writer) {
    const enumValue = findValue(val);
    writer.int32(enumValue);
  };
  const decode14 = function enumDecode(reader) {
    const val = reader.int32();
    return findValue(val);
  };
  return createCodec2("enum", CODEC_TYPES.VARINT, encode13, decode14);
}

// ../../node_modules/protons-runtime/dist/src/codecs/message.js
function message(encode13, decode14) {
  return createCodec2("message", CODEC_TYPES.LENGTH_DELIMITED, encode13, decode14);
}

// ../../node_modules/protons-runtime/dist/src/index.js
var CodeError = class extends Error {
  constructor(message2, code5) {
    super(message2);
    __publicField(this, "code");
    this.code = code5;
  }
};
var MaxLengthError = class extends Error {
  constructor() {
    super(...arguments);
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    __publicField(this, "code", "ERR_MAX_LENGTH");
    __publicField(this, "name", "MaxLengthError");
  }
};
var MaxSizeError = class extends Error {
  constructor() {
    super(...arguments);
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    __publicField(this, "code", "ERR_MAX_SIZE");
    __publicField(this, "name", "MaxSizeError");
  }
};
var ParseError = class extends Error {
  constructor() {
    super(...arguments);
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    __publicField(this, "code", "ERR_PARSE_ERROR");
    __publicField(this, "name", "ParseError");
  }
};
var NoMessagesFoundError = class extends Error {
  constructor() {
    super(...arguments);
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    __publicField(this, "code", "ERR_NO_MESSAGES_FOUND");
    __publicField(this, "name", "NoMessagesFoundError");
  }
};

// ../../node_modules/@libp2p/crypto/dist/src/keys/keys.js
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["secp256k1"] = "secp256k1";
  KeyType2["ECDSA"] = "ECDSA";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["secp256k1"] = 2] = "secp256k1";
  __KeyTypeValues2[__KeyTypeValues2["ECDSA"] = 3] = "ECDSA";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey2) {
  let _codec;
  PublicKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {};
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey2.encode = (obj) => {
    return encodeMessage(obj, PublicKey2.codec());
  };
  PublicKey2.decode = (buf2, opts) => {
    return decodeMessage(buf2, PublicKey2.codec(), opts);
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey2) {
  let _codec;
  PrivateKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.Type != null) {
          w.uint32(8);
          KeyType.codec().encode(obj.Type, w);
        }
        if (obj.Data != null) {
          w.uint32(18);
          w.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {};
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.Type = KeyType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.Data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey2.encode = (obj) => {
    return encodeMessage(obj, PrivateKey2.codec());
  };
  PrivateKey2.decode = (buf2, opts) => {
    return decodeMessage(buf2, PrivateKey2.codec(), opts);
  };
})(PrivateKey || (PrivateKey = {}));

// ../../node_modules/@libp2p/crypto/dist/src/random-bytes.js
function randomBytes2(length4) {
  if (isNaN(length4) || length4 <= 0) {
    throw new InvalidParametersError2("random bytes length must be a Number bigger than 0");
  }
  return randomBytes(length4);
}

// ../../node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
var utils_exports = {};
__export(utils_exports, {
  MAX_RSA_KEY_SIZE: () => MAX_RSA_KEY_SIZE,
  generateRSAKeyPair: () => generateRSAKeyPair,
  jwkToJWKKeyPair: () => jwkToJWKKeyPair,
  jwkToPkcs1: () => jwkToPkcs1,
  jwkToPkix: () => jwkToPkix,
  jwkToRSAPrivateKey: () => jwkToRSAPrivateKey,
  pkcs1MessageToJwk: () => pkcs1MessageToJwk,
  pkcs1MessageToRSAPrivateKey: () => pkcs1MessageToRSAPrivateKey,
  pkcs1ToJwk: () => pkcs1ToJwk,
  pkcs1ToRSAPrivateKey: () => pkcs1ToRSAPrivateKey,
  pkixMessageToJwk: () => pkixMessageToJwk,
  pkixMessageToRSAPublicKey: () => pkixMessageToRSAPublicKey,
  pkixToJwk: () => pkixToJwk,
  pkixToRSAPublicKey: () => pkixToRSAPublicKey
});

// ../../node_modules/@libp2p/crypto/dist/src/keys/rsa/rsa.js
var RSAPublicKey = class {
  constructor(jwk, digest2) {
    __publicField(this, "type", "RSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    __publicField(this, "_multihash");
    this.jwk = jwk;
    this._multihash = digest2;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = utils_exports.jwkToPkix(this.jwk);
    }
    return this._raw;
  }
  toMultihash() {
    return this._multihash;
  }
  toCID() {
    return CID.createV1(114, this._multihash);
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  verify(data, sig, options2) {
    return hashAndVerify3(this.jwk, sig, data, options2);
  }
};
var RSAPrivateKey = class {
  constructor(jwk, publicKey2) {
    __publicField(this, "type", "RSA");
    __publicField(this, "jwk");
    __publicField(this, "_raw");
    __publicField(this, "publicKey");
    this.jwk = jwk;
    this.publicKey = publicKey2;
  }
  get raw() {
    if (this._raw == null) {
      this._raw = utils_exports.jwkToPkcs1(this.jwk);
    }
    return this._raw;
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  sign(message2, options2) {
    return hashAndSign3(this.jwk, message2, options2);
  }
};

// ../../node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
var MAX_RSA_KEY_SIZE = 8192;
var SHA2_256_CODE = 18;
var MAX_RSA_JWK_SIZE = 1062;
var RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([
  48,
  13,
  6,
  9,
  42,
  134,
  72,
  134,
  247,
  13,
  1,
  1,
  1,
  5,
  0
]);
function pkcs1ToJwk(bytes) {
  const message2 = decodeDer(bytes);
  return pkcs1MessageToJwk(message2);
}
function pkcs1MessageToJwk(message2) {
  return {
    n: toString2(message2[1], "base64url"),
    e: toString2(message2[2], "base64url"),
    d: toString2(message2[3], "base64url"),
    p: toString2(message2[4], "base64url"),
    q: toString2(message2[5], "base64url"),
    dp: toString2(message2[6], "base64url"),
    dq: toString2(message2[7], "base64url"),
    qi: toString2(message2[8], "base64url"),
    kty: "RSA"
  };
}
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw new InvalidParametersError2("JWK was missing components");
  }
  return encodeSequence([
    encodeInteger(Uint8Array.from([0])),
    encodeInteger(fromString2(jwk.n, "base64url")),
    encodeInteger(fromString2(jwk.e, "base64url")),
    encodeInteger(fromString2(jwk.d, "base64url")),
    encodeInteger(fromString2(jwk.p, "base64url")),
    encodeInteger(fromString2(jwk.q, "base64url")),
    encodeInteger(fromString2(jwk.dp, "base64url")),
    encodeInteger(fromString2(jwk.dq, "base64url")),
    encodeInteger(fromString2(jwk.qi, "base64url"))
  ]).subarray();
}
function pkixToJwk(bytes) {
  const message2 = decodeDer(bytes, {
    offset: 0
  });
  return pkixMessageToJwk(message2);
}
function pkixMessageToJwk(message2) {
  const keys = decodeDer(message2[1], {
    offset: 0
  });
  return {
    kty: "RSA",
    n: toString2(keys[0], "base64url"),
    e: toString2(keys[1], "base64url")
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new InvalidParametersError2("JWK was missing components");
  }
  const subjectPublicKeyInfo = encodeSequence([
    RSA_ALGORITHM_IDENTIFIER,
    encodeBitString(encodeSequence([
      encodeInteger(fromString2(jwk.n, "base64url")),
      encodeInteger(fromString2(jwk.e, "base64url"))
    ]))
  ]);
  return subjectPublicKeyInfo.subarray();
}
function pkcs1ToRSAPrivateKey(bytes) {
  const message2 = decodeDer(bytes);
  return pkcs1MessageToRSAPrivateKey(message2);
}
function pkcs1MessageToRSAPrivateKey(message2) {
  const jwk = pkcs1MessageToJwk(message2);
  return jwkToRSAPrivateKey(jwk);
}
function pkixToRSAPublicKey(bytes, digest2) {
  if (bytes.byteLength >= MAX_RSA_JWK_SIZE) {
    throw new InvalidPublicKeyError2("Key size is too large");
  }
  const message2 = decodeDer(bytes, {
    offset: 0
  });
  return pkixMessageToRSAPublicKey(message2, bytes, digest2);
}
function pkixMessageToRSAPublicKey(message2, bytes, digest2) {
  const jwk = pkixMessageToJwk(message2);
  if (digest2 == null) {
    const hash = sha2562(PublicKey.encode({
      Type: KeyType.RSA,
      Data: bytes
    }));
    digest2 = create(SHA2_256_CODE, hash);
  }
  return new RSAPublicKey(jwk, digest2);
}
function jwkToRSAPrivateKey(jwk) {
  if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {
    throw new InvalidParametersError2("Key size is too large");
  }
  const keys = jwkToJWKKeyPair(jwk);
  const hash = sha2562(PublicKey.encode({
    Type: KeyType.RSA,
    Data: jwkToPkix(keys.publicKey)
  }));
  const digest2 = create(SHA2_256_CODE, hash);
  return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest2));
}
async function generateRSAKeyPair(bits) {
  if (bits > MAX_RSA_KEY_SIZE) {
    throw new InvalidParametersError2("Key size is too large");
  }
  const keys = await generateRSAKey(bits);
  const hash = sha2562(PublicKey.encode({
    Type: KeyType.RSA,
    Data: jwkToPkix(keys.publicKey)
  }));
  const digest2 = create(SHA2_256_CODE, hash);
  return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest2));
}
function jwkToJWKKeyPair(key) {
  if (key == null) {
    throw new InvalidParametersError2("Missing key parameter");
  }
  return {
    privateKey: key,
    publicKey: {
      kty: key.kty,
      n: key.n,
      e: key.e
    }
  };
}

// ../../node_modules/@libp2p/crypto/dist/src/keys/rsa/index.browser.js
var RSAES_PKCS1_V1_5_OID = "1.2.840.113549.1.1.1";
async function generateRSAKey(bits, options2) {
  const pair = await webcrypto_default.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  options2?.signal?.throwIfAborted();
  const keys = await exportKey(pair, options2);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function hashAndSign3(key, msg, options2) {
  const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  options2?.signal?.throwIfAborted();
  const sig = await webcrypto_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
  options2?.signal?.throwIfAborted();
  return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify3(key, sig, msg, options2) {
  const publicKey2 = await webcrypto_default.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  options2?.signal?.throwIfAborted();
  const result = await webcrypto_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey2, sig, msg instanceof Uint8Array ? msg : msg.subarray());
  options2?.signal?.throwIfAborted();
  return result;
}
async function exportKey(pair, options2) {
  if (pair.privateKey == null || pair.publicKey == null) {
    throw new InvalidParametersError2("Private and public key are required");
  }
  const result = await Promise.all([
    webcrypto_default.get().subtle.exportKey("jwk", pair.privateKey),
    webcrypto_default.get().subtle.exportKey("jwk", pair.publicKey)
  ]);
  options2?.signal?.throwIfAborted();
  return result;
}
function rsaKeySize(jwk) {
  if (jwk.kty !== "RSA") {
    throw new InvalidParametersError2("invalid key type");
  } else if (jwk.n == null) {
    throw new InvalidParametersError2("invalid key modulus");
  }
  const bytes = fromString2(jwk.n, "base64url");
  return bytes.length * 8;
}

// ../../node_modules/@noble/hashes/hmac.js
var _HMAC = class {
  constructor(hash, key) {
    __publicField(this, "oHash");
    __publicField(this, "iHash");
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "finished", false);
    __publicField(this, "destroyed", false);
    ahash(hash);
    abytes(key, void 0, "key");
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i2 = 0; i2 < pad.length; i2++)
      pad[i2] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf2) {
    aexists(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen, "output");
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash, key, message2) => new _HMAC(hash, key).update(message2).digest();
hmac.create = (hash, key) => new _HMAC(hash, key);

// ../../node_modules/@noble/curves/abstract/weierstrass.js
var divNearest = (num2, den) => (num2 + (num2 >= 0 ? den : -den) / _2n5) / den;
function _splitEndoScalar(k, basis, n2) {
  const [[a1, b1], [a2, b2]] = basis;
  const c1 = divNearest(b2 * k, n2);
  const c2 = divNearest(-b1 * k, n2);
  let k1 = k - c1 * a1 - c2 * a2;
  let k2 = -c1 * b1 - c2 * b2;
  const k1neg = k1 < _0n7;
  const k2neg = k2 < _0n7;
  if (k1neg)
    k1 = -k1;
  if (k2neg)
    k2 = -k2;
  const MAX_NUM = bitMask(Math.ceil(bitLen(n2) / 2)) + _1n7;
  if (k1 < _0n7 || k1 >= MAX_NUM || k2 < _0n7 || k2 >= MAX_NUM) {
    throw new Error("splitScalar (endomorphism): failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format2) {
  if (!["compact", "recovered", "der"].includes(format2))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return format2;
}
function validateSigOpts(opts, def) {
  const optsn = {};
  for (let optName of Object.keys(def)) {
    optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
  }
  abool(optsn.lowS, "lowS");
  abool(optsn.prehash, "prehash");
  if (optsn.format !== void 0)
    validateSigFormat(optsn.format);
  return optsn;
}
var DERErr = class extends Error {
  constructor(m2 = "") {
    super(m2);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E } = DER;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t2 = numberToHexUnpadded(tag);
      return t2 + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length4 = 0;
      if (!isLong)
        length4 = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length4 = length4 << 8 | b;
        pos += lenLen;
        if (length4 < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length4);
      if (v.length !== length4)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length4) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num2) {
      const { Err: E } = DER;
      if (num2 < _0n7)
        throw new E("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded(num2);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(bytes) {
    const { Err: E, _int: int, _tlv: tlv } = DER;
    const data = abytes(bytes, void 0, "signature");
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
var _0n7 = BigInt(0), _1n7 = BigInt(1), _2n5 = BigInt(2), _3n3 = BigInt(3), _4n2 = BigInt(4);
function weierstrass(params, extraOpts = {}) {
  const validated = createCurveFields("weierstrass", params, extraOpts);
  const { Fp: Fp2, Fn: Fn2 } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  validateObject(extraOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo } = extraOpts;
  if (endo) {
    if (!Fp2.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
      throw new Error('invalid endo: expected "beta": bigint and "basises": array');
    }
  }
  const lengths = getWLengths(Fp2, Fn2);
  function assertCompressionIsSupported() {
    if (!Fp2.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes2(_c15, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp2.toBytes(x);
    abool(isCompressed, "isCompressed");
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp2.isOdd(y);
      return concatBytes(pprefix(hasEvenY), bx);
    } else {
      return concatBytes(Uint8Array.of(4), bx, Fp2.toBytes(y));
    }
  }
  function pointFromBytes(bytes) {
    abytes(bytes, void 0, "Point");
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    const length4 = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    if (length4 === comp && (head === 2 || head === 3)) {
      const x = Fp2.fromBytes(tail);
      if (!Fp2.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp2.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const evenY = Fp2.isOdd(y);
      const evenH = (head & 1) === 1;
      if (evenH !== evenY)
        y = Fp2.neg(y);
      return { x, y };
    } else if (length4 === uncomp && head === 4) {
      const L = Fp2.BYTES;
      const x = Fp2.fromBytes(tail.subarray(0, L));
      const y = Fp2.fromBytes(tail.subarray(L, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length4}, expected compressed=${comp} or uncompressed=${uncomp}`);
    }
  }
  const encodePoint = extraOpts.toBytes || pointToBytes2;
  const decodePoint = extraOpts.fromBytes || pointFromBytes;
  function weierstrassEquation(x) {
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, CURVE.a)), CURVE.b);
  }
  function isValidXY(x, y) {
    const left = Fp2.sqr(y);
    const right = weierstrassEquation(x);
    return Fp2.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp2.mul(Fp2.pow(CURVE.a, _3n3), _4n2);
  const _27b2 = Fp2.mul(Fp2.sqr(CURVE.b), BigInt(27));
  if (Fp2.is0(Fp2.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n2, banZero = false) {
    if (!Fp2.isValid(n2) || banZero && Fp2.is0(n2))
      throw new Error(`bad point coordinate ${title}`);
    return n2;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point))
      throw new Error("Weierstrass Point expected");
  }
  function splitEndoScalarN(k) {
    if (!endo || !endo.basises)
      throw new Error("no endo");
    return _splitEndoScalar(k, endo.basises, Fn2.ORDER);
  }
  const toAffineMemo = memoized((p2, iz) => {
    const { X, Y, Z } = p2;
    if (Fp2.eql(Z, Fp2.ONE))
      return { x: X, y: Y };
    const is0 = p2.is0();
    if (iz == null)
      iz = is0 ? Fp2.ONE : Fp2.inv(Z);
    const x = Fp2.mul(X, iz);
    const y = Fp2.mul(Y, iz);
    const zz = Fp2.mul(Z, iz);
    if (is0)
      return { x: Fp2.ZERO, y: Fp2.ZERO };
    if (!Fp2.eql(zz, Fp2.ONE))
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p2) => {
    if (p2.is0()) {
      if (extraOpts.allowInfinityPoint && !Fp2.is0(p2.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p2.toAffine();
    if (!Fp2.isValid(x) || !Fp2.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p2.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point(Fp2.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  const _Point = class _Point {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(X, Y, Z) {
      __publicField(this, "X");
      __publicField(this, "Y");
      __publicField(this, "Z");
      this.X = acoord("x", X);
      this.Y = acoord("y", Y, true);
      this.Z = acoord("z", Z);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p2) {
      const { x, y } = p2 || {};
      if (!p2 || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p2 instanceof _Point)
        throw new Error("projective point not allowed");
      if (Fp2.is0(x) && Fp2.is0(y))
        return _Point.ZERO;
      return new _Point(x, y, Fp2.ONE);
    }
    static fromBytes(bytes) {
      const P = _Point.fromAffine(decodePoint(abytes(bytes, void 0, "point")));
      P.assertValidity();
      return P;
    }
    static fromHex(hex) {
      return _Point.fromBytes(hexToBytes(hex));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_3n3);
      return this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp2.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp2.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new _Point(this.X, Fp2.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a2, b } = CURVE;
      const b3 = Fp2.mul(b, _3n3);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a2, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a2, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a2, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new _Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a2 = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n3);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a2, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a2, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new _Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(_Point.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = extraOpts;
      if (!Fn2.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul = (n2) => wnaf.cached(this, n2, (p2) => normalizeZ(_Point, p2));
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
        const { p: k1p, f: k1f } = mul(k1);
        const { p: k2p, f: k2f } = mul(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p: p2, f: f2 } = mul(scalar);
        point = p2;
        fake = f2;
      }
      return normalizeZ(_Point, [point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = extraOpts;
      const p2 = this;
      if (!Fn2.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n7 || p2.is0())
        return _Point.ZERO;
      if (sc === _1n7)
        return p2;
      if (wnaf.hasCache(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
        const { p1, p2: p22 } = mulEndoUnsafe(_Point, p2, k1, k2);
        return finishEndo(endo2.beta, p1, p22, k1neg, k2neg);
      } else {
        return wnaf.unsafe(p2, sc);
      }
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = extraOpts;
      if (cofactor === _1n7)
        return true;
      if (isTorsionFree)
        return isTorsionFree(_Point, this);
      return wnaf.unsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = extraOpts;
      if (cofactor === _1n7)
        return this;
      if (clearCofactor)
        return clearCofactor(_Point, this);
      return this.multiplyUnsafe(cofactor);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    toBytes(isCompressed = true) {
      abool(isCompressed, "isCompressed");
      this.assertValidity();
      return encodePoint(_Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  };
  // base / generator point
  __publicField(_Point, "BASE", new _Point(CURVE.Gx, CURVE.Gy, Fp2.ONE));
  // zero / infinity / identity point
  __publicField(_Point, "ZERO", new _Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO));
  // 0, 1, 0
  // math field
  __publicField(_Point, "Fp", Fp2);
  // scalar field
  __publicField(_Point, "Fn", Fn2);
  let Point = _Point;
  const bits = Fn2.BITS;
  const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
  Point.BASE.precompute(8);
  return Point;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function SWUFpSqrtRatio(Fp2, Z) {
  const q = Fp2.ORDER;
  let l2 = _0n7;
  for (let o2 = q - _1n7; o2 % _2n5 === _0n7; o2 /= _2n5)
    l2 += _1n7;
  const c1 = l2;
  const _2n_pow_c1_1 = _2n5 << c1 - _1n7 - _1n7;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n5;
  const c2 = (q - _1n7) / _2n_pow_c1;
  const c3 = (c2 - _1n7) / _2n5;
  const c4 = _2n_pow_c1 - _1n7;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp2.pow(Z, c2);
  const c7 = Fp2.pow(Z, (c2 + _1n7) / _2n5);
  let sqrtRatio = (u2, v) => {
    let tv1 = c6;
    let tv2 = Fp2.pow(v, c4);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v);
    let tv5 = Fp2.mul(u2, tv3);
    tv5 = Fp2.pow(tv5, c3);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v);
    tv3 = Fp2.mul(tv5, u2);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c5);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c7);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i2 = c1; i2 > _1n7; i2--) {
      let tv52 = i2 - _2n5;
      tv52 = _2n5 << tv52 - _1n7;
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n3) {
    const c12 = (Fp2.ORDER - _3n3) / _4n2;
    const c22 = Fp2.sqrt(Fp2.neg(Z));
    sqrtRatio = (u2, v) => {
      let tv1 = Fp2.sqr(v);
      const tv2 = Fp2.mul(u2, v);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y2 = Fp2.mul(y1, c22);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v);
      const isQR = Fp2.eql(tv3, u2);
      let y = Fp2.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  const { A, B, Z } = opts;
  if (!Fp2.isValid(A) || !Fp2.isValid(B) || !Fp2.isValid(Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, Z);
  if (!Fp2.isOdd)
    throw new Error("Field does not have .isOdd()");
  return (u2) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp2.sqr(u2);
    tv1 = Fp2.mul(tv1, Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, B);
    tv4 = Fp2.cmov(Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, B);
    tv2 = Fp2.add(tv2, tv5);
    x = Fp2.mul(tv1, tv3);
    const { isValid: isValid2, value: value2 } = sqrtRatio(tv2, tv6);
    y = Fp2.mul(tv1, u2);
    y = Fp2.mul(y, value2);
    x = Fp2.cmov(x, tv3, isValid2);
    y = Fp2.cmov(y, value2, isValid2);
    const e1 = Fp2.isOdd(u2) === Fp2.isOdd(y);
    y = Fp2.cmov(Fp2.neg(y), y, e1);
    const tv4_inv = FpInvertBatch(Fp2, [tv4], true)[0];
    x = Fp2.mul(x, tv4_inv);
    return { x, y };
  };
}
function getWLengths(Fp2, Fn2) {
  return {
    secretKey: Fn2.BYTES,
    publicKey: 1 + Fp2.BYTES,
    publicKeyUncompressed: 1 + 2 * Fp2.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * Fn2.BYTES
  };
}
function ecdh(Point, ecdhOpts = {}) {
  const { Fn: Fn2 } = Point;
  const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
  const lengths = Object.assign(getWLengths(Point.Fp, Fn2), { seed: getMinHashLength(Fn2.ORDER) });
  function isValidSecretKey(secretKey) {
    try {
      const num2 = Fn2.fromBytes(secretKey);
      return Fn2.isValidNot0(num2);
    } catch (error) {
      return false;
    }
  }
  function isValidPublicKey(publicKey2, isCompressed) {
    const { publicKey: comp, publicKeyUncompressed } = lengths;
    try {
      const l2 = publicKey2.length;
      if (isCompressed === true && l2 !== comp)
        return false;
      if (isCompressed === false && l2 !== publicKeyUncompressed)
        return false;
      return !!Point.fromBytes(publicKey2);
    } catch (error) {
      return false;
    }
  }
  function randomSecretKey(seed = randomBytes_(lengths.seed)) {
    return mapHashToField(abytes(seed, lengths.seed, "seed"), Fn2.ORDER);
  }
  function getPublicKey(secretKey, isCompressed = true) {
    return Point.BASE.multiply(Fn2.fromBytes(secretKey)).toBytes(isCompressed);
  }
  function isProbPub(item) {
    const { secretKey, publicKey: publicKey2, publicKeyUncompressed } = lengths;
    if (!isBytes(item))
      return void 0;
    if ("_lengths" in Fn2 && Fn2._lengths || secretKey === publicKey2)
      return void 0;
    const l2 = abytes(item, void 0, "key").length;
    return l2 === publicKey2 || l2 === publicKeyUncompressed;
  }
  function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
    if (isProbPub(secretKeyA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicKeyB) === false)
      throw new Error("second arg must be public key");
    const s2 = Fn2.fromBytes(secretKeyA);
    const b = Point.fromBytes(publicKeyB);
    return b.multiply(s2).toBytes(isCompressed);
  }
  const utils = {
    isValidSecretKey,
    isValidPublicKey,
    randomSecretKey
  };
  const keygen = createKeygen(randomSecretKey, getPublicKey);
  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
}
function ecdsa(Point, hash, ecdsaOpts = {}) {
  ahash(hash);
  validateObject(ecdsaOpts, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  ecdsaOpts = Object.assign({}, ecdsaOpts);
  const randomBytes4 = ecdsaOpts.randomBytes || randomBytes;
  const hmac2 = ecdsaOpts.hmac || ((key, msg) => hmac(hash, key, msg));
  const { Fp: Fp2, Fn: Fn2 } = Point;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn2;
  const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
  const defaultSigOpts = {
    prehash: true,
    lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : true,
    format: "compact",
    extraEntropy: false
  };
  const hasLargeCofactor = CURVE_ORDER * _2n5 < Fp2.ORDER;
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n7;
    return number > HALF;
  }
  function validateRS(title, num2) {
    if (!Fn2.isValidNot0(num2))
      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
    return num2;
  }
  function assertSmallCofactor() {
    if (hasLargeCofactor)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function validateSigLength(bytes, format2) {
    validateSigFormat(format2);
    const size = lengths.signature;
    const sizer = format2 === "compact" ? size : format2 === "recovered" ? size + 1 : void 0;
    return abytes(bytes, sizer);
  }
  class Signature {
    constructor(r2, s2, recovery) {
      __publicField(this, "r");
      __publicField(this, "s");
      __publicField(this, "recovery");
      this.r = validateRS("r", r2);
      this.s = validateRS("s", s2);
      if (recovery != null) {
        assertSmallCofactor();
        if (![0, 1, 2, 3].includes(recovery))
          throw new Error("invalid recovery id");
        this.recovery = recovery;
      }
      Object.freeze(this);
    }
    static fromBytes(bytes, format2 = defaultSigOpts.format) {
      validateSigLength(bytes, format2);
      let recid;
      if (format2 === "der") {
        const { r: r3, s: s3 } = DER.toSig(abytes(bytes));
        return new Signature(r3, s3);
      }
      if (format2 === "recovered") {
        recid = bytes[0];
        format2 = "compact";
        bytes = bytes.subarray(1);
      }
      const L = lengths.signature / 2;
      const r2 = bytes.subarray(0, L);
      const s2 = bytes.subarray(L, L * 2);
      return new Signature(Fn2.fromBytes(r2), Fn2.fromBytes(s2), recid);
    }
    static fromHex(hex, format2) {
      return this.fromBytes(hexToBytes(hex), format2);
    }
    assertRecovery() {
      const { recovery } = this;
      if (recovery == null)
        throw new Error("invalid recovery id: must be present");
      return recovery;
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(messageHash) {
      const { r: r2, s: s2 } = this;
      const recovery = this.assertRecovery();
      const radj = recovery === 2 || recovery === 3 ? r2 + CURVE_ORDER : r2;
      if (!Fp2.isValid(radj))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const x = Fp2.toBytes(radj);
      const R = Point.fromBytes(concatBytes(pprefix((recovery & 1) === 0), x));
      const ir = Fn2.inv(radj);
      const h = bits2int_modN(abytes(messageHash, void 0, "msgHash"));
      const u1 = Fn2.create(-h * ir);
      const u2 = Fn2.create(s2 * ir);
      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("invalid recovery: point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    toBytes(format2 = defaultSigOpts.format) {
      validateSigFormat(format2);
      if (format2 === "der")
        return hexToBytes(DER.hexFromSig(this));
      const { r: r2, s: s2 } = this;
      const rb = Fn2.toBytes(r2);
      const sb = Fn2.toBytes(s2);
      if (format2 === "recovered") {
        assertSmallCofactor();
        return concatBytes(Uint8Array.of(this.assertRecovery()), rb, sb);
      }
      return concatBytes(rb, sb);
    }
    toHex(format2) {
      return bytesToHex(this.toBytes(format2));
    }
  }
  const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num2 = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - fnBits;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
    return Fn2.create(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(fnBits);
  function int2octets(num2) {
    aInRange("num < 2^" + fnBits, num2, _0n7, ORDER_MASK);
    return Fn2.toBytes(num2);
  }
  function validateMsgAndHash(message2, prehash) {
    abytes(message2, void 0, "message");
    return prehash ? abytes(hash(message2), void 0, "prehashed message") : message2;
  }
  function prepSig(message2, secretKey, opts) {
    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
    message2 = validateMsgAndHash(message2, prehash);
    const h1int = bits2int_modN(message2);
    const d2 = Fn2.fromBytes(secretKey);
    if (!Fn2.isValidNot0(d2))
      throw new Error("invalid private key");
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (extraEntropy != null && extraEntropy !== false) {
      const e2 = extraEntropy === true ? randomBytes4(lengths.secretKey) : extraEntropy;
      seedArgs.push(abytes(e2, void 0, "extraEntropy"));
    }
    const seed = concatBytes(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn2.isValidNot0(k))
        return;
      const ik = Fn2.inv(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r2 = Fn2.create(q.x);
      if (r2 === _0n7)
        return;
      const s2 = Fn2.create(ik * Fn2.create(m2 + r2 * d2));
      if (s2 === _0n7)
        return;
      let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n7);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = Fn2.neg(s2);
        recovery ^= 1;
      }
      return new Signature(r2, normS, hasLargeCofactor ? void 0 : recovery);
    }
    return { seed, k2sig };
  }
  function sign3(message2, secretKey, opts = {}) {
    const { seed, k2sig } = prepSig(message2, secretKey, opts);
    const drbg = createHmacDrbg(hash.outputLen, Fn2.BYTES, hmac2);
    const sig = drbg(seed, k2sig);
    return sig.toBytes(opts.format);
  }
  function verify2(signature, message2, publicKey2, opts = {}) {
    const { lowS, prehash, format: format2 } = validateSigOpts(opts, defaultSigOpts);
    publicKey2 = abytes(publicKey2, void 0, "publicKey");
    message2 = validateMsgAndHash(message2, prehash);
    if (!isBytes(signature)) {
      const end = signature instanceof Signature ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + end);
    }
    validateSigLength(signature, format2);
    try {
      const sig = Signature.fromBytes(signature, format2);
      const P = Point.fromBytes(publicKey2);
      if (lowS && sig.hasHighS())
        return false;
      const { r: r2, s: s2 } = sig;
      const h = bits2int_modN(message2);
      const is2 = Fn2.inv(s2);
      const u1 = Fn2.create(h * is2);
      const u2 = Fn2.create(r2 * is2);
      const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
      if (R.is0())
        return false;
      const v = Fn2.create(R.x);
      return v === r2;
    } catch (e2) {
      return false;
    }
  }
  function recoverPublicKey(signature, message2, opts = {}) {
    const { prehash } = validateSigOpts(opts, defaultSigOpts);
    message2 = validateMsgAndHash(message2, prehash);
    return Signature.fromBytes(signature, "recovered").recoverPublicKey(message2).toBytes();
  }
  return Object.freeze({
    keygen,
    getPublicKey,
    getSharedSecret,
    utils,
    lengths,
    Point,
    sign: sign3,
    verify: verify2,
    recoverPublicKey,
    Signature,
    hash
  });
}

// ../../node_modules/@noble/curves/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n8 = /* @__PURE__ */ BigInt(0);
var _2n6 = /* @__PURE__ */ BigInt(2);
function sqrtMod(y) {
  const P = secp256k1_CURVE.p;
  const _3n4 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n4, P) * b3 % P;
  const b9 = pow2(b6, _3n4, P) * b3 % P;
  const b11 = pow2(b9, _2n6, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n4, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n6, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
var Pointk1 = /* @__PURE__ */ weierstrass(secp256k1_CURVE, {
  Fp: Fpk1,
  endo: secp256k1_ENDO
});
var secp256k1 = /* @__PURE__ */ ecdsa(Pointk1, sha2562);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages2) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha2562(asciiToBytes(tag));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha2562(concatBytes(tagP, ...messages2));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var hasEven = (y) => y % _2n6 === _0n8;
function schnorrGetExtPubKey(priv) {
  const { Fn: Fn2, BASE } = Pointk1;
  const d_ = Fn2.fromBytes(priv);
  const p2 = BASE.multiply(d_);
  const scalar = hasEven(p2.y) ? d_ : Fn2.neg(d_);
  return { scalar, bytes: pointToBytes(p2) };
}
function lift_x(x) {
  const Fp2 = Fpk1;
  if (!Fp2.isValidNot0(x))
    throw new Error("invalid x: Fail if x  p");
  const xx = Fp2.create(x * x);
  const c2 = Fp2.create(xx * x + BigInt(7));
  let y = Fp2.sqrt(c2);
  if (!hasEven(y))
    y = Fp2.neg(y);
  const p2 = Pointk1.fromAffine({ x, y });
  p2.assertValidity();
  return p2;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message2, secretKey, auxRand = randomBytes(32)) {
  const { Fn: Fn2 } = Pointk1;
  const m2 = abytes(message2, void 0, "message");
  const { bytes: px, scalar: d2 } = schnorrGetExtPubKey(secretKey);
  const a2 = abytes(auxRand, 32, "auxRand");
  const t2 = Fn2.toBytes(d2 ^ num(taggedHash("BIP0340/aux", a2)));
  const rand = taggedHash("BIP0340/nonce", t2, px, m2);
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
  const e2 = challenge(rx, px, m2);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn2.toBytes(Fn2.create(k + e2 * d2)), 32);
  if (!schnorrVerify(sig, m2, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message2, publicKey2) {
  const { Fp: Fp2, Fn: Fn2, BASE } = Pointk1;
  const sig = abytes(signature, 64, "signature");
  const m2 = abytes(message2, void 0, "message");
  const pub = abytes(publicKey2, 32, "publicKey");
  try {
    const P = lift_x(num(pub));
    const r2 = num(sig.subarray(0, 32));
    if (!Fp2.isValidNot0(r2))
      return false;
    const s2 = num(sig.subarray(32, 64));
    if (!Fn2.isValidNot0(s2))
      return false;
    const e2 = challenge(Fn2.toBytes(r2), pointToBytes(P), m2);
    const R = BASE.multiplyUnsafe(s2).add(P.multiplyUnsafe(Fn2.neg(e2)));
    const { x, y } = R.toAffine();
    if (R.is0() || !hasEven(y) || x !== r2)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = /* @__PURE__ */ (() => {
  const size = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes(seedLength)) => {
    return mapHashToField(seed, secp256k1_CURVE.n);
  };
  return {
    keygen: createKeygen(randomSecretKey, schnorrGetPublicKey),
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    Point: Pointk1,
    utils: {
      randomSecretKey,
      taggedHash,
      lift_x,
      pointToBytes
    },
    lengths: {
      secretKey: size,
      publicKey: size,
      publicKeyHasPrefix: false,
      signature: size * 2,
      seed: seedLength
    }
  };
})();
var isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i2) => i2.map((j) => BigInt(j)))))();
var mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = /* @__PURE__ */ (() => createHasher2(Pointk1, (scalars) => {
  const { x, y } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha2562
}))();

// ../../node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js
var PUBLIC_KEY_BYTE_LENGTH2 = 33;
var PRIVATE_KEY_BYTE_LENGTH2 = 32;
function hashAndSign4(key, msg, options2) {
  const p2 = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise(p2)) {
    return p2.then(({ digest: digest2 }) => {
      options2?.signal?.throwIfAborted();
      return secp256k1.sign(digest2, key, {
        prehash: false,
        format: "der"
      });
    }).catch((err) => {
      if (err.name === "AbortError") {
        throw err;
      }
      throw new SigningError(String(err));
    });
  }
  try {
    return secp256k1.sign(p2.digest, key, {
      prehash: false,
      format: "der"
    });
  } catch (err) {
    throw new SigningError(String(err));
  }
}
function hashAndVerify4(key, sig, msg, options2) {
  const p2 = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise(p2)) {
    return p2.then(({ digest: digest2 }) => {
      options2?.signal?.throwIfAborted();
      return secp256k1.verify(sig, digest2, key, {
        prehash: false,
        format: "der"
      });
    }).catch((err) => {
      if (err.name === "AbortError") {
        throw err;
      }
      throw new VerificationError(String(err));
    });
  }
  try {
    options2?.signal?.throwIfAborted();
    return secp256k1.verify(sig, p2.digest, key, {
      prehash: false,
      format: "der"
    });
  } catch (err) {
    throw new VerificationError(String(err));
  }
}

// ../../node_modules/@libp2p/crypto/dist/src/keys/secp256k1/secp256k1.js
var Secp256k1PublicKey = class {
  constructor(key) {
    __publicField(this, "type", "secp256k1");
    __publicField(this, "raw");
    __publicField(this, "_key");
    this._key = validateSecp256k1PublicKey(key);
    this.raw = compressSecp256k1PublicKey(this._key);
  }
  toMultihash() {
    return identity.digest(publicKeyToProtobuf(this));
  }
  toCID() {
    return CID.createV1(114, this.toMultihash());
  }
  toString() {
    return base58btc.encode(this.toMultihash().bytes).substring(1);
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  verify(data, sig, options2) {
    return hashAndVerify4(this._key, sig, data, options2);
  }
};
var Secp256k1PrivateKey = class {
  constructor(key, publicKey2) {
    __publicField(this, "type", "secp256k1");
    __publicField(this, "raw");
    __publicField(this, "publicKey");
    this.raw = validateSecp256k1PrivateKey(key);
    this.publicKey = new Secp256k1PublicKey(publicKey2 ?? computeSecp256k1PublicKey(key));
  }
  equals(key) {
    if (key == null || !(key.raw instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.raw, key.raw);
  }
  sign(message2, options2) {
    return hashAndSign4(this.raw, message2, options2);
  }
};

// ../../node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js
var PRIVATE_KEY_BYTE_LENGTH3 = 32;
function unmarshalSecp256k1PrivateKey(bytes) {
  return new Secp256k1PrivateKey(bytes);
}
function unmarshalSecp256k1PublicKey(bytes) {
  return new Secp256k1PublicKey(bytes);
}
async function generateSecp256k1KeyPair() {
  const privateKeyBytes = generateSecp256k1PrivateKey();
  return new Secp256k1PrivateKey(privateKeyBytes);
}
function compressSecp256k1PublicKey(key) {
  return secp256k1.Point.fromBytes(key).toBytes();
}
function decompressSecp256k1PublicKey(key) {
  return secp256k1.Point.fromBytes(key).toBytes(false);
}
function validateSecp256k1PrivateKey(key) {
  try {
    secp256k1.getPublicKey(key, true);
    return key;
  } catch (err) {
    throw new InvalidPrivateKeyError2(String(err));
  }
}
function validateSecp256k1PublicKey(key) {
  try {
    secp256k1.Point.fromBytes(key);
    return key;
  } catch (err) {
    throw new InvalidPublicKeyError2(String(err));
  }
}
function computeSecp256k1PublicKey(privateKey) {
  try {
    return secp256k1.getPublicKey(privateKey, true);
  } catch (err) {
    throw new InvalidPrivateKeyError2(String(err));
  }
}
function generateSecp256k1PrivateKey() {
  return secp256k1.utils.randomSecretKey();
}

// ../../node_modules/@libp2p/crypto/dist/src/keys/ecdh/index.browser.js
var curveLengths = {
  "P-256": 32,
  "P-384": 48,
  "P-521": 66
};
var curveTypes = Object.keys(curveLengths);
var names = curveTypes.join(" / ");
async function generateEphemeralKeyPair(curve) {
  if (curve !== "P-256" && curve !== "P-384" && curve !== "P-521") {
    throw new InvalidParametersError2(`Unknown curve: ${curve}. Must be ${names}`);
  }
  const pair = await webcrypto_default.get().subtle.generateKey({
    name: "ECDH",
    namedCurve: curve
  }, true, ["deriveBits"]);
  const genSharedKey = async (theirPub, forcePrivate) => {
    let privateKey;
    if (forcePrivate != null) {
      privateKey = await webcrypto_default.get().subtle.importKey("jwk", unmarshalPrivateKey(curve, forcePrivate), {
        name: "ECDH",
        namedCurve: curve
      }, false, ["deriveBits"]);
    } else {
      privateKey = pair.privateKey;
    }
    const key = await webcrypto_default.get().subtle.importKey("jwk", unmarshalPublicKey(curve, theirPub), {
      name: "ECDH",
      namedCurve: curve
    }, false, []);
    const buffer2 = await webcrypto_default.get().subtle.deriveBits({
      name: "ECDH",
      public: key
    }, privateKey, curveLengths[curve] * 8);
    return new Uint8Array(buffer2, 0, buffer2.byteLength);
  };
  const publicKey2 = await webcrypto_default.get().subtle.exportKey("jwk", pair.publicKey);
  const ecdhKey = {
    key: marshalPublicKey(publicKey2),
    genSharedKey
  };
  return ecdhKey;
}
function marshalPublicKey(jwk) {
  if (jwk.crv == null || jwk.x == null || jwk.y == null) {
    throw new InvalidParametersError2("JWK was missing components");
  }
  if (jwk.crv !== "P-256" && jwk.crv !== "P-384" && jwk.crv !== "P-521") {
    throw new InvalidParametersError2(`Unknown curve: ${jwk.crv}. Must be ${names}`);
  }
  const byteLen = curveLengths[jwk.crv];
  return concat([
    Uint8Array.from([4]),
    // uncompressed point
    base64urlToBuffer(jwk.x, byteLen),
    base64urlToBuffer(jwk.y, byteLen)
  ], 1 + byteLen * 2);
}
function unmarshalPublicKey(curve, key) {
  if (curve !== "P-256" && curve !== "P-384" && curve !== "P-521") {
    throw new InvalidParametersError2(`Unknown curve: ${curve}. Must be ${names}`);
  }
  const byteLen = curveLengths[curve];
  if (!equals3(key.subarray(0, 1), Uint8Array.from([4]))) {
    throw new InvalidParametersError2("Cannot unmarshal public key - invalid key format");
  }
  return {
    kty: "EC",
    crv: curve,
    x: toString2(key.subarray(1, byteLen + 1), "base64url"),
    y: toString2(key.subarray(1 + byteLen), "base64url"),
    ext: true
  };
}
var unmarshalPrivateKey = (curve, key) => ({
  ...unmarshalPublicKey(curve, key.public),
  d: toString2(key.private, "base64url")
});

// ../../node_modules/@libp2p/crypto/dist/src/hmac/index.browser.js
var index_browser_exports2 = {};
__export(index_browser_exports2, {
  create: () => create2
});

// ../../node_modules/@libp2p/crypto/dist/src/hmac/lengths.js
var lengths_default = {
  SHA1: 20,
  SHA256: 32,
  SHA512: 64
};

// ../../node_modules/@libp2p/crypto/dist/src/hmac/index.browser.js
var hashTypes = {
  SHA1: "SHA-1",
  SHA256: "SHA-256",
  SHA512: "SHA-512"
};
var sign = async (key, data) => {
  const buf2 = await webcrypto_default.get().subtle.sign({ name: "HMAC" }, key, data);
  return new Uint8Array(buf2, 0, buf2.byteLength);
};
async function create2(hashType, secret) {
  const hash = hashTypes[hashType];
  const key = await webcrypto_default.get().subtle.importKey("raw", secret, {
    name: "HMAC",
    hash: { name: hash }
  }, false, ["sign"]);
  return {
    async digest(data) {
      return sign(key, data);
    },
    length: lengths_default[hashType]
  };
}

// ../../node_modules/@libp2p/crypto/dist/src/keys/key-stretcher.js
var cipherMap = {
  "AES-128": {
    ivSize: 16,
    keySize: 16
  },
  "AES-256": {
    ivSize: 16,
    keySize: 32
  },
  Blowfish: {
    ivSize: 8,
    keySize: 32
  }
};
async function keyStretcher(cipherType, hash, secret) {
  if (cipherType !== "AES-128" && cipherType !== "AES-256" && cipherType !== "Blowfish") {
    throw new InvalidParametersError2("Cipher type was missing or unsupported");
  }
  if (hash !== "SHA1" && hash !== "SHA256" && hash !== "SHA512") {
    throw new InvalidParametersError2("Hash type was missing or unsupported");
  }
  if (secret == null || !(secret instanceof Uint8Array)) {
    throw new InvalidParametersError2("Secret was missing or an incorrect type");
  }
  const cipher = cipherMap[cipherType];
  const cipherKeySize = cipher.keySize;
  const ivSize = cipher.ivSize;
  const hmacKeySize = 20;
  const seed = fromString2("key expansion");
  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
  const m2 = await create2(hash, secret);
  let a2 = await m2.digest(seed);
  const result = [];
  let j = 0;
  while (j < resultLength) {
    const b = await m2.digest(concat([a2, seed]));
    let todo = b.length;
    if (j + todo > resultLength) {
      todo = resultLength - j;
    }
    result.push(b);
    j += todo;
    a2 = await m2.digest(a2);
  }
  const half = resultLength / 2;
  const resultBuffer = concat(result);
  const r1 = resultBuffer.subarray(0, half);
  const r2 = resultBuffer.subarray(half, resultLength);
  const createKey = (res) => ({
    iv: res.subarray(0, ivSize),
    cipherKey: res.subarray(ivSize, ivSize + cipherKeySize),
    macKey: res.subarray(ivSize + cipherKeySize)
  });
  return {
    k1: createKey(r1),
    k2: createKey(r2)
  };
}

// ../../node_modules/@libp2p/crypto/dist/src/keys/index.js
async function generateKeyPair(type, bits) {
  if (type === "Ed25519") {
    return generateEd25519KeyPair();
  }
  if (type === "secp256k1") {
    return generateSecp256k1KeyPair();
  }
  if (type === "RSA") {
    return generateRSAKeyPair(toBits(bits));
  }
  if (type === "ECDSA") {
    return generateECDSAKeyPair(toCurve(bits));
  }
  throw new UnsupportedKeyTypeError2();
}
async function generateKeyPairFromSeed(type, seed) {
  if (type !== "Ed25519") {
    throw new UnsupportedKeyTypeError2("Seed key derivation only supported for Ed25519 keys");
  }
  return generateEd25519KeyPairFromSeed(seed);
}
function publicKeyFromProtobuf(buf2, digest2) {
  const { Type: Type2, Data } = PublicKey.decode(buf2);
  const data = Data ?? new Uint8Array();
  switch (Type2) {
    case KeyType.RSA:
      return pkixToRSAPublicKey(data, digest2);
    case KeyType.Ed25519:
      return unmarshalEd25519PublicKey(data);
    case KeyType.secp256k1:
      return unmarshalSecp256k1PublicKey(data);
    case KeyType.ECDSA:
      return unmarshalECDSAPublicKey(data);
    default:
      throw new UnsupportedKeyTypeError2();
  }
}
function publicKeyFromRaw(buf2) {
  if (buf2.byteLength === PUBLIC_KEY_BYTE_LENGTH) {
    return unmarshalEd25519PublicKey(buf2);
  } else if (buf2.byteLength === PUBLIC_KEY_BYTE_LENGTH2) {
    return unmarshalSecp256k1PublicKey(buf2);
  }
  const message2 = decodeDer(buf2);
  const ecdsaOid = message2[1]?.[0];
  if (ecdsaOid === ECDSA_P_256_OID || ecdsaOid === ECDSA_P_384_OID || ecdsaOid === ECDSA_P_521_OID) {
    return pkiMessageToECDSAPublicKey(message2);
  }
  if (message2[0]?.[0] === RSAES_PKCS1_V1_5_OID) {
    return pkixMessageToRSAPublicKey(message2, buf2);
  }
  throw new InvalidParametersError2("Could not extract public key from raw bytes");
}
function publicKeyFromMultihash(digest2) {
  const { Type: Type2, Data } = PublicKey.decode(digest2.digest);
  const data = Data ?? new Uint8Array();
  switch (Type2) {
    case KeyType.Ed25519:
      return unmarshalEd25519PublicKey(data);
    case KeyType.secp256k1:
      return unmarshalSecp256k1PublicKey(data);
    case KeyType.ECDSA:
      return unmarshalECDSAPublicKey(data);
    default:
      throw new UnsupportedKeyTypeError2();
  }
}
function publicKeyToProtobuf(key) {
  return PublicKey.encode({
    Type: KeyType[key.type],
    Data: key.raw
  });
}
function privateKeyFromProtobuf(buf2) {
  const decoded = PrivateKey.decode(buf2);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return pkcs1ToRSAPrivateKey(data);
    case KeyType.Ed25519:
      return unmarshalEd25519PrivateKey(data);
    case KeyType.secp256k1:
      return unmarshalSecp256k1PrivateKey(data);
    case KeyType.ECDSA:
      return unmarshalECDSAPrivateKey(data);
    default:
      throw new UnsupportedKeyTypeError2();
  }
}
function privateKeyFromRaw(buf2) {
  if (buf2.byteLength === PRIVATE_KEY_BYTE_LENGTH) {
    return unmarshalEd25519PrivateKey(buf2);
  } else if (buf2.byteLength === PRIVATE_KEY_BYTE_LENGTH2) {
    return unmarshalSecp256k1PrivateKey(buf2);
  }
  const message2 = decodeDer(buf2);
  const ecdsaOid = message2[2]?.[0];
  if (ecdsaOid === ECDSA_P_256_OID || ecdsaOid === ECDSA_P_384_OID || ecdsaOid === ECDSA_P_521_OID) {
    return pkiMessageToECDSAPrivateKey(message2);
  }
  if (message2.length > 8) {
    return pkcs1MessageToRSAPrivateKey(message2);
  }
  throw new InvalidParametersError2("Could not extract private key from raw bytes");
}
function privateKeyToProtobuf(key) {
  return PrivateKey.encode({
    Type: KeyType[key.type],
    Data: key.raw
  });
}
function toBits(bits) {
  if (bits == null) {
    return 2048;
  }
  return parseInt(bits, 10);
}
function toCurve(curve) {
  if (curve === "P-256" || curve == null) {
    return "P-256";
  }
  if (curve === "P-384") {
    return "P-384";
  }
  if (curve === "P-521") {
    return "P-521";
  }
  throw new InvalidParametersError2("Unsupported curve, should be P-256, P-384 or P-521");
}
async function privateKeyToCryptoKeyPair(privateKey) {
  if (privateKey.type === "RSA") {
    return {
      privateKey: await crypto.subtle.importKey("jwk", privateKey.jwk, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, true, ["sign"]),
      publicKey: await crypto.subtle.importKey("jwk", privateKey.publicKey.jwk, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, true, ["verify"])
    };
  }
  if (privateKey.type === "ECDSA") {
    return {
      privateKey: await crypto.subtle.importKey("jwk", privateKey.jwk, {
        name: "ECDSA",
        namedCurve: privateKey.jwk.crv ?? "P-256"
      }, true, ["sign"]),
      publicKey: await crypto.subtle.importKey("jwk", privateKey.publicKey.jwk, {
        name: "ECDSA",
        namedCurve: privateKey.publicKey.jwk.crv ?? "P-256"
      }, true, ["verify"])
    };
  }
  throw new InvalidParametersError2("Only RSA and ECDSA keys are supported");
}
async function privateKeyFromCryptoKeyPair(keyPair) {
  if (keyPair.privateKey.algorithm.name === "RSASSA-PKCS1-v1_5") {
    const jwk = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
    return jwkToRSAPrivateKey(jwk);
  }
  if (keyPair.privateKey.algorithm.name === "ECDSA") {
    const jwk = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
    return new ECDSAPrivateKey(jwk);
  }
  throw new InvalidParametersError2("Only RSA and ECDSA keys are supported");
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/peer-id/dist/src/peer-id.js
var _a3, _b, _c;
var inspect = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var LIBP2P_KEY_CODE = 114;
var PeerIdImpl = class {
  constructor(init) {
    __publicField(this, "type");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "string");
    __publicField(this, _a3, true);
    this.type = init.type;
    this.multihash = init.multihash;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toMultihash() {
    return this.multihash;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id == null) {
      return false;
    }
    if (id instanceof Uint8Array) {
      return equals3(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return this.toString() === id;
    } else if (id?.toMultihash()?.bytes != null) {
      return equals3(this.multihash.bytes, id.toMultihash().bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```TypeScript
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [(_a3 = peerIdSymbol, inspect)]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "RSA" });
    __publicField(this, "type", "RSA");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    __publicField(this, "type", "Ed25519");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Secp256k1PeerId = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    __publicField(this, "type", "secp256k1");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
var URLPeerId = class {
  constructor(url) {
    __publicField(this, "type", "url");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "url");
    __publicField(this, _b, true);
    this.url = url.toString();
    this.multihash = identity.digest(fromString2(this.url));
  }
  [(_c = inspect, _b = peerIdSymbol, _c)]() {
    return `PeerId(${this.url})`;
  }
  toString() {
    return this.toCID().toString();
  }
  toMultihash() {
    return this.multihash;
  }
  toCID() {
    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.toMultihash());
  }
  toJSON() {
    return this.toString();
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString2(other);
    }
    return other.toString() === this.toString();
  }
};

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@libp2p/peer-id/dist/src/index.js
var LIBP2P_KEY_CODE2 = 114;
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE2 = 2336;
function peerIdFromString(str, decoder) {
  let multihash;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    multihash = decode4(base58btc.decode(`z${str}`));
  } else if (str.startsWith("k51qzi5uqu5") || str.startsWith("kzwfwjn5ji4") || str.startsWith("k2k4r8") || str.startsWith("bafz")) {
    return peerIdFromCID(CID.parse(str));
  } else {
    if (decoder == null) {
      throw new InvalidParametersError('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
    }
    multihash = decode4(decoder.decode(str));
  }
  return peerIdFromMultihash(multihash);
}
function peerIdFromPublicKey(publicKey2) {
  if (publicKey2.type === "Ed25519") {
    return new Ed25519PeerId({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  } else if (publicKey2.type === "secp256k1") {
    return new Secp256k1PeerId({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  } else if (publicKey2.type === "RSA") {
    return new RSAPeerId({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  }
  throw new UnsupportedKeyTypeError();
}
function peerIdFromPrivateKey(privateKey) {
  return peerIdFromPublicKey(privateKey.publicKey);
}
function peerIdFromMultihash(multihash) {
  if (isSha256Multihash(multihash)) {
    return new RSAPeerId({ multihash });
  } else if (isIdentityMultihash(multihash)) {
    try {
      const publicKey2 = publicKeyFromMultihash(multihash);
      if (publicKey2.type === "Ed25519") {
        return new Ed25519PeerId({ multihash, publicKey: publicKey2 });
      } else if (publicKey2.type === "secp256k1") {
        return new Secp256k1PeerId({ multihash, publicKey: publicKey2 });
      }
    } catch (err) {
      const url = toString2(multihash.digest);
      return new URLPeerId(new URL(url));
    }
  }
  throw new InvalidMultihashError("Supplied PeerID Multihash is invalid");
}
function peerIdFromCID(cid) {
  if (cid?.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE2 && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
    throw new InvalidCIDError("Supplied PeerID CID is invalid");
  }
  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
    const url = toString2(cid.multihash.digest);
    return new URLPeerId(new URL(url));
  }
  return peerIdFromMultihash(cid.multihash);
}
function isIdentityMultihash(multihash) {
  return multihash.code === identity.code;
}
function isSha256Multihash(multihash) {
  return multihash.code === sha256.code;
}

// ../../node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}

// ../../node_modules/it-length-prefixed/dist/src/encode.js
var defaultEncoder = (length4) => {
  const lengthLength = encodingLength2(length4);
  const lengthBuf = allocUnsafe(lengthLength);
  encode7(length4, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode8(source, options2) {
  options2 = options2 ?? {};
  const encodeLength2 = options2.lengthEncoder ?? defaultEncoder;
  function* maybeYield(chunk) {
    const length4 = encodeLength2(chunk.byteLength);
    if (length4 instanceof Uint8Array) {
      yield length4;
    } else {
      yield* length4;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable(source)) {
    return (async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    })();
  }
  return (function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  })();
}
encode8.single = (chunk, options2) => {
  options2 = options2 ?? {};
  const encodeLength2 = options2.lengthEncoder ?? defaultEncoder;
  return new Uint8ArrayList(encodeLength2(chunk.byteLength), chunk);
};

// ../../node_modules/it-length-prefixed/dist/src/errors.js
var InvalidMessageLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};
var UnexpectedEOFError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// ../../node_modules/it-length-prefixed/dist/src/decode.js
var MAX_LENGTH_LENGTH = 8;
var MAX_DATA_LENGTH = 1024 * 1024 * 4;
var ReadMode;
(function(ReadMode5) {
  ReadMode5[ReadMode5["LENGTH"] = 0] = "LENGTH";
  ReadMode5[ReadMode5["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
var defaultDecoder = (buf2) => {
  const length4 = decode8(buf2);
  defaultDecoder.bytes = encodingLength2(length4);
  return length4;
};
defaultDecoder.bytes = 0;
function decode9(source, options2) {
  const buffer2 = new Uint8ArrayList();
  let mode = ReadMode.LENGTH;
  let dataLength = -1;
  const lengthDecoder = options2?.lengthDecoder ?? defaultDecoder;
  const maxLengthLength = options2?.maxLengthLength ?? MAX_LENGTH_LENGTH;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH;
  function* maybeYield() {
    while (buffer2.byteLength > 0) {
      if (mode === ReadMode.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer2);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer2.consume(dataLengthLength);
          if (options2?.onLength != null) {
            options2.onLength(dataLength);
          }
          mode = ReadMode.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer2.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode.DATA) {
        if (buffer2.byteLength < dataLength) {
          break;
        }
        const data = buffer2.sublist(0, dataLength);
        buffer2.consume(dataLength);
        if (options2?.onData != null) {
          options2.onData(data);
        }
        yield data;
        mode = ReadMode.LENGTH;
      }
    }
  }
  if (isAsyncIterable(source)) {
    return (async function* () {
      for await (const buf2 of source) {
        buffer2.append(buf2);
        yield* maybeYield();
      }
      if (buffer2.byteLength > 0) {
        throw new UnexpectedEOFError("Unexpected end of input");
      }
    })();
  }
  return (function* () {
    for (const buf2 of source) {
      buffer2.append(buf2);
      yield* maybeYield();
    }
    if (buffer2.byteLength > 0) {
      throw new UnexpectedEOFError("Unexpected end of input");
    }
  })();
}
decode9.fromReader = (reader, options2) => {
  let byteLength = 1;
  const varByteSource = (async function* () {
    while (true) {
      try {
        const { done, value: value2 } = await reader.next(byteLength);
        if (done === true) {
          return;
        }
        if (value2 != null) {
          yield value2;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  })();
  const onLength = (l2) => {
    byteLength = l2;
  };
  return decode9(varByteSource, {
    ...options2 ?? {},
    onLength
  });
};

// ../../node_modules/p-defer/index.js
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// ../../node_modules/it-pushable/dist/src/fifo.js
var FixedFIFO = class {
  constructor(hwm) {
    __publicField(this, "buffer");
    __publicField(this, "mask");
    __publicField(this, "top");
    __publicField(this, "btm");
    __publicField(this, "next");
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var FIFO = class {
  constructor(options2 = {}) {
    __publicField(this, "size");
    __publicField(this, "hwm");
    __publicField(this, "head");
    __publicField(this, "tail");
    this.hwm = options2.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if (obj?.byteLength != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if (val?.value != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if (val?.value != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};

// ../../node_modules/it-pushable/dist/src/index.js
var AbortError3 = class extends Error {
  constructor(message2, code5) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.code = code5 ?? "ABORT_ERR";
  }
};
function pushable(options2 = {}) {
  const getNext = (buffer2) => {
    const next = buffer2.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      // @ts-expect-error if done is false, value will be present
      value: next.value
    };
  };
  return _pushable(getNext, options2);
}
function pushableV(options2 = {}) {
  const getNext = (buffer2) => {
    let next;
    const values = [];
    while (!buffer2.isEmpty()) {
      next = buffer2.shift();
      if (next == null) {
        break;
      }
      if (next.error != null) {
        throw next.error;
      }
      if (next.done === false) {
        values.push(next.value);
      }
    }
    if (next == null) {
      return { done: true };
    }
    return {
      done: next.done === true,
      value: values
    };
  };
  return _pushable(getNext, options2);
}
function _pushable(getNext, options2) {
  options2 = options2 ?? {};
  let onEnd = options2.onEnd;
  let buffer2 = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  let drain2 = pDefer();
  const waitNext = async () => {
    try {
      if (!buffer2.isEmpty()) {
        return getNext(buffer2);
      }
      if (ended) {
        return { done: true };
      }
      return await new Promise((resolve, reject) => {
        onNext = (next) => {
          onNext = null;
          buffer2.push(next);
          try {
            resolve(getNext(buffer2));
          } catch (err) {
            reject(err);
          }
          return pushable2;
        };
      });
    } finally {
      if (buffer2.isEmpty()) {
        queueMicrotask(() => {
          drain2.resolve();
          drain2 = pDefer();
        });
      }
    }
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer2.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer2 = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer2.push({ error: err });
    return pushable2;
  };
  const push = (value2) => {
    if (ended) {
      return pushable2;
    }
    if (options2?.objectMode !== true && value2?.byteLength == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value: value2 });
  };
  const end = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer2 = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err) => {
    end(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer2.size;
    },
    onEmpty: async (options3) => {
      const signal = options3?.signal;
      signal?.throwIfAborted();
      if (buffer2.isEmpty()) {
        return;
      }
      let cancel;
      let listener;
      if (signal != null) {
        cancel = new Promise((resolve, reject) => {
          listener = () => {
            reject(new AbortError3());
          };
          signal.addEventListener("abort", listener);
        });
      }
      try {
        await Promise.race([
          drain2.promise,
          cancel
        ]);
      } finally {
        if (listener != null && signal != null) {
          signal?.removeEventListener("abort", listener);
        }
      }
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    },
    onEmpty: (opts) => {
      return _pushable2.onEmpty(opts);
    }
  };
  return pushable2;
}

// ../../node_modules/race-signal/dist/src/index.js
function defaultTranslate(signal) {
  return signal.reason;
}
async function raceSignal(promise, signal, opts) {
  if (signal == null) {
    return promise;
  }
  const translateError = opts?.translateError ?? defaultTranslate;
  if (signal.aborted) {
    promise.catch(() => {
    });
    return Promise.reject(translateError(signal));
  }
  let listener;
  try {
    return await Promise.race([
      promise,
      new Promise((resolve, reject) => {
        listener = () => {
          reject(translateError(signal));
        };
        signal.addEventListener("abort", listener);
      })
    ]);
  } finally {
    if (listener != null) {
      signal.removeEventListener("abort", listener);
    }
  }
}

// ../../node_modules/it-queueless-pushable/dist/src/index.js
var QueuelessPushable = class {
  constructor() {
    __publicField(this, "readNext");
    __publicField(this, "haveNext");
    __publicField(this, "ended");
    __publicField(this, "nextResult");
    __publicField(this, "error");
    this.ended = false;
    this.readNext = pDefer();
    this.haveNext = pDefer();
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async next() {
    if (this.nextResult == null) {
      await this.haveNext.promise;
    }
    if (this.nextResult == null) {
      throw new Error("HaveNext promise resolved but nextResult was undefined");
    }
    const nextResult = this.nextResult;
    this.nextResult = void 0;
    this.readNext.resolve();
    this.readNext = pDefer();
    return nextResult;
  }
  async throw(err) {
    this.ended = true;
    this.error = err;
    if (err != null) {
      this.haveNext.promise.catch(() => {
      });
      this.haveNext.reject(err);
    }
    const result = {
      done: true,
      value: void 0
    };
    return result;
  }
  async return() {
    const result = {
      done: true,
      value: void 0
    };
    this.ended = true;
    this.nextResult = result;
    this.haveNext.resolve();
    return result;
  }
  async push(value2, options2) {
    await this._push(value2, options2);
  }
  async end(err, options2) {
    if (err != null) {
      await this.throw(err);
    } else {
      await this._push(void 0, options2);
    }
  }
  async _push(value2, options2) {
    if (value2 != null && this.ended) {
      throw this.error ?? new Error("Cannot push value onto an ended pushable");
    }
    while (this.nextResult != null) {
      await this.readNext.promise;
    }
    if (value2 != null) {
      this.nextResult = { done: false, value: value2 };
    } else {
      this.ended = true;
      this.nextResult = { done: true, value: void 0 };
    }
    this.haveNext.resolve();
    this.haveNext = pDefer();
    await raceSignal(this.readNext.promise, options2?.signal, options2);
  }
};
function queuelessPushable() {
  return new QueuelessPushable();
}

// ../../node_modules/it-merge/dist/src/index.js
function isAsyncIterable2(thing) {
  return thing[Symbol.asyncIterator] != null;
}
async function addAllToPushable(sources, output, signal) {
  try {
    await Promise.all(sources.map(async (source) => {
      for await (const item of source) {
        await output.push(item, {
          signal
        });
        signal.throwIfAborted();
      }
    }));
    await output.end(void 0, {
      signal
    });
  } catch (err) {
    await output.end(err, {
      signal
    }).catch(() => {
    });
  }
}
async function* mergeSources(sources) {
  const controller = new AbortController();
  const output = queuelessPushable();
  addAllToPushable(sources, output, controller.signal).catch(() => {
  });
  try {
    yield* output;
  } finally {
    controller.abort();
  }
}
function* mergeSyncSources(syncSources) {
  for (const source of syncSources) {
    yield* source;
  }
}
function merge(...sources) {
  const syncSources = [];
  for (const source of sources) {
    if (!isAsyncIterable2(source)) {
      syncSources.push(source);
    }
  }
  if (syncSources.length === sources.length) {
    return mergeSyncSources(syncSources);
  }
  return mergeSources(sources);
}
var src_default = merge;

// ../../node_modules/it-pipe/dist/src/index.js
function pipe(first, ...rest) {
  if (first == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex(first)) {
    const duplex = first;
    first = () => duplex.source;
  } else if (isIterable(first) || isAsyncIterable3(first)) {
    const source = first;
    first = () => source;
  }
  const fns = [first, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i2 = 1; i2 < fns.length - 1; i2++) {
      if (isDuplex(fns[i2])) {
        fns[i2] = duplexPipelineFn(fns[i2]);
      }
    }
  }
  return rawPipe(...fns);
}
var rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
var isAsyncIterable3 = (obj) => {
  return obj?.[Symbol.asyncIterator] != null;
};
var isIterable = (obj) => {
  return obj?.[Symbol.iterator] != null;
};
var isDuplex = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
var duplexPipelineFn = (duplex) => {
  return (source) => {
    const p2 = duplex.sink(source);
    if (p2?.then != null) {
      const stream = pushable({
        objectMode: true
      });
      p2.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable3(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return src_default(stream, sourceWrap());
    }
    return duplex.source;
  };
};

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/constants.js
var second = 1e3;
var minute = 60 * second;
var FloodsubID = "/floodsub/1.0.0";
var GossipsubIDv10 = "/meshsub/1.0.0";
var GossipsubIDv11 = "/meshsub/1.1.0";
var GossipsubIDv12 = "/meshsub/1.2.0";
var GossipsubD = 6;
var GossipsubDlo = 4;
var GossipsubDhi = 12;
var GossipsubDscore = 4;
var GossipsubDout = 2;
var GossipsubHistoryLength = 5;
var GossipsubHistoryGossip = 3;
var GossipsubDlazy = 6;
var GossipsubGossipFactor = 0.25;
var GossipsubGossipRetransmission = 3;
var GossipsubHeartbeatInitialDelay = 100;
var GossipsubHeartbeatInterval = second;
var GossipsubFanoutTTL = minute;
var GossipsubPrunePeers = 16;
var GossipsubPruneBackoff = minute;
var GossipsubUnsubscribeBackoff = 10 * second;
var GossipsubPruneBackoffTicks = 15;
var GossipsubConnectors = 8;
var GossipsubMaxPendingConnections = 128;
var GossipsubConnectionTimeout = 30 * second;
var GossipsubDirectConnectTicks = 300;
var GossipsubDirectConnectInitialDelay = second;
var GossipsubOpportunisticGraftTicks = 60;
var GossipsubOpportunisticGraftPeers = 2;
var GossipsubGraftFloodThreshold = 10 * second;
var GossipsubMaxIHaveLength = 5e3;
var GossipsubMaxIHaveMessages = 10;
var GossipsubIWantFollowupTime = 3 * second;
var GossipsubSeenTTL = 2 * minute;
var TimeCacheDuration = 120 * 1e3;
var ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
var ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
var ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0;
var ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128;
var ACCEPT_FROM_WHITELIST_DURATION_MS = 1e3;
var DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1e3;
var BACKOFF_SLACK = 1;
var GossipsubIdontwantMinDataSize = 512;
var GossipsubIdontwantMaxMessages = 512;

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/decodeRpc.js
var defaultDecodeRpcLimits = {
  maxSubscriptions: Infinity,
  maxMessages: Infinity,
  maxIhaveMessageIDs: Infinity,
  maxIwantMessageIDs: Infinity,
  maxIdontwantMessageIDs: Infinity,
  maxControlMessages: Infinity,
  maxPeerInfos: Infinity
};

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.js
var RPC;
(function(RPC4) {
  let SubOpts;
  (function(SubOpts2) {
    let _codec2;
    SubOpts2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.subscribe != null) {
            w.uint32(8);
            w.bool(obj.subscribe);
          }
          if (obj.topic != null) {
            w.uint32(18);
            w.string(obj.topic);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.subscribe = reader.bool();
                break;
              }
              case 2: {
                obj.topic = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    SubOpts2.encode = (obj) => {
      return encodeMessage(obj, SubOpts2.codec());
    };
    SubOpts2.decode = (buf2, opts) => {
      return decodeMessage(buf2, SubOpts2.codec(), opts);
    };
  })(SubOpts = RPC4.SubOpts || (RPC4.SubOpts = {}));
  let Message4;
  (function(Message5) {
    let _codec2;
    Message5.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.from != null) {
            w.uint32(10);
            w.bytes(obj.from);
          }
          if (obj.data != null) {
            w.uint32(18);
            w.bytes(obj.data);
          }
          if (obj.seqno != null) {
            w.uint32(26);
            w.bytes(obj.seqno);
          }
          if (obj.topic != null && obj.topic !== "") {
            w.uint32(34);
            w.string(obj.topic);
          }
          if (obj.signature != null) {
            w.uint32(42);
            w.bytes(obj.signature);
          }
          if (obj.key != null) {
            w.uint32(50);
            w.bytes(obj.key);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            topic: ""
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.from = reader.bytes();
                break;
              }
              case 2: {
                obj.data = reader.bytes();
                break;
              }
              case 3: {
                obj.seqno = reader.bytes();
                break;
              }
              case 4: {
                obj.topic = reader.string();
                break;
              }
              case 5: {
                obj.signature = reader.bytes();
                break;
              }
              case 6: {
                obj.key = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Message5.encode = (obj) => {
      return encodeMessage(obj, Message5.codec());
    };
    Message5.decode = (buf2, opts) => {
      return decodeMessage(buf2, Message5.codec(), opts);
    };
  })(Message4 = RPC4.Message || (RPC4.Message = {}));
  let ControlMessage2;
  (function(ControlMessage3) {
    let _codec2;
    ControlMessage3.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.ihave != null) {
            for (const value2 of obj.ihave) {
              w.uint32(10);
              RPC4.ControlIHave.codec().encode(value2, w);
            }
          }
          if (obj.iwant != null) {
            for (const value2 of obj.iwant) {
              w.uint32(18);
              RPC4.ControlIWant.codec().encode(value2, w);
            }
          }
          if (obj.graft != null) {
            for (const value2 of obj.graft) {
              w.uint32(26);
              RPC4.ControlGraft.codec().encode(value2, w);
            }
          }
          if (obj.prune != null) {
            for (const value2 of obj.prune) {
              w.uint32(34);
              RPC4.ControlPrune.codec().encode(value2, w);
            }
          }
          if (obj.idontwant != null) {
            for (const value2 of obj.idontwant) {
              w.uint32(42);
              RPC4.ControlIDontWant.codec().encode(value2, w);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            ihave: [],
            iwant: [],
            graft: [],
            prune: [],
            idontwant: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.ihave != null && obj.ihave.length === opts.limits.ihave) {
                  throw new MaxLengthError('Decode error - map field "ihave" had too many elements');
                }
                obj.ihave.push(RPC4.ControlIHave.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.ihave$
                }));
                break;
              }
              case 2: {
                if (opts.limits?.iwant != null && obj.iwant.length === opts.limits.iwant) {
                  throw new MaxLengthError('Decode error - map field "iwant" had too many elements');
                }
                obj.iwant.push(RPC4.ControlIWant.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.iwant$
                }));
                break;
              }
              case 3: {
                if (opts.limits?.graft != null && obj.graft.length === opts.limits.graft) {
                  throw new MaxLengthError('Decode error - map field "graft" had too many elements');
                }
                obj.graft.push(RPC4.ControlGraft.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.graft$
                }));
                break;
              }
              case 4: {
                if (opts.limits?.prune != null && obj.prune.length === opts.limits.prune) {
                  throw new MaxLengthError('Decode error - map field "prune" had too many elements');
                }
                obj.prune.push(RPC4.ControlPrune.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.prune$
                }));
                break;
              }
              case 5: {
                if (opts.limits?.idontwant != null && obj.idontwant.length === opts.limits.idontwant) {
                  throw new MaxLengthError('Decode error - map field "idontwant" had too many elements');
                }
                obj.idontwant.push(RPC4.ControlIDontWant.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.idontwant$
                }));
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlMessage3.encode = (obj) => {
      return encodeMessage(obj, ControlMessage3.codec());
    };
    ControlMessage3.decode = (buf2, opts) => {
      return decodeMessage(buf2, ControlMessage3.codec(), opts);
    };
  })(ControlMessage2 = RPC4.ControlMessage || (RPC4.ControlMessage = {}));
  let ControlIHave2;
  (function(ControlIHave3) {
    let _codec2;
    ControlIHave3.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.topicID != null) {
            w.uint32(10);
            w.string(obj.topicID);
          }
          if (obj.messageIDs != null) {
            for (const value2 of obj.messageIDs) {
              w.uint32(18);
              w.bytes(value2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            messageIDs: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.topicID = reader.string();
                break;
              }
              case 2: {
                if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {
                  throw new MaxLengthError('Decode error - map field "messageIDs" had too many elements');
                }
                obj.messageIDs.push(reader.bytes());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlIHave3.encode = (obj) => {
      return encodeMessage(obj, ControlIHave3.codec());
    };
    ControlIHave3.decode = (buf2, opts) => {
      return decodeMessage(buf2, ControlIHave3.codec(), opts);
    };
  })(ControlIHave2 = RPC4.ControlIHave || (RPC4.ControlIHave = {}));
  let ControlIWant2;
  (function(ControlIWant3) {
    let _codec2;
    ControlIWant3.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.messageIDs != null) {
            for (const value2 of obj.messageIDs) {
              w.uint32(10);
              w.bytes(value2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            messageIDs: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {
                  throw new MaxLengthError('Decode error - map field "messageIDs" had too many elements');
                }
                obj.messageIDs.push(reader.bytes());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlIWant3.encode = (obj) => {
      return encodeMessage(obj, ControlIWant3.codec());
    };
    ControlIWant3.decode = (buf2, opts) => {
      return decodeMessage(buf2, ControlIWant3.codec(), opts);
    };
  })(ControlIWant2 = RPC4.ControlIWant || (RPC4.ControlIWant = {}));
  let ControlGraft2;
  (function(ControlGraft3) {
    let _codec2;
    ControlGraft3.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.topicID != null) {
            w.uint32(10);
            w.string(obj.topicID);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.topicID = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlGraft3.encode = (obj) => {
      return encodeMessage(obj, ControlGraft3.codec());
    };
    ControlGraft3.decode = (buf2, opts) => {
      return decodeMessage(buf2, ControlGraft3.codec(), opts);
    };
  })(ControlGraft2 = RPC4.ControlGraft || (RPC4.ControlGraft = {}));
  let ControlPrune2;
  (function(ControlPrune3) {
    let _codec2;
    ControlPrune3.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.topicID != null) {
            w.uint32(10);
            w.string(obj.topicID);
          }
          if (obj.peers != null) {
            for (const value2 of obj.peers) {
              w.uint32(18);
              RPC4.PeerInfo.codec().encode(value2, w);
            }
          }
          if (obj.backoff != null) {
            w.uint32(24);
            w.uint64Number(obj.backoff);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            peers: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.topicID = reader.string();
                break;
              }
              case 2: {
                if (opts.limits?.peers != null && obj.peers.length === opts.limits.peers) {
                  throw new MaxLengthError('Decode error - map field "peers" had too many elements');
                }
                obj.peers.push(RPC4.PeerInfo.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.peers$
                }));
                break;
              }
              case 3: {
                obj.backoff = reader.uint64Number();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlPrune3.encode = (obj) => {
      return encodeMessage(obj, ControlPrune3.codec());
    };
    ControlPrune3.decode = (buf2, opts) => {
      return decodeMessage(buf2, ControlPrune3.codec(), opts);
    };
  })(ControlPrune2 = RPC4.ControlPrune || (RPC4.ControlPrune = {}));
  let PeerInfo3;
  (function(PeerInfo4) {
    let _codec2;
    PeerInfo4.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.peerID != null) {
            w.uint32(10);
            w.bytes(obj.peerID);
          }
          if (obj.signedPeerRecord != null) {
            w.uint32(18);
            w.bytes(obj.signedPeerRecord);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.peerID = reader.bytes();
                break;
              }
              case 2: {
                obj.signedPeerRecord = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    PeerInfo4.encode = (obj) => {
      return encodeMessage(obj, PeerInfo4.codec());
    };
    PeerInfo4.decode = (buf2, opts) => {
      return decodeMessage(buf2, PeerInfo4.codec(), opts);
    };
  })(PeerInfo3 = RPC4.PeerInfo || (RPC4.PeerInfo = {}));
  let ControlIDontWant;
  (function(ControlIDontWant2) {
    let _codec2;
    ControlIDontWant2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.messageIDs != null) {
            for (const value2 of obj.messageIDs) {
              w.uint32(10);
              w.bytes(value2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            messageIDs: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {
                  throw new MaxLengthError('Decode error - map field "messageIDs" had too many elements');
                }
                obj.messageIDs.push(reader.bytes());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    ControlIDontWant2.encode = (obj) => {
      return encodeMessage(obj, ControlIDontWant2.codec());
    };
    ControlIDontWant2.decode = (buf2, opts) => {
      return decodeMessage(buf2, ControlIDontWant2.codec(), opts);
    };
  })(ControlIDontWant = RPC4.ControlIDontWant || (RPC4.ControlIDontWant = {}));
  let _codec;
  RPC4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.subscriptions != null) {
          for (const value2 of obj.subscriptions) {
            w.uint32(10);
            RPC4.SubOpts.codec().encode(value2, w);
          }
        }
        if (obj.messages != null) {
          for (const value2 of obj.messages) {
            w.uint32(18);
            RPC4.Message.codec().encode(value2, w);
          }
        }
        if (obj.control != null) {
          w.uint32(26);
          RPC4.ControlMessage.codec().encode(obj.control, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          subscriptions: [],
          messages: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.subscriptions != null && obj.subscriptions.length === opts.limits.subscriptions) {
                throw new MaxLengthError('Decode error - map field "subscriptions" had too many elements');
              }
              obj.subscriptions.push(RPC4.SubOpts.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.subscriptions$
              }));
              break;
            }
            case 2: {
              if (opts.limits?.messages != null && obj.messages.length === opts.limits.messages) {
                throw new MaxLengthError('Decode error - map field "messages" had too many elements');
              }
              obj.messages.push(RPC4.Message.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.messages$
              }));
              break;
            }
            case 3: {
              obj.control = RPC4.ControlMessage.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.control
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RPC4.encode = (obj) => {
    return encodeMessage(obj, RPC4.codec());
  };
  RPC4.decode = (buf2, opts) => {
    return decodeMessage(buf2, RPC4.codec(), opts);
  };
})(RPC || (RPC = {}));

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/message-cache.js
var MessageCache = class {
  /**
   * Holds history of messages in timebounded history arrays
   */
  constructor(gossip, historyCapacity, msgIdToStrFn) {
    __publicField(this, "gossip");
    __publicField(this, "msgs", /* @__PURE__ */ new Map());
    __publicField(this, "msgIdToStrFn");
    __publicField(this, "history", []);
    /** Track with accounting of messages in the mcache that are not yet validated */
    __publicField(this, "notValidatedCount", 0);
    this.gossip = gossip;
    this.msgIdToStrFn = msgIdToStrFn;
    for (let i2 = 0; i2 < historyCapacity; i2++) {
      this.history[i2] = [];
    }
  }
  get size() {
    return this.msgs.size;
  }
  /**
   * Adds a message to the current window and the cache
   * Returns true if the message is not known and is inserted in the cache
   */
  put(messageId, msg, validated = false) {
    const { msgIdStr } = messageId;
    if (this.msgs.has(msgIdStr)) {
      return false;
    }
    this.msgs.set(msgIdStr, {
      message: msg,
      validated,
      originatingPeers: /* @__PURE__ */ new Set(),
      iwantCounts: /* @__PURE__ */ new Map()
    });
    this.history[0].push({ ...messageId, topic: msg.topic });
    if (!validated) {
      this.notValidatedCount++;
    }
    return true;
  }
  observeDuplicate(msgId3, fromPeerIdStr) {
    const entry = this.msgs.get(msgId3);
    if (entry != null && // if the message is already validated, we don't need to store extra peers sending us
    // duplicates as the message has already been forwarded
    !entry.validated) {
      entry.originatingPeers.add(fromPeerIdStr);
    }
  }
  /**
   * Retrieves a message from the cache by its ID, if it is still present
   */
  get(msgId3) {
    return this.msgs.get(this.msgIdToStrFn(msgId3))?.message;
  }
  /**
   * Increases the iwant count for the given message by one and returns the message together
   * with the iwant if the message exists.
   */
  getWithIWantCount(msgIdStr, p2) {
    const msg = this.msgs.get(msgIdStr);
    if (msg == null) {
      return null;
    }
    const count = (msg.iwantCounts.get(p2) ?? 0) + 1;
    msg.iwantCounts.set(p2, count);
    return { msg: msg.message, count };
  }
  /**
   * Retrieves a list of message IDs for a set of topics
   */
  getGossipIDs(topics) {
    const msgIdsByTopic = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < this.gossip; i2++) {
      this.history[i2].forEach((entry) => {
        const msg = this.msgs.get(entry.msgIdStr);
        if ((msg?.validated ?? false) && topics.has(entry.topic)) {
          let msgIds = msgIdsByTopic.get(entry.topic);
          if (msgIds == null) {
            msgIds = [];
            msgIdsByTopic.set(entry.topic, msgIds);
          }
          msgIds.push(entry.msgId);
        }
      });
    }
    return msgIdsByTopic;
  }
  /**
   * Gets a message with msgId and tags it as validated.
   * This function also returns the known peers that have sent us this message. This is used to
   * prevent us sending redundant messages to peers who have already propagated it.
   */
  validate(msgId3) {
    const entry = this.msgs.get(msgId3);
    if (entry == null) {
      return null;
    }
    if (!entry.validated) {
      this.notValidatedCount--;
    }
    const { message: message2, originatingPeers } = entry;
    entry.validated = true;
    entry.originatingPeers = /* @__PURE__ */ new Set();
    return { message: message2, originatingPeers };
  }
  /**
   * Shifts the current window, discarding messages older than this.history.length of the cache
   */
  shift() {
    const lastCacheEntries = this.history[this.history.length - 1];
    lastCacheEntries.forEach((cacheEntry) => {
      const entry = this.msgs.get(cacheEntry.msgIdStr);
      if (entry != null) {
        this.msgs.delete(cacheEntry.msgIdStr);
        if (!entry.validated) {
          this.notValidatedCount--;
        }
      }
    });
    this.history.pop();
    this.history.unshift([]);
  }
  remove(msgId3) {
    const entry = this.msgs.get(msgId3);
    if (entry == null) {
      return null;
    }
    this.msgs.delete(msgId3);
    return entry;
  }
};

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/types.js
var SignaturePolicy;
(function(SignaturePolicy2) {
  SignaturePolicy2["StrictSign"] = "StrictSign";
  SignaturePolicy2["StrictNoSign"] = "StrictNoSign";
})(SignaturePolicy || (SignaturePolicy = {}));
var PublishConfigType;
(function(PublishConfigType2) {
  PublishConfigType2[PublishConfigType2["Signing"] = 0] = "Signing";
  PublishConfigType2[PublishConfigType2["Anonymous"] = 1] = "Anonymous";
})(PublishConfigType || (PublishConfigType = {}));
var RejectReason;
(function(RejectReason2) {
  RejectReason2["Error"] = "error";
  RejectReason2["Ignore"] = "ignore";
  RejectReason2["Reject"] = "reject";
  RejectReason2["Blacklisted"] = "blacklisted";
})(RejectReason || (RejectReason = {}));
var ValidateError;
(function(ValidateError2) {
  ValidateError2["InvalidSignature"] = "invalid_signature";
  ValidateError2["InvalidSeqno"] = "invalid_seqno";
  ValidateError2["InvalidPeerId"] = "invalid_peerid";
  ValidateError2["SignaturePresent"] = "signature_present";
  ValidateError2["SeqnoPresent"] = "seqno_present";
  ValidateError2["FromPresent"] = "from_present";
  ValidateError2["TransformFailed"] = "transform_failed";
})(ValidateError || (ValidateError = {}));
var MessageStatus;
(function(MessageStatus2) {
  MessageStatus2["duplicate"] = "duplicate";
  MessageStatus2["invalid"] = "invalid";
  MessageStatus2["valid"] = "valid";
})(MessageStatus || (MessageStatus = {}));
function rejectReasonFromAcceptance(acceptance) {
  switch (acceptance) {
    case TopicValidatorResult.Ignore:
      return RejectReason.Ignore;
    case TopicValidatorResult.Reject:
      return RejectReason.Reject;
    default:
      throw new Error("Unreachable");
  }
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/metrics.js
var MessageSource;
(function(MessageSource2) {
  MessageSource2["forward"] = "forward";
  MessageSource2["publish"] = "publish";
})(MessageSource || (MessageSource = {}));
var InclusionReason;
(function(InclusionReason2) {
  InclusionReason2["Fanout"] = "fanout";
  InclusionReason2["Random"] = "random";
  InclusionReason2["Subscribed"] = "subscribed";
  InclusionReason2["Outbound"] = "outbound";
  InclusionReason2["NotEnough"] = "not_enough";
  InclusionReason2["Opportunistic"] = "opportunistic";
})(InclusionReason || (InclusionReason = {}));
var ChurnReason;
(function(ChurnReason2) {
  ChurnReason2["Dc"] = "disconnected";
  ChurnReason2["BadScore"] = "bad_score";
  ChurnReason2["Prune"] = "prune";
  ChurnReason2["Excess"] = "excess";
})(ChurnReason || (ChurnReason = {}));
var ScorePenalty;
(function(ScorePenalty2) {
  ScorePenalty2["GraftBackoff"] = "graft_backoff";
  ScorePenalty2["BrokenPromise"] = "broken_promise";
  ScorePenalty2["MessageDeficit"] = "message_deficit";
  ScorePenalty2["IPColocation"] = "IP_colocation";
})(ScorePenalty || (ScorePenalty = {}));
var IHaveIgnoreReason;
(function(IHaveIgnoreReason2) {
  IHaveIgnoreReason2["LowScore"] = "low_score";
  IHaveIgnoreReason2["MaxIhave"] = "max_ihave";
  IHaveIgnoreReason2["MaxIasked"] = "max_iasked";
})(IHaveIgnoreReason || (IHaveIgnoreReason = {}));
var ScoreThreshold;
(function(ScoreThreshold2) {
  ScoreThreshold2["graylist"] = "graylist";
  ScoreThreshold2["publish"] = "publish";
  ScoreThreshold2["gossip"] = "gossip";
  ScoreThreshold2["mesh"] = "mesh";
})(ScoreThreshold || (ScoreThreshold = {}));
function getMetrics(register, topicStrToLabel, opts) {
  return {
    /* Metrics for static config */
    protocolsEnabled: register.gauge({
      name: "gossipsub_protocol",
      help: "Status of enabled protocols",
      labelNames: ["protocol"]
    }),
    /* Metrics per known topic */
    /**
     * Status of our subscription to this topic. This metric allows analyzing other topic metrics
     * filtered by our current subscription status.
     * = rust-libp2p `topic_subscription_status` */
    topicSubscriptionStatus: register.gauge({
      name: "gossipsub_topic_subscription_status",
      help: "Status of our subscription to this topic",
      labelNames: ["topicStr"]
    }),
    /** Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour
     * regardless of our subscription status. */
    topicPeersCount: register.gauge({
      name: "gossipsub_topic_peer_count",
      help: "Number of peers subscribed to each topic",
      labelNames: ["topicStr"]
    }),
    /* Metrics regarding mesh state */
    /**
     * Number of peers in our mesh. This metric should be updated with the count of peers for a
     * topic in the mesh regardless of inclusion and churn events.
     * = rust-libp2p `mesh_peer_counts` */
    meshPeerCounts: register.gauge({
      name: "gossipsub_mesh_peer_count",
      help: "Number of peers in our mesh",
      labelNames: ["topicStr"]
    }),
    /**
     * Number of times we include peers in a topic mesh for different reasons.
     * = rust-libp2p `mesh_peer_inclusion_events` */
    meshPeerInclusionEventsFanout: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_fanout_total",
      help: "Number of times we include peers in a topic mesh for fanout reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsRandom: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_random_total",
      help: "Number of times we include peers in a topic mesh for random reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsSubscribed: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_subscribed_total",
      help: "Number of times we include peers in a topic mesh for subscribed reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsOutbound: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_outbound_total",
      help: "Number of times we include peers in a topic mesh for outbound reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsNotEnough: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_not_enough_total",
      help: "Number of times we include peers in a topic mesh for not_enough reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsOpportunistic: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_opportunistic_total",
      help: "Number of times we include peers in a topic mesh for opportunistic reasons",
      labelNames: ["topic"]
    }),
    meshPeerInclusionEventsUnknown: register.gauge({
      name: "gossipsub_mesh_peer_inclusion_events_unknown_total",
      help: "Number of times we include peers in a topic mesh for unknown reasons",
      labelNames: ["topic"]
    }),
    /**
     * Number of times we remove peers in a topic mesh for different reasons.
     * = rust-libp2p `mesh_peer_churn_events` */
    meshPeerChurnEventsDisconnected: register.gauge({
      name: "gossipsub_peer_churn_events_disconnected_total",
      help: "Number of times we remove peers in a topic mesh for disconnected reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsBadScore: register.gauge({
      name: "gossipsub_peer_churn_events_bad_score_total",
      help: "Number of times we remove peers in a topic mesh for bad_score reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsPrune: register.gauge({
      name: "gossipsub_peer_churn_events_prune_total",
      help: "Number of times we remove peers in a topic mesh for prune reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsExcess: register.gauge({
      name: "gossipsub_peer_churn_events_excess_total",
      help: "Number of times we remove peers in a topic mesh for excess reasons",
      labelNames: ["topic"]
    }),
    meshPeerChurnEventsUnknown: register.gauge({
      name: "gossipsub_peer_churn_events_unknown_total",
      help: "Number of times we remove peers in a topic mesh for unknown reasons",
      labelNames: ["topic"]
    }),
    /* General Metrics */
    /**
     * Gossipsub supports floodsub, gossipsub v1.0, v1.1, and v1.2. Peers are classified based
     * on which protocol they support. This metric keeps track of the number of peers that are
     * connected of each type. */
    peersPerProtocol: register.gauge({
      name: "gossipsub_peers_per_protocol_count",
      help: "Peers connected for each topic",
      labelNames: ["protocol"]
    }),
    /** The time it takes to complete one iteration of the heartbeat. */
    heartbeatDuration: register.histogram({
      name: "gossipsub_heartbeat_duration_seconds",
      help: "The time it takes to complete one iteration of the heartbeat",
      // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled
      buckets: [0.01, 0.1, 1]
    }),
    /** Heartbeat run took longer than heartbeat interval so next is skipped */
    heartbeatSkipped: register.gauge({
      name: "gossipsub_heartbeat_skipped",
      help: "Heartbeat run took longer than heartbeat interval so next is skipped"
    }),
    /**
     * Message validation results for each topic.
     * Invalid == Reject?
     * = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages` */
    acceptedMessagesTotal: register.gauge({
      name: "gossipsub_accepted_messages_total",
      help: "Total accepted messages for each topic",
      labelNames: ["topic"]
    }),
    ignoredMessagesTotal: register.gauge({
      name: "gossipsub_ignored_messages_total",
      help: "Total ignored messages for each topic",
      labelNames: ["topic"]
    }),
    rejectedMessagesTotal: register.gauge({
      name: "gossipsub_rejected_messages_total",
      help: "Total rejected messages for each topic",
      labelNames: ["topic"]
    }),
    unknownValidationResultsTotal: register.gauge({
      name: "gossipsub_unknown_validation_results_total",
      help: "Total unknown validation results for each topic",
      labelNames: ["topic"]
    }),
    /**
     * When the user validates a message, it tries to re propagate it to its mesh peers. If the
     * message expires from the memcache before it can be validated, we count this a cache miss
     * and it is an indicator that the memcache size should be increased.
     * = rust-libp2p `mcache_misses` */
    asyncValidationMcacheHit: register.gauge({
      name: "gossipsub_async_validation_mcache_hit_total",
      help: "Async validation result reported by the user layer",
      labelNames: ["hit"]
    }),
    asyncValidationDelayFromFirstSeenSec: register.histogram({
      name: "gossipsub_async_validation_delay_from_first_seen",
      help: "Async validation report delay from first seen in second",
      buckets: [0.01, 0.03, 0.1, 0.3, 1, 3, 10]
    }),
    asyncValidationUnknownFirstSeen: register.gauge({
      name: "gossipsub_async_validation_unknown_first_seen_count_total",
      help: "Async validation report unknown first seen value for message"
    }),
    // peer stream
    peerReadStreamError: register.gauge({
      name: "gossipsub_peer_read_stream_err_count_total",
      help: "Peer read stream error"
    }),
    // RPC outgoing. Track byte length + data structure sizes
    rpcRecvBytes: register.gauge({ name: "gossipsub_rpc_recv_bytes_total", help: "RPC recv" }),
    rpcRecvCount: register.gauge({ name: "gossipsub_rpc_recv_count_total", help: "RPC recv" }),
    rpcRecvSubscription: register.gauge({ name: "gossipsub_rpc_recv_subscription_total", help: "RPC recv" }),
    rpcRecvMessage: register.gauge({ name: "gossipsub_rpc_recv_message_total", help: "RPC recv" }),
    rpcRecvControl: register.gauge({ name: "gossipsub_rpc_recv_control_total", help: "RPC recv" }),
    rpcRecvIHave: register.gauge({ name: "gossipsub_rpc_recv_ihave_total", help: "RPC recv" }),
    rpcRecvIWant: register.gauge({ name: "gossipsub_rpc_recv_iwant_total", help: "RPC recv" }),
    rpcRecvGraft: register.gauge({ name: "gossipsub_rpc_recv_graft_total", help: "RPC recv" }),
    rpcRecvPrune: register.gauge({ name: "gossipsub_rpc_recv_prune_total", help: "RPC recv" }),
    rpcDataError: register.gauge({ name: "gossipsub_rpc_data_err_count_total", help: "RPC data error" }),
    rpcRecvError: register.gauge({ name: "gossipsub_rpc_recv_err_count_total", help: "RPC recv error" }),
    /** Total count of RPC dropped because acceptFrom() == false */
    rpcRecvNotAccepted: register.gauge({
      name: "gossipsub_rpc_rcv_not_accepted_total",
      help: "Total count of RPC dropped because acceptFrom() == false"
    }),
    // RPC incoming. Track byte length + data structure sizes
    rpcSentBytes: register.gauge({ name: "gossipsub_rpc_sent_bytes_total", help: "RPC sent" }),
    rpcSentCount: register.gauge({ name: "gossipsub_rpc_sent_count_total", help: "RPC sent" }),
    rpcSentSubscription: register.gauge({ name: "gossipsub_rpc_sent_subscription_total", help: "RPC sent" }),
    rpcSentMessage: register.gauge({ name: "gossipsub_rpc_sent_message_total", help: "RPC sent" }),
    rpcSentControl: register.gauge({ name: "gossipsub_rpc_sent_control_total", help: "RPC sent" }),
    rpcSentIHave: register.gauge({ name: "gossipsub_rpc_sent_ihave_total", help: "RPC sent" }),
    rpcSentIWant: register.gauge({ name: "gossipsub_rpc_sent_iwant_total", help: "RPC sent" }),
    rpcSentGraft: register.gauge({ name: "gossipsub_rpc_sent_graft_total", help: "RPC sent" }),
    rpcSentPrune: register.gauge({ name: "gossipsub_rpc_sent_prune_total", help: "RPC sent" }),
    rpcSentIDontWant: register.gauge({ name: "gossipsub_rpc_sent_idontwant_total", help: "RPC sent" }),
    // publish message. Track peers sent to and bytes
    /** Total count of msg published by topic */
    msgPublishCount: register.gauge({
      name: "gossipsub_msg_publish_count_total",
      help: "Total count of msg published by topic",
      labelNames: ["topic"]
    }),
    /** Total count of peers that we publish a msg to */
    msgPublishPeersByTopic: register.gauge({
      name: "gossipsub_msg_publish_peers_total",
      help: "Total count of peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of peers (by group) that we publish a msg to */
    directPeersPublishedTotal: register.gauge({
      name: "gossipsub_direct_peers_published_total",
      help: "Total direct peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    floodsubPeersPublishedTotal: register.gauge({
      name: "gossipsub_floodsub_peers_published_total",
      help: "Total floodsub peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    meshPeersPublishedTotal: register.gauge({
      name: "gossipsub_mesh_peers_published_total",
      help: "Total mesh peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    fanoutPeersPublishedTotal: register.gauge({
      name: "gossipsub_fanout_peers_published_total",
      help: "Total fanout peers that we publish a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of msg publish data.length bytes */
    msgPublishBytes: register.gauge({
      name: "gossipsub_msg_publish_bytes_total",
      help: "Total count of msg publish data.length bytes",
      labelNames: ["topic"]
    }),
    /** Total time in seconds to publish a message */
    msgPublishTime: register.histogram({
      name: "gossipsub_msg_publish_seconds",
      help: "Total time in seconds to publish a message",
      buckets: [1e-3, 2e-3, 5e-3, 0.01, 0.1, 0.5, 1],
      labelNames: ["topic"]
    }),
    /** Total count of msg forwarded by topic */
    msgForwardCount: register.gauge({
      name: "gossipsub_msg_forward_count_total",
      help: "Total count of msg forwarded by topic",
      labelNames: ["topic"]
    }),
    /** Total count of peers that we forward a msg to */
    msgForwardPeers: register.gauge({
      name: "gossipsub_msg_forward_peers_total",
      help: "Total count of peers that we forward a msg to",
      labelNames: ["topic"]
    }),
    /** Total count of recv msgs before any validation */
    msgReceivedPreValidation: register.gauge({
      name: "gossipsub_msg_received_prevalidation_total",
      help: "Total count of recv msgs before any validation",
      labelNames: ["topic"]
    }),
    /** Total count of recv msgs error */
    msgReceivedError: register.gauge({
      name: "gossipsub_msg_received_error_total",
      help: "Total count of recv msgs error",
      labelNames: ["topic"]
    }),
    /** Tracks distribution of recv msgs by duplicate, invalid, valid */
    prevalidationInvalidTotal: register.gauge({
      name: "gossipsub_pre_validation_invalid_total",
      help: "Total count of invalid messages received",
      labelNames: ["topic"]
    }),
    prevalidationValidTotal: register.gauge({
      name: "gossipsub_pre_validation_valid_total",
      help: "Total count of valid messages received",
      labelNames: ["topic"]
    }),
    prevalidationDuplicateTotal: register.gauge({
      name: "gossipsub_pre_validation_duplicate_total",
      help: "Total count of duplicate messages received",
      labelNames: ["topic"]
    }),
    prevalidationUnknownTotal: register.gauge({
      name: "gossipsub_pre_validation_unknown_status_total",
      help: "Total count of unknown_status messages received",
      labelNames: ["topic"]
    }),
    /** Tracks specific reason of invalid */
    msgReceivedInvalid: register.gauge({
      name: "gossipsub_msg_received_invalid_total",
      help: "Tracks specific reason of invalid",
      labelNames: ["error"]
    }),
    msgReceivedInvalidByTopic: register.gauge({
      name: "gossipsub_msg_received_invalid_by_topic_total",
      help: "Tracks specific invalid message by topic",
      labelNames: ["topic"]
    }),
    /** Track duplicate message delivery time */
    duplicateMsgDeliveryDelay: register.histogram({
      name: "gossisub_duplicate_msg_delivery_delay_seconds",
      help: "Time since the 1st duplicated message validated",
      labelNames: ["topic"],
      buckets: [
        0.25 * opts.maxMeshMessageDeliveriesWindowSec,
        0.5 * opts.maxMeshMessageDeliveriesWindowSec,
        Number(opts.maxMeshMessageDeliveriesWindowSec),
        2 * opts.maxMeshMessageDeliveriesWindowSec,
        4 * opts.maxMeshMessageDeliveriesWindowSec
      ]
    }),
    /** Total count of late msg delivery total by topic */
    duplicateMsgLateDelivery: register.gauge({
      name: "gossisub_duplicate_msg_late_delivery_total",
      help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty",
      labelNames: ["topic"]
    }),
    duplicateMsgIgnored: register.gauge({
      name: "gossisub_ignored_published_duplicate_msgs_total",
      help: "Total count of published duplicate message ignored by topic",
      labelNames: ["topic"]
    }),
    /* Metrics related to scoring */
    /** Total times score() is called */
    scoreFnCalls: register.gauge({
      name: "gossipsub_score_fn_calls_total",
      help: "Total times score() is called"
    }),
    /** Total times score() call actually computed computeScore(), no cache */
    scoreFnRuns: register.gauge({
      name: "gossipsub_score_fn_runs_total",
      help: "Total times score() call actually computed computeScore(), no cache"
    }),
    scoreCachedDelta: register.histogram({
      name: "gossipsub_score_cache_delta",
      help: "Delta of score between cached values that expired",
      buckets: [10, 100, 1e3]
    }),
    /** Current count of peers by score threshold */
    peersByScoreThreshold: register.gauge({
      name: "gossipsub_peers_by_score_threshold_count",
      help: "Current count of peers by score threshold",
      labelNames: ["threshold"]
    }),
    score: register.avgMinMax({
      name: "gossipsub_score",
      help: "Avg min max of gossip scores"
    }),
    /**
     * Separate score weights
     * Need to use 2-label metrics in this case to debug the score weights
     **/
    scoreWeights: register.avgMinMax({
      name: "gossipsub_score_weights",
      help: "Separate score weights",
      labelNames: ["topic", "p"]
    }),
    /** Histogram of the scores for each mesh topic. */
    // TODO: Not implemented
    scorePerMesh: register.avgMinMax({
      name: "gossipsub_score_per_mesh",
      help: "Histogram of the scores for each mesh topic",
      labelNames: ["topic"]
    }),
    /** A counter of the kind of penalties being applied to peers. */
    // TODO: Not fully implemented
    scoringPenalties: register.gauge({
      name: "gossipsub_scoring_penalties_total",
      help: "A counter of the kind of penalties being applied to peers",
      labelNames: ["penalty"]
    }),
    behaviourPenalty: register.histogram({
      name: "gossipsub_peer_stat_behaviour_penalty",
      help: "Current peer stat behaviour_penalty at each scrape",
      buckets: [
        0.25 * opts.behaviourPenaltyThreshold,
        0.5 * opts.behaviourPenaltyThreshold,
        Number(opts.behaviourPenaltyThreshold),
        2 * opts.behaviourPenaltyThreshold,
        4 * opts.behaviourPenaltyThreshold
      ]
    }),
    // TODO:
    // - iasked per peer (on heartbeat)
    // - when promise is resolved, track messages from promises
    /** Total received IHAVE messages that we ignore for some reason */
    ihaveRcvIgnored: register.gauge({
      name: "gossipsub_ihave_rcv_ignored_total",
      help: "Total received IHAVE messages that we ignore for some reason",
      labelNames: ["reason"]
    }),
    /** Total received IHAVE messages by topic */
    ihaveRcvMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_msgids_total",
      help: "Total received IHAVE messages by topic",
      labelNames: ["topic"]
    }),
    /**
     * Total messages per topic we don't have. Not actual requests.
     * The number of times we have decided that an IWANT control message is required for this
     * topic. A very high metric might indicate an underperforming network.
     * = rust-libp2p `topic_iwant_msgs` */
    ihaveRcvNotSeenMsgids: register.gauge({
      name: "gossipsub_ihave_rcv_not_seen_msgids_total",
      help: "Total messages per topic we do not have, not actual requests",
      labelNames: ["topic"]
    }),
    /** Total received IWANT messages by topic */
    iwantRcvMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_msgids_total",
      help: "Total received IWANT messages by topic",
      labelNames: ["topic"]
    }),
    /** Total requested messageIDs that we don't have */
    iwantRcvDonthaveMsgids: register.gauge({
      name: "gossipsub_iwant_rcv_dont_have_msgids_total",
      help: "Total requested messageIDs that we do not have"
    }),
    /** Total received IDONTWANT messages */
    idontwantRcvMsgids: register.gauge({
      name: "gossipsub_idontwant_rcv_msgids_total",
      help: "Total received IDONTWANT messages"
    }),
    /** Total received IDONTWANT messageIDs that we don't have */
    idontwantRcvDonthaveMsgids: register.gauge({
      name: "gossipsub_idontwant_rcv_dont_have_msgids_total",
      help: "Total received IDONTWANT messageIDs that we do not have in mcache"
    }),
    iwantPromiseStarted: register.gauge({
      name: "gossipsub_iwant_promise_sent_total",
      help: "Total count of started IWANT promises"
    }),
    /** Total count of resolved IWANT promises */
    iwantPromiseResolved: register.gauge({
      name: "gossipsub_iwant_promise_resolved_total",
      help: "Total count of resolved IWANT promises"
    }),
    /** Total count of resolved IWANT promises from duplicate messages */
    iwantPromiseResolvedFromDuplicate: register.gauge({
      name: "gossipsub_iwant_promise_resolved_from_duplicate_total",
      help: "Total count of resolved IWANT promises from duplicate messages"
    }),
    /** Total count of peers we have asked IWANT promises that are resolved */
    iwantPromiseResolvedPeers: register.gauge({
      name: "gossipsub_iwant_promise_resolved_peers",
      help: "Total count of peers we have asked IWANT promises that are resolved"
    }),
    iwantPromiseBroken: register.gauge({
      name: "gossipsub_iwant_promise_broken",
      help: "Total count of broken IWANT promises"
    }),
    iwantMessagePruned: register.gauge({
      name: "gossipsub_iwant_message_pruned",
      help: "Total count of pruned IWANT messages"
    }),
    /** Histogram of delivery time of resolved IWANT promises */
    iwantPromiseDeliveryTime: register.histogram({
      name: "gossipsub_iwant_promise_delivery_seconds",
      help: "Histogram of delivery time of resolved IWANT promises",
      buckets: [
        0.5 * opts.gossipPromiseExpireSec,
        Number(opts.gossipPromiseExpireSec),
        2 * opts.gossipPromiseExpireSec,
        4 * opts.gossipPromiseExpireSec
      ]
    }),
    iwantPromiseUntracked: register.gauge({
      name: "gossip_iwant_promise_untracked",
      help: "Total count of untracked IWANT promise"
    }),
    /** Backoff time */
    connectedPeersBackoffSec: register.histogram({
      name: "gossipsub_connected_peers_backoff_seconds",
      help: "Backoff time in seconds",
      // Using 1 seconds as minimum as that's close to the heartbeat duration, no need for more resolution.
      // As per spec, backoff times are 10 seconds for UnsubscribeBackoff and 60 seconds for PruneBackoff.
      // Higher values of 60 seconds should not occur, but we add 120 seconds just in case
      // https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#overview-of-new-parameters
      buckets: [1, 2, 4, 10, 20, 60, 120]
    }),
    /* Data structure sizes */
    /** Unbounded cache sizes */
    cacheSize: register.gauge({
      name: "gossipsub_cache_size",
      help: "Unbounded cache sizes",
      labelNames: ["cache"]
    }),
    /** Current mcache msg count */
    mcacheSize: register.gauge({
      name: "gossipsub_mcache_size",
      help: "Current mcache msg count"
    }),
    mcacheNotValidatedCount: register.gauge({
      name: "gossipsub_mcache_not_validated_count",
      help: "Current mcache msg count not validated"
    }),
    fastMsgIdCacheCollision: register.gauge({
      name: "gossipsub_fastmsgid_cache_collision_total",
      help: "Total count of key collisions on fastmsgid cache put"
    }),
    newConnectionCount: register.gauge({
      name: "gossipsub_new_connection_total",
      help: "Total new connection by status",
      labelNames: ["status"]
    }),
    topicStrToLabel,
    toTopic(topicStr) {
      return this.topicStrToLabel.get(topicStr) ?? topicStr;
    },
    /** We joined a topic */
    onJoin(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 1);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    /** We left a topic */
    onLeave(topicStr) {
      this.topicSubscriptionStatus.set({ topicStr }, 0);
      this.meshPeerCounts.set({ topicStr }, 0);
    },
    /** Register the inclusion of peers in our mesh due to some reason. */
    onAddToMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      switch (reason) {
        case InclusionReason.Fanout:
          this.meshPeerInclusionEventsFanout.inc({ topic }, count);
          break;
        case InclusionReason.Random:
          this.meshPeerInclusionEventsRandom.inc({ topic }, count);
          break;
        case InclusionReason.Subscribed:
          this.meshPeerInclusionEventsSubscribed.inc({ topic }, count);
          break;
        case InclusionReason.Outbound:
          this.meshPeerInclusionEventsOutbound.inc({ topic }, count);
          break;
        case InclusionReason.NotEnough:
          this.meshPeerInclusionEventsNotEnough.inc({ topic }, count);
          break;
        case InclusionReason.Opportunistic:
          this.meshPeerInclusionEventsOpportunistic.inc({ topic }, count);
          break;
        default:
          this.meshPeerInclusionEventsUnknown.inc({ topic }, count);
          break;
      }
    },
    /** Register the removal of peers in our mesh due to some reason */
    // - remove_peer_from_mesh()
    // - heartbeat() Churn::BadScore
    // - heartbeat() Churn::Excess
    // - on_disconnect() Churn::Ds
    onRemoveFromMesh(topicStr, reason, count) {
      const topic = this.toTopic(topicStr);
      switch (reason) {
        case ChurnReason.Dc:
          this.meshPeerChurnEventsDisconnected.inc({ topic }, count);
          break;
        case ChurnReason.BadScore:
          this.meshPeerChurnEventsBadScore.inc({ topic }, count);
          break;
        case ChurnReason.Prune:
          this.meshPeerChurnEventsPrune.inc({ topic }, count);
          break;
        case ChurnReason.Excess:
          this.meshPeerChurnEventsExcess.inc({ topic }, count);
          break;
        default:
          this.meshPeerChurnEventsUnknown.inc({ topic }, count);
          break;
      }
    },
    /**
     * Update validation result to metrics
     *
     * @param messageRecord - null means the message's mcache record was not known at the time of acceptance report
     */
    onReportValidation(messageRecord, acceptance, firstSeenTimestampMs) {
      this.asyncValidationMcacheHit.inc({ hit: messageRecord != null ? "hit" : "miss" });
      if (messageRecord != null) {
        const topic = this.toTopic(messageRecord.message.topic);
        switch (acceptance) {
          case TopicValidatorResult.Accept:
            this.acceptedMessagesTotal.inc({ topic });
            break;
          case TopicValidatorResult.Ignore:
            this.ignoredMessagesTotal.inc({ topic });
            break;
          case TopicValidatorResult.Reject:
            this.rejectedMessagesTotal.inc({ topic });
            break;
          default:
            this.unknownValidationResultsTotal.inc({ topic });
            break;
        }
      }
      if (firstSeenTimestampMs != null) {
        this.asyncValidationDelayFromFirstSeenSec.observe((Date.now() - firstSeenTimestampMs) / 1e3);
      } else {
        this.asyncValidationUnknownFirstSeen.inc();
      }
    },
    /**
     * - in handle_graft() Penalty::GraftBackoff
     * - in apply_iwant_penalties() Penalty::BrokenPromise
     * - in metric_score() P3 Penalty::MessageDeficit
     * - in metric_score() P6 Penalty::IPColocation
     */
    onScorePenalty(penalty) {
      this.scoringPenalties.inc({ penalty }, 1);
    },
    onIhaveRcv(topicStr, ihave, idonthave) {
      const topic = this.toTopic(topicStr);
      this.ihaveRcvMsgids.inc({ topic }, ihave);
      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave);
    },
    onIwantRcv(iwantByTopic, iwantDonthave) {
      for (const [topicStr, iwant] of iwantByTopic) {
        const topic = this.toTopic(topicStr);
        this.iwantRcvMsgids.inc({ topic }, iwant);
      }
      this.iwantRcvDonthaveMsgids.inc(iwantDonthave);
    },
    onIdontwantRcv(idontwant, idontwantDonthave) {
      this.idontwantRcvMsgids.inc(idontwant);
      this.idontwantRcvDonthaveMsgids.inc(idontwantDonthave);
    },
    onForwardMsg(topicStr, tosendCount) {
      const topic = this.toTopic(topicStr);
      this.msgForwardCount.inc({ topic }, 1);
      this.msgForwardPeers.inc({ topic }, tosendCount);
    },
    onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen, ms) {
      const topic = this.toTopic(topicStr);
      this.msgPublishCount.inc({ topic }, 1);
      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen);
      this.msgPublishPeersByTopic.inc({ topic }, tosendCount);
      this.directPeersPublishedTotal.inc({ topic }, tosendGroupCount.direct);
      this.floodsubPeersPublishedTotal.inc({ topic }, tosendGroupCount.floodsub);
      this.meshPeersPublishedTotal.inc({ topic }, tosendGroupCount.mesh);
      this.fanoutPeersPublishedTotal.inc({ topic }, tosendGroupCount.fanout);
      this.msgPublishTime.observe({ topic }, ms / 1e3);
    },
    onMsgRecvPreValidation(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedPreValidation.inc({ topic }, 1);
    },
    onMsgRecvError(topicStr) {
      const topic = this.toTopic(topicStr);
      this.msgReceivedError.inc({ topic }, 1);
    },
    onPrevalidationResult(topicStr, status) {
      const topic = this.toTopic(topicStr);
      switch (status) {
        case MessageStatus.duplicate:
          this.prevalidationDuplicateTotal.inc({ topic });
          break;
        case MessageStatus.invalid:
          this.prevalidationInvalidTotal.inc({ topic });
          break;
        case MessageStatus.valid:
          this.prevalidationValidTotal.inc({ topic });
          break;
        default:
          this.prevalidationUnknownTotal.inc({ topic });
          break;
      }
    },
    onMsgRecvInvalid(topicStr, reason) {
      const topic = this.toTopic(topicStr);
      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason;
      this.msgReceivedInvalid.inc({ error }, 1);
      this.msgReceivedInvalidByTopic.inc({ topic }, 1);
    },
    onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {
      const topic = this.toTopic(topicStr);
      this.duplicateMsgDeliveryDelay.observe({ topic }, deliveryDelayMs / 1e3);
      if (isLateDelivery) {
        this.duplicateMsgLateDelivery.inc({ topic }, 1);
      }
    },
    onPublishDuplicateMsg(topicStr) {
      const topic = this.toTopic(topicStr);
      this.duplicateMsgIgnored.inc({ topic }, 1);
    },
    onPeerReadStreamError() {
      this.peerReadStreamError.inc(1);
    },
    onRpcRecvError() {
      this.rpcRecvError.inc(1);
    },
    onRpcDataError() {
      this.rpcDataError.inc(1);
    },
    onRpcRecv(rpc, rpcBytes) {
      this.rpcRecvBytes.inc(rpcBytes);
      this.rpcRecvCount.inc(1);
      if (rpc.subscriptions != null)
        this.rpcRecvSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages != null)
        this.rpcRecvMessage.inc(rpc.messages.length);
      if (rpc.control != null) {
        this.rpcRecvControl.inc(1);
        if (rpc.control.ihave != null)
          this.rpcRecvIHave.inc(rpc.control.ihave.length);
        if (rpc.control.iwant != null)
          this.rpcRecvIWant.inc(rpc.control.iwant.length);
        if (rpc.control.graft != null)
          this.rpcRecvGraft.inc(rpc.control.graft.length);
        if (rpc.control.prune != null)
          this.rpcRecvPrune.inc(rpc.control.prune.length);
      }
    },
    onRpcSent(rpc, rpcBytes) {
      this.rpcSentBytes.inc(rpcBytes);
      this.rpcSentCount.inc(1);
      if (rpc.subscriptions != null)
        this.rpcSentSubscription.inc(rpc.subscriptions.length);
      if (rpc.messages != null)
        this.rpcSentMessage.inc(rpc.messages.length);
      if (rpc.control != null) {
        const ihave = rpc.control.ihave?.length ?? 0;
        const iwant = rpc.control.iwant?.length ?? 0;
        const graft = rpc.control.graft?.length ?? 0;
        const prune = rpc.control.prune?.length ?? 0;
        const idontwant = rpc.control.idontwant?.length ?? 0;
        if (ihave > 0)
          this.rpcSentIHave.inc(ihave);
        if (iwant > 0)
          this.rpcSentIWant.inc(iwant);
        if (graft > 0)
          this.rpcSentGraft.inc(graft);
        if (prune > 0)
          this.rpcSentPrune.inc(prune);
        if (idontwant > 0)
          this.rpcSentIDontWant.inc(idontwant);
        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0 || idontwant > 0)
          this.rpcSentControl.inc(1);
      }
    },
    registerScores(scores, scoreThresholds) {
      let graylist = 0;
      let publish = 0;
      let gossip = 0;
      let mesh = 0;
      for (const score of scores) {
        if (score >= scoreThresholds.graylistThreshold)
          graylist++;
        if (score >= scoreThresholds.publishThreshold)
          publish++;
        if (score >= scoreThresholds.gossipThreshold)
          gossip++;
        if (score >= 0)
          mesh++;
      }
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip);
      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh);
      this.score.set(scores);
    },
    registerScoreWeights(sw) {
      for (const [topic, wsTopic] of sw.byTopic) {
        this.scoreWeights.set({ topic, p: "p1" }, wsTopic.p1w);
        this.scoreWeights.set({ topic, p: "p2" }, wsTopic.p2w);
        this.scoreWeights.set({ topic, p: "p3" }, wsTopic.p3w);
        this.scoreWeights.set({ topic, p: "p3b" }, wsTopic.p3bw);
        this.scoreWeights.set({ topic, p: "p4" }, wsTopic.p4w);
      }
      this.scoreWeights.set({ p: "p5" }, sw.p5w);
      this.scoreWeights.set({ p: "p6" }, sw.p6w);
      this.scoreWeights.set({ p: "p7" }, sw.p7w);
    },
    registerScorePerMesh(mesh, scoreByPeer) {
      const peersPerTopicLabel = /* @__PURE__ */ new Map();
      mesh.forEach((peers, topicStr) => {
        const topicLabel = this.topicStrToLabel.get(topicStr) ?? "unknown";
        let peersInMesh = peersPerTopicLabel.get(topicLabel);
        if (peersInMesh == null) {
          peersInMesh = /* @__PURE__ */ new Set();
          peersPerTopicLabel.set(topicLabel, peersInMesh);
        }
        peers.forEach((p2) => peersInMesh?.add(p2));
      });
      for (const [topic, peers] of peersPerTopicLabel) {
        const meshScores = [];
        peers.forEach((peer) => {
          meshScores.push(scoreByPeer.get(peer) ?? 0);
        });
        this.scorePerMesh.set({ topic }, meshScores);
      }
    }
  };
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/errors.js
var InvalidPeerScoreParamsError = class extends Error {
  constructor(message2 = "Invalid peer score params") {
    super(message2);
    this.name = "InvalidPeerScoreParamsError";
  }
};
__publicField(InvalidPeerScoreParamsError, "name", "InvalidPeerScoreParamsError");
var InvalidPeerScoreThresholdsError = class extends Error {
  constructor(message2 = "Invalid peer score thresholds") {
    super(message2);
    this.name = "InvalidPeerScoreThresholdsError";
  }
};
__publicField(InvalidPeerScoreThresholdsError, "name", "InvalidPeerScoreThresholdsError");

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-params.js
var defaultPeerScoreParams = {
  topics: {},
  topicScoreCap: 10,
  appSpecificScore: () => 0,
  appSpecificWeight: 10,
  IPColocationFactorWeight: -5,
  IPColocationFactorThreshold: 10,
  IPColocationFactorWhitelist: /* @__PURE__ */ new Set(),
  behaviourPenaltyWeight: -10,
  behaviourPenaltyThreshold: 0,
  behaviourPenaltyDecay: 0.2,
  decayInterval: 1e3,
  decayToZero: 0.1,
  retainScore: 3600 * 1e3
};
var defaultTopicScoreParams = {
  topicWeight: 0.5,
  timeInMeshWeight: 1,
  timeInMeshQuantum: 1,
  timeInMeshCap: 3600,
  firstMessageDeliveriesWeight: 1,
  firstMessageDeliveriesDecay: 0.5,
  firstMessageDeliveriesCap: 2e3,
  meshMessageDeliveriesWeight: -1,
  meshMessageDeliveriesDecay: 0.5,
  meshMessageDeliveriesCap: 100,
  meshMessageDeliveriesThreshold: 20,
  meshMessageDeliveriesWindow: 10,
  meshMessageDeliveriesActivation: 5e3,
  meshFailurePenaltyWeight: -1,
  meshFailurePenaltyDecay: 0.5,
  invalidMessageDeliveriesWeight: -1,
  invalidMessageDeliveriesDecay: 0.3
};
function createPeerScoreParams(p2 = {}) {
  return {
    ...defaultPeerScoreParams,
    ...p2,
    topics: p2.topics != null ? Object.entries(p2.topics).reduce((topics, [topic, topicScoreParams]) => {
      topics[topic] = createTopicScoreParams(topicScoreParams);
      return topics;
    }, {}) : {}
  };
}
function createTopicScoreParams(p2 = {}) {
  return {
    ...defaultTopicScoreParams,
    ...p2
  };
}
function validatePeerScoreParams(p2) {
  for (const [topic, params] of Object.entries(p2.topics)) {
    try {
      validateTopicScoreParams(params);
    } catch (e2) {
      throw new InvalidPeerScoreParamsError(`invalid score parameters for topic ${topic}: ${e2.message}`);
    }
  }
  if (p2.topicScoreCap < 0) {
    throw new InvalidPeerScoreParamsError("invalid topic score cap; must be positive (or 0 for no cap)");
  }
  if (p2.appSpecificScore === null || p2.appSpecificScore === void 0) {
    throw new InvalidPeerScoreParamsError("missing application specific score function");
  }
  if (p2.IPColocationFactorWeight > 0) {
    throw new InvalidPeerScoreParamsError("invalid IPColocationFactorWeight; must be negative (or 0 to disable)");
  }
  if (p2.IPColocationFactorWeight !== 0 && p2.IPColocationFactorThreshold < 1) {
    throw new InvalidPeerScoreParamsError("invalid IPColocationFactorThreshold; must be at least 1");
  }
  if (p2.behaviourPenaltyWeight > 0) {
    throw new InvalidPeerScoreParamsError("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)");
  }
  if (p2.behaviourPenaltyWeight !== 0 && (p2.behaviourPenaltyDecay <= 0 || p2.behaviourPenaltyDecay >= 1)) {
    throw new InvalidPeerScoreParamsError("invalid BehaviourPenaltyDecay; must be between 0 and 1");
  }
  if (p2.decayInterval < 1e3) {
    throw new InvalidPeerScoreParamsError("invalid DecayInterval; must be at least 1s");
  }
  if (p2.decayToZero <= 0 || p2.decayToZero >= 1) {
    throw new InvalidPeerScoreParamsError("invalid DecayToZero; must be between 0 and 1");
  }
}
function validateTopicScoreParams(p2) {
  if (p2.topicWeight < 0) {
    throw new InvalidPeerScoreParamsError("invalid topic weight; must be >= 0");
  }
  if (p2.timeInMeshQuantum === 0) {
    throw new InvalidPeerScoreParamsError("invalid TimeInMeshQuantum; must be non zero");
  }
  if (p2.timeInMeshWeight < 0) {
    throw new InvalidPeerScoreParamsError("invalid TimeInMeshWeight; must be positive (or 0 to disable)");
  }
  if (p2.timeInMeshWeight !== 0 && p2.timeInMeshQuantum <= 0) {
    throw new InvalidPeerScoreParamsError("invalid TimeInMeshQuantum; must be positive");
  }
  if (p2.timeInMeshWeight !== 0 && p2.timeInMeshCap <= 0) {
    throw new InvalidPeerScoreParamsError("invalid TimeInMeshCap; must be positive");
  }
  if (p2.firstMessageDeliveriesWeight < 0) {
    throw new InvalidPeerScoreParamsError("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)");
  }
  if (p2.firstMessageDeliveriesWeight !== 0 && (p2.firstMessageDeliveriesDecay <= 0 || p2.firstMessageDeliveriesDecay >= 1)) {
    throw new InvalidPeerScoreParamsError("invalid FirstMessageDeliveriesDecay; must be between 0 and 1");
  }
  if (p2.firstMessageDeliveriesWeight !== 0 && p2.firstMessageDeliveriesCap <= 0) {
    throw new InvalidPeerScoreParamsError("invalid FirstMessageDeliveriesCap; must be positive");
  }
  if (p2.meshMessageDeliveriesWeight > 0) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)");
  }
  if (p2.meshMessageDeliveriesWeight !== 0 && (p2.meshMessageDeliveriesDecay <= 0 || p2.meshMessageDeliveriesDecay >= 1)) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesDecay; must be between 0 and 1");
  }
  if (p2.meshMessageDeliveriesWeight !== 0 && p2.meshMessageDeliveriesCap <= 0) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesCap; must be positive");
  }
  if (p2.meshMessageDeliveriesWeight !== 0 && p2.meshMessageDeliveriesThreshold <= 0) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesThreshold; must be positive");
  }
  if (p2.meshMessageDeliveriesWindow < 0) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesWindow; must be non-negative");
  }
  if (p2.meshMessageDeliveriesWeight !== 0 && p2.meshMessageDeliveriesActivation < 1e3) {
    throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesActivation; must be at least 1s");
  }
  if (p2.meshFailurePenaltyWeight > 0) {
    throw new InvalidPeerScoreParamsError("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)");
  }
  if (p2.meshFailurePenaltyWeight !== 0 && (p2.meshFailurePenaltyDecay <= 0 || p2.meshFailurePenaltyDecay >= 1)) {
    throw new InvalidPeerScoreParamsError("invalid MeshFailurePenaltyDecay; must be between 0 and 1");
  }
  if (p2.invalidMessageDeliveriesWeight > 0) {
    throw new InvalidPeerScoreParamsError("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)");
  }
  if (p2.invalidMessageDeliveriesDecay <= 0 || p2.invalidMessageDeliveriesDecay >= 1) {
    throw new InvalidPeerScoreParamsError("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1");
  }
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-thresholds.js
var defaultPeerScoreThresholds = {
  gossipThreshold: -10,
  publishThreshold: -50,
  graylistThreshold: -80,
  acceptPXThreshold: 10,
  opportunisticGraftThreshold: 20
};
function createPeerScoreThresholds(p2 = {}) {
  return {
    ...defaultPeerScoreThresholds,
    ...p2
  };
}
function validatePeerScoreThresholds(p2) {
  if (p2.gossipThreshold > 0) {
    throw new InvalidPeerScoreThresholdsError("invalid gossip threshold; it must be <= 0");
  }
  if (p2.publishThreshold > 0 || p2.publishThreshold > p2.gossipThreshold) {
    throw new InvalidPeerScoreThresholdsError("invalid publish threshold; it must be <= 0 and <= gossip threshold");
  }
  if (p2.graylistThreshold > 0 || p2.graylistThreshold > p2.publishThreshold) {
    throw new InvalidPeerScoreThresholdsError("invalid graylist threshold; it must be <= 0 and <= publish threshold");
  }
  if (p2.acceptPXThreshold < 0) {
    throw new InvalidPeerScoreThresholdsError("invalid accept PX threshold; it must be >= 0");
  }
  if (p2.opportunisticGraftThreshold < 0) {
    throw new InvalidPeerScoreThresholdsError("invalid opportunistic grafting threshold; it must be >= 0");
  }
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/set.js
function removeItemsFromSet(superSet, ineed, cond = () => true) {
  const subset = /* @__PURE__ */ new Set();
  if (ineed <= 0)
    return subset;
  for (const id of superSet) {
    if (subset.size >= ineed)
      break;
    if (cond(id)) {
      subset.add(id);
      superSet.delete(id);
    }
  }
  return subset;
}
function removeFirstNItemsFromSet(superSet, ineed) {
  return removeItemsFromSet(superSet, ineed, () => true);
}
var MapDef = class extends Map {
  constructor(getDefault) {
    super();
    __publicField(this, "getDefault");
    this.getDefault = getDefault;
  }
  getOrDefault(key) {
    let value2 = super.get(key);
    if (value2 === void 0) {
      value2 = this.getDefault();
      this.set(key, value2);
    }
    return value2;
  }
};

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/compute-score.js
function computeScore(peer, pstats, params, peerIPs) {
  let score = 0;
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScore = 0;
    if (tstats.inMesh) {
      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
      if (p1 > topicParams.timeInMeshCap) {
        p1 = topicParams.timeInMeshCap;
      }
      topicScore += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    topicScore += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += topicScore * topicParams.topicWeight;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
  }
  const p5 = params.appSpecificScore(peer);
  score += p5 * params.appSpecificWeight;
  pstats.knownIPs.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP != null ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      score += p6 * params.IPColocationFactorWeight;
    }
  });
  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {
    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold;
    const p7 = excess * excess;
    score += p7 * params.behaviourPenaltyWeight;
  }
  return score;
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/message-deliveries.js
var import_denque = __toESM(require_denque(), 1);
var DeliveryRecordStatus;
(function(DeliveryRecordStatus2) {
  DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
  DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
  DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
})(DeliveryRecordStatus || (DeliveryRecordStatus = {}));
var MessageDeliveries = class {
  constructor() {
    __publicField(this, "records");
    __publicField(this, "queue");
    this.records = /* @__PURE__ */ new Map();
    this.queue = new import_denque.default();
  }
  getRecord(msgIdStr) {
    return this.records.get(msgIdStr);
  }
  ensureRecord(msgIdStr) {
    let drec = this.records.get(msgIdStr);
    if (drec != null) {
      return drec;
    }
    drec = {
      status: DeliveryRecordStatus.unknown,
      firstSeenTsMs: Date.now(),
      validated: 0,
      peers: /* @__PURE__ */ new Set()
    };
    this.records.set(msgIdStr, drec);
    const entry = {
      msgId: msgIdStr,
      expire: Date.now() + TimeCacheDuration
    };
    this.queue.push(entry);
    return drec;
  }
  gc() {
    const now = Date.now();
    let head = this.queue.peekFront();
    while (head != null && head.expire < now) {
      this.records.delete(head.msgId);
      this.queue.shift();
      head = this.queue.peekFront();
    }
  }
  clear() {
    this.records.clear();
    this.queue.clear();
  }
};

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score.js
var PeerScore = class {
  constructor(params, metrics, componentLogger, opts) {
    __publicField(this, "params");
    __publicField(this, "metrics");
    /**
     * Per-peer stats for score calculation
     */
    __publicField(this, "peerStats", /* @__PURE__ */ new Map());
    /**
     * IP colocation tracking; maps IP => set of peers.
     */
    __publicField(this, "peerIPs", new MapDef(() => /* @__PURE__ */ new Set()));
    /**
     * Cache score up to decayInterval if topic stats are unchanged.
     */
    __publicField(this, "scoreCache", /* @__PURE__ */ new Map());
    /**
     * Recent message delivery timing/participants
     */
    __publicField(this, "deliveryRecords", new MessageDeliveries());
    __publicField(this, "_backgroundInterval");
    __publicField(this, "scoreCacheValidityMs");
    __publicField(this, "computeScore");
    __publicField(this, "log");
    this.params = params;
    this.metrics = metrics;
    validatePeerScoreParams(params);
    this.scoreCacheValidityMs = opts.scoreCacheValidityMs;
    this.computeScore = opts.computeScore ?? computeScore;
    this.log = componentLogger.forComponent("libp2p:gossipsub:score");
  }
  get size() {
    return this.peerStats.size;
  }
  /**
   * Start PeerScore instance
   */
  start() {
    if (this._backgroundInterval != null) {
      this.log("Peer score already running");
      return;
    }
    this._backgroundInterval = setInterval(() => {
      this.background();
    }, this.params.decayInterval);
    this.log("started");
  }
  /**
   * Stop PeerScore instance
   */
  stop() {
    if (this._backgroundInterval == null) {
      this.log("Peer score already stopped");
      return;
    }
    clearInterval(this._backgroundInterval);
    delete this._backgroundInterval;
    this.peerIPs.clear();
    this.peerStats.clear();
    this.deliveryRecords.clear();
    this.log("stopped");
  }
  /**
   * Periodic maintenance
   */
  background() {
    this.refreshScores();
    this.deliveryRecords.gc();
  }
  dumpPeerScoreStats() {
    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]));
  }
  messageFirstSeenTimestampMs(msgIdStr) {
    const drec = this.deliveryRecords.getRecord(msgIdStr);
    return drec != null ? drec.firstSeenTsMs : null;
  }
  /**
   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.
   */
  refreshScores() {
    const now = Date.now();
    const decayToZero = this.params.decayToZero;
    this.peerStats.forEach((pstats, id) => {
      if (!pstats.connected) {
        if (now > pstats.expire) {
          this.removeIPsForPeer(id, pstats.knownIPs);
          this.peerStats.delete(id);
          this.scoreCache.delete(id);
        }
        return;
      }
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        const tparams = this.params.topics[topic];
        if (tparams === void 0) {
          return;
        }
        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
        if (tstats.firstMessageDeliveries < decayToZero) {
          tstats.firstMessageDeliveries = 0;
        }
        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
        if (tstats.meshMessageDeliveries < decayToZero) {
          tstats.meshMessageDeliveries = 0;
        }
        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
        if (tstats.meshFailurePenalty < decayToZero) {
          tstats.meshFailurePenalty = 0;
        }
        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
        if (tstats.invalidMessageDeliveries < decayToZero) {
          tstats.invalidMessageDeliveries = 0;
        }
        if (tstats.inMesh) {
          tstats.meshTime = now - tstats.graftTime;
          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
            tstats.meshMessageDeliveriesActive = true;
          }
        }
      });
      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
      if (pstats.behaviourPenalty < decayToZero) {
        pstats.behaviourPenalty = 0;
      }
    });
  }
  /**
   * Return the score for a peer
   */
  score(id) {
    this.metrics?.scoreFnCalls.inc();
    const pstats = this.peerStats.get(id);
    if (pstats == null) {
      return 0;
    }
    const now = Date.now();
    const cacheEntry = this.scoreCache.get(id);
    if (cacheEntry != null && cacheEntry.cacheUntil > now) {
      return cacheEntry.score;
    }
    this.metrics?.scoreFnRuns.inc();
    const score = this.computeScore(id, pstats, this.params, this.peerIPs);
    const cacheUntil = now + this.scoreCacheValidityMs;
    if (cacheEntry != null) {
      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));
      cacheEntry.score = score;
      cacheEntry.cacheUntil = cacheUntil;
    } else {
      this.scoreCache.set(id, { score, cacheUntil });
    }
    return score;
  }
  /**
   * Apply a behavioural penalty to a peer
   */
  addPenalty(id, penalty, penaltyLabel) {
    const pstats = this.peerStats.get(id);
    if (pstats != null) {
      pstats.behaviourPenalty += penalty;
      this.metrics?.onScorePenalty(penaltyLabel);
    }
  }
  addPeer(id) {
    const pstats = {
      connected: true,
      expire: 0,
      topics: {},
      knownIPs: /* @__PURE__ */ new Set(),
      behaviourPenalty: 0
    };
    this.peerStats.set(id, pstats);
  }
  /** Adds a new IP to a peer, if the peer is not known the update is ignored */
  addIP(id, ip) {
    const pstats = this.peerStats.get(id);
    if (pstats != null) {
      pstats.knownIPs.add(ip);
    }
    this.peerIPs.getOrDefault(ip).add(id);
  }
  /** Remove peer association with IP */
  removeIP(id, ip) {
    const pstats = this.peerStats.get(id);
    if (pstats != null) {
      pstats.knownIPs.delete(ip);
    }
    const peersWithIP = this.peerIPs.get(ip);
    if (peersWithIP != null) {
      peersWithIP.delete(id);
      if (peersWithIP.size === 0) {
        this.peerIPs.delete(ip);
      }
    }
  }
  removePeer(id) {
    const pstats = this.peerStats.get(id);
    if (pstats == null) {
      return;
    }
    if (this.score(id) > 0) {
      this.removeIPsForPeer(id, pstats.knownIPs);
      this.peerStats.delete(id);
      return;
    }
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      tstats.firstMessageDeliveries = 0;
      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
        const deficit = threshold - tstats.meshMessageDeliveries;
        tstats.meshFailurePenalty += deficit * deficit;
      }
      tstats.inMesh = false;
      tstats.meshMessageDeliveriesActive = false;
    });
    pstats.connected = false;
    pstats.expire = Date.now() + this.params.retainScore;
  }
  /** Handles scoring functionality as a peer GRAFTs to a topic. */
  graft(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats != null) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats != null) {
        tstats.inMesh = true;
        tstats.graftTime = Date.now();
        tstats.meshTime = 0;
        tstats.meshMessageDeliveriesActive = false;
      }
    }
  }
  /** Handles scoring functionality as a peer PRUNEs from a topic. */
  prune(id, topic) {
    const pstats = this.peerStats.get(id);
    if (pstats != null) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats != null) {
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.meshMessageDeliveriesActive = false;
        tstats.inMesh = false;
      }
    }
  }
  validateMessage(msgIdStr) {
    this.deliveryRecords.ensureRecord(msgIdStr);
  }
  deliverMessage(from3, msgIdStr, topic) {
    this.markFirstMessageDelivery(from3, topic);
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    const now = Date.now();
    if (drec.status !== DeliveryRecordStatus.unknown) {
      this.log("unexpected delivery: message from %s was first seen %s ago and has delivery status %s", from3, now - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);
      return;
    }
    drec.status = DeliveryRecordStatus.valid;
    drec.validated = now;
    drec.peers.forEach((p2) => {
      if (p2 !== from3.toString()) {
        this.markDuplicateMessageDelivery(p2, topic);
      }
    });
  }
  /**
   * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.
   */
  rejectInvalidMessage(from3, topic) {
    this.markInvalidMessageDelivery(from3, topic);
  }
  rejectMessage(from3, msgIdStr, topic, reason) {
    switch (reason) {
      // these messages are not tracked, but the peer is penalized as they are invalid
      case RejectReason.Error:
        this.markInvalidMessageDelivery(from3, topic);
        return;
      // we ignore those messages, so do nothing.
      case RejectReason.Blacklisted:
        return;
    }
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.status !== DeliveryRecordStatus.unknown) {
      this.log("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", from3, Date.now() - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);
      return;
    }
    if (reason === RejectReason.Ignore) {
      drec.status = DeliveryRecordStatus.ignored;
      drec.peers.clear();
      return;
    }
    drec.status = DeliveryRecordStatus.invalid;
    this.markInvalidMessageDelivery(from3, topic);
    drec.peers.forEach((p2) => {
      this.markInvalidMessageDelivery(p2, topic);
    });
    drec.peers.clear();
  }
  duplicateMessage(from3, msgIdStr, topic) {
    const drec = this.deliveryRecords.ensureRecord(msgIdStr);
    if (drec.peers.has(from3)) {
      return;
    }
    switch (drec.status) {
      case DeliveryRecordStatus.unknown:
        drec.peers.add(from3);
        break;
      case DeliveryRecordStatus.valid:
        drec.peers.add(from3);
        this.markDuplicateMessageDelivery(from3, topic, drec.validated);
        break;
      case DeliveryRecordStatus.invalid:
        this.markInvalidMessageDelivery(from3, topic);
        break;
      case DeliveryRecordStatus.ignored:
        break;
    }
  }
  /**
   * Increments the "invalid message deliveries" counter for all scored topics the message is published in.
   */
  markInvalidMessageDelivery(from3, topic) {
    const pstats = this.peerStats.get(from3);
    if (pstats != null) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats != null) {
        tstats.invalidMessageDeliveries += 1;
      }
    }
  }
  /**
   * Increments the "first message deliveries" counter for all scored topics the message is published in,
   * as well as the "mesh message deliveries" counter, if the peer is in the mesh for the topic.
   * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()
   */
  markFirstMessageDelivery(from3, topic) {
    const pstats = this.peerStats.get(from3);
    if (pstats != null) {
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats != null) {
        let cap = this.params.topics[topic].firstMessageDeliveriesCap;
        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);
        if (tstats.inMesh) {
          cap = this.params.topics[topic].meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
        }
      }
    }
  }
  /**
   * Increments the "mesh message deliveries" counter for messages we've seen before,
   * as long the message was received within the P3 window.
   */
  markDuplicateMessageDelivery(from3, topic, validatedTime) {
    const pstats = this.peerStats.get(from3);
    if (pstats != null) {
      const now = validatedTime !== void 0 ? Date.now() : 0;
      const tstats = this.getPtopicStats(pstats, topic);
      if (tstats != null && tstats.inMesh) {
        const tparams = this.params.topics[topic];
        if (validatedTime !== void 0) {
          const deliveryDelayMs = now - validatedTime;
          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;
          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);
          if (isLateDelivery) {
            return;
          }
        }
        const cap = tparams.meshMessageDeliveriesCap;
        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
      }
    }
  }
  /**
   * Removes an IP list from the tracking list for a peer.
   */
  removeIPsForPeer(id, ipsToRemove) {
    for (const ipToRemove of ipsToRemove) {
      const peerSet2 = this.peerIPs.get(ipToRemove);
      if (peerSet2 != null) {
        peerSet2.delete(id);
        if (peerSet2.size === 0) {
          this.peerIPs.delete(ipToRemove);
        }
      }
    }
  }
  /**
   * Returns topic stats if they exist, otherwise if the supplied parameters score the
   * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.
   */
  getPtopicStats(pstats, topic) {
    let topicStats = pstats.topics[topic];
    if (topicStats !== void 0) {
      return topicStats;
    }
    if (this.params.topics[topic] !== void 0) {
      topicStats = {
        inMesh: false,
        graftTime: 0,
        meshTime: 0,
        firstMessageDeliveries: 0,
        meshMessageDeliveries: 0,
        meshMessageDeliveriesActive: false,
        meshFailurePenalty: 0,
        invalidMessageDeliveries: 0
      };
      pstats.topics[topic] = topicStats;
      return topicStats;
    }
    return null;
  }
};

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/scoreMetrics.js
function computeScoreWeights(peer, pstats, params, peerIPs, topicStrToLabel) {
  let score = 0;
  const byTopic = /* @__PURE__ */ new Map();
  Object.entries(pstats.topics).forEach(([topic, tstats]) => {
    const topicLabel = topicStrToLabel.get(topic) ?? "unknown";
    const topicParams = params.topics[topic];
    if (topicParams === void 0) {
      return;
    }
    let topicScores = byTopic.get(topicLabel);
    if (topicScores == null) {
      topicScores = {
        p1w: 0,
        p2w: 0,
        p3w: 0,
        p3bw: 0,
        p4w: 0
      };
      byTopic.set(topicLabel, topicScores);
    }
    let p1w = 0;
    let p2w = 0;
    let p3w = 0;
    let p3bw = 0;
    let p4w = 0;
    if (tstats.inMesh) {
      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap);
      p1w += p1 * topicParams.timeInMeshWeight;
    }
    let p2 = tstats.firstMessageDeliveries;
    if (p2 > topicParams.firstMessageDeliveriesCap) {
      p2 = topicParams.firstMessageDeliveriesCap;
    }
    p2w += p2 * topicParams.firstMessageDeliveriesWeight;
    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
      const p3 = deficit * deficit;
      p3w += p3 * topicParams.meshMessageDeliveriesWeight;
    }
    const p3b = tstats.meshFailurePenalty;
    p3bw += p3b * topicParams.meshFailurePenaltyWeight;
    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
    p4w += p4 * topicParams.invalidMessageDeliveriesWeight;
    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight;
    topicScores.p1w += p1w;
    topicScores.p2w += p2w;
    topicScores.p3w += p3w;
    topicScores.p3bw += p3bw;
    topicScores.p4w += p4w;
  });
  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
    score = params.topicScoreCap;
    const capF = params.topicScoreCap / score;
    for (const ws of byTopic.values()) {
      ws.p1w *= capF;
      ws.p2w *= capF;
      ws.p3w *= capF;
      ws.p3bw *= capF;
      ws.p4w *= capF;
    }
  }
  let p5w = 0;
  let p6w = 0;
  let p7w = 0;
  const p5 = params.appSpecificScore(peer);
  p5w += p5 * params.appSpecificWeight;
  pstats.knownIPs.forEach((ip) => {
    if (params.IPColocationFactorWhitelist.has(ip)) {
      return;
    }
    const peersInIP = peerIPs.get(ip);
    const numPeersInIP = peersInIP != null ? peersInIP.size : 0;
    if (numPeersInIP > params.IPColocationFactorThreshold) {
      const surplus = numPeersInIP - params.IPColocationFactorThreshold;
      const p6 = surplus * surplus;
      p6w += p6 * params.IPColocationFactorWeight;
    }
  });
  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
  p7w += p7 * params.behaviourPenaltyWeight;
  score += p5w + p6w + p7w;
  return {
    byTopic,
    p5w,
    p6w,
    p7w,
    score
  };
}
function computeAllPeersScoreWeights(peerIdStrs, peerStats, params, peerIPs, topicStrToLabel) {
  const sw = {
    byTopic: /* @__PURE__ */ new Map(),
    p5w: [],
    p6w: [],
    p7w: [],
    score: []
  };
  for (const peerIdStr of peerIdStrs) {
    const pstats = peerStats.get(peerIdStr);
    if (pstats != null) {
      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel);
      for (const [topic, swPeerTopic] of swPeer.byTopic) {
        let swTopic = sw.byTopic.get(topic);
        if (swTopic == null) {
          swTopic = {
            p1w: [],
            p2w: [],
            p3w: [],
            p3bw: [],
            p4w: []
          };
          sw.byTopic.set(topic, swTopic);
        }
        swTopic.p1w.push(swPeerTopic.p1w);
        swTopic.p2w.push(swPeerTopic.p2w);
        swTopic.p3w.push(swPeerTopic.p3w);
        swTopic.p3bw.push(swPeerTopic.p3bw);
        swTopic.p4w.push(swPeerTopic.p4w);
      }
      sw.p5w.push(swPeer.p5w);
      sw.p6w.push(swPeer.p6w);
      sw.p7w.push(swPeer.p7w);
      sw.score.push(swPeer.score);
    } else {
      sw.p5w.push(0);
      sw.p6w.push(0);
      sw.p7w.push(0);
      sw.score.push(0);
    }
  }
  return sw;
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/stream.js
var OutboundStream = class {
  constructor(rawStream, errCallback, opts) {
    __publicField(this, "rawStream");
    __publicField(this, "pushable");
    __publicField(this, "closeController");
    __publicField(this, "maxBufferSize");
    this.rawStream = rawStream;
    this.pushable = pushable();
    this.closeController = new AbortController();
    this.maxBufferSize = opts.maxBufferSize ?? Infinity;
    this.closeController.signal.addEventListener("abort", () => {
      rawStream.close().catch((err) => {
        rawStream.abort(err);
      });
    });
    pipe(this.pushable, this.rawStream).catch(errCallback);
  }
  get protocol() {
    return this.rawStream.protocol;
  }
  push(data) {
    if (this.pushable.readableLength > this.maxBufferSize) {
      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
    }
    this.pushable.push(encode8.single(data));
  }
  /**
   * Same to push() but this is prefixed data so no need to encode length prefixed again
   */
  pushPrefixed(data) {
    if (this.pushable.readableLength > this.maxBufferSize) {
      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
    }
    this.pushable.push(data);
  }
  async close() {
    this.closeController.abort();
    await this.pushable.return();
  }
};
var InboundStream = class {
  constructor(rawStream, opts = {}) {
    __publicField(this, "source");
    __publicField(this, "rawStream");
    __publicField(this, "closeController");
    this.rawStream = rawStream;
    this.closeController = new AbortController();
    this.closeController.signal.addEventListener("abort", () => {
      rawStream.close().catch((err) => {
        rawStream.abort(err);
      });
    });
    this.source = pipe(this.rawStream, (source) => decode9(source, opts));
  }
  async close() {
    this.closeController.abort();
  }
};

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/tracer.js
var IWantTracer = class {
  constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {
    __publicField(this, "gossipsubIWantFollowupMs");
    __publicField(this, "msgIdToStrFn");
    __publicField(this, "metrics");
    /**
     * Promises to deliver a message
     * Map per message id, per peer, promise expiration time
     */
    __publicField(this, "promises", /* @__PURE__ */ new Map());
    /**
     * First request time by msgId. Used for metrics to track expire times.
     * Necessary to know if peers are actually breaking promises or simply sending them a bit later
     */
    __publicField(this, "requestMsByMsg", /* @__PURE__ */ new Map());
    __publicField(this, "requestMsByMsgExpire");
    this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;
    this.msgIdToStrFn = msgIdToStrFn;
    this.metrics = metrics;
    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;
  }
  get size() {
    return this.promises.size;
  }
  get requestMsByMsgSize() {
    return this.requestMsByMsg.size;
  }
  /**
   * Track a promise to deliver a message from a list of msgIds we are requesting
   */
  addPromise(from3, msgIds) {
    const ix = Math.floor(Math.random() * msgIds.length);
    const msgId3 = msgIds[ix];
    const msgIdStr = this.msgIdToStrFn(msgId3);
    let expireByPeer = this.promises.get(msgIdStr);
    if (expireByPeer == null) {
      expireByPeer = /* @__PURE__ */ new Map();
      this.promises.set(msgIdStr, expireByPeer);
    }
    const now = Date.now();
    if (!expireByPeer.has(from3)) {
      expireByPeer.set(from3, now + this.gossipsubIWantFollowupMs);
      if (this.metrics != null) {
        this.metrics.iwantPromiseStarted.inc(1);
        if (!this.requestMsByMsg.has(msgIdStr)) {
          this.requestMsByMsg.set(msgIdStr, now);
        }
      }
    }
  }
  /**
   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.
   *
   * This should be called not too often relative to the expire times, since it iterates over the whole data.
   */
  getBrokenPromises() {
    const now = Date.now();
    const result = /* @__PURE__ */ new Map();
    let brokenPromises = 0;
    this.promises.forEach((expireByPeer, msgId3) => {
      expireByPeer.forEach((expire, p2) => {
        if (expire < now) {
          result.set(p2, (result.get(p2) ?? 0) + 1);
          expireByPeer.delete(p2);
          brokenPromises++;
        }
      });
      if (expireByPeer.size === 0) {
        this.promises.delete(msgId3);
      }
    });
    this.metrics?.iwantPromiseBroken.inc(brokenPromises);
    return result;
  }
  /**
   * Someone delivered a message, stop tracking promises for it
   */
  deliverMessage(msgIdStr, isDuplicate = false) {
    this.trackMessage(msgIdStr);
    const expireByPeer = this.promises.get(msgIdStr);
    if (expireByPeer != null) {
      this.promises.delete(msgIdStr);
      if (this.metrics != null) {
        this.metrics.iwantPromiseResolved.inc(1);
        if (isDuplicate)
          this.metrics.iwantPromiseResolvedFromDuplicate.inc(1);
        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);
      }
    }
  }
  /**
   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,
   * unless its an obviously invalid message.
   */
  rejectMessage(msgIdStr, reason) {
    this.trackMessage(msgIdStr);
    switch (reason) {
      case RejectReason.Error:
        return;
      default:
        break;
    }
    this.promises.delete(msgIdStr);
  }
  clear() {
    this.promises.clear();
  }
  prune() {
    const maxMs = Date.now() - this.requestMsByMsgExpire;
    let count = 0;
    for (const [k, v] of this.requestMsByMsg.entries()) {
      if (v < maxMs) {
        this.requestMsByMsg.delete(k);
        count++;
      } else {
        break;
      }
    }
    this.metrics?.iwantMessagePruned.inc(count);
  }
  trackMessage(msgIdStr) {
    if (this.metrics != null) {
      const requestMs = this.requestMsByMsg.get(msgIdStr);
      if (requestMs !== void 0) {
        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1e3);
        this.requestMsByMsg.delete(msgIdStr);
      }
    }
  }
};

// ../../node_modules/@noble/hashes/legacy.js
var SHA1_IV = /* @__PURE__ */ Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = /* @__PURE__ */ new Uint32Array(80);
var _SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    __publicField(this, "A", SHA1_IV[0] | 0);
    __publicField(this, "B", SHA1_IV[1] | 0);
    __publicField(this, "C", SHA1_IV[2] | 0);
    __publicField(this, "D", SHA1_IV[3] | 0);
    __publicField(this, "E", SHA1_IV[4] | 0);
  }
  get() {
    const { A, B, C, D, E } = this;
    return [A, B, C, D, E];
  }
  set(A, B, C, D, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA1_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 80; i2++)
      SHA1_W[i2] = rotl(SHA1_W[i2 - 3] ^ SHA1_W[i2 - 8] ^ SHA1_W[i2 - 14] ^ SHA1_W[i2 - 16], 1);
    let { A, B, C, D, E } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      let F, K3;
      if (i2 < 20) {
        F = Chi(B, C, D);
        K3 = 1518500249;
      } else if (i2 < 40) {
        F = B ^ C ^ D;
        K3 = 1859775393;
      } else if (i2 < 60) {
        F = Maj(B, C, D);
        K3 = 2400959708;
      } else {
        F = B ^ C ^ D;
        K3 = 3395469782;
      }
      const T = rotl(A, 5) + F + E + K3 + SHA1_W[i2] | 0;
      E = D;
      D = C;
      C = rotl(B, 30);
      B = A;
      A = T;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C, D, E);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha1 = /* @__PURE__ */ createHasher(() => new _SHA1());
var p32 = /* @__PURE__ */ Math.pow(2, 32);
var K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i2) => Math.floor(p32 * Math.abs(Math.sin(i2 + 1))));
var MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
var MD5_W = /* @__PURE__ */ new Uint32Array(16);
var _MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    __publicField(this, "A", MD5_IV[0] | 0);
    __publicField(this, "B", MD5_IV[1] | 0);
    __publicField(this, "C", MD5_IV[2] | 0);
    __publicField(this, "D", MD5_IV[3] | 0);
  }
  get() {
    const { A, B, C, D } = this;
    return [A, B, C, D];
  }
  set(A, B, C, D) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      MD5_W[i2] = view.getUint32(offset, true);
    let { A, B, C, D } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      let F, g, s2;
      if (i2 < 16) {
        F = Chi(B, C, D);
        g = i2;
        s2 = [7, 12, 17, 22];
      } else if (i2 < 32) {
        F = Chi(D, B, C);
        g = (5 * i2 + 1) % 16;
        s2 = [5, 9, 14, 20];
      } else if (i2 < 48) {
        F = B ^ C ^ D;
        g = (3 * i2 + 5) % 16;
        s2 = [4, 11, 16, 23];
      } else {
        F = C ^ (B | ~D);
        g = 7 * i2 % 16;
        s2 = [6, 10, 15, 21];
      }
      F = F + A + K[i2] + MD5_W[g];
      A = D;
      D = C;
      C = B;
      B = B + rotl(F, s2[i2 % 4]);
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    this.set(A, B, C, D);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md5 = /* @__PURE__ */ createHasher(() => new _MD5());
var Rho160 = /* @__PURE__ */ Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i2) => i2)))();
var Pi160 = /* @__PURE__ */ (() => Id160.map((i2) => (9 * i2 + 5) % 16))();
var idxLR = /* @__PURE__ */ (() => {
  const L = [Id160];
  const R = [Pi160];
  const res = [L, R];
  for (let i2 = 0; i2 < 4; i2++)
    for (let j of res)
      j.push(j[i2].map((k) => Rho160[k]));
  return res;
})();
var idxL = /* @__PURE__ */ (() => idxLR[0])();
var idxR = /* @__PURE__ */ (() => idxLR[1])();
var shifts160 = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => Uint8Array.from(i2));
var shiftsL160 = /* @__PURE__ */ idxL.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var shiftsR160 = /* @__PURE__ */ idxR.map((idx, i2) => idx.map((j) => shifts160[i2][j]));
var Kl160 = /* @__PURE__ */ Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = /* @__PURE__ */ Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  if (group === 1)
    return x & y | ~x & z;
  if (group === 2)
    return (x | ~y) ^ z;
  if (group === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var BUF_160 = /* @__PURE__ */ new Uint32Array(16);
var _RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    __publicField(this, "h0", 1732584193 | 0);
    __publicField(this, "h1", 4023233417 | 0);
    __publicField(this, "h2", 2562383102 | 0);
    __publicField(this, "h3", 271733878 | 0);
    __publicField(this, "h4", 3285377520 | 0);
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      BUF_160[i2] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i2]] + hbl, sl[i2]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i2]] + hbr, sr[i2]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = /* @__PURE__ */ createHasher(() => new _RIPEMD160());

// ../../node_modules/@noble/hashes/pbkdf2.js
function pbkdf2Init(hash, _password, _salt, _opts) {
  ahash(hash);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c2, dkLen, asyncTick } = opts;
  anumber(c2, "c");
  anumber(dkLen, "dkLen");
  anumber(asyncTick, "asyncTick");
  if (c2 < 1)
    throw new Error("iterations (c) must be >= 1");
  const password = kdfInputToBytes(_password, "password");
  const salt = kdfInputToBytes(_salt, "salt");
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u2) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  clean(u2);
  return DK;
}
function pbkdf2(hash, password, salt, opts) {
  const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u2 = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
    Ti.set(u2.subarray(0, Ti.length));
    for (let ui = 1; ui < c2; ui++) {
      PRF._cloneInto(prfW).update(u2).digestInto(u2);
      for (let i2 = 0; i2 < Ti.length; i2++)
        Ti[i2] ^= u2[i2];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u2);
}
async function pbkdf2Async(hash, password, salt, opts) {
  const { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u2 = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u2);
    Ti.set(u2.subarray(0, Ti.length));
    await asyncLoop(c2 - 1, asyncTick, () => {
      PRF._cloneInto(prfW).update(u2).digestInto(u2);
      for (let i2 = 0; i2 < Ti.length; i2++)
        Ti[i2] ^= u2[i2];
    });
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u2);
}

// ../../node_modules/@libp2p/crypto/dist/src/pbkdf2.js
var hashName = {
  sha1,
  "sha2-256": sha2562,
  "sha2-512": sha5122
};
function pbkdf22(password, salt, iterations, keySize, hash) {
  if (hash !== "sha1" && hash !== "sha2-256" && hash !== "sha2-512") {
    const types = Object.keys(hashName).join(" / ");
    throw new InvalidParametersError2(`Hash '${hash}' is unknown or not supported. Must be ${types}`);
  }
  const hasher = hashName[hash];
  const dek = pbkdf2(hasher, password, salt, {
    c: iterations,
    dkLen: keySize
  });
  return base64.encode(dek).substring(1);
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/buildRawMessage.js
var SignPrefix = fromString2("libp2p-pubsub:");
async function buildRawMessage(publishConfig, topic, originalData, transformedData) {
  switch (publishConfig.type) {
    case PublishConfigType.Signing: {
      const rpcMsg = {
        from: publishConfig.author.toMultihash().bytes,
        data: transformedData,
        seqno: randomBytes2(8),
        topic,
        signature: void 0,
        // Exclude signature field for signing
        key: void 0
        // Exclude key field for signing
      };
      const bytes = concat([SignPrefix, RPC.Message.encode(rpcMsg)]);
      rpcMsg.signature = await publishConfig.privateKey.sign(bytes);
      rpcMsg.key = publishConfig.key;
      const msg = {
        type: "signed",
        from: publishConfig.author,
        data: originalData,
        sequenceNumber: BigInt(`0x${toString2(rpcMsg.seqno ?? new Uint8Array(0), "base16")}`),
        topic,
        signature: rpcMsg.signature,
        key: publicKeyFromProtobuf(rpcMsg.key)
      };
      return {
        raw: rpcMsg,
        msg
      };
    }
    case PublishConfigType.Anonymous: {
      return {
        raw: {
          from: void 0,
          data: transformedData,
          seqno: void 0,
          topic,
          signature: void 0,
          key: void 0
        },
        msg: {
          type: "unsigned",
          data: originalData,
          topic
        }
      };
    }
    default:
      throw new Error("Unreachable");
  }
}
async function validateToRawMessage(signaturePolicy, msg) {
  switch (signaturePolicy) {
    case StrictNoSign:
      if (msg.signature != null)
        return { valid: false, error: ValidateError.SignaturePresent };
      if (msg.seqno != null)
        return { valid: false, error: ValidateError.SeqnoPresent };
      if (msg.from != null)
        return { valid: false, error: ValidateError.FromPresent };
      return { valid: true, message: { type: "unsigned", topic: msg.topic, data: msg.data ?? new Uint8Array(0) } };
    case StrictSign: {
      if (msg.seqno == null)
        return { valid: false, error: ValidateError.InvalidSeqno };
      if (msg.seqno.length !== 8) {
        return { valid: false, error: ValidateError.InvalidSeqno };
      }
      if (msg.signature == null)
        return { valid: false, error: ValidateError.InvalidSignature };
      if (msg.from == null)
        return { valid: false, error: ValidateError.InvalidPeerId };
      let fromPeerId;
      try {
        fromPeerId = peerIdFromMultihash(decode4(msg.from));
      } catch (e2) {
        return { valid: false, error: ValidateError.InvalidPeerId };
      }
      let publicKey2;
      if (msg.key != null) {
        publicKey2 = publicKeyFromProtobuf(msg.key);
        if (fromPeerId.publicKey !== void 0 && !publicKey2.equals(fromPeerId.publicKey)) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
      } else {
        if (fromPeerId.publicKey == null) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
        publicKey2 = fromPeerId.publicKey;
      }
      const rpcMsgPreSign = {
        from: msg.from,
        data: msg.data,
        seqno: msg.seqno,
        topic: msg.topic,
        signature: void 0,
        // Exclude signature field for signing
        key: void 0
        // Exclude key field for signing
      };
      const bytes = concat([SignPrefix, RPC.Message.encode(rpcMsgPreSign)]);
      if (!await publicKey2.verify(bytes, msg.signature)) {
        return { valid: false, error: ValidateError.InvalidSignature };
      }
      return {
        valid: true,
        message: {
          type: "signed",
          from: fromPeerId,
          data: msg.data ?? new Uint8Array(0),
          sequenceNumber: BigInt(`0x${toString2(msg.seqno, "base16")}`),
          topic: msg.topic,
          signature: msg.signature,
          key: publicKey2
        }
      };
    }
    default:
      throw new Error("Unreachable");
  }
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/create-gossip-rpc.js
function createGossipRpc(messages2 = [], control) {
  return {
    subscriptions: [],
    messages: messages2,
    control: control !== void 0 ? {
      graft: control.graft ?? [],
      prune: control.prune ?? [],
      ihave: control.ihave ?? [],
      iwant: control.iwant ?? [],
      idontwant: control.idontwant ?? []
    } : void 0
  };
}
function ensureControl(rpc) {
  if (rpc.control === void 0) {
    rpc.control = {
      graft: [],
      prune: [],
      ihave: [],
      iwant: [],
      idontwant: []
    };
  }
  return rpc;
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/shuffle.js
function shuffle(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  const randInt = () => {
    return Math.floor(Math.random() * Math.floor(arr.length));
  };
  for (let i2 = 0; i2 < arr.length; i2++) {
    const j = randInt();
    const tmp = arr[i2];
    arr[i2] = arr[j];
    arr[j] = tmp;
  }
  return arr;
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/messageIdToString.js
function messageIdToString(msgId3) {
  return toString2(msgId3, "base64");
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/publishConfig.js
function getPublishConfigFromPeerId(signaturePolicy, peerId, privateKey) {
  switch (signaturePolicy) {
    case StrictSign: {
      return {
        type: PublishConfigType.Signing,
        author: peerId,
        key: publicKeyToProtobuf(privateKey.publicKey),
        privateKey
      };
    }
    case StrictNoSign:
      return {
        type: PublishConfigType.Anonymous
      };
    default:
      throw new Error(`Unknown signature policy "${signaturePolicy}"`);
  }
}

// ../../node_modules/@libp2p/pubsub/node_modules/@libp2p/interface/dist/src/peer-id.js
var peerIdSymbol3 = /* @__PURE__ */ Symbol.for("@libp2p/peer-id");
function isPeerId3(other) {
  return Boolean(other?.[peerIdSymbol3]);
}

// ../../node_modules/@libp2p/pubsub/node_modules/@libp2p/interface/dist/src/errors.js
var AbortError4 = class extends Error {
  constructor(message2 = "The operation was aborted") {
    super(message2);
    this.name = "AbortError";
  }
};
__publicField(AbortError4, "name", "AbortError");
var UnexpectedPeerError3 = class extends Error {
  constructor(message2 = "Unexpected Peer") {
    super(message2);
    this.name = "UnexpectedPeerError";
  }
};
__publicField(UnexpectedPeerError3, "name", "UnexpectedPeerError");
var InvalidCryptoExchangeError3 = class extends Error {
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    this.name = "InvalidCryptoExchangeError";
  }
};
__publicField(InvalidCryptoExchangeError3, "name", "InvalidCryptoExchangeError");
var InvalidParametersError3 = class extends Error {
  constructor(message2 = "Invalid parameters") {
    super(message2);
    this.name = "InvalidParametersError";
  }
};
__publicField(InvalidParametersError3, "name", "InvalidParametersError");
var InvalidPublicKeyError3 = class extends Error {
  constructor(message2 = "Invalid public key") {
    super(message2);
    this.name = "InvalidPublicKeyError";
  }
};
__publicField(InvalidPublicKeyError3, "name", "InvalidPublicKeyError");
var InvalidPrivateKeyError3 = class extends Error {
  constructor(message2 = "Invalid private key") {
    super(message2);
    this.name = "InvalidPrivateKeyError";
  }
};
__publicField(InvalidPrivateKeyError3, "name", "InvalidPrivateKeyError");
var UnsupportedOperationError3 = class extends Error {
  constructor(message2 = "Unsupported operation") {
    super(message2);
    this.name = "UnsupportedOperationError";
  }
};
__publicField(UnsupportedOperationError3, "name", "UnsupportedOperationError");
var ConnectionClosingError3 = class extends Error {
  constructor(message2 = "The connection is closing") {
    super(message2);
    this.name = "ConnectionClosingError";
  }
};
__publicField(ConnectionClosingError3, "name", "ConnectionClosingError");
var ConnectionClosedError3 = class extends Error {
  constructor(message2 = "The connection is closed") {
    super(message2);
    this.name = "ConnectionClosedError";
  }
};
__publicField(ConnectionClosedError3, "name", "ConnectionClosedError");
var ConnectionFailedError3 = class extends Error {
  constructor(message2 = "Connection failed") {
    super(message2);
    this.name = "ConnectionFailedError";
  }
};
__publicField(ConnectionFailedError3, "name", "ConnectionFailedError");
var MuxerClosedError3 = class extends Error {
  constructor(message2 = "The muxer is closed") {
    super(message2);
    this.name = "MuxerClosedError";
  }
};
__publicField(MuxerClosedError3, "name", "MuxerClosedError");
var StreamResetError3 = class extends Error {
  constructor(message2 = "The stream has been reset") {
    super(message2);
    this.name = "StreamResetError";
  }
};
__publicField(StreamResetError3, "name", "StreamResetError");
var StreamStateError3 = class extends Error {
  constructor(message2 = "The stream is in an invalid state") {
    super(message2);
    this.name = "StreamStateError";
  }
};
__publicField(StreamStateError3, "name", "StreamStateError");
var NotFoundError3 = class extends Error {
  constructor(message2 = "Not found") {
    super(message2);
    this.name = "NotFoundError";
  }
};
__publicField(NotFoundError3, "name", "NotFoundError");
var InvalidPeerIdError3 = class extends Error {
  constructor(message2 = "Invalid PeerID") {
    super(message2);
    this.name = "InvalidPeerIdError";
  }
};
__publicField(InvalidPeerIdError3, "name", "InvalidPeerIdError");
var InvalidMultiaddrError3 = class extends Error {
  constructor(message2 = "Invalid multiaddr") {
    super(message2);
    this.name = "InvalidMultiaddrError";
  }
};
__publicField(InvalidMultiaddrError3, "name", "InvalidMultiaddrError");
var InvalidCIDError3 = class extends Error {
  constructor(message2 = "Invalid CID") {
    super(message2);
    this.name = "InvalidCIDError";
  }
};
__publicField(InvalidCIDError3, "name", "InvalidCIDError");
var InvalidMultihashError3 = class extends Error {
  constructor(message2 = "Invalid Multihash") {
    super(message2);
    this.name = "InvalidMultihashError";
  }
};
__publicField(InvalidMultihashError3, "name", "InvalidMultihashError");
var UnsupportedProtocolError3 = class extends Error {
  constructor(message2 = "Unsupported protocol error") {
    super(message2);
    this.name = "UnsupportedProtocolError";
  }
};
__publicField(UnsupportedProtocolError3, "name", "UnsupportedProtocolError");
var InvalidMessageError3 = class extends Error {
  constructor(message2 = "Invalid message") {
    super(message2);
    this.name = "InvalidMessageError";
  }
};
__publicField(InvalidMessageError3, "name", "InvalidMessageError");
var ProtocolError3 = class extends Error {
  constructor(message2 = "Protocol error") {
    super(message2);
    this.name = "ProtocolError";
  }
};
__publicField(ProtocolError3, "name", "ProtocolError");
var TimeoutError3 = class extends Error {
  constructor(message2 = "Timed out") {
    super(message2);
    this.name = "TimeoutError";
  }
};
__publicField(TimeoutError3, "name", "TimeoutError");
var NotStartedError3 = class extends Error {
  constructor(message2 = "Not started") {
    super(message2);
    this.name = "NotStartedError";
  }
};
__publicField(NotStartedError3, "name", "NotStartedError");
var AlreadyStartedError3 = class extends Error {
  constructor(message2 = "Already started") {
    super(message2);
    this.name = "AlreadyStartedError";
  }
};
__publicField(AlreadyStartedError3, "name", "AlreadyStartedError");
var DialError3 = class extends Error {
  constructor(message2 = "Dial error") {
    super(message2);
    this.name = "DialError";
  }
};
__publicField(DialError3, "name", "DialError");
var ListenError3 = class extends Error {
  constructor(message2 = "Listen error") {
    super(message2);
    this.name = "ListenError";
  }
};
__publicField(ListenError3, "name", "ListenError");
var LimitedConnectionError3 = class extends Error {
  constructor(message2 = "Limited connection") {
    super(message2);
    this.name = "LimitedConnectionError";
  }
};
__publicField(LimitedConnectionError3, "name", "LimitedConnectionError");
var TooManyInboundProtocolStreamsError3 = class extends Error {
  constructor(message2 = "Too many inbound protocol streams") {
    super(message2);
    this.name = "TooManyInboundProtocolStreamsError";
  }
};
__publicField(TooManyInboundProtocolStreamsError3, "name", "TooManyInboundProtocolStreamsError");
var TooManyOutboundProtocolStreamsError3 = class extends Error {
  constructor(message2 = "Too many outbound protocol streams") {
    super(message2);
    this.name = "TooManyOutboundProtocolStreamsError";
  }
};
__publicField(TooManyOutboundProtocolStreamsError3, "name", "TooManyOutboundProtocolStreamsError");
var UnsupportedKeyTypeError3 = class extends Error {
  constructor(message2 = "Unsupported key type") {
    super(message2);
    this.name = "UnsupportedKeyTypeError";
  }
};
__publicField(UnsupportedKeyTypeError3, "name", "UnsupportedKeyTypeError");
var NotImplementedError3 = class extends Error {
  constructor(message2 = "Not implemented") {
    super(message2);
    this.name = "NotImplementedError";
  }
};
__publicField(NotImplementedError3, "name", "NotImplementedError");

// ../../node_modules/@libp2p/pubsub/node_modules/@libp2p/peer-id/dist/src/peer-id.js
var _a4, _b2, _c2;
var inspect2 = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var LIBP2P_KEY_CODE3 = 114;
var PeerIdImpl2 = class {
  constructor(init) {
    __publicField(this, "type");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "string");
    __publicField(this, _a4, true);
    this.type = init.type;
    this.multihash = init.multihash;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toMultihash() {
    return this.multihash;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE3, this.multihash);
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id == null) {
      return false;
    }
    if (id instanceof Uint8Array) {
      return equals3(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return this.toString() === id;
    } else if (id?.toMultihash()?.bytes != null) {
      return equals3(this.multihash.bytes, id.toMultihash().bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```TypeScript
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [(_a4 = peerIdSymbol3, inspect2)]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerId2 = class extends PeerIdImpl2 {
  constructor(init) {
    super({ ...init, type: "RSA" });
    __publicField(this, "type", "RSA");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerId2 = class extends PeerIdImpl2 {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    __publicField(this, "type", "Ed25519");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Secp256k1PeerId2 = class extends PeerIdImpl2 {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    __publicField(this, "type", "secp256k1");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE3 = 2336;
var URLPeerId2 = class {
  constructor(url) {
    __publicField(this, "type", "url");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "url");
    __publicField(this, _b2, true);
    this.url = url.toString();
    this.multihash = identity.digest(fromString2(this.url));
  }
  [(_c2 = inspect2, _b2 = peerIdSymbol3, _c2)]() {
    return `PeerId(${this.url})`;
  }
  toString() {
    return this.toCID().toString();
  }
  toMultihash() {
    return this.multihash;
  }
  toCID() {
    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE3, this.toMultihash());
  }
  toJSON() {
    return this.toString();
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString2(other);
    }
    return other.toString() === this.toString();
  }
};

// ../../node_modules/@libp2p/pubsub/node_modules/@libp2p/peer-id/dist/src/index.js
var LIBP2P_KEY_CODE4 = 114;
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE4 = 2336;
function peerIdFromString2(str, decoder) {
  let multihash;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    multihash = decode4(base58btc.decode(`z${str}`));
  } else if (str.startsWith("k51qzi5uqu5") || str.startsWith("kzwfwjn5ji4") || str.startsWith("k2k4r8") || str.startsWith("bafz")) {
    return peerIdFromCID2(CID.parse(str));
  } else {
    if (decoder == null) {
      throw new InvalidParametersError3('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
    }
    multihash = decode4(decoder.decode(str));
  }
  return peerIdFromMultihash2(multihash);
}
function peerIdFromPublicKey2(publicKey2) {
  if (publicKey2.type === "Ed25519") {
    return new Ed25519PeerId2({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  } else if (publicKey2.type === "secp256k1") {
    return new Secp256k1PeerId2({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  } else if (publicKey2.type === "RSA") {
    return new RSAPeerId2({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  }
  throw new UnsupportedKeyTypeError3();
}
function peerIdFromPrivateKey2(privateKey) {
  return peerIdFromPublicKey2(privateKey.publicKey);
}
function peerIdFromMultihash2(multihash) {
  if (isSha256Multihash2(multihash)) {
    return new RSAPeerId2({ multihash });
  } else if (isIdentityMultihash2(multihash)) {
    try {
      const publicKey2 = publicKeyFromMultihash(multihash);
      if (publicKey2.type === "Ed25519") {
        return new Ed25519PeerId2({ multihash, publicKey: publicKey2 });
      } else if (publicKey2.type === "secp256k1") {
        return new Secp256k1PeerId2({ multihash, publicKey: publicKey2 });
      }
    } catch (err) {
      const url = toString2(multihash.digest);
      return new URLPeerId2(new URL(url));
    }
  }
  throw new InvalidMultihashError3("Supplied PeerID Multihash is invalid");
}
function peerIdFromCID2(cid) {
  if (cid?.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE4 && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE4) {
    throw new InvalidCIDError3("Supplied PeerID CID is invalid");
  }
  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE4) {
    const url = toString2(cid.multihash.digest);
    return new URLPeerId2(new URL(url));
  }
  return peerIdFromMultihash2(cid.multihash);
}
function isIdentityMultihash2(multihash) {
  return multihash.code === identity.code;
}
function isSha256Multihash2(multihash) {
  return multihash.code === sha256.code;
}

// ../../node_modules/@libp2p/pubsub/dist/src/utils.js
function randomSeqno() {
  return BigInt(`0x${toString2(randomBytes2(8), "base16")}`);
}
var msgId = (key, seqno) => {
  const seqnoBytes = fromString2(seqno.toString(16).padStart(16, "0"), "base16");
  const keyBytes = publicKeyToProtobuf(key);
  const msgId3 = new Uint8Array(keyBytes.byteLength + seqnoBytes.length);
  msgId3.set(keyBytes, 0);
  msgId3.set(seqnoBytes, keyBytes.byteLength);
  return msgId3;
};
var noSignMsgId = (data) => {
  return sha256.encode(data);
};
var anyMatch = (a2, b) => {
  let bHas;
  if (Array.isArray(b)) {
    bHas = (val) => b.includes(val);
  } else {
    bHas = (val) => b.has(val);
  }
  for (const val of a2) {
    if (bHas(val)) {
      return true;
    }
  }
  return false;
};
var ensureArray = function(maybeArray) {
  if (!Array.isArray(maybeArray)) {
    return [maybeArray];
  }
  return maybeArray;
};
var isSigned = async (message2) => {
  if (message2.sequenceNumber == null || message2.from == null || message2.signature == null) {
    return false;
  }
  const fromID = peerIdFromMultihash2(decode4(message2.from));
  if (fromID.publicKey != null) {
    return true;
  }
  if (message2.key != null) {
    const signingKey = message2.key;
    const signingID = peerIdFromPublicKey2(publicKeyFromProtobuf(signingKey));
    return signingID.equals(fromID);
  }
  return false;
};
var toMessage = async (message2) => {
  if (message2.from == null) {
    throw new InvalidMessageError3("RPC message was missing from");
  }
  if (!await isSigned(message2)) {
    return {
      type: "unsigned",
      topic: message2.topic ?? "",
      data: message2.data ?? new Uint8Array(0)
    };
  }
  const from3 = peerIdFromMultihash2(decode4(message2.from));
  const key = message2.key ?? from3.publicKey;
  if (key == null) {
    throw new InvalidMessageError3("RPC message was missing public key");
  }
  const msg = {
    type: "signed",
    from: from3,
    topic: message2.topic ?? "",
    sequenceNumber: bigIntFromBytes(message2.sequenceNumber ?? new Uint8Array(0)),
    data: message2.data ?? new Uint8Array(0),
    signature: message2.signature ?? new Uint8Array(0),
    key: key instanceof Uint8Array ? publicKeyFromProtobuf(key) : key
  };
  return msg;
};
var toRpcMessage = (message2) => {
  if (message2.type === "signed") {
    return {
      from: message2.from.toMultihash().bytes,
      data: message2.data,
      sequenceNumber: bigIntToBytes(message2.sequenceNumber),
      topic: message2.topic,
      signature: message2.signature,
      key: message2.key ? publicKeyToProtobuf(message2.key) : void 0
    };
  }
  return {
    data: message2.data,
    topic: message2.topic
  };
};
var bigIntToBytes = (num2) => {
  let str = num2.toString(16);
  if (str.length % 2 !== 0) {
    str = `0${str}`;
  }
  return fromString2(str, "base16");
};
var bigIntFromBytes = (num2) => {
  return BigInt(`0x${toString2(num2, "base16")}`);
};

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/msgIdFn.js
function msgIdFnStrictSign(msg) {
  if (msg.type !== "signed") {
    throw new Error("expected signed message type");
  }
  if (msg.sequenceNumber == null)
    throw Error("missing seqno field");
  return msgId(msg.from.publicKey ?? msg.key, msg.sequenceNumber);
}
async function msgIdFnStrictNoSign(msg) {
  return sha256.encode(msg.data);
}

// ../../node_modules/@chainsafe/is-ip/lib/parser.js
var Parser = class {
  constructor() {
    __publicField(this, "index", 0);
    __publicField(this, "input", "");
  }
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  /** Run a parser, and restore the pre-parse state if it fails. */
  readAtomically(fn) {
    const index = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index;
    }
    return result;
  }
  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  /** Peek the next character from the input */
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  /** Read the next character from the input */
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  /** Read the next character from the input if it matches the target. */
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  /**
   * Helper for reading separators in an indexed loop. Reads the separator
   * character iff index > 0, then runs the parser. When used in a loop,
   * the separator character will only be read on index > 0 (see
   * readIPv4Addr for an example)
   */
  readSeparator(sep, index, inner) {
    return this.readAtomically(() => {
      if (index > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  /**
   * Read a number off the front of the input in the given radix, stopping
   * at the first non-digit character or eof. Fails if the number has more
   * digits than max_digits or if there is no number.
   */
  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue3 = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num2 = Number.parseInt(char, radix);
          if (Number.isNaN(num2)) {
            return void 0;
          }
          return num2;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix;
        result += digit;
        if (result > maxValue3) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  /** Read an IPv4 address. */
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i2 = 0; i2 < out.length; i2++) {
        const ix = this.readSeparator(".", i2, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i2] = ix;
      }
      return out;
    });
  }
  /** Read an IPv6 Address. */
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i2 = 0; i2 < groups.length / 2; i2++) {
        const ix = i2 * 2;
        if (i2 < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i2, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i2, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  /** Read an IP Address, either IPv4 or IPv6. */
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
};

// ../../node_modules/@chainsafe/is-ip/lib/parse.js
var MAX_IPV6_LENGTH = 45;
var MAX_IPV4_LENGTH = 15;
var parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
function parseIPv4Mapped(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  const ipv4 = parser.new(input).parseWith(() => parser.readIPv4Addr());
  if (ipv4 === void 0) {
    return void 0;
  }
  return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, ipv4[0], ipv4[1], ipv4[2], ipv4[3]]);
}
function parseIPv6(input) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
function parseIP(input, mapIPv4ToIPv6 = false) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  const addr = parser.new(input).parseWith(() => parser.readIPAddr());
  if (!addr) {
    return void 0;
  }
  if (mapIPv4ToIPv6 && addr.length === 4) {
    return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, addr[0], addr[1], addr[2], addr[3]]);
  }
  return addr;
}

// ../../node_modules/@chainsafe/netmask/dist/src/util.js
function allFF(a2, from3, to) {
  let i2 = 0;
  for (const e2 of a2) {
    if (i2 < from3)
      continue;
    if (i2 > to)
      break;
    if (e2 !== 255)
      return false;
    i2++;
  }
  return true;
}
function deepEqual(a2, b, from3, to) {
  let i2 = 0;
  for (const e2 of a2) {
    if (i2 < from3)
      continue;
    if (i2 > to)
      break;
    if (e2 !== b[i2])
      return false;
    i2++;
  }
  return true;
}
function ipToString(ip) {
  switch (ip.length) {
    case IPv4Len: {
      return ip.join(".");
    }
    case IPv6Len: {
      const result = [];
      for (let i2 = 0; i2 < ip.length; i2++) {
        if (i2 % 2 === 0) {
          result.push(ip[i2].toString(16).padStart(2, "0") + ip[i2 + 1].toString(16).padStart(2, "0"));
        }
      }
      return result.join(":");
    }
    default: {
      throw new Error("Invalid ip length");
    }
  }
}
function simpleMaskLength(mask) {
  let ones = 0;
  for (let [index, byte] of mask.entries()) {
    if (byte === 255) {
      ones += 8;
      continue;
    }
    while ((byte & 128) != 0) {
      ones++;
      byte = byte << 1;
    }
    if ((byte & 128) != 0) {
      return -1;
    }
    for (let i2 = index + 1; i2 < mask.length; i2++) {
      if (mask[i2] != 0) {
        return -1;
      }
    }
    break;
  }
  return ones;
}
function maskToHex(mask) {
  let hex = "0x";
  for (const byte of mask) {
    hex += (byte >> 4).toString(16) + (byte & 15).toString(16);
  }
  return hex;
}

// ../../node_modules/@chainsafe/netmask/dist/src/ip.js
var IPv4Len = 4;
var IPv6Len = 16;
var maxIPv6Octet = parseInt("0xFFFF", 16);
var ipv4Prefix = new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  255,
  255
]);
function maskIp(ip, mask) {
  if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {
    mask = mask.slice(12);
  }
  if (mask.length === IPv4Len && ip.length === IPv6Len && deepEqual(ip, ipv4Prefix, 0, 11)) {
    ip = ip.slice(12);
  }
  const n2 = ip.length;
  if (n2 != mask.length) {
    throw new Error("Failed to mask ip");
  }
  const out = new Uint8Array(n2);
  for (let i2 = 0; i2 < n2; i2++) {
    out[i2] = ip[i2] & mask[i2];
  }
  return out;
}
function containsIp(net, ip) {
  if (typeof ip === "string") {
    ip = parseIP(ip);
  }
  if (ip == null)
    throw new Error("Invalid ip");
  if (ip.length !== net.network.length) {
    return false;
  }
  for (let i2 = 0; i2 < ip.length; i2++) {
    if ((net.network[i2] & net.mask[i2]) !== (ip[i2] & net.mask[i2])) {
      return false;
    }
  }
  return true;
}
function iPv4FromIPv6(ip) {
  if (!isIPv4mappedIPv6(ip)) {
    throw new Error("Must have 0xffff prefix");
  }
  return ip.slice(12);
}
function isIPv4mappedIPv6(ip) {
  return deepEqual(ip, ipv4Prefix, 0, 11);
}

// ../../node_modules/@chainsafe/netmask/dist/src/cidr.js
function parseCidr(s2) {
  const [address, maskString] = s2.split("/");
  if (!address || !maskString)
    throw new Error("Failed to parse given CIDR: " + s2);
  let ipLength = IPv4Len;
  let ip = parseIPv4(address);
  if (ip == null) {
    ipLength = IPv6Len;
    ip = parseIPv6(address);
    if (ip == null)
      throw new Error("Failed to parse given CIDR: " + s2);
  }
  const m2 = parseInt(maskString, 10);
  if (Number.isNaN(m2) || String(m2).length !== maskString.length || m2 < 0 || m2 > ipLength * 8) {
    throw new Error("Failed to parse given CIDR: " + s2);
  }
  const mask = cidrMask(m2, 8 * ipLength);
  return {
    network: maskIp(ip, mask),
    mask
  };
}
function cidrMask(ones, bits) {
  if (bits !== 8 * IPv4Len && bits !== 8 * IPv6Len)
    throw new Error("Invalid CIDR mask");
  if (ones < 0 || ones > bits)
    throw new Error("Invalid CIDR mask");
  const l2 = bits / 8;
  const m2 = new Uint8Array(l2);
  for (let i2 = 0; i2 < l2; i2++) {
    if (ones >= 8) {
      m2[i2] = 255;
      ones -= 8;
      continue;
    }
    m2[i2] = 255 - (255 >> ones);
    ones = 0;
  }
  return m2;
}

// ../../node_modules/@chainsafe/netmask/dist/src/ipnet.js
var IpNet = class {
  /**
   *
   * @param ipOrCidr either network ip or full cidr address
   * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address
   */
  constructor(ipOrCidr, mask) {
    if (mask == null) {
      ({ network: this.network, mask: this.mask } = parseCidr(ipOrCidr));
    } else {
      const ipResult = parseIP(ipOrCidr);
      if (ipResult == null) {
        throw new Error("Failed to parse network");
      }
      mask = String(mask);
      const m2 = parseInt(mask, 10);
      if (Number.isNaN(m2) || String(m2).length !== mask.length || m2 < 0 || m2 > ipResult.length * 8) {
        const maskResult = parseIP(mask);
        if (maskResult == null) {
          throw new Error("Failed to parse mask");
        }
        this.mask = maskResult;
      } else {
        this.mask = cidrMask(m2, 8 * ipResult.length);
      }
      this.network = maskIp(ipResult, this.mask);
    }
  }
  /**
   * Checks if netmask contains ip address
   * @param ip
   * @returns
   */
  contains(ip) {
    return containsIp({ network: this.network, mask: this.mask }, ip);
  }
  /**Serializes back to string format */
  toString() {
    const l2 = simpleMaskLength(this.mask);
    const mask = l2 !== -1 ? String(l2) : maskToHex(this.mask);
    return ipToString(this.network) + "/" + mask;
  }
};

// ../../node_modules/@chainsafe/netmask/dist/src/index.js
function cidrContains(cidr, ip) {
  const ipnet = new IpNet(cidr);
  return ipnet.contains(ip);
}

// ../../node_modules/@chainsafe/is-ip/lib/is-ip.js
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}
function isIP(input) {
  return Boolean(parseIP(input));
}
function ipVersion(input) {
  if (isIPv4(input)) {
    return 4;
  } else if (isIPv6(input)) {
    return 6;
  } else {
    return void 0;
  }
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@multiformats/multiaddr/dist/src/constants.js
var CODE_IP4 = 4;
var CODE_TCP = 6;
var CODE_UDP = 273;
var CODE_DCCP = 33;
var CODE_IP6 = 41;
var CODE_IP6ZONE = 42;
var CODE_IPCIDR = 43;
var CODE_DNS = 53;
var CODE_DNS4 = 54;
var CODE_DNS6 = 55;
var CODE_DNSADDR = 56;
var CODE_SCTP = 132;
var CODE_UDT = 301;
var CODE_UTP = 302;
var CODE_UNIX = 400;
var CODE_P2P = 421;
var CODE_ONION = 444;
var CODE_ONION3 = 445;
var CODE_GARLIC64 = 446;
var CODE_GARLIC32 = 447;
var CODE_TLS = 448;
var CODE_SNI = 449;
var CODE_NOISE = 454;
var CODE_QUIC = 460;
var CODE_QUIC_V1 = 461;
var CODE_WEBTRANSPORT = 465;
var CODE_CERTHASH = 466;
var CODE_HTTP = 480;
var CODE_HTTP_PATH = 481;
var CODE_HTTPS = 443;
var CODE_WS = 477;
var CODE_WSS = 478;
var CODE_P2P_WEBSOCKET_STAR = 479;
var CODE_P2P_STARDUST = 277;
var CODE_P2P_WEBRTC_STAR = 275;
var CODE_P2P_WEBRTC_DIRECT = 276;
var CODE_WEBRTC_DIRECT = 280;
var CODE_WEBRTC = 281;
var CODE_P2P_CIRCUIT = 290;
var CODE_MEMORY = 777;

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@multiformats/multiaddr/dist/src/errors.js
var InvalidMultiaddrError4 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMultiaddrError");
  }
};
__publicField(InvalidMultiaddrError4, "name", "InvalidMultiaddrError");
var ValidationError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ValidationError");
  }
};
__publicField(ValidationError, "name", "ValidationError");
var InvalidParametersError4 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidParametersError");
  }
};
__publicField(InvalidParametersError4, "name", "InvalidParametersError");
var UnknownProtocolError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnknownProtocolError");
  }
};
__publicField(UnknownProtocolError, "name", "UnknownProtocolError");

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@multiformats/multiaddr/dist/src/utils.js
function bytesToString(base3) {
  return (buf2) => {
    return toString2(buf2, base3);
  };
}
function stringToBytes(base3) {
  return (buf2) => {
    return fromString2(buf2, base3);
  };
}
function bytes2port(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset).toString();
}
function port2bytes(port) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, typeof port === "string" ? parseInt(port) : port);
  return new Uint8Array(buf2);
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = fromString2(addr[0], "base32");
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base32.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion(buf2) {
  const addrBytes = buf2.subarray(0, buf2.length - 2);
  const portBytes = buf2.subarray(buf2.length - 2);
  const addr = toString2(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}
var ip4ToBytes = function(ip) {
  ip = ip.toString().trim();
  const bytes = new Uint8Array(4);
  ip.split(/\./g).forEach((byte, index) => {
    const value2 = parseInt(byte, 10);
    if (isNaN(value2) || value2 < 0 || value2 > 255) {
      throw new InvalidMultiaddrError4("Invalid byte value in IP address");
    }
    bytes[index] = value2;
  });
  return bytes;
};
var ip6ToBytes = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  const sections = ip.split(":", 8);
  let i2;
  for (i2 = 0; i2 < sections.length; i2++) {
    const isv4 = isIPv4(sections[i2]);
    let v4Buffer;
    if (isv4) {
      v4Buffer = ip4ToBytes(sections[i2]);
      sections[i2] = toString2(v4Buffer.subarray(0, 2), "base16");
    }
    if (v4Buffer != null && ++i2 < 8) {
      sections.splice(i2, 0, toString2(v4Buffer.subarray(2, 4), "base16"));
    }
  }
  if (sections[0] === "") {
    while (sections.length < 8) {
      sections.unshift("0");
    }
  } else if (sections[sections.length - 1] === "") {
    while (sections.length < 8) {
      sections.push("0");
    }
  } else if (sections.length < 8) {
    for (i2 = 0; i2 < sections.length && sections[i2] !== ""; i2++) {
    }
    const argv = [i2, 1];
    for (i2 = 9 - sections.length; i2 > 0; i2--) {
      argv.push("0");
    }
    sections.splice.apply(sections, argv);
  }
  const bytes = new Uint8Array(offset + 16);
  for (i2 = 0; i2 < sections.length; i2++) {
    if (sections[i2] === "") {
      sections[i2] = "0";
    }
    const word2 = parseInt(sections[i2], 16);
    if (isNaN(word2) || word2 < 0 || word2 > 65535) {
      throw new InvalidMultiaddrError4("Invalid byte value in IP address");
    }
    bytes[offset++] = word2 >> 8 & 255;
    bytes[offset++] = word2 & 255;
  }
  return bytes;
};
var ip4ToString = function(buf2) {
  if (buf2.byteLength !== 4) {
    throw new InvalidMultiaddrError4("IPv4 address was incorrect length");
  }
  const result = [];
  for (let i2 = 0; i2 < buf2.byteLength; i2++) {
    result.push(buf2[i2]);
  }
  return result.join(".");
};
var ip6ToString = function(buf2) {
  if (buf2.byteLength !== 16) {
    throw new InvalidMultiaddrError4("IPv6 address was incorrect length");
  }
  const result = [];
  for (let i2 = 0; i2 < buf2.byteLength; i2 += 2) {
    const byte1 = buf2[i2];
    const byte2 = buf2[i2 + 1];
    const tuple = `${byte1.toString(16).padStart(2, "0")}${byte2.toString(16).padStart(2, "0")}`;
    result.push(tuple);
  }
  const ip = result.join(":");
  try {
    const url = new URL(`http://[${ip}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError4(`Invalid IPv6 address "${ip}"`);
  }
};
function ip6StringToValue(str) {
  try {
    const url = new URL(`http://[${str}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError4(`Invalid IPv6 address "${str}"`);
  }
}
var decoders2 = Object.values(bases).map((c2) => c2.decoder);
var anybaseDecoder = (function() {
  let acc = decoders2[0].or(decoders2[1]);
  decoders2.slice(2).forEach((d2) => acc = acc.or(d2));
  return acc;
})();
function mb2bytes(mbstr) {
  return anybaseDecoder.decode(mbstr);
}
function bytes2mb(base3) {
  return (buf2) => {
    return base3.encoder.encode(buf2);
  };
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@multiformats/multiaddr/dist/src/validation.js
function integer(value2) {
  const int = parseInt(value2);
  if (int.toString() !== value2) {
    throw new ValidationError("Value must be an integer");
  }
}
function positive(value2) {
  if (value2 < 0) {
    throw new ValidationError("Value must be a positive integer, or zero");
  }
}
function maxValue(max) {
  return (value2) => {
    if (value2 > max) {
      throw new ValidationError(`Value must be smaller than or equal to ${max}`);
    }
  };
}
function validate(...funcs) {
  return (value2) => {
    for (const fn of funcs) {
      fn(value2);
    }
  };
}
var validatePort = validate(integer, positive, maxValue(65535));

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@multiformats/multiaddr/dist/src/registry.js
var V = -1;
var Registry = class {
  constructor() {
    __publicField(this, "protocolsByCode", /* @__PURE__ */ new Map());
    __publicField(this, "protocolsByName", /* @__PURE__ */ new Map());
  }
  getProtocol(key) {
    let codec;
    if (typeof key === "string") {
      codec = this.protocolsByName.get(key);
    } else {
      codec = this.protocolsByCode.get(key);
    }
    if (codec == null) {
      throw new UnknownProtocolError(`Protocol ${key} was unknown`);
    }
    return codec;
  }
  addProtocol(codec) {
    this.protocolsByCode.set(codec.code, codec);
    this.protocolsByName.set(codec.name, codec);
    codec.aliases?.forEach((alias) => {
      this.protocolsByName.set(alias, codec);
    });
  }
  removeProtocol(code5) {
    const codec = this.protocolsByCode.get(code5);
    if (codec == null) {
      return;
    }
    this.protocolsByCode.delete(codec.code);
    this.protocolsByName.delete(codec.name);
    codec.aliases?.forEach((alias) => {
      this.protocolsByName.delete(alias);
    });
  }
};
var registry = new Registry();
var codecs2 = [{
  code: CODE_IP4,
  name: "ip4",
  size: 32,
  valueToBytes: ip4ToBytes,
  bytesToValue: ip4ToString,
  validate: (value2) => {
    if (!isIPv4(value2)) {
      throw new ValidationError(`Invalid IPv4 address "${value2}"`);
    }
  }
}, {
  code: CODE_TCP,
  name: "tcp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_UDP,
  name: "udp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_DCCP,
  name: "dccp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_IP6,
  name: "ip6",
  size: 128,
  valueToBytes: ip6ToBytes,
  bytesToValue: ip6ToString,
  stringToValue: ip6StringToValue,
  validate: (value2) => {
    if (!isIPv6(value2)) {
      throw new ValidationError(`Invalid IPv6 address "${value2}"`);
    }
  }
}, {
  code: CODE_IP6ZONE,
  name: "ip6zone",
  size: V
}, {
  code: CODE_IPCIDR,
  name: "ipcidr",
  size: 8,
  bytesToValue: bytesToString("base10"),
  valueToBytes: stringToBytes("base10")
}, {
  code: CODE_DNS,
  name: "dns",
  size: V,
  resolvable: true
}, {
  code: CODE_DNS4,
  name: "dns4",
  size: V,
  resolvable: true
}, {
  code: CODE_DNS6,
  name: "dns6",
  size: V,
  resolvable: true
}, {
  code: CODE_DNSADDR,
  name: "dnsaddr",
  size: V,
  resolvable: true
}, {
  code: CODE_SCTP,
  name: "sctp",
  size: 16,
  valueToBytes: port2bytes,
  bytesToValue: bytes2port,
  validate: validatePort
}, {
  code: CODE_UDT,
  name: "udt"
}, {
  code: CODE_UTP,
  name: "utp"
}, {
  code: CODE_UNIX,
  name: "unix",
  size: V,
  path: true,
  stringToValue: (str) => decodeURIComponent(str),
  valueToString: (val) => encodeURIComponent(val)
}, {
  code: CODE_P2P,
  name: "p2p",
  aliases: ["ipfs"],
  size: V,
  bytesToValue: bytesToString("base58btc"),
  valueToBytes: (val) => {
    if (val.startsWith("Q") || val.startsWith("1")) {
      return stringToBytes("base58btc")(val);
    }
    return CID.parse(val).multihash.bytes;
  }
}, {
  code: CODE_ONION,
  name: "onion",
  size: 96,
  bytesToValue: bytes2onion,
  valueToBytes: onion2bytes
}, {
  code: CODE_ONION3,
  name: "onion3",
  size: 296,
  bytesToValue: bytes2onion,
  valueToBytes: onion32bytes
}, {
  code: CODE_GARLIC64,
  name: "garlic64",
  size: V
}, {
  code: CODE_GARLIC32,
  name: "garlic32",
  size: V
}, {
  code: CODE_TLS,
  name: "tls"
}, {
  code: CODE_SNI,
  name: "sni",
  size: V
}, {
  code: CODE_NOISE,
  name: "noise"
}, {
  code: CODE_QUIC,
  name: "quic"
}, {
  code: CODE_QUIC_V1,
  name: "quic-v1"
}, {
  code: CODE_WEBTRANSPORT,
  name: "webtransport"
}, {
  code: CODE_CERTHASH,
  name: "certhash",
  size: V,
  bytesToValue: bytes2mb(base64url),
  valueToBytes: mb2bytes
}, {
  code: CODE_HTTP,
  name: "http"
}, {
  code: CODE_HTTP_PATH,
  name: "http-path",
  size: V,
  stringToValue: (str) => `/${decodeURIComponent(str)}`,
  valueToString: (val) => encodeURIComponent(val.substring(1))
}, {
  code: CODE_HTTPS,
  name: "https"
}, {
  code: CODE_WS,
  name: "ws"
}, {
  code: CODE_WSS,
  name: "wss"
}, {
  code: CODE_P2P_WEBSOCKET_STAR,
  name: "p2p-websocket-star"
}, {
  code: CODE_P2P_STARDUST,
  name: "p2p-stardust"
}, {
  code: CODE_P2P_WEBRTC_STAR,
  name: "p2p-webrtc-star"
}, {
  code: CODE_P2P_WEBRTC_DIRECT,
  name: "p2p-webrtc-direct"
}, {
  code: CODE_WEBRTC_DIRECT,
  name: "webrtc-direct"
}, {
  code: CODE_WEBRTC,
  name: "webrtc"
}, {
  code: CODE_P2P_CIRCUIT,
  name: "p2p-circuit"
}, {
  code: CODE_MEMORY,
  name: "memory",
  size: V
}];
codecs2.forEach((codec) => {
  registry.addProtocol(codec);
});

// ../../node_modules/@chainsafe/libp2p-gossipsub/node_modules/@multiformats/multiaddr/dist/src/convert.js
function convertToIpNet(multiaddr2) {
  let mask;
  let addr;
  multiaddr2.getComponents().forEach((component) => {
    if (component.name === "ip4" || component.name === "ip6") {
      addr = component.value;
    }
    if (component.name === "ipcidr") {
      mask = component.value;
    }
  });
  if (mask == null || addr == null) {
    throw new Error("Invalid multiaddr");
  }
  return new IpNet(addr, mask);
}
function convert(proto, a2) {
  if (a2 instanceof Uint8Array) {
    return convertToString(proto, a2);
  } else {
    return convertToBytes(proto, a2);
  }
}
function convertToString(proto, buf2) {
  const protocol2 = registry.getProtocol(proto);
  return protocol2.bytesToValue?.(buf2) ?? toString2(buf2, "base16");
}
function convertToBytes(proto, str) {
  const protocol2 = registry.getProtocol(proto);
  return protocol2.valueToBytes?.(str) ?? fromString2(str, "base16");
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/multiaddr.js
var Protocol;
(function(Protocol2) {
  Protocol2[Protocol2["ip4"] = 4] = "ip4";
  Protocol2[Protocol2["ip6"] = 41] = "ip6";
})(Protocol || (Protocol = {}));
function multiaddrToIPStr(multiaddr2) {
  for (const tuple of multiaddr2.tuples()) {
    switch (tuple[0]) {
      case Protocol.ip4:
      case Protocol.ip6:
        return convertToString(tuple[0], tuple[1]);
      default:
        break;
    }
  }
  return null;
}

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/time-cache.js
var SimpleTimeCache = class {
  constructor(opts) {
    __publicField(this, "entries", /* @__PURE__ */ new Map());
    __publicField(this, "validityMs");
    this.validityMs = opts.validityMs;
  }
  get size() {
    return this.entries.size;
  }
  /** Returns true if there was a key collision and the entry is dropped */
  put(key, value2) {
    if (this.entries.has(key)) {
      return true;
    }
    this.entries.set(key, { value: value2, validUntilMs: Date.now() + this.validityMs });
    return false;
  }
  prune() {
    const now = Date.now();
    for (const [k, v] of this.entries.entries()) {
      if (v.validUntilMs < now) {
        this.entries.delete(k);
      } else {
        break;
      }
    }
  }
  has(key) {
    return this.entries.has(key);
  }
  get(key) {
    const value2 = this.entries.get(key);
    return value2 != null && value2.validUntilMs >= Date.now() ? value2.value : void 0;
  }
  clear() {
    this.entries.clear();
  }
};

// ../../node_modules/@chainsafe/libp2p-gossipsub/dist/src/index.js
var _a5, _b3, _c3, _d;
var multicodec = GossipsubIDv12;
var GossipStatusCode;
(function(GossipStatusCode2) {
  GossipStatusCode2[GossipStatusCode2["started"] = 0] = "started";
  GossipStatusCode2[GossipStatusCode2["stopped"] = 1] = "stopped";
})(GossipStatusCode || (GossipStatusCode = {}));
var GossipSub = class extends (_d = TypedEventEmitter, _c3 = Symbol.toStringTag, _b3 = serviceCapabilities, _a5 = serviceDependencies, _d) {
  constructor(components, options2 = {}) {
    super();
    /**
     * The signature policy to follow by default
     */
    __publicField(this, "globalSignaturePolicy");
    __publicField(this, "multicodecs", [GossipsubIDv12, GossipsubIDv11, GossipsubIDv10]);
    __publicField(this, "publishConfig");
    __publicField(this, "dataTransform");
    // State
    __publicField(this, "peers", /* @__PURE__ */ new Map());
    __publicField(this, "streamsInbound", /* @__PURE__ */ new Map());
    __publicField(this, "streamsOutbound", /* @__PURE__ */ new Map());
    /** Ensures outbound streams are created sequentially */
    __publicField(this, "outboundInflightQueue", pushable({ objectMode: true }));
    /** Direct peers */
    __publicField(this, "direct", /* @__PURE__ */ new Set());
    /** Floodsub peers */
    __publicField(this, "floodsubPeers", /* @__PURE__ */ new Set());
    /** Cache of seen messages */
    __publicField(this, "seenCache");
    /**
     * Map of peer id and AcceptRequestWhileListEntry
     */
    __publicField(this, "acceptFromWhitelist", /* @__PURE__ */ new Map());
    /**
     * Map of topics to which peers are subscribed to
     */
    __publicField(this, "topics", /* @__PURE__ */ new Map());
    /**
     * List of our subscriptions
     */
    __publicField(this, "subscriptions", /* @__PURE__ */ new Set());
    /**
     * Map of topic meshes
     * topic => peer id set
     */
    __publicField(this, "mesh", /* @__PURE__ */ new Map());
    /**
     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership
     * topic => peer id set
     */
    __publicField(this, "fanout", /* @__PURE__ */ new Map());
    /**
     * Map of last publish time for fanout topics
     * topic => last publish time
     */
    __publicField(this, "fanoutLastpub", /* @__PURE__ */ new Map());
    /**
     * Map of pending messages to gossip
     * peer id => control messages
     */
    __publicField(this, "gossip", /* @__PURE__ */ new Map());
    /**
     * Map of control messages
     * peer id => control message
     */
    __publicField(this, "control", /* @__PURE__ */ new Map());
    /**
     * Number of IHAVEs received from peer in the last heartbeat
     */
    __publicField(this, "peerhave", /* @__PURE__ */ new Map());
    /** Number of messages we have asked from peer in the last heartbeat */
    __publicField(this, "iasked", /* @__PURE__ */ new Map());
    /** Prune backoff map */
    __publicField(this, "backoff", /* @__PURE__ */ new Map());
    /**
     * Connection direction cache, marks peers with outbound connections
     * peer id => direction
     */
    __publicField(this, "outbound", /* @__PURE__ */ new Map());
    __publicField(this, "msgIdFn");
    /**
     * A fast message id function used for internal message de-duplication
     */
    __publicField(this, "fastMsgIdFn");
    __publicField(this, "msgIdToStrFn");
    /** Maps fast message-id to canonical message-id */
    __publicField(this, "fastMsgIdCache");
    /**
     * Short term cache for published message ids. This is used for penalizing peers sending
     * our own messages back if the messages are anonymous or use a random author.
     */
    __publicField(this, "publishedMessageIds");
    /**
     * A message cache that contains the messages for last few heartbeat ticks
     */
    __publicField(this, "mcache");
    /** Peer score tracking */
    __publicField(this, "score");
    /**
     * Custom validator function per topic.
     * Must return or resolve quickly (< 100ms) to prevent causing penalties for late messages.
     * If you need to apply validation that may require longer times use `asyncValidation` option and callback the
     * validation result through `Gossipsub.reportValidationResult`
     */
    __publicField(this, "topicValidators", /* @__PURE__ */ new Map());
    /**
     * Make this protected so child class may want to redirect to its own log.
     */
    __publicField(this, "log");
    /**
     * Number of heartbeats since the beginning of time
     * This allows us to amortize some resource cleanup -- eg: backoff cleanup
     */
    __publicField(this, "heartbeatTicks", 0);
    /**
     * Tracks IHAVE/IWANT promises broken by peers
     */
    __publicField(this, "gossipTracer");
    /**
     * Tracks IDONTWANT messages received by peers in the current heartbeat
     */
    __publicField(this, "idontwantCounts", /* @__PURE__ */ new Map());
    /**
     * Tracks IDONTWANT messages received by peers and the heartbeat they were received in
     *
     * idontwants are stored for `mcacheLength` heartbeats before being pruned,
     * so this map is bounded by peerCount * idontwantMaxMessages * mcacheLength
     */
    __publicField(this, "idontwants", /* @__PURE__ */ new Map());
    __publicField(this, "components");
    __publicField(this, "directPeerInitial", null);
    // Options
    __publicField(this, "opts");
    __publicField(this, "decodeRpcLimits");
    __publicField(this, "metrics");
    __publicField(this, "status", { code: GossipStatusCode.stopped });
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "runOnLimitedConnection");
    __publicField(this, "allowedTopics");
    __publicField(this, "heartbeatTimer", null);
    __publicField(this, _c3, "@chainsafe/libp2p-gossipsub");
    __publicField(this, _b3, [
      "@libp2p/pubsub"
    ]);
    __publicField(this, _a5, [
      "@libp2p/identify"
    ]);
    __publicField(this, "runHeartbeat", () => {
      const timer = this.metrics?.heartbeatDuration.startTimer();
      this.heartbeat().catch((err) => {
        this.log("Error running heartbeat", err);
      }).finally(() => {
        if (timer != null) {
          timer();
        }
        if (this.status.code === GossipStatusCode.started) {
          clearTimeout(this.status.heartbeatTimeout);
          let msToNextHeartbeat = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {
            msToNextHeartbeat += this.opts.heartbeatInterval;
            this.metrics?.heartbeatSkipped.inc();
          }
          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);
        }
      });
    });
    __publicField(this, "tagMeshPeer", (evt) => {
      const { peerId, topic } = evt.detail;
      this.components.peerStore.merge(this.peers.get(peerId) ?? peerIdFromString(peerId), {
        tags: {
          [topic]: {
            value: 100
          }
        }
      }).catch((err) => {
        this.log.error("Error tagging peer %s with topic %s", peerId, topic, err);
      });
    });
    __publicField(this, "untagMeshPeer", (evt) => {
      const { peerId, topic } = evt.detail;
      this.components.peerStore.merge(this.peers.get(peerId) ?? peerIdFromString(peerId), {
        tags: {
          [topic]: void 0
        }
      }).catch((err) => {
        this.log.error("Error untagging peer %s with topic %s", peerId, topic, err);
      });
    });
    const opts = {
      fallbackToFloodsub: true,
      floodPublish: true,
      batchPublish: false,
      tagMeshPeers: true,
      doPX: false,
      directPeers: [],
      D: GossipsubD,
      Dlo: GossipsubDlo,
      Dhi: GossipsubDhi,
      Dscore: GossipsubDscore,
      Dout: GossipsubDout,
      Dlazy: GossipsubDlazy,
      heartbeatInterval: GossipsubHeartbeatInterval,
      fanoutTTL: GossipsubFanoutTTL,
      mcacheLength: GossipsubHistoryLength,
      mcacheGossip: GossipsubHistoryGossip,
      seenTTL: GossipsubSeenTTL,
      gossipsubIWantFollowupMs: GossipsubIWantFollowupTime,
      prunePeers: GossipsubPrunePeers,
      pruneBackoff: GossipsubPruneBackoff,
      unsubcribeBackoff: GossipsubUnsubscribeBackoff,
      graftFloodThreshold: GossipsubGraftFloodThreshold,
      opportunisticGraftPeers: GossipsubOpportunisticGraftPeers,
      opportunisticGraftTicks: GossipsubOpportunisticGraftTicks,
      directConnectTicks: GossipsubDirectConnectTicks,
      gossipFactor: GossipsubGossipFactor,
      idontwantMinDataSize: GossipsubIdontwantMinDataSize,
      idontwantMaxMessages: GossipsubIdontwantMaxMessages,
      ...options2,
      scoreParams: createPeerScoreParams(options2.scoreParams),
      scoreThresholds: createPeerScoreThresholds(options2.scoreThresholds)
    };
    this.components = components;
    this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits;
    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign;
    if (opts.fallbackToFloodsub) {
      this.multicodecs.push(FloodsubID);
    }
    this.log = components.logger.forComponent(opts.debugName ?? "libp2p:gossipsub");
    this.opts = opts;
    this.direct = new Set(opts.directPeers.map((p2) => p2.id.toString()));
    this.seenCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    this.publishedMessageIds = new SimpleTimeCache({ validityMs: opts.seenTTL });
    if (options2.msgIdFn != null) {
      this.msgIdFn = options2.msgIdFn;
    } else {
      switch (this.globalSignaturePolicy) {
        case StrictSign:
          this.msgIdFn = msgIdFnStrictSign;
          break;
        case StrictNoSign:
          this.msgIdFn = msgIdFnStrictNoSign;
          break;
        default:
          throw new Error(`Invalid globalSignaturePolicy: ${this.globalSignaturePolicy}`);
      }
    }
    if (options2.fastMsgIdFn != null) {
      this.fastMsgIdFn = options2.fastMsgIdFn;
      this.fastMsgIdCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
    }
    this.msgIdToStrFn = options2.msgIdToStrFn ?? messageIdToString;
    this.mcache = options2.messageCache ?? new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);
    if (options2.dataTransform != null) {
      this.dataTransform = options2.dataTransform;
    }
    if (options2.metricsRegister != null) {
      if (options2.metricsTopicStrToLabel == null) {
        throw Error("Must set metricsTopicStrToLabel with metrics");
      }
      const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow), DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);
      const metrics = getMetrics(options2.metricsRegister, options2.metricsTopicStrToLabel, {
        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1e3,
        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,
        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1e3
      });
      metrics.mcacheSize.addCollect(() => {
        this.onScrapeMetrics(metrics);
      });
      for (const protocol2 of this.multicodecs) {
        metrics.protocolsEnabled.set({ protocol: protocol2 }, 1);
      }
      this.metrics = metrics;
    } else {
      this.metrics = null;
    }
    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);
    this.score = new PeerScore(this.opts.scoreParams, this.metrics, this.components.logger, {
      scoreCacheValidityMs: opts.heartbeatInterval
    });
    this.maxInboundStreams = options2.maxInboundStreams;
    this.maxOutboundStreams = options2.maxOutboundStreams;
    this.runOnLimitedConnection = options2.runOnLimitedConnection;
    this.allowedTopics = opts.allowedTopics != null ? new Set(opts.allowedTopics) : null;
  }
  getPeers() {
    return [...this.peers.values()];
  }
  isStarted() {
    return this.status.code === GossipStatusCode.started;
  }
  // LIFECYCLE METHODS
  /**
   * Mounts the gossipsub protocol onto the libp2p node and sends our
   * our subscriptions to every peer connected
   */
  async start() {
    if (this.isStarted()) {
      return;
    }
    this.log("starting");
    this.publishConfig = getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId, this.components.privateKey);
    this.outboundInflightQueue = pushable({ objectMode: true });
    pipe(this.outboundInflightQueue, async (source) => {
      for await (const { peerId, connection } of source) {
        await this.createOutboundStream(peerId, connection);
      }
    }).catch((e2) => {
      this.log.error("outbound inflight queue error", e2);
    });
    await Promise.all(this.opts.directPeers.map(async (p2) => {
      await this.components.peerStore.merge(p2.id, {
        multiaddrs: p2.addrs
      });
    }));
    const registrar = this.components.registrar;
    await Promise.all(this.multicodecs.map(async (multicodec3) => registrar.handle(multicodec3, this.onIncomingStream.bind(this), {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    })));
    const topology = {
      onConnect: this.onPeerConnected.bind(this),
      onDisconnect: this.onPeerDisconnected.bind(this),
      notifyOnLimitedConnection: this.runOnLimitedConnection
    };
    const registrarTopologyIds = await Promise.all(this.multicodecs.map(async (multicodec3) => registrar.register(multicodec3, topology)));
    const heartbeatTimeout = setTimeout(this.runHeartbeat, GossipsubHeartbeatInitialDelay);
    this.status = {
      code: GossipStatusCode.started,
      registrarTopologyIds,
      heartbeatTimeout,
      hearbeatStartMs: Date.now() + GossipsubHeartbeatInitialDelay
    };
    this.score.start();
    this.directPeerInitial = setTimeout(() => {
      Promise.resolve().then(async () => {
        await Promise.all(Array.from(this.direct).map(async (id) => this.connect(id)));
      }).catch((err) => {
        this.log(err);
      });
    }, GossipsubDirectConnectInitialDelay);
    if (this.opts.tagMeshPeers) {
      this.addEventListener("gossipsub:graft", this.tagMeshPeer);
      this.addEventListener("gossipsub:prune", this.untagMeshPeer);
    }
    this.log("started");
  }
  /**
   * Unmounts the gossipsub protocol and shuts down every connection
   */
  async stop() {
    this.log("stopping");
    if (this.status.code !== GossipStatusCode.started) {
      return;
    }
    const { registrarTopologyIds } = this.status;
    this.status = { code: GossipStatusCode.stopped };
    if (this.opts.tagMeshPeers) {
      this.removeEventListener("gossipsub:graft", this.tagMeshPeer);
      this.removeEventListener("gossipsub:prune", this.untagMeshPeer);
    }
    const registrar = this.components.registrar;
    await Promise.all(this.multicodecs.map(async (multicodec3) => registrar.unhandle(multicodec3)));
    registrarTopologyIds.forEach((id) => {
      registrar.unregister(id);
    });
    this.outboundInflightQueue.end();
    const closePromises = [];
    for (const outboundStream of this.streamsOutbound.values()) {
      closePromises.push(outboundStream.close());
    }
    this.streamsOutbound.clear();
    for (const inboundStream of this.streamsInbound.values()) {
      closePromises.push(inboundStream.close());
    }
    this.streamsInbound.clear();
    await Promise.all(closePromises);
    this.peers.clear();
    this.subscriptions.clear();
    if (this.heartbeatTimer != null) {
      this.heartbeatTimer.cancel();
      this.heartbeatTimer = null;
    }
    this.score.stop();
    this.mesh.clear();
    this.fanout.clear();
    this.fanoutLastpub.clear();
    this.gossip.clear();
    this.control.clear();
    this.peerhave.clear();
    this.iasked.clear();
    this.backoff.clear();
    this.outbound.clear();
    this.gossipTracer.clear();
    this.seenCache.clear();
    if (this.fastMsgIdCache != null)
      this.fastMsgIdCache.clear();
    if (this.directPeerInitial != null)
      clearTimeout(this.directPeerInitial);
    this.idontwantCounts.clear();
    this.idontwants.clear();
    this.log("stopped");
  }
  /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */
  dumpPeerScoreStats() {
    return this.score.dumpPeerScoreStats();
  }
  /**
   * On an inbound stream opened
   */
  onIncomingStream({ stream, connection }) {
    if (!this.isStarted()) {
      return;
    }
    const peerId = connection.remotePeer;
    this.addPeer(peerId, connection.direction, connection.remoteAddr);
    this.createInboundStream(peerId, stream);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  /**
   * Registrar notifies an established connection with pubsub protocol
   */
  onPeerConnected(peerId, connection) {
    this.metrics?.newConnectionCount.inc({ status: connection.status });
    if (!this.isStarted() || connection.status !== "open") {
      return;
    }
    this.addPeer(peerId, connection.direction, connection.remoteAddr);
    this.outboundInflightQueue.push({ peerId, connection });
  }
  /**
   * Registrar notifies a closing connection with pubsub protocol
   */
  onPeerDisconnected(peerId) {
    this.log("connection ended %p", peerId);
    this.removePeer(peerId);
  }
  async createOutboundStream(peerId, connection) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    if (this.streamsOutbound.has(id)) {
      return;
    }
    try {
      const stream = new OutboundStream(await connection.newStream(this.multicodecs, {
        runOnLimitedConnection: this.runOnLimitedConnection
      }), (e2) => {
        this.log.error("outbound pipe error", e2);
      }, { maxBufferSize: this.opts.maxOutboundBufferSize });
      this.log("create outbound stream %p", peerId);
      this.streamsOutbound.set(id, stream);
      const protocol2 = stream.protocol;
      if (protocol2 === FloodsubID) {
        this.floodsubPeers.add(id);
      }
      this.metrics?.peersPerProtocol.inc({ protocol: protocol2 }, 1);
      if (this.subscriptions.size > 0) {
        this.log("send subscriptions to", id);
        this.sendSubscriptions(id, Array.from(this.subscriptions), true);
      }
    } catch (e2) {
      this.log.error("createOutboundStream error", e2);
    }
  }
  createInboundStream(peerId, stream) {
    if (!this.isStarted()) {
      return;
    }
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    const priorInboundStream = this.streamsInbound.get(id);
    if (priorInboundStream !== void 0) {
      this.log("replacing existing inbound steam %s", id);
      priorInboundStream.close().catch((err) => {
        this.log.error(err);
      });
    }
    this.log("create inbound stream %s", id);
    const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength });
    this.streamsInbound.set(id, inboundStream);
    this.pipePeerReadStream(peerId, inboundStream.source).catch((err) => {
      this.log(err);
    });
  }
  /**
   * Add a peer to the router
   */
  addPeer(peerId, direction, addr) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      this.log("new peer %p", peerId);
      this.peers.set(id, peerId);
      this.score.addPeer(id);
      const currentIP = multiaddrToIPStr(addr);
      if (currentIP !== null) {
        this.score.addIP(id, currentIP);
      } else {
        this.log("Added peer has no IP in current address %s %s", id, addr.toString());
      }
      if (!this.outbound.has(id)) {
        this.outbound.set(id, direction === "outbound");
      }
    }
  }
  /**
   * Removes a peer from the router
   */
  removePeer(peerId) {
    const id = peerId.toString();
    if (!this.peers.has(id)) {
      return;
    }
    this.log("delete peer %p", peerId);
    this.peers.delete(id);
    const outboundStream = this.streamsOutbound.get(id);
    const inboundStream = this.streamsInbound.get(id);
    if (outboundStream != null) {
      this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1);
    }
    outboundStream?.close().catch((err) => {
      this.log.error(err);
    });
    inboundStream?.close().catch((err) => {
      this.log.error(err);
    });
    this.streamsOutbound.delete(id);
    this.streamsInbound.delete(id);
    for (const peers of this.topics.values()) {
      peers.delete(id);
    }
    for (const [topicStr, peers] of this.mesh) {
      if (peers.delete(id)) {
        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);
      }
    }
    for (const peers of this.fanout.values()) {
      peers.delete(id);
    }
    this.floodsubPeers.delete(id);
    this.gossip.delete(id);
    this.control.delete(id);
    this.outbound.delete(id);
    this.idontwantCounts.delete(id);
    this.idontwants.delete(id);
    this.score.removePeer(id);
    this.acceptFromWhitelist.delete(id);
  }
  // API METHODS
  get started() {
    return this.status.code === GossipStatusCode.started;
  }
  /**
   * Get a the peer-ids in a topic mesh
   */
  getMeshPeers(topic) {
    const peersInTopic = this.mesh.get(topic);
    return peersInTopic != null ? Array.from(peersInTopic) : [];
  }
  /**
   * Get a list of the peer-ids that are subscribed to one topic.
   */
  getSubscribers(topic) {
    const peersInTopic = this.topics.get(topic);
    return (peersInTopic != null ? Array.from(peersInTopic) : []).map((str) => this.peers.get(str) ?? peerIdFromString(str));
  }
  /**
   * Get the list of topics which the peer is subscribed to.
   */
  getTopics() {
    return Array.from(this.subscriptions);
  }
  // TODO: Reviewing Pubsub API
  // MESSAGE METHODS
  /**
   * Responsible for processing each RPC message received by other peers.
   */
  async pipePeerReadStream(peerId, stream) {
    try {
      await pipe(stream, async (source) => {
        for await (const data of source) {
          try {
            const rpcBytes = data.subarray();
            const rpc = RPC.decode(rpcBytes, {
              limits: {
                subscriptions: this.decodeRpcLimits.maxSubscriptions,
                messages: this.decodeRpcLimits.maxMessages,
                control$: {
                  ihave: this.decodeRpcLimits.maxIhaveMessageIDs,
                  iwant: this.decodeRpcLimits.maxIwantMessageIDs,
                  graft: this.decodeRpcLimits.maxControlMessages,
                  prune: this.decodeRpcLimits.maxControlMessages,
                  prune$: {
                    peers: this.decodeRpcLimits.maxPeerInfos
                  },
                  idontwant: this.decodeRpcLimits.maxControlMessages,
                  idontwant$: {
                    messageIDs: this.decodeRpcLimits.maxIdontwantMessageIDs
                  }
                }
              }
            });
            this.metrics?.onRpcRecv(rpc, rpcBytes.length);
            if (this.opts.awaitRpcHandler) {
              try {
                await this.handleReceivedRpc(peerId, rpc);
              } catch (err) {
                this.metrics?.onRpcRecvError();
                this.log(err);
              }
            } else {
              this.handleReceivedRpc(peerId, rpc).catch((err) => {
                this.metrics?.onRpcRecvError();
                this.log(err);
              });
            }
          } catch (e2) {
            this.metrics?.onRpcDataError();
            this.log(e2);
          }
        }
      });
    } catch (err) {
      this.metrics?.onPeerReadStreamError();
      this.handlePeerReadStreamError(err, peerId);
    }
  }
  /**
   * Handle error when read stream pipe throws, less of the functional use but more
   * to for testing purposes to spy on the error handling
   * */
  handlePeerReadStreamError(err, peerId) {
    this.log.error(err);
    this.onPeerDisconnected(peerId);
  }
  /**
   * Handles an rpc request from a peer
   */
  async handleReceivedRpc(from3, rpc) {
    if (!this.acceptFrom(from3.toString())) {
      this.log("received message from unacceptable peer %p", from3);
      this.metrics?.rpcRecvNotAccepted.inc();
      return;
    }
    const subscriptions = rpc.subscriptions != null ? rpc.subscriptions.length : 0;
    const messages2 = rpc.messages != null ? rpc.messages.length : 0;
    let ihave = 0;
    let iwant = 0;
    let graft = 0;
    let prune = 0;
    if (rpc.control != null) {
      if (rpc.control.ihave != null)
        ihave = rpc.control.ihave.length;
      if (rpc.control.iwant != null)
        iwant = rpc.control.iwant.length;
      if (rpc.control.graft != null)
        graft = rpc.control.graft.length;
      if (rpc.control.prune != null)
        prune = rpc.control.prune.length;
    }
    this.log(`rpc.from ${from3.toString()} subscriptions ${subscriptions} messages ${messages2} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`);
    if (rpc.subscriptions != null && rpc.subscriptions.length > 0) {
      const subscriptions2 = [];
      rpc.subscriptions.forEach((subOpt) => {
        const topic = subOpt.topic;
        const subscribe = subOpt.subscribe === true;
        if (topic != null) {
          if (this.allowedTopics != null && !this.allowedTopics.has(topic)) {
            return;
          }
          this.handleReceivedSubscription(from3, topic, subscribe);
          subscriptions2.push({ topic, subscribe });
        }
      });
      this.safeDispatchEvent("subscription-change", {
        detail: { peerId: from3, subscriptions: subscriptions2 }
      });
    }
    for (const message2 of rpc.messages) {
      if (this.allowedTopics != null && !this.allowedTopics.has(message2.topic)) {
        continue;
      }
      const handleReceivedMessagePromise = this.handleReceivedMessage(from3, message2).catch((err) => {
        this.metrics?.onMsgRecvError(message2.topic);
        this.log(err);
      });
      if (this.opts.awaitRpcMessageHandler) {
        await handleReceivedMessagePromise;
      }
    }
    if (rpc.control != null) {
      await this.handleControlMessage(from3.toString(), rpc.control);
    }
  }
  /**
   * Handles a subscription change from a peer
   */
  handleReceivedSubscription(from3, topic, subscribe) {
    this.log("subscription update from %p topic %s", from3, topic);
    let topicSet = this.topics.get(topic);
    if (topicSet == null) {
      topicSet = /* @__PURE__ */ new Set();
      this.topics.set(topic, topicSet);
    }
    if (subscribe) {
      topicSet.add(from3.toString());
    } else {
      topicSet.delete(from3.toString());
    }
  }
  /**
   * Handles a newly received message from an RPC.
   * May forward to all peers in the mesh.
   */
  async handleReceivedMessage(from3, rpcMsg) {
    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic);
    const validationResult = await this.validateReceivedMessage(from3, rpcMsg);
    this.metrics?.onPrevalidationResult(rpcMsg.topic, validationResult.code);
    const validationCode = validationResult.code;
    switch (validationCode) {
      case MessageStatus.duplicate:
        this.score.duplicateMessage(from3.toString(), validationResult.msgIdStr, rpcMsg.topic);
        this.gossipTracer.deliverMessage(validationResult.msgIdStr, true);
        this.mcache.observeDuplicate(validationResult.msgIdStr, from3.toString());
        return;
      case MessageStatus.invalid:
        if (validationResult.msgIdStr != null) {
          const msgIdStr = validationResult.msgIdStr;
          this.score.rejectMessage(from3.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);
          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);
        } else {
          this.score.rejectInvalidMessage(from3.toString(), rpcMsg.topic);
        }
        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult);
        return;
      case MessageStatus.valid:
        this.score.validateMessage(validationResult.messageId.msgIdStr);
        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr);
        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation);
        if (this.subscriptions.has(rpcMsg.topic)) {
          const isFromSelf = this.components.peerId.equals(from3);
          if (!isFromSelf || this.opts.emitSelf) {
            super.dispatchEvent(new CustomEvent("gossipsub:message", {
              detail: {
                propagationSource: from3,
                msgId: validationResult.messageId.msgIdStr,
                msg: validationResult.msg
              }
            }));
            super.dispatchEvent(new CustomEvent("message", { detail: validationResult.msg }));
          }
        }
        if (!this.opts.asyncValidation) {
          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from3.toString());
        }
        break;
      default:
        throw new Error(`Invalid validation result: ${validationCode}`);
    }
  }
  /**
   * Handles a newly received message from an RPC.
   * May forward to all peers in the mesh.
   */
  async validateReceivedMessage(propagationSource, rpcMsg) {
    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg);
    const msgIdCached = fastMsgIdStr !== void 0 ? this.fastMsgIdCache?.get(fastMsgIdStr) : void 0;
    if (msgIdCached != null) {
      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached };
    }
    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);
    if (!validationResult.valid) {
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error };
    }
    const msg = validationResult.message;
    try {
      if (this.dataTransform != null) {
        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);
      }
    } catch (e2) {
      this.log("Invalid message, transform failed", e2);
      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed };
    }
    const msgId3 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId3);
    const messageId = { msgId: msgId3, msgIdStr };
    if (fastMsgIdStr !== void 0 && this.fastMsgIdCache != null) {
      const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr);
      if (collision) {
        this.metrics?.fastMsgIdCacheCollision.inc();
      }
    }
    if (this.seenCache.has(msgIdStr)) {
      return { code: MessageStatus.duplicate, msgIdStr };
    } else {
      this.seenCache.put(msgIdStr);
    }
    if ((rpcMsg.data?.length ?? 0) >= this.opts.idontwantMinDataSize) {
      this.sendIDontWants(msgId3, rpcMsg.topic, propagationSource.toString());
    }
    const topicValidator = this.topicValidators.get(rpcMsg.topic);
    if (topicValidator != null) {
      let acceptance;
      try {
        acceptance = await topicValidator(propagationSource, msg);
      } catch (e2) {
        const errCode = e2.code;
        if (errCode === ERR_TOPIC_VALIDATOR_IGNORE)
          acceptance = TopicValidatorResult.Ignore;
        if (errCode === ERR_TOPIC_VALIDATOR_REJECT)
          acceptance = TopicValidatorResult.Reject;
        else
          acceptance = TopicValidatorResult.Ignore;
      }
      if (acceptance !== TopicValidatorResult.Accept) {
        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr };
      }
    }
    return { code: MessageStatus.valid, messageId, msg };
  }
  /**
   * Return score of a peer.
   */
  getScore(peerId) {
    return this.score.score(peerId);
  }
  /**
   * Send an rpc object to a peer with subscriptions
   */
  sendSubscriptions(toPeer, topics, subscribe) {
    this.sendRpc(toPeer, {
      subscriptions: topics.map((topic) => ({ topic, subscribe })),
      messages: []
    });
  }
  /**
   * Handles an rpc control message from a peer
   */
  async handleControlMessage(id, controlMsg) {
    if (controlMsg === void 0) {
      return;
    }
    const iwant = controlMsg.ihave?.length > 0 ? this.handleIHave(id, controlMsg.ihave) : [];
    const ihave = controlMsg.iwant?.length > 0 ? this.handleIWant(id, controlMsg.iwant) : [];
    const prune = controlMsg.graft?.length > 0 ? await this.handleGraft(id, controlMsg.graft) : [];
    controlMsg.prune?.length > 0 && await this.handlePrune(id, controlMsg.prune);
    controlMsg.idontwant?.length > 0 && this.handleIdontwant(id, controlMsg.idontwant);
    if (iwant.length === 0 && ihave.length === 0 && prune.length === 0) {
      return;
    }
    const sent = this.sendRpc(id, createGossipRpc(ihave, { iwant, prune }));
    const iwantMessageIds = iwant[0]?.messageIDs;
    if (iwantMessageIds != null) {
      if (sent) {
        this.gossipTracer.addPromise(id, iwantMessageIds);
      } else {
        this.metrics?.iwantPromiseUntracked.inc(1);
      }
    }
  }
  /**
   * Whether to accept a message from a peer
   */
  acceptFrom(id) {
    if (this.direct.has(id)) {
      return true;
    }
    const now = Date.now();
    const entry = this.acceptFromWhitelist.get(id);
    if (entry != null && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {
      entry.messagesAccepted += 1;
      return true;
    }
    const score = this.score.score(id);
    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {
      this.acceptFromWhitelist.set(id, {
        messagesAccepted: 0,
        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS
      });
    } else {
      this.acceptFromWhitelist.delete(id);
    }
    return score >= this.opts.scoreThresholds.graylistThreshold;
  }
  /**
   * Handles IHAVE messages
   */
  handleIHave(id, ihave) {
    if (ihave.length === 0) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore });
      return [];
    }
    const peerhave = (this.peerhave.get(id) ?? 0) + 1;
    this.peerhave.set(id, peerhave);
    if (peerhave > GossipsubMaxIHaveMessages) {
      this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave });
      return [];
    }
    const iasked = this.iasked.get(id) ?? 0;
    if (iasked >= GossipsubMaxIHaveLength) {
      this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked });
      return [];
    }
    const iwant = /* @__PURE__ */ new Map();
    ihave.forEach(({ topicID, messageIDs }) => {
      if (topicID == null || messageIDs == null || !this.mesh.has(topicID)) {
        return;
      }
      let idonthave = 0;
      messageIDs.forEach((msgId3) => {
        const msgIdStr = this.msgIdToStrFn(msgId3);
        if (!this.seenCache.has(msgIdStr)) {
          iwant.set(msgIdStr, msgId3);
          idonthave++;
        }
      });
      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave);
    });
    if (iwant.size === 0) {
      return [];
    }
    let iask = iwant.size;
    if (iask + iasked > GossipsubMaxIHaveLength) {
      iask = GossipsubMaxIHaveLength - iasked;
    }
    this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
    let iwantList = Array.from(iwant.values());
    shuffle(iwantList);
    iwantList = iwantList.slice(0, iask);
    this.iasked.set(id, iasked + iask);
    return [
      {
        messageIDs: iwantList
      }
    ];
  }
  /**
   * Handles IWANT messages
   * Returns messages to send back to peer
   */
  handleIWant(id, iwant) {
    if (iwant.length === 0) {
      return [];
    }
    const score = this.score.score(id);
    if (score < this.opts.scoreThresholds.gossipThreshold) {
      this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
      return [];
    }
    const ihave = /* @__PURE__ */ new Map();
    const iwantByTopic = /* @__PURE__ */ new Map();
    let iwantDonthave = 0;
    iwant.forEach(({ messageIDs }) => {
      messageIDs?.forEach((msgId3) => {
        const msgIdStr = this.msgIdToStrFn(msgId3);
        const entry = this.mcache.getWithIWantCount(msgIdStr, id);
        if (entry == null) {
          iwantDonthave++;
          return;
        }
        iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));
        if (entry.count > GossipsubGossipRetransmission) {
          this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgId3);
          return;
        }
        ihave.set(msgIdStr, entry.msg);
      });
    });
    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave);
    if (ihave.size === 0) {
      this.log("IWANT: Could not provide any wanted messages to %s", id);
      return [];
    }
    this.log("IWANT: Sending %d messages to %s", ihave.size, id);
    return Array.from(ihave.values());
  }
  /**
   * Handles Graft messages
   */
  async handleGraft(id, graft) {
    const prune = [];
    const score = this.score.score(id);
    const now = Date.now();
    let doPX = this.opts.doPX;
    graft.forEach(({ topicID }) => {
      if (topicID == null) {
        return;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (peersInMesh == null) {
        doPX = false;
        return;
      }
      if (peersInMesh.has(id)) {
        return;
      }
      const backoffExpiry = this.backoff.get(topicID)?.get(id);
      if (this.direct.has(id)) {
        this.log("GRAFT: ignoring request from direct peer %s", id);
        prune.push(topicID);
        doPX = false;
      } else if (typeof backoffExpiry === "number" && now < backoffExpiry) {
        this.log("GRAFT: ignoring backed off peer %s", id);
        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        doPX = false;
        const floodCutoff = backoffExpiry + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
        if (now < floodCutoff) {
          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
        }
        this.addBackoff(id, topicID);
        prune.push(topicID);
      } else if (score < 0) {
        this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
        prune.push(topicID);
        doPX = false;
        this.addBackoff(id, topicID);
      } else if (peersInMesh.size >= this.opts.Dhi && !(this.outbound.get(id) ?? false)) {
        prune.push(topicID);
        this.addBackoff(id, topicID);
      } else {
        this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
        this.score.graft(id, topicID);
        peersInMesh.add(id);
        this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1);
      }
      this.safeDispatchEvent("gossipsub:graft", { detail: { peerId: id, topic: topicID, direction: "inbound" } });
    });
    if (prune.length === 0) {
      return [];
    }
    const onUnsubscribe = false;
    return Promise.all(prune.map(async (topic) => this.makePrune(id, topic, doPX, onUnsubscribe)));
  }
  /**
   * Handles Prune messages
   */
  async handlePrune(id, prune) {
    const score = this.score.score(id);
    for (const { topicID, backoff, peers } of prune) {
      if (topicID == null) {
        continue;
      }
      const peersInMesh = this.mesh.get(topicID);
      if (peersInMesh == null) {
        return;
      }
      this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
      this.score.prune(id, topicID);
      if (peersInMesh.has(id)) {
        peersInMesh.delete(id);
        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Prune, 1);
      }
      if (typeof backoff === "number" && backoff > 0) {
        this.doAddBackoff(id, topicID, backoff * 1e3);
      } else {
        this.addBackoff(id, topicID);
      }
      if (peers != null && peers.length > 0) {
        if (score < this.opts.scoreThresholds.acceptPXThreshold) {
          this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
        } else {
          await this.pxConnect(peers);
        }
      }
      this.safeDispatchEvent("gossipsub:prune", { detail: { peerId: id, topic: topicID, direction: "inbound" } });
    }
  }
  handleIdontwant(id, idontwant) {
    let idontwantCount = this.idontwantCounts.get(id) ?? 0;
    if (idontwantCount >= this.opts.idontwantMaxMessages) {
      return;
    }
    const startIdontwantCount = idontwantCount;
    let idontwants = this.idontwants.get(id);
    if (idontwants == null) {
      idontwants = /* @__PURE__ */ new Map();
      this.idontwants.set(id, idontwants);
    }
    let idonthave = 0;
    out: for (const { messageIDs } of idontwant) {
      for (const msgId3 of messageIDs) {
        if (idontwantCount >= this.opts.idontwantMaxMessages) {
          break out;
        }
        idontwantCount++;
        const msgIdStr = this.msgIdToStrFn(msgId3);
        idontwants.set(msgIdStr, this.heartbeatTicks);
        if (!this.mcache.msgs.has(msgIdStr))
          idonthave++;
      }
    }
    this.idontwantCounts.set(id, idontwantCount);
    const total = idontwantCount - startIdontwantCount;
    this.metrics?.onIdontwantRcv(total, idonthave);
  }
  /**
   * Add standard backoff log for a peer in a topic
   */
  addBackoff(id, topic) {
    this.doAddBackoff(id, topic, this.opts.pruneBackoff);
  }
  /**
   * Add backoff expiry interval for a peer in a topic
   *
   * @param id
   * @param topic
   * @param intervalMs - backoff duration in milliseconds
   */
  doAddBackoff(id, topic, intervalMs) {
    let backoff = this.backoff.get(topic);
    if (backoff == null) {
      backoff = /* @__PURE__ */ new Map();
      this.backoff.set(topic, backoff);
    }
    const expire = Date.now() + intervalMs;
    const existingExpire = backoff.get(id) ?? 0;
    if (existingExpire < expire) {
      backoff.set(id, expire);
    }
  }
  /**
   * Apply penalties from broken IHAVE/IWANT promises
   */
  applyIwantPenalties() {
    this.gossipTracer.getBrokenPromises().forEach((count, p2) => {
      this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p2, count);
      this.score.addPenalty(p2, count, ScorePenalty.BrokenPromise);
    });
  }
  /**
   * Clear expired backoff expiries
   */
  clearBackoff() {
    if (this.heartbeatTicks % GossipsubPruneBackoffTicks !== 0) {
      return;
    }
    const now = Date.now();
    this.backoff.forEach((backoff, topic) => {
      backoff.forEach((expire, id) => {
        if (expire + BACKOFF_SLACK * this.opts.heartbeatInterval < now) {
          backoff.delete(id);
        }
      });
      if (backoff.size === 0) {
        this.backoff.delete(topic);
      }
    });
  }
  /**
   * Maybe reconnect to direct peers
   */
  async directConnect() {
    const toconnect = [];
    this.direct.forEach((id) => {
      if (!this.streamsOutbound.has(id)) {
        toconnect.push(id);
      }
    });
    await Promise.all(toconnect.map(async (id) => this.connect(id)));
  }
  /**
   * Maybe attempt connection given signed peer records
   */
  async pxConnect(peers) {
    if (peers.length > this.opts.prunePeers) {
      shuffle(peers);
      peers = peers.slice(0, this.opts.prunePeers);
    }
    const toconnect = [];
    await Promise.all(peers.map(async (pi) => {
      if (pi.peerID == null) {
        return;
      }
      const peer = peerIdFromMultihash(decode4(pi.peerID));
      const p2 = peer.toString();
      if (this.peers.has(p2)) {
        return;
      }
      if (pi.signedPeerRecord == null) {
        toconnect.push(p2);
        return;
      }
      try {
        if (!await this.components.peerStore.consumePeerRecord(pi.signedPeerRecord, peer)) {
          this.log("bogus peer record obtained through px: could not add peer record to address book");
          return;
        }
        toconnect.push(p2);
      } catch (e2) {
        this.log("bogus peer record obtained through px: invalid signature or not a peer record");
      }
    }));
    if (toconnect.length === 0) {
      return;
    }
    await Promise.all(toconnect.map(async (id) => this.connect(id)));
  }
  /**
   * Connect to a peer using the gossipsub protocol
   */
  async connect(id) {
    this.log("Initiating connection with %s", id);
    const peerId = peerIdFromString(id);
    const connection = await this.components.connectionManager.openConnection(peerId);
    for (const multicodec3 of this.multicodecs) {
      for (const topology of this.components.registrar.getTopologies(multicodec3)) {
        topology.onConnect?.(peerId, connection);
      }
    }
  }
  /**
   * Subscribes to a topic
   */
  subscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub has not started");
    }
    if (!this.subscriptions.has(topic)) {
      this.subscriptions.add(topic);
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], true);
      }
    }
    this.join(topic);
  }
  /**
   * Unsubscribe to a topic
   */
  unsubscribe(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Pubsub is not started");
    }
    const wasSubscribed = this.subscriptions.delete(topic);
    this.log("unsubscribe from %s - am subscribed %s", topic, wasSubscribed);
    if (wasSubscribed) {
      for (const peerId of this.peers.keys()) {
        this.sendSubscriptions(peerId, [topic], false);
      }
    }
    this.leave(topic);
  }
  /**
   * Join topic
   */
  join(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    if (this.mesh.has(topic)) {
      return;
    }
    this.log("JOIN %s", topic);
    this.metrics?.onJoin(topic);
    const toAdd = /* @__PURE__ */ new Set();
    const backoff = this.backoff.get(topic);
    const fanoutPeers = this.fanout.get(topic);
    if (fanoutPeers != null) {
      this.fanout.delete(topic);
      this.fanoutLastpub.delete(topic);
      fanoutPeers.forEach((id) => {
        if (!this.direct.has(id) && this.score.score(id) >= 0 && backoff?.has(id) !== true) {
          toAdd.add(id);
        }
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);
    }
    if (toAdd.size < this.opts.D) {
      const fanoutCount = toAdd.size;
      const newPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => (
        // filter direct peers and peers with negative score
        !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0 && backoff?.has(id) !== true
      ));
      newPeers.forEach((peer) => {
        toAdd.add(peer);
      });
      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);
    }
    this.mesh.set(topic, toAdd);
    toAdd.forEach((id) => {
      this.log("JOIN: Add mesh link to %s in %s", id, topic);
      this.sendGraft(id, topic);
    });
  }
  /**
   * Leave topic
   */
  leave(topic) {
    if (this.status.code !== GossipStatusCode.started) {
      throw new Error("Gossipsub has not started");
    }
    this.log("LEAVE %s", topic);
    this.metrics?.onLeave(topic);
    const meshPeers = this.mesh.get(topic);
    if (meshPeers != null) {
      Promise.all(Array.from(meshPeers).map(async (id) => {
        this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
        await this.sendPrune(id, topic);
      })).catch((err) => {
        this.log("Error sending prunes to mesh peers", err);
      });
      this.mesh.delete(topic);
    }
  }
  selectPeersToForward(topic, propagationSource, excludePeers) {
    const tosend = /* @__PURE__ */ new Set();
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic != null) {
      this.direct.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !(excludePeers?.has(peer) ?? false)) {
          tosend.add(peer);
        }
      });
      this.floodsubPeers.forEach((peer) => {
        if (peersInTopic.has(peer) && propagationSource !== peer && !(excludePeers?.has(peer) ?? false) && this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {
          tosend.add(peer);
        }
      });
    }
    const meshPeers = this.mesh.get(topic);
    if (meshPeers != null && meshPeers.size > 0) {
      meshPeers.forEach((peer) => {
        if (propagationSource !== peer && !(excludePeers?.has(peer) ?? false)) {
          tosend.add(peer);
        }
      });
    }
    return tosend;
  }
  selectPeersToPublish(topic) {
    const tosend = /* @__PURE__ */ new Set();
    const tosendCount = {
      direct: 0,
      floodsub: 0,
      mesh: 0,
      fanout: 0
    };
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic != null) {
      if (this.opts.floodPublish) {
        peersInTopic.forEach((id) => {
          if (this.direct.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
      } else {
        this.direct.forEach((id) => {
          if (peersInTopic.has(id)) {
            tosend.add(id);
            tosendCount.direct++;
          }
        });
        this.floodsubPeers.forEach((id) => {
          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(id);
            tosendCount.floodsub++;
          }
        });
        const meshPeers = this.mesh.get(topic);
        if (meshPeers != null && meshPeers.size > 0) {
          meshPeers.forEach((peer) => {
            tosend.add(peer);
            tosendCount.mesh++;
          });
          if (meshPeers.size < this.opts.D) {
            const topicPeers = this.getRandomGossipPeers(topic, this.opts.D - meshPeers.size, (id) => {
              return !meshPeers.has(id) && !this.direct.has(id) && !this.floodsubPeers.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
            });
            topicPeers.forEach((peer) => {
              tosend.add(peer);
              tosendCount.mesh++;
            });
          }
        } else {
          const fanoutPeers = this.fanout.get(topic);
          if (fanoutPeers != null && fanoutPeers.size > 0) {
            fanoutPeers.forEach((peer) => {
              tosend.add(peer);
              tosendCount.fanout++;
            });
          } else {
            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {
              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
            });
            if (newFanoutPeers.size > 0) {
              this.fanout.set(topic, newFanoutPeers);
              newFanoutPeers.forEach((peer) => {
                tosend.add(peer);
                tosendCount.fanout++;
              });
            }
          }
          this.fanoutLastpub.set(topic, Date.now());
        }
      }
    }
    return { tosend, tosendCount };
  }
  /**
   * Forwards a message from our peers.
   *
   * For messages published by us (the app layer), this class uses `publish`
   */
  forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {
    if (propagationSource != null) {
      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);
    }
    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers);
    tosend.forEach((id) => {
      this.sendRpc(id, createGossipRpc([rawMsg]));
    });
    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size);
  }
  /**
   * App layer publishes a message to peers, return number of peers this message is published to
   * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.
   *
   * For messages not from us, this class uses `forwardMessage`.
   */
  async publish(topic, data, opts) {
    const startMs = Date.now();
    const transformedData = this.dataTransform != null ? this.dataTransform.outboundTransform(topic, data) : data;
    if (this.publishConfig == null) {
      throw Error("PublishError.Uninitialized");
    }
    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData);
    const msgId3 = await this.msgIdFn(msg);
    const msgIdStr = this.msgIdToStrFn(msgId3);
    const ignoreDuplicatePublishError = opts?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError;
    if (this.seenCache.has(msgIdStr)) {
      if (ignoreDuplicatePublishError) {
        this.metrics?.onPublishDuplicateMsg(topic);
        return { recipients: [] };
      }
      throw Error("PublishError.Duplicate");
    }
    const { tosend, tosendCount } = this.selectPeersToPublish(topic);
    const willSendToSelf = this.opts.emitSelf && this.subscriptions.has(topic);
    const allowPublishToZeroTopicPeers = opts?.allowPublishToZeroTopicPeers ?? this.opts.allowPublishToZeroTopicPeers;
    if (tosend.size === 0 && !allowPublishToZeroTopicPeers && !willSendToSelf) {
      throw Error("PublishError.NoPeersSubscribedToTopic");
    }
    this.seenCache.put(msgIdStr);
    this.mcache.put({ msgId: msgId3, msgIdStr }, rawMsg, true);
    this.gossipTracer.deliverMessage(msgIdStr);
    this.publishedMessageIds.put(msgIdStr);
    const batchPublish = opts?.batchPublish ?? this.opts.batchPublish;
    const rpc = createGossipRpc([rawMsg]);
    if (batchPublish) {
      this.sendRpcInBatch(tosend, rpc);
    } else {
      for (const id of tosend) {
        const sent = this.sendRpc(id, rpc);
        if (!sent) {
          tosend.delete(id);
        }
      }
    }
    const durationMs = Date.now() - startMs;
    this.metrics?.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0, durationMs);
    if (willSendToSelf) {
      tosend.add(this.components.peerId.toString());
      super.dispatchEvent(new CustomEvent("gossipsub:message", {
        detail: {
          propagationSource: this.components.peerId,
          msgId: msgIdStr,
          msg
        }
      }));
      super.dispatchEvent(new CustomEvent("message", { detail: msg }));
    }
    return {
      recipients: Array.from(tosend.values()).map((str) => this.peers.get(str) ?? peerIdFromString(str))
    };
  }
  /**
   * Send the same data in batch to tosend list without considering cached control messages
   * This is not only faster but also avoid allocating memory for each peer
   * see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/344
   */
  sendRpcInBatch(tosend, rpc) {
    const rpcBytes = RPC.encode(rpc);
    const prefixedData = encode8.single(rpcBytes);
    for (const id of tosend) {
      const outboundStream = this.streamsOutbound.get(id);
      if (outboundStream == null) {
        this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
        tosend.delete(id);
        continue;
      }
      try {
        outboundStream.pushPrefixed(prefixedData);
      } catch (e2) {
        tosend.delete(id);
        this.log.error(`Cannot send rpc to ${id}`, e2);
      }
      this.metrics?.onRpcSent(rpc, rpcBytes.length);
    }
  }
  /**
   * This function should be called when `asyncValidation` is `true` after
   * the message got validated by the caller. Messages are stored in the `mcache` and
   * validation is expected to be fast enough that the messages should still exist in the cache.
   * There are three possible validation outcomes and the outcome is given in acceptance.
   *
   * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the
   * network. The `propagation_source` parameter indicates who the message was received by and
   * will not be forwarded back to that peer.
   *
   * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache
   * and the P penalty will be applied to the `propagationSource`.
   *
   * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache
   * but no P penalty will be applied.
   *
   * This function will return true if the message was found in the cache and false if was not
   * in the cache anymore.
   *
   * This should only be called once per message.
   */
  reportMessageValidationResult(msgId3, propagationSource, acceptance) {
    let cacheEntry;
    if (acceptance === TopicValidatorResult.Accept) {
      cacheEntry = this.mcache.validate(msgId3);
      if (cacheEntry != null) {
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.deliverMessage(propagationSource, msgId3, rawMsg.topic);
        this.forwardMessage(msgId3, cacheEntry.message, propagationSource, originatingPeers);
      }
    } else {
      cacheEntry = this.mcache.remove(msgId3);
      if (cacheEntry != null) {
        const rejectReason = rejectReasonFromAcceptance(acceptance);
        const { message: rawMsg, originatingPeers } = cacheEntry;
        this.score.rejectMessage(propagationSource, msgId3, rawMsg.topic, rejectReason);
        for (const peer of originatingPeers) {
          this.score.rejectMessage(peer, msgId3, rawMsg.topic, rejectReason);
        }
      }
    }
    const firstSeenTimestampMs = this.score.messageFirstSeenTimestampMs(msgId3);
    this.metrics?.onReportValidation(cacheEntry, acceptance, firstSeenTimestampMs);
  }
  /**
   * Sends a GRAFT message to a peer
   */
  sendGraft(id, topic) {
    const graft = [
      {
        topicID: topic
      }
    ];
    const out = createGossipRpc([], { graft });
    this.sendRpc(id, out);
  }
  /**
   * Sends a PRUNE message to a peer
   */
  async sendPrune(id, topic) {
    const onUnsubscribe = true;
    const prune = [await this.makePrune(id, topic, this.opts.doPX, onUnsubscribe)];
    const out = createGossipRpc([], { prune });
    this.sendRpc(id, out);
  }
  sendIDontWants(msgId3, topic, source) {
    const ids = this.mesh.get(topic);
    if (ids == null) {
      return;
    }
    const tosend = new Set(ids);
    tosend.delete(source);
    for (const id of tosend) {
      if (this.streamsOutbound.get(id)?.protocol !== GossipsubIDv12) {
        tosend.delete(id);
      }
    }
    const idontwantRpc = createGossipRpc([], { idontwant: [{ messageIDs: [msgId3] }] });
    this.sendRpcInBatch(tosend, idontwantRpc);
  }
  /**
   * Send an rpc object to a peer
   */
  sendRpc(id, rpc) {
    const outboundStream = this.streamsOutbound.get(id);
    if (outboundStream == null) {
      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
      return false;
    }
    const ctrl = this.control.get(id);
    if (ctrl != null) {
      this.piggybackControl(id, rpc, ctrl);
      this.control.delete(id);
    }
    const ihave = this.gossip.get(id);
    if (ihave != null) {
      this.piggybackGossip(id, rpc, ihave);
      this.gossip.delete(id);
    }
    const rpcBytes = RPC.encode(rpc);
    try {
      outboundStream.push(rpcBytes);
    } catch (e2) {
      this.log.error(`Cannot send rpc to ${id}`, e2);
      if (ctrl != null) {
        this.control.set(id, ctrl);
      }
      if (ihave != null) {
        this.gossip.set(id, ihave);
      }
      return false;
    }
    this.metrics?.onRpcSent(rpc, rpcBytes.length);
    if (rpc.control?.graft != null) {
      for (const topic of rpc.control?.graft) {
        if (topic.topicID != null) {
          this.safeDispatchEvent("gossipsub:graft", { detail: { peerId: id, topic: topic.topicID, direction: "outbound" } });
        }
      }
    }
    if (rpc.control?.prune != null) {
      for (const topic of rpc.control?.prune) {
        if (topic.topicID != null) {
          this.safeDispatchEvent("gossipsub:prune", { detail: { peerId: id, topic: topic.topicID, direction: "outbound" } });
        }
      }
    }
    return true;
  }
  /** Mutates `outRpc` adding graft and prune control messages */
  piggybackControl(id, outRpc, ctrl) {
    const rpc = ensureControl(outRpc);
    for (const graft of ctrl.graft) {
      if (graft.topicID != null && (this.mesh.get(graft.topicID)?.has(id) ?? false)) {
        rpc.control.graft.push(graft);
      }
    }
    for (const prune of ctrl.prune) {
      if (prune.topicID != null && !(this.mesh.get(prune.topicID)?.has(id) ?? false)) {
        rpc.control.prune.push(prune);
      }
    }
  }
  /** Mutates `outRpc` adding ihave control messages */
  piggybackGossip(id, outRpc, ihave) {
    const rpc = ensureControl(outRpc);
    rpc.control.ihave = ihave;
  }
  /**
   * Send graft and prune messages
   *
   * @param tograft - peer id => topic[]
   * @param toprune - peer id => topic[]
   */
  async sendGraftPrune(tograft, toprune, noPX) {
    const doPX = this.opts.doPX;
    const onUnsubscribe = false;
    for (const [id, topics] of tograft) {
      const graft = topics.map((topicID) => ({ topicID }));
      let prune = [];
      const pruning = toprune.get(id);
      if (pruning != null) {
        prune = await Promise.all(pruning.map(async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));
        toprune.delete(id);
      }
      this.sendRpc(id, createGossipRpc([], { graft, prune }));
    }
    for (const [id, topics] of toprune) {
      const prune = await Promise.all(topics.map(async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));
      this.sendRpc(id, createGossipRpc([], { prune }));
    }
  }
  /**
   * Emits gossip - Send IHAVE messages to a random set of gossip peers
   */
  emitGossip(peersToGossipByTopic) {
    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));
    for (const [topic, peersToGossip] of peersToGossipByTopic) {
      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);
    }
  }
  /**
   * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy
   * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers
   * We also exclude direct peers, as there is no reason to emit gossip to them
   *
   * @param topic
   * @param candidateToGossip - peers to gossip
   * @param messageIDs - message ids to gossip
   */
  doEmitGossip(topic, candidateToGossip, messageIDs) {
    if (messageIDs.length === 0) {
      return;
    }
    shuffle(messageIDs);
    if (messageIDs.length > GossipsubMaxIHaveLength) {
      this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
    }
    if (candidateToGossip.size === 0)
      return;
    let target = this.opts.Dlazy;
    const gossipFactor = this.opts.gossipFactor;
    const factor = gossipFactor * candidateToGossip.size;
    let peersToGossip = candidateToGossip;
    if (factor > target) {
      target = factor;
    }
    if (target > peersToGossip.size) {
      target = peersToGossip.size;
    } else {
      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);
    }
    peersToGossip.forEach((id) => {
      let peerMessageIDs = messageIDs;
      if (messageIDs.length > GossipsubMaxIHaveLength) {
        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, GossipsubMaxIHaveLength);
      }
      this.pushGossip(id, {
        topicID: topic,
        messageIDs: peerMessageIDs
      });
    });
  }
  /**
   * Flush gossip and control messages
   */
  flush() {
    for (const [peer, ihave] of this.gossip.entries()) {
      this.gossip.delete(peer);
      this.sendRpc(peer, createGossipRpc([], { ihave }));
    }
    for (const [peer, control] of this.control.entries()) {
      this.control.delete(peer);
      const out = createGossipRpc([], { graft: control.graft, prune: control.prune });
      this.sendRpc(peer, out);
    }
  }
  /**
   * Adds new IHAVE messages to pending gossip
   */
  pushGossip(id, controlIHaveMsgs) {
    this.log("Add gossip to %s", id);
    const gossip = this.gossip.get(id) ?? [];
    this.gossip.set(id, gossip.concat(controlIHaveMsgs));
  }
  /**
   * Make a PRUNE control message for a peer in a topic
   */
  async makePrune(id, topic, doPX, onUnsubscribe) {
    this.score.prune(id, topic);
    if (this.streamsOutbound.get(id)?.protocol === GossipsubIDv10) {
      return {
        topicID: topic,
        peers: []
      };
    }
    const backoffMs = onUnsubscribe ? this.opts.unsubcribeBackoff : this.opts.pruneBackoff;
    const backoff = backoffMs / 1e3;
    this.doAddBackoff(id, topic, backoffMs);
    if (!doPX) {
      return {
        topicID: topic,
        peers: [],
        backoff
      };
    }
    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {
      return xid !== id && this.score.score(xid) >= 0;
    });
    const px = await Promise.all(Array.from(peers).map(async (peerId) => {
      const id2 = this.peers.get(peerId) ?? peerIdFromString(peerId);
      let peerInfo;
      try {
        peerInfo = await this.components.peerStore.get(id2);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      return {
        peerID: id2.toMultihash().bytes,
        signedPeerRecord: peerInfo?.peerRecordEnvelope
      };
    }));
    return {
      topicID: topic,
      peers: px,
      backoff
    };
  }
  /**
   * Maintains the mesh and fanout maps in gossipsub.
   */
  async heartbeat() {
    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts;
    this.heartbeatTicks++;
    const scores = /* @__PURE__ */ new Map();
    const getScore = (id) => {
      let s2 = scores.get(id);
      if (s2 === void 0) {
        s2 = this.score.score(id);
        scores.set(id, s2);
      }
      return s2;
    };
    const tograft = /* @__PURE__ */ new Map();
    const toprune = /* @__PURE__ */ new Map();
    const noPX = /* @__PURE__ */ new Map();
    this.clearBackoff();
    this.peerhave.clear();
    this.metrics?.cacheSize.set({ cache: "iasked" }, this.iasked.size);
    this.iasked.clear();
    this.applyIwantPenalties();
    this.idontwantCounts.clear();
    for (const idontwants of this.idontwants.values()) {
      for (const [msgId3, heartbeatTick] of idontwants) {
        if (this.heartbeatTicks - heartbeatTick >= this.opts.mcacheLength) {
          idontwants.delete(msgId3);
        }
      }
    }
    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {
      await this.directConnect();
    }
    this.fastMsgIdCache?.prune();
    this.seenCache.prune();
    this.gossipTracer.prune();
    this.publishedMessageIds.prune();
    const peersToGossipByTopic = /* @__PURE__ */ new Map();
    this.mesh.forEach((peers, topic) => {
      const peersInTopic = this.topics.get(topic);
      const candidateMeshPeers = /* @__PURE__ */ new Set();
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic != null) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        const backoff = this.backoff.get(topic);
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams != null && this.multicodecs.includes(peerStreams.protocol) && !peers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if (backoff?.has(id) !== true && score >= 0)
              candidateMeshPeers.add(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      const prunePeer = (id, reason) => {
        this.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
        this.addBackoff(id, topic);
        peers.delete(id);
        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold)
          peersToGossip.add(id);
        this.metrics?.onRemoveFromMesh(topic, reason, 1);
        const topics = toprune.get(id);
        if (topics == null) {
          toprune.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      const graftPeer = (id, reason) => {
        this.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
        this.score.graft(id, topic);
        peers.add(id);
        peersToGossip.delete(id);
        this.metrics?.onAddToMesh(topic, reason, 1);
        const topics = tograft.get(id);
        if (topics == null) {
          tograft.set(id, [topic]);
        } else {
          topics.push(topic);
        }
      };
      peers.forEach((id) => {
        const score = getScore(id);
        if (score < 0) {
          this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
          prunePeer(id, ChurnReason.BadScore);
          noPX.set(id, true);
        }
      });
      if (peers.size < Dlo) {
        const ineed = D - peers.size;
        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);
        newMeshPeers.forEach((p2) => {
          graftPeer(p2, InclusionReason.NotEnough);
        });
      }
      if (peers.size > Dhi) {
        let peersArray = Array.from(peers);
        peersArray.sort((a2, b) => getScore(b) - getScore(a2));
        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)));
        let outbound = 0;
        peersArray.slice(0, D).forEach((p2) => {
          if (this.outbound.get(p2) ?? false) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const rotate = (i2) => {
            const p2 = peersArray[i2];
            for (let j = i2; j > 0; j--) {
              peersArray[j] = peersArray[j - 1];
            }
            peersArray[0] = p2;
          };
          if (outbound > 0) {
            let ihave = outbound;
            for (let i2 = 1; i2 < D && ihave > 0; i2++) {
              if (this.outbound.get(peersArray[i2]) ?? false) {
                rotate(i2);
                ihave--;
              }
            }
          }
          let ineed = D - outbound;
          for (let i2 = D; i2 < peersArray.length && ineed > 0; i2++) {
            if (this.outbound.get(peersArray[i2]) ?? false) {
              rotate(i2);
              ineed--;
            }
          }
        }
        peersArray.slice(D).forEach((p2) => {
          prunePeer(p2, ChurnReason.Excess);
        });
      }
      if (peers.size >= Dlo) {
        let outbound = 0;
        peers.forEach((p2) => {
          if (this.outbound.get(p2) ?? false) {
            outbound++;
          }
        });
        if (outbound < Dout) {
          const ineed = Dout - outbound;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true);
          newMeshPeers.forEach((p2) => {
            graftPeer(p2, InclusionReason.Outbound);
          });
        }
      }
      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {
        const peersList = Array.from(peers).sort((a2, b) => getScore(a2) - getScore(b));
        const medianIndex = Math.floor(peers.size / 2);
        const medianScore = getScore(peersList[medianIndex]);
        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {
          const ineed = this.opts.opportunisticGraftPeers;
          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore);
          for (const id of newMeshPeers) {
            this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
            graftPeer(id, InclusionReason.Opportunistic);
          }
        }
      }
    });
    const now = Date.now();
    this.fanoutLastpub.forEach((lastpb, topic) => {
      if (lastpb + fanoutTTL < now) {
        this.fanout.delete(topic);
        this.fanoutLastpub.delete(topic);
      }
    });
    this.fanout.forEach((fanoutPeers, topic) => {
      const topicPeers = this.topics.get(topic);
      fanoutPeers.forEach((id) => {
        if (!(topicPeers?.has(id) ?? false) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {
          fanoutPeers.delete(id);
        }
      });
      const peersInTopic = this.topics.get(topic);
      const candidateFanoutPeers = [];
      const peersToGossip = /* @__PURE__ */ new Set();
      peersToGossipByTopic.set(topic, peersToGossip);
      if (peersInTopic != null) {
        const shuffledPeers = shuffle(Array.from(peersInTopic));
        for (const id of shuffledPeers) {
          const peerStreams = this.streamsOutbound.get(id);
          if (peerStreams != null && this.multicodecs.includes(peerStreams.protocol) && !fanoutPeers.has(id) && !this.direct.has(id)) {
            const score = getScore(id);
            if (score >= this.opts.scoreThresholds.publishThreshold)
              candidateFanoutPeers.push(id);
            if (score >= this.opts.scoreThresholds.gossipThreshold)
              peersToGossip.add(id);
          }
        }
      }
      if (fanoutPeers.size < D) {
        const ineed = D - fanoutPeers.size;
        candidateFanoutPeers.slice(0, ineed).forEach((id) => {
          fanoutPeers.add(id);
          peersToGossip?.delete(id);
        });
      }
    });
    this.emitGossip(peersToGossipByTopic);
    await this.sendGraftPrune(tograft, toprune, noPX);
    this.flush();
    this.mcache.shift();
    this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"));
  }
  /**
   * Given a topic, returns up to count peers subscribed to that topic
   * that pass an optional filter function
   *
   * @param topic
   * @param count
   * @param filter - a function to filter acceptable peers
   */
  getRandomGossipPeers(topic, count, filter2 = () => true) {
    const peersInTopic = this.topics.get(topic);
    if (peersInTopic == null) {
      return /* @__PURE__ */ new Set();
    }
    let peers = [];
    peersInTopic.forEach((id) => {
      const peerStreams = this.streamsOutbound.get(id);
      if (peerStreams == null) {
        return;
      }
      if (this.multicodecs.includes(peerStreams.protocol) && filter2(id)) {
        peers.push(id);
      }
    });
    peers = shuffle(peers);
    if (count > 0 && peers.length > count) {
      peers = peers.slice(0, count);
    }
    return new Set(peers);
  }
  onScrapeMetrics(metrics) {
    metrics.mcacheSize.set(this.mcache.size);
    metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount);
    metrics.cacheSize.set({ cache: "direct" }, this.direct.size);
    metrics.cacheSize.set({ cache: "seenCache" }, this.seenCache.size);
    metrics.cacheSize.set({ cache: "fastMsgIdCache" }, this.fastMsgIdCache?.size ?? 0);
    metrics.cacheSize.set({ cache: "publishedMessageIds" }, this.publishedMessageIds.size);
    metrics.cacheSize.set({ cache: "mcache" }, this.mcache.size);
    metrics.cacheSize.set({ cache: "score" }, this.score.size);
    metrics.cacheSize.set({ cache: "gossipTracer.promises" }, this.gossipTracer.size);
    metrics.cacheSize.set({ cache: "gossipTracer.requests" }, this.gossipTracer.requestMsByMsgSize);
    metrics.cacheSize.set({ cache: "topics" }, this.topics.size);
    metrics.cacheSize.set({ cache: "subscriptions" }, this.subscriptions.size);
    metrics.cacheSize.set({ cache: "mesh" }, this.mesh.size);
    metrics.cacheSize.set({ cache: "fanout" }, this.fanout.size);
    metrics.cacheSize.set({ cache: "peers" }, this.peers.size);
    metrics.cacheSize.set({ cache: "streamsOutbound" }, this.streamsOutbound.size);
    metrics.cacheSize.set({ cache: "streamsInbound" }, this.streamsInbound.size);
    metrics.cacheSize.set({ cache: "acceptFromWhitelist" }, this.acceptFromWhitelist.size);
    metrics.cacheSize.set({ cache: "gossip" }, this.gossip.size);
    metrics.cacheSize.set({ cache: "control" }, this.control.size);
    metrics.cacheSize.set({ cache: "peerhave" }, this.peerhave.size);
    metrics.cacheSize.set({ cache: "outbound" }, this.outbound.size);
    let backoffSize = 0;
    const now = Date.now();
    metrics.connectedPeersBackoffSec.reset();
    for (const backoff of this.backoff.values()) {
      backoffSize += backoff.size;
      for (const [peer, expiredMs] of backoff.entries()) {
        if (this.peers.has(peer)) {
          metrics.connectedPeersBackoffSec.observe(Math.max(0, expiredMs - now) / 1e3);
        }
      }
    }
    metrics.cacheSize.set({ cache: "backoff" }, backoffSize);
    let idontwantsCount = 0;
    for (const idontwant of this.idontwants.values()) {
      idontwantsCount += idontwant.size;
    }
    metrics.cacheSize.set({ cache: "idontwants" }, idontwantsCount);
    for (const [topicStr, peers] of this.topics) {
      metrics.topicPeersCount.set({ topicStr }, peers.size);
    }
    for (const [topicStr, peers] of this.mesh) {
      metrics.meshPeerCounts.set({ topicStr }, peers.size);
    }
    const scores = [];
    const scoreByPeer = /* @__PURE__ */ new Map();
    metrics.behaviourPenalty.reset();
    for (const peerIdStr of this.peers.keys()) {
      const score = this.score.score(peerIdStr);
      scores.push(score);
      scoreByPeer.set(peerIdStr, score);
      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0);
    }
    metrics.registerScores(scores, this.opts.scoreThresholds);
    metrics.registerScorePerMesh(this.mesh, scoreByPeer);
    const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);
    metrics.registerScoreWeights(sw);
  }
};
__publicField(GossipSub, "multicodec", GossipsubIDv12);
function gossipsub(init = {}) {
  return (components) => new GossipSub(components, init);
}

// ../../node_modules/@libp2p/peer-id/dist/src/peer-id.js
var _a6, _b4, _c4;
var inspect3 = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var LIBP2P_KEY_CODE5 = 114;
var PeerIdImpl3 = class {
  constructor(init) {
    __publicField(this, "type");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "string");
    __publicField(this, _a6, true);
    this.type = init.type;
    this.multihash = init.multihash;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toMultihash() {
    return this.multihash;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE5, this.multihash);
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id) {
    if (id == null) {
      return false;
    }
    if (id instanceof Uint8Array) {
      return equals3(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return this.toString() === id;
    } else if (id?.toMultihash()?.bytes != null) {
      return equals3(this.multihash.bytes, id.toMultihash().bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```TypeScript
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [(_a6 = peerIdSymbol2, inspect3)]() {
    return `PeerId(${this.toString()})`;
  }
};
var RSAPeerId3 = class extends PeerIdImpl3 {
  constructor(init) {
    super({ ...init, type: "RSA" });
    __publicField(this, "type", "RSA");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerId3 = class extends PeerIdImpl3 {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    __publicField(this, "type", "Ed25519");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var Secp256k1PeerId3 = class extends PeerIdImpl3 {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    __publicField(this, "type", "secp256k1");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
};
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE5 = 2336;
var URLPeerId3 = class {
  constructor(url) {
    __publicField(this, "type", "url");
    __publicField(this, "multihash");
    __publicField(this, "publicKey");
    __publicField(this, "url");
    __publicField(this, _b4, true);
    this.url = url.toString();
    this.multihash = identity.digest(fromString2(this.url));
  }
  [(_c4 = inspect3, _b4 = peerIdSymbol2, _c4)]() {
    return `PeerId(${this.url})`;
  }
  toString() {
    return this.toCID().toString();
  }
  toMultihash() {
    return this.multihash;
  }
  toCID() {
    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE5, this.toMultihash());
  }
  toJSON() {
    return this.toString();
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString2(other);
    }
    return other.toString() === this.toString();
  }
};

// ../../node_modules/@libp2p/peer-id/dist/src/index.js
var LIBP2P_KEY_CODE6 = 114;
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE6 = 2336;
function peerIdFromString3(str, decoder) {
  let multihash;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    multihash = decode4(base58btc.decode(`z${str}`));
  } else if (str.startsWith("k51qzi5uqu5") || str.startsWith("kzwfwjn5ji4") || str.startsWith("k2k4r8") || str.startsWith("bafz")) {
    return peerIdFromCID3(CID.parse(str));
  } else {
    if (decoder == null) {
      throw new InvalidParametersError2('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
    }
    multihash = decode4(decoder.decode(str));
  }
  return peerIdFromMultihash3(multihash);
}
function peerIdFromPublicKey3(publicKey2) {
  if (publicKey2.type === "Ed25519") {
    return new Ed25519PeerId3({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  } else if (publicKey2.type === "secp256k1") {
    return new Secp256k1PeerId3({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  } else if (publicKey2.type === "RSA") {
    return new RSAPeerId3({
      multihash: publicKey2.toCID().multihash,
      publicKey: publicKey2
    });
  }
  throw new UnsupportedKeyTypeError2();
}
function peerIdFromPrivateKey3(privateKey) {
  return peerIdFromPublicKey3(privateKey.publicKey);
}
function peerIdFromMultihash3(multihash) {
  if (isSha256Multihash3(multihash)) {
    return new RSAPeerId3({ multihash });
  } else if (isIdentityMultihash3(multihash)) {
    try {
      const publicKey2 = publicKeyFromMultihash(multihash);
      if (publicKey2.type === "Ed25519") {
        return new Ed25519PeerId3({ multihash, publicKey: publicKey2 });
      } else if (publicKey2.type === "secp256k1") {
        return new Secp256k1PeerId3({ multihash, publicKey: publicKey2 });
      }
    } catch (err) {
      const url = toString2(multihash.digest);
      return new URLPeerId3(new URL(url));
    }
  }
  throw new InvalidMultihashError2("Supplied PeerID Multihash is invalid");
}
function peerIdFromCID3(cid) {
  if (cid?.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE6 && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE6) {
    throw new InvalidCIDError2("Supplied PeerID CID is invalid");
  }
  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE6) {
    const url = toString2(cid.multihash.digest);
    return new URLPeerId3(new URL(url));
  }
  return peerIdFromMultihash3(cid.multihash);
}
function isIdentityMultihash3(multihash) {
  return multihash.code === identity.code;
}
function isSha256Multihash3(multihash) {
  return multihash.code === sha256.code;
}

// ../../node_modules/@sindresorhus/fnv1a/index.js
var FNV_PRIMES = {
  32: 16777619n,
  64: 1099511628211n,
  128: 309485009821345068724781371n,
  256: 374144419156711147060143317175368453031918731002211n,
  512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
  1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
};
var FNV_OFFSETS = {
  32: 2166136261n,
  64: 14695981039346656037n,
  128: 144066263297769815596495629667062367629n,
  256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
  512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
  1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
};
var cachedEncoder = new window.TextEncoder();
function fnv1aUint8Array(uint8Array, size) {
  const fnvPrime = FNV_PRIMES[size];
  let hash = FNV_OFFSETS[size];
  for (let index = 0; index < uint8Array.length; index++) {
    hash ^= BigInt(uint8Array[index]);
    hash = BigInt.asUintN(size, hash * fnvPrime);
  }
  return hash;
}
function fnv1aEncodeInto(string2, size, utf8Buffer) {
  if (utf8Buffer.length === 0) {
    throw new Error("The `utf8Buffer` option must have a length greater than zero");
  }
  const fnvPrime = FNV_PRIMES[size];
  let hash = FNV_OFFSETS[size];
  let remaining = string2;
  while (remaining.length > 0) {
    const result = cachedEncoder.encodeInto(remaining, utf8Buffer);
    remaining = remaining.slice(result.read);
    for (let index = 0; index < result.written; index++) {
      hash ^= BigInt(utf8Buffer[index]);
      hash = BigInt.asUintN(size, hash * fnvPrime);
    }
  }
  return hash;
}
function fnv1a(value2, { size = 32, utf8Buffer } = {}) {
  if (!FNV_PRIMES[size]) {
    throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
  }
  if (typeof value2 === "string") {
    if (utf8Buffer) {
      return fnv1aEncodeInto(value2, size, utf8Buffer);
    }
    value2 = cachedEncoder.encode(value2);
  }
  return fnv1aUint8Array(value2, size);
}

// ../../node_modules/@libp2p/utils/dist/src/filters/hashes.js
var fnv1a2 = {
  hash: (input) => {
    return Number(fnv1a(input, {
      size: 32
    }));
  },
  hashV: (input, seed) => {
    return numberToBuffer(fnv1a2.hash(input, seed));
  }
};
function numberToBuffer(num2) {
  let hex = num2.toString(16);
  if (hex.length % 2 === 1) {
    hex = `0${hex}`;
  }
  return fromString2(hex, "base16");
}

// ../../node_modules/@libp2p/utils/dist/src/filters/bloom-filter.js
var LN2_SQUARED = Math.LN2 * Math.LN2;
var BloomFilter = class {
  constructor(options2 = {}) {
    __publicField(this, "seeds");
    __publicField(this, "bits");
    __publicField(this, "buffer");
    if (options2.seeds != null) {
      this.seeds = options2.seeds;
    } else {
      this.seeds = generateSeeds(options2.hashes ?? 8);
    }
    this.bits = options2.bits ?? 1024;
    this.buffer = alloc(Math.ceil(this.bits / 8));
  }
  /**
   * Add an item to the filter
   */
  add(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    for (let i2 = 0; i2 < this.seeds.length; i2++) {
      const hash = fnv1a2.hash(item, this.seeds[i2]);
      const bit = hash % this.bits;
      this.setbit(bit);
    }
  }
  /**
   * Test if the filter has an item. If it returns false it definitely does not
   * have the item. If it returns true, it probably has the item but there's
   * an `errorRate` chance it doesn't.
   */
  has(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    for (let i2 = 0; i2 < this.seeds.length; i2++) {
      const hash = fnv1a2.hash(item, this.seeds[i2]);
      const bit = hash % this.bits;
      const isSet = this.getbit(bit);
      if (!isSet) {
        return false;
      }
    }
    return true;
  }
  /**
   * Reset the filter
   */
  clear() {
    this.buffer.fill(0);
  }
  setbit(bit) {
    const pos = Math.floor(bit / 8);
    const shift = bit % 8;
    let bitField = this.buffer[pos];
    bitField |= 1 << shift;
    this.buffer[pos] = bitField;
  }
  getbit(bit) {
    const pos = Math.floor(bit / 8);
    const shift = bit % 8;
    const bitField = this.buffer[pos];
    return (bitField & 1 << shift) !== 0;
  }
};
function createBloomFilter(itemCount, errorRate = 5e-3) {
  const opts = optimize(itemCount, errorRate);
  return new BloomFilter(opts);
}
function optimize(itemCount, errorRate = 5e-3) {
  const bits = Math.round(-1 * itemCount * Math.log(errorRate) / LN2_SQUARED);
  const hashes2 = Math.round(bits / itemCount * Math.LN2);
  return { bits, hashes: hashes2 };
}
function generateSeeds(count) {
  let buf2;
  let j;
  const seeds = [];
  for (let i2 = 0; i2 < count; i2++) {
    buf2 = new Uint8ArrayList(randomBytes2(4));
    seeds[i2] = buf2.getUint32(0, true);
    for (j = 0; j < i2; j++) {
      if (seeds[i2] === seeds[j]) {
        i2--;
        break;
      }
    }
  }
  return seeds;
}

// ../../node_modules/@libp2p/utils/dist/src/filters/fingerprint.js
var MAX_FINGERPRINT_SIZE = 64;
var Fingerprint = class {
  constructor(buf2, hash, seed, fingerprintSize = 2) {
    __publicField(this, "fp");
    __publicField(this, "h");
    __publicField(this, "seed");
    if (fingerprintSize > MAX_FINGERPRINT_SIZE) {
      throw new TypeError("Invalid Fingerprint Size");
    }
    const fnv = hash.hashV(buf2, seed);
    const fp = alloc(fingerprintSize);
    for (let i2 = 0; i2 < fp.length; i2++) {
      fp[i2] = fnv[i2];
    }
    if (fp.length === 0) {
      fp[0] = 7;
    }
    this.fp = fp;
    this.h = hash;
    this.seed = seed;
  }
  hash() {
    return this.h.hash(this.fp, this.seed);
  }
  equals(other) {
    if (!(other?.fp instanceof Uint8Array)) {
      return false;
    }
    return equals3(this.fp, other.fp);
  }
};

// ../../node_modules/@libp2p/utils/dist/src/filters/utils.js
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

// ../../node_modules/@libp2p/utils/dist/src/filters/bucket.js
var Bucket = class {
  constructor(size) {
    __publicField(this, "contents");
    this.contents = new Array(size).fill(null);
  }
  has(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    return this.contents.some((fp) => {
      return fingerprint.equals(fp);
    });
  }
  add(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    for (let i2 = 0; i2 < this.contents.length; i2++) {
      if (this.contents[i2] == null) {
        this.contents[i2] = fingerprint;
        return true;
      }
    }
    return true;
  }
  swap(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const i2 = getRandomInt(0, this.contents.length - 1);
    const current = this.contents[i2];
    this.contents[i2] = fingerprint;
    return current;
  }
  remove(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const found = this.contents.findIndex((fp) => {
      return fingerprint.equals(fp);
    });
    if (found > -1) {
      this.contents[found] = null;
      return true;
    } else {
      return false;
    }
  }
};

// ../../node_modules/@libp2p/utils/dist/src/filters/cuckoo-filter.js
var maxCuckooCount = 500;
var CuckooFilter = class {
  constructor(init) {
    __publicField(this, "bucketSize");
    __publicField(this, "filterSize");
    __publicField(this, "fingerprintSize");
    __publicField(this, "buckets");
    __publicField(this, "count");
    __publicField(this, "hash");
    __publicField(this, "seed");
    this.filterSize = init.filterSize;
    this.bucketSize = init.bucketSize ?? 4;
    this.fingerprintSize = init.fingerprintSize ?? 2;
    this.count = 0;
    this.buckets = [];
    this.hash = init.hash ?? fnv1a2;
    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    if (this.buckets[j] == null) {
      this.buckets[j] = new Bucket(this.bucketSize);
    }
    if (this.buckets[k] == null) {
      this.buckets[k] = new Bucket(this.bucketSize);
    }
    if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {
      this.count++;
      return true;
    }
    const rand = [j, k];
    let i2 = rand[getRandomInt(0, rand.length - 1)];
    if (this.buckets[i2] == null) {
      this.buckets[i2] = new Bucket(this.bucketSize);
    }
    for (let n2 = 0; n2 < maxCuckooCount; n2++) {
      const swapped = this.buckets[i2].swap(fingerprint);
      if (swapped == null) {
        continue;
      }
      i2 = (i2 ^ swapped.hash()) % this.filterSize;
      if (this.buckets[i2] == null) {
        this.buckets[i2] = new Bucket(this.bucketSize);
      }
      if (this.buckets[i2].add(swapped)) {
        this.count++;
        return true;
      } else {
        continue;
      }
    }
    return false;
  }
  has(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = this.buckets[j]?.has(fingerprint) ?? false;
    if (inJ) {
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    return this.buckets[k]?.has(fingerprint) ?? false;
  }
  remove(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = this.buckets[j]?.remove(fingerprint) ?? false;
    if (inJ) {
      this.count--;
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    const inK = this.buckets[k]?.remove(fingerprint) ?? false;
    if (inK) {
      this.count--;
    }
    return inK;
  }
  get reliable() {
    return Math.floor(100 * (this.count / this.filterSize)) <= 90;
  }
};
var MAX_LOAD = {
  1: 0.5,
  2: 0.84,
  4: 0.95,
  8: 0.98
};
function calculateBucketSize(errorRate = 1e-3) {
  if (errorRate > 2e-3) {
    return 2;
  }
  if (errorRate > 1e-5) {
    return 4;
  }
  return 8;
}
function optimize2(maxItems, errorRate = 1e-3) {
  const bucketSize = calculateBucketSize(errorRate);
  const load2 = MAX_LOAD[bucketSize];
  const filterSize = Math.round(maxItems / load2);
  const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE);
  return {
    filterSize,
    bucketSize,
    fingerprintSize
  };
}
function createCuckooFilter(maxItems, errorRate = 5e-3) {
  const opts = optimize2(maxItems, errorRate);
  return new CuckooFilter(opts);
}

// ../../node_modules/@libp2p/utils/dist/src/filters/scalable-cuckoo-filter.js
var ScalableCuckooFilter = class {
  constructor(init) {
    __publicField(this, "filterSize");
    __publicField(this, "bucketSize");
    __publicField(this, "fingerprintSize");
    __publicField(this, "scale");
    __publicField(this, "filterSeries");
    __publicField(this, "hash");
    __publicField(this, "seed");
    this.bucketSize = init.bucketSize ?? 4;
    this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize;
    this.fingerprintSize = init.fingerprintSize ?? 2;
    this.scale = init.scale ?? 2;
    this.hash = init.hash ?? fnv1a2;
    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
    this.filterSeries = [
      new CuckooFilter({
        filterSize: this.filterSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      })
    ];
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    if (this.has(item)) {
      return true;
    }
    let current = this.filterSeries.find((cuckoo) => {
      return cuckoo.reliable;
    });
    if (current == null) {
      const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length);
      current = new CuckooFilter({
        filterSize: curSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      });
      this.filterSeries.push(current);
    }
    return current.add(item);
  }
  has(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    for (let i2 = 0; i2 < this.filterSeries.length; i2++) {
      if (this.filterSeries[i2].has(item)) {
        return true;
      }
    }
    return false;
  }
  remove(item) {
    if (typeof item === "string") {
      item = fromString2(item);
    }
    for (let i2 = 0; i2 < this.filterSeries.length; i2++) {
      if (this.filterSeries[i2].remove(item)) {
        return true;
      }
    }
    return false;
  }
  get count() {
    return this.filterSeries.reduce((acc, curr) => {
      return acc + curr.count;
    }, 0);
  }
};
function createScalableCuckooFilter(maxItems, errorRate = 1e-3, options2) {
  return new ScalableCuckooFilter({
    ...optimize2(maxItems, errorRate),
    ...options2 ?? {}
  });
}

// ../../node_modules/@libp2p/utils/dist/src/multiaddr/get-net-config.js
function getNetConfig(ma) {
  const components = ma.getComponents();
  const config = {};
  let index = 0;
  if (components[index]?.name === "ip6zone") {
    config.zone = `${components[index].value}`;
    index++;
  }
  if (components[index].name === "ip4" || components[index].name === "ip6") {
    config.type = components[index].name;
    config.host = components[index].value;
    index++;
  } else if (components[index].name === "dns" || components[index].name === "dns4" || components[index].name === "dns6") {
    config.type = components[index].name;
    config.host = components[index].value;
    index++;
  } else if (components[index].name === "dnsaddr") {
    config.type = components[index].name;
    config.host = `_dnsaddr.${components[index].value}`;
    index++;
  }
  if (components[index]?.name === "tcp" || components[index]?.name === "udp") {
    config.protocol = components[index].name === "tcp" ? "tcp" : "udp";
    config.port = parseInt(`${components[index].value}`);
    index++;
  }
  if (components[index]?.name === "ipcidr") {
    if (config.type === "ip4") {
      config.cidr = parseInt(`${components[index].value}`);
    } else if (config.type === "ip6") {
      config.cidr = `${components[index].value}`;
    }
    index++;
  }
  if (config.type == null || config.host == null) {
    throw new InvalidParametersError2(`Multiaddr ${ma} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`);
  }
  if (components[index]?.name === "tls" && components[index + 1]?.name === "sni") {
    config.sni = components[index + 1].value;
    index += 2;
  }
  return config;
}

// ../../node_modules/@libp2p/utils/dist/src/multiaddr/is-global-unicast.js
function isGlobalUnicast(ma) {
  try {
    const config = getNetConfig(ma);
    switch (config.type) {
      case "ip6":
        return cidrContains("2000::/3", config.host);
      default:
        return false;
    }
  } catch {
    return false;
  }
}

// ../../node_modules/@libp2p/utils/dist/src/multiaddr/is-link-local.js
function isLinkLocal(ma) {
  try {
    const config = getNetConfig(ma);
    switch (config.type) {
      case "ip4":
        return config.host.startsWith("169.254.");
      case "ip6":
        return config.host.toLowerCase().startsWith("fe80");
      default:
        return false;
    }
  } catch (err) {
    return false;
  }
}

// ../../node_modules/is-loopback-addr/dist/src/index.js
function isLoopbackAddr(ip) {
  return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
}

// ../../node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
function isLoopback(ma) {
  try {
    const config = getNetConfig(ma);
    switch (config.type) {
      case "ip4":
      case "ip6":
        return isLoopbackAddr(config.host);
      default:
        return false;
    }
  } catch {
    return false;
  }
}

// ../../node_modules/@libp2p/utils/dist/src/multiaddr/is-network-address.js
function isNetworkAddress(ma) {
  try {
    getNetConfig(ma);
    return true;
  } catch {
    return false;
  }
}

// ../../node_modules/@libp2p/utils/dist/src/private-ip.js
var import_netmask3 = __toESM(require_netmask(), 1);
var PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange) => new import_netmask3.Netmask(ipRange));
function ipv4Check(ipAddr) {
  for (const r2 of NETMASK_RANGES) {
    if (r2.contains(ipAddr)) {
      return true;
    }
  }
  return false;
}
function isIpv4MappedIpv6(ipAddr) {
  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);
}
function ipv4MappedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  if (parts.length < 2) {
    return false;
  }
  const octet34 = parts[parts.length - 1].padStart(4, "0");
  const octet12 = parts[parts.length - 2].padStart(4, "0");
  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;
  return ipv4Check(ip4);
}
function isIpv4EmbeddedIpv6(ipAddr) {
  return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr);
}
function ipv4EmbeddedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  const ip4 = parts[parts.length - 1];
  return ipv4Check(ip4);
}
function ipv6Check(ipAddr) {
  return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
}
function isPrivateIp(ip) {
  if (isIPv4(ip)) {
    return ipv4Check(ip);
  }
  if (isIpv4MappedIpv6(ip)) {
    return ipv4MappedIpv6Check(ip);
  }
  if (isIpv4EmbeddedIpv6(ip)) {
    return ipv4EmbeddedIpv6Check(ip);
  }
  if (isIPv6(ip)) {
    return ipv6Check(ip);
  }
}

// ../../node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
function isPrivate(ma) {
  try {
    const config = getNetConfig(ma);
    switch (config.type) {
      case "ip4":
      case "ip6":
        return isPrivateIp(config.host) ?? false;
      default:
        return config.host === "localhost";
    }
  } catch {
    return false;
  }
}

// ../../node_modules/p-event/node_modules/p-timeout/index.js
var TimeoutError4 = class extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
};
var AbortError5 = class extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
var getDOMException = (errorMessage) => window.DOMException === void 0 ? new AbortError5(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options2) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout }
  } = options2;
  let timer;
  let abortHandler;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options2.signal) {
      const { signal } = options2;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      abortHandler = () => {
        reject(getAbortedReason(signal));
      };
      signal.addEventListener("abort", abortHandler, { once: true });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError4();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message2 === false) {
        resolve();
      } else if (message2 instanceof Error) {
        reject(message2);
      } else {
        timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      }
    })();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
    if (abortHandler && options2.signal) {
      options2.signal.removeEventListener("abort", abortHandler);
    }
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// ../../node_modules/p-event/index.js
var normalizeEmitter = (emitter) => {
  const addListener2 = emitter.addEventListener || emitter.on || emitter.addListener;
  const removeListener2 = emitter.removeEventListener || emitter.off || emitter.removeListener;
  if (!addListener2 || !removeListener2) {
    throw new TypeError("Emitter is not compatible");
  }
  return {
    addListener: addListener2.bind(emitter),
    removeListener: removeListener2.bind(emitter)
  };
};
function pEventMultiple(emitter, event, options2) {
  let cancel;
  const returnValue = new Promise((resolve, reject) => {
    options2 = {
      rejectionEvents: ["error"],
      multiArgs: false,
      rejectionMultiArgs: false,
      resolveImmediately: false,
      ...options2
    };
    if (!(options2.count >= 0 && (options2.count === Number.POSITIVE_INFINITY || Number.isInteger(options2.count)))) {
      throw new TypeError("The `count` option should be at least 0 or more");
    }
    options2.signal?.throwIfAborted();
    const events = [event].flat();
    const items = [];
    const { addListener: addListener2, removeListener: removeListener2 } = normalizeEmitter(emitter);
    const onItem = async (...arguments_) => {
      const value2 = options2.multiArgs ? arguments_ : arguments_[0];
      if (options2.filter) {
        try {
          if (!await options2.filter(value2)) {
            return;
          }
        } catch (error) {
          cancel();
          reject(error);
          return;
        }
      }
      items.push(value2);
      if (options2.count === items.length) {
        cancel();
        resolve(items);
      }
    };
    const rejectHandler = (...arguments_) => {
      cancel();
      reject(options2.rejectionMultiArgs ? arguments_ : arguments_[0]);
    };
    cancel = () => {
      for (const event2 of events) {
        removeListener2(event2, onItem);
      }
      for (const rejectionEvent of options2.rejectionEvents) {
        if (!events.includes(rejectionEvent)) {
          removeListener2(rejectionEvent, rejectHandler);
        }
      }
    };
    for (const event2 of events) {
      addListener2(event2, onItem);
    }
    for (const rejectionEvent of options2.rejectionEvents) {
      if (!events.includes(rejectionEvent)) {
        addListener2(rejectionEvent, rejectHandler);
      }
    }
    if (options2.signal) {
      options2.signal.addEventListener("abort", () => {
        rejectHandler(options2.signal.reason);
      }, { once: true });
    }
    if (options2.resolveImmediately) {
      resolve(items);
    }
  });
  returnValue.cancel = cancel;
  if (typeof options2.timeout === "number") {
    const timeout = pTimeout(returnValue, { milliseconds: options2.timeout });
    timeout.cancel = () => {
      cancel();
      timeout.clear();
    };
    return timeout;
  }
  return returnValue;
}
function pEvent(emitter, event, options2) {
  if (typeof options2 === "function") {
    options2 = { filter: options2 };
  }
  options2 = {
    ...options2,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = pEventMultiple(emitter, event, options2);
  const promise = arrayPromise.then((array) => array[0]);
  promise.cancel = arrayPromise.cancel;
  return promise;
}
function pEventIterator(emitter, event, options2) {
  if (typeof options2 === "function") {
    options2 = { filter: options2 };
  }
  const events = [event].flat();
  options2 = {
    rejectionEvents: ["error"],
    resolutionEvents: [],
    limit: Number.POSITIVE_INFINITY,
    multiArgs: false,
    rejectionMultiArgs: false,
    ...options2
  };
  const { limit } = options2;
  const isValidLimit = limit >= 0 && (limit === Number.POSITIVE_INFINITY || Number.isInteger(limit));
  if (!isValidLimit) {
    throw new TypeError("The `limit` option should be a non-negative integer or Infinity");
  }
  options2.signal?.throwIfAborted();
  if (limit === 0) {
    return {
      [Symbol.asyncIterator]() {
        return this;
      },
      async next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
  const { addListener: addListener2, removeListener: removeListener2 } = normalizeEmitter(emitter);
  let isDone = false;
  let error;
  let hasPendingError = false;
  const nextQueue = [];
  const valueQueue = [];
  let eventCount = 0;
  let isLimitReached = false;
  const valueHandler = (...arguments_) => {
    eventCount++;
    isLimitReached = eventCount === limit;
    const value2 = options2.multiArgs ? arguments_ : arguments_[0];
    if (nextQueue.length > 0) {
      const { resolve } = nextQueue.shift();
      resolve({ done: false, value: value2 });
      if (isLimitReached) {
        cancel();
      }
      return;
    }
    valueQueue.push(value2);
    if (isLimitReached) {
      cancel();
    }
  };
  const cancel = () => {
    isDone = true;
    for (const event2 of events) {
      removeListener2(event2, valueHandler);
    }
    for (const rejectionEvent of options2.rejectionEvents) {
      removeListener2(rejectionEvent, rejectHandler);
    }
    for (const resolutionEvent of options2.resolutionEvents) {
      removeListener2(resolutionEvent, resolveHandler);
    }
    while (nextQueue.length > 0) {
      const { resolve } = nextQueue.shift();
      resolve({ done: true, value: void 0 });
    }
  };
  const rejectHandler = (...arguments_) => {
    error = options2.rejectionMultiArgs ? arguments_ : arguments_[0];
    if (nextQueue.length > 0) {
      const { reject } = nextQueue.shift();
      reject(error);
    } else {
      hasPendingError = true;
    }
    cancel();
  };
  const resolveHandler = async (...arguments_) => {
    const value2 = options2.multiArgs ? arguments_ : arguments_[0];
    if (options2.filter) {
      try {
        if (!await options2.filter(value2)) {
          cancel();
          return;
        }
      } catch (filterError) {
        cancel();
        if (nextQueue.length > 0) {
          const { reject } = nextQueue.shift();
          reject(filterError);
        } else {
          hasPendingError = true;
          error = filterError;
        }
        return;
      }
    }
    if (nextQueue.length > 0) {
      const { resolve } = nextQueue.shift();
      resolve({ done: true, value: value2 });
    } else {
      valueQueue.push(value2);
    }
    cancel();
  };
  for (const event2 of events) {
    addListener2(event2, valueHandler);
  }
  for (const rejectionEvent of options2.rejectionEvents) {
    addListener2(rejectionEvent, rejectHandler);
  }
  for (const resolutionEvent of options2.resolutionEvents) {
    addListener2(resolutionEvent, resolveHandler);
  }
  if (options2.signal) {
    options2.signal.addEventListener("abort", () => {
      rejectHandler(options2.signal.reason);
    }, { once: true });
  }
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    async next() {
      if (valueQueue.length > 0) {
        const value2 = valueQueue.shift();
        return {
          done: isDone && valueQueue.length === 0 && !isLimitReached,
          value: value2
        };
      }
      if (hasPendingError) {
        hasPendingError = false;
        throw error;
      }
      if (isDone) {
        return {
          done: true,
          value: void 0
        };
      }
      return new Promise((resolve, reject) => {
        nextQueue.push({ resolve, reject });
      });
    },
    async return(value2) {
      cancel();
      return {
        done: isDone,
        value: value2
      };
    }
  };
}

// ../../node_modules/@libp2p/utils/dist/src/debounce.js
function debounce(func, wait) {
  let timeout;
  const output = function() {
    const later = function() {
      timeout = void 0;
      void func();
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
  output.start = () => {
  };
  output.stop = () => {
    clearTimeout(timeout);
  };
  return output;
}

// ../../node_modules/@libp2p/utils/dist/src/errors.js
var RateLimitError = class extends Error {
  constructor(message2 = "Rate limit exceeded", props) {
    super(message2);
    __publicField(this, "remainingPoints");
    __publicField(this, "msBeforeNext");
    __publicField(this, "consumedPoints");
    __publicField(this, "isFirstInDuration");
    this.name = "RateLimitError";
    this.remainingPoints = props.remainingPoints;
    this.msBeforeNext = props.msBeforeNext;
    this.consumedPoints = props.consumedPoints;
    this.isFirstInDuration = props.isFirstInDuration;
  }
};
var QueueFullError = class extends Error {
  constructor(message2 = "The queue was full") {
    super(message2);
    this.name = "QueueFullError";
  }
};
__publicField(QueueFullError, "name", "QueueFullError");
var UnexpectedEOFError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
  }
};
__publicField(UnexpectedEOFError2, "name", "UnexpectedEOFError");
var MaxEarlyStreamsError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "MaxEarlyStreamsError");
  }
};
__publicField(MaxEarlyStreamsError, "name", "MaxEarlyStreamsError");
var StreamClosedError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "StreamClosedError");
  }
};
__publicField(StreamClosedError, "name", "StreamClosedError");

// ../../node_modules/@libp2p/utils/dist/src/queue/recipient.js
var JobRecipient = class {
  constructor(signal) {
    __publicField(this, "deferred");
    __publicField(this, "signal");
    this.signal = signal;
    this.deferred = pDefer();
    this.onAbort = this.onAbort.bind(this);
    this.signal?.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    this.deferred.reject(this.signal?.reason ?? new AbortError2());
  }
  cleanup() {
    this.signal?.removeEventListener("abort", this.onAbort);
  }
};

// ../../node_modules/@libp2p/utils/dist/src/queue/job.js
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
var Job = class {
  constructor(fn, options2) {
    __publicField(this, "id");
    __publicField(this, "fn");
    __publicField(this, "options");
    __publicField(this, "recipients");
    __publicField(this, "status");
    __publicField(this, "timeline");
    __publicField(this, "controller");
    this.id = randomId();
    this.status = "queued";
    this.fn = fn;
    this.options = options2;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      return acc && curr.signal?.aborted === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError2());
      this.cleanup();
    }
  }
  async join(options2 = {}) {
    const recipient = new JobRecipient(options2.signal);
    this.recipients.push(recipient);
    options2.signal?.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      recipient.cleanup();
      recipient.signal?.removeEventListener("abort", this.onAbort);
    });
  }
};

// ../../node_modules/@libp2p/utils/dist/src/queue/index.js
var Queue = class extends TypedEventEmitter {
  constructor(init = {}) {
    super();
    __publicField(this, "concurrency");
    __publicField(this, "maxSize");
    __publicField(this, "queue");
    __publicField(this, "pending");
    __publicField(this, "sort");
    __publicField(this, "paused");
    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    this.paused = false;
    if (init.metricName != null) {
      init.metrics?.registerMetricGroup(init.metricName, {
        calculate: () => {
          return {
            size: this.queue.length,
            running: this.pending,
            queued: this.queue.length - this.pending
          };
        }
      });
    }
    this.sort = init.sort;
    this.queue = [];
    this.emitEmpty = debounce(this.emitEmpty.bind(this), 1);
    this.emitIdle = debounce(this.emitIdle.bind(this), 1);
  }
  emitEmpty() {
    if (this.size !== 0) {
      return;
    }
    this.safeDispatchEvent("empty");
  }
  emitIdle() {
    if (this.running !== 0) {
      return;
    }
    this.safeDispatchEvent("idle");
  }
  pause() {
    this.paused = true;
  }
  resume() {
    if (!this.paused) {
      return;
    }
    this.paused = false;
    this.tryToStartAnother();
  }
  tryToStartAnother() {
    if (this.paused) {
      return false;
    }
    if (this.size === 0) {
      this.emitEmpty();
      if (this.running === 0) {
        this.emitIdle();
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
        this.pending--;
        this.tryToStartAnother();
        this.safeDispatchEvent("next");
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options2) {
    options2?.signal?.throwIfAborted();
    if (this.size === this.maxSize) {
      throw new QueueFullError();
    }
    const job = new Job(fn, options2);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    this.tryToStartAnother();
    return job.join(options2).then((result) => {
      this.safeDispatchEvent("completed", { detail: result });
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError2());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options2) {
    if (this.size === 0) {
      return;
    }
    await pEvent(this, "empty", options2);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options2) {
    if (this.size < limit) {
      return;
    }
    await pEvent(this, "next", {
      ...options2,
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options2) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await pEvent(this, "idle", options2);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options2) {
    options2?.signal?.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail);
      }
    };
    const onQueueFailure = (evt) => {
      cleanup(evt.detail.error);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new AbortError2("Queue aborted"));
    };
    this.addEventListener("completed", onQueueJobComplete);
    this.addEventListener("failure", onQueueFailure);
    this.addEventListener("idle", onQueueIdle);
    options2?.signal?.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("completed", onQueueJobComplete);
      this.removeEventListener("failure", onQueueFailure);
      this.removeEventListener("idle", onQueueIdle);
      options2?.signal?.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};

// ../../node_modules/@libp2p/utils/dist/src/abstract-message-stream.js
var DEFAULT_MAX_READ_BUFFER_LENGTH = Math.pow(2, 20) * 4;
var AbstractMessageStream = class extends TypedEventEmitter {
  constructor(init) {
    super();
    __publicField(this, "status");
    __publicField(this, "timeline");
    __publicField(this, "inactivityTimeout");
    __publicField(this, "maxReadBufferLength");
    __publicField(this, "maxWriteBufferLength");
    __publicField(this, "log");
    __publicField(this, "direction");
    __publicField(this, "maxMessageSize");
    __publicField(this, "readStatus");
    __publicField(this, "writeStatus");
    __publicField(this, "remoteReadStatus");
    __publicField(this, "remoteWriteStatus");
    __publicField(this, "writableNeedsDrain");
    /**
     * Any data stored here is emitted before any new incoming data.
     *
     * This is used when the stream is paused or if data is pushed onto the stream
     */
    __publicField(this, "readBuffer");
    __publicField(this, "writeBuffer");
    __publicField(this, "sendingData");
    __publicField(this, "onDrainPromise");
    this.status = "open";
    this.log = init.log;
    this.direction = init.direction ?? "outbound";
    this.inactivityTimeout = init.inactivityTimeout ?? 12e4;
    this.maxReadBufferLength = init.maxReadBufferLength ?? DEFAULT_MAX_READ_BUFFER_LENGTH;
    this.maxWriteBufferLength = init.maxWriteBufferLength;
    this.maxMessageSize = init.maxMessageSize;
    this.readBuffer = new Uint8ArrayList();
    this.writeBuffer = new Uint8ArrayList();
    this.readStatus = "readable";
    this.remoteReadStatus = "readable";
    this.writeStatus = "writable";
    this.remoteWriteStatus = "writable";
    this.sendingData = false;
    this.writableNeedsDrain = false;
    this.timeline = {
      open: Date.now()
    };
    this.processSendQueue = this.processSendQueue.bind(this);
    const continueSendingOnDrain = () => {
      if (this.writableNeedsDrain) {
        this.log.trace("drain event received, continue sending data");
        this.writableNeedsDrain = false;
        this.processSendQueue();
      }
      this.onDrainPromise?.resolve();
    };
    this.addEventListener("drain", continueSendingOnDrain);
    const rejectOnDrainOnClose = (evt) => {
      this.onDrainPromise?.reject(evt.error ?? new StreamClosedError());
    };
    this.addEventListener("close", rejectOnDrainOnClose);
  }
  get readBufferLength() {
    return this.readBuffer.byteLength;
  }
  get writeBufferLength() {
    return this.writeBuffer.byteLength;
  }
  async onDrain(options2) {
    if (this.writableNeedsDrain !== true) {
      return Promise.resolve();
    }
    if (this.onDrainPromise == null) {
      this.onDrainPromise = Promise.withResolvers();
    }
    return raceSignal(this.onDrainPromise.promise, options2?.signal);
  }
  async *[Symbol.asyncIterator]() {
    if (this.readStatus !== "readable" && this.readStatus !== "paused") {
      return;
    }
    const output = pushable();
    const streamAsyncIterableOnMessageListener = (evt) => {
      output.push(evt.data);
    };
    this.addEventListener("message", streamAsyncIterableOnMessageListener);
    const streamAsyncIterableOnCloseListener = (evt) => {
      output.end(evt.error);
    };
    this.addEventListener("close", streamAsyncIterableOnCloseListener);
    const streamAsyncIterableOnRemoteCloseWriteListener = () => {
      output.end();
    };
    this.addEventListener("remoteCloseWrite", streamAsyncIterableOnRemoteCloseWriteListener);
    try {
      yield* output;
    } finally {
      this.removeEventListener("message", streamAsyncIterableOnMessageListener);
      this.removeEventListener("close", streamAsyncIterableOnCloseListener);
      this.removeEventListener("remoteCloseWrite", streamAsyncIterableOnRemoteCloseWriteListener);
    }
  }
  isReadable() {
    return this.status === "open";
  }
  send(data) {
    if (this.writeStatus === "closed" || this.writeStatus === "closing") {
      throw new StreamStateError2(`Cannot write to a stream that is ${this.writeStatus}`);
    }
    this.log.trace("append %d bytes to write buffer", data.byteLength);
    this.writeBuffer.append(data);
    return this.processSendQueue();
  }
  /**
   * Close immediately for reading and writing and send a reset message (local
   * error)
   */
  abort(err) {
    if (this.status === "aborted" || this.status === "reset" || this.status === "closed") {
      return;
    }
    this.log.error("abort with error - %e", err);
    this.status = "aborted";
    if (this.readBuffer.byteLength > 0) {
      this.readBuffer.consume(this.readBuffer.byteLength);
    }
    if (this.writeBuffer.byteLength > 0) {
      this.writeBuffer.consume(this.writeBuffer.byteLength);
      this.safeDispatchEvent("idle");
    }
    this.writeStatus = "closed";
    this.remoteWriteStatus = "closed";
    this.readStatus = "closed";
    this.remoteReadStatus = "closed";
    this.timeline.close = Date.now();
    try {
      this.sendReset(err);
    } catch (err2) {
      this.log("failed to send reset to remote - %e", err2);
    }
    this.dispatchEvent(new StreamAbortEvent(err));
  }
  pause() {
    if (this.readStatus === "closed" || this.readStatus === "closing") {
      throw new StreamStateError2("Cannot pause a stream that is closing/closed");
    }
    if (this.readStatus === "paused") {
      return;
    }
    this.readStatus = "paused";
    this.sendPause();
  }
  resume() {
    if (this.readStatus === "closed" || this.readStatus === "closing") {
      throw new StreamStateError2("Cannot resume a stream that is closing/closed");
    }
    if (this.readStatus === "readable") {
      return;
    }
    this.readStatus = "readable";
    this.dispatchReadBuffer();
    this.sendResume();
  }
  push(data) {
    if (this.readStatus === "closed" || this.readStatus === "closing") {
      throw new StreamStateError2(`Cannot push data onto a stream that is ${this.readStatus}`);
    }
    if (data.byteLength === 0) {
      return;
    }
    this.readBuffer.append(data);
    if (this.readStatus === "paused" || this.listenerCount("message") === 0) {
      this.checkReadBufferLength();
      return;
    }
    setTimeout(() => {
      this.dispatchReadBuffer();
    }, 0);
  }
  unshift(data) {
    if (this.readStatus === "closed" || this.readStatus === "closing") {
      throw new StreamStateError2(`Cannot push data onto a stream that is ${this.readStatus}`);
    }
    if (data.byteLength === 0) {
      return;
    }
    this.readBuffer.prepend(data);
    if (this.readStatus === "paused" || this.listenerCount("message") === 0) {
      this.checkReadBufferLength();
      return;
    }
    setTimeout(() => {
      this.dispatchReadBuffer();
    }, 0);
  }
  /**
   * When an extending class reads data from it's implementation-specific source,
   * call this method to allow the stream consumer to read the data.
   */
  onData(data) {
    if (data.byteLength === 0) {
      return;
    }
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      this.log("ignoring data - read status %s", this.readStatus);
      return;
    }
    this.readBuffer.append(data);
    this.dispatchReadBuffer();
  }
  addEventListener(...args) {
    super.addEventListener.apply(this, args);
    if (args[0] === "message" && this.readBuffer.byteLength > 0) {
      queueMicrotask(() => {
        this.dispatchReadBuffer();
      });
    }
  }
  /**
   * Receive a reset message - close immediately for reading and writing (remote
   * error)
   */
  onRemoteReset() {
    this.log("remote reset");
    this.status = "reset";
    this.writeStatus = "closed";
    this.remoteWriteStatus = "closed";
    this.remoteReadStatus = "closed";
    this.timeline.close = Date.now();
    if (this.readBuffer.byteLength === 0) {
      this.readStatus = "closed";
    }
    const err = new StreamResetError2();
    this.dispatchEvent(new StreamResetEvent(err));
  }
  /**
   * The underlying resource or transport this stream uses has closed - it is
   * not possible to send any more messages though any data still in the read
   * buffer may still be read
   */
  onTransportClosed(err) {
    this.log("transport closed");
    if (this.readStatus === "readable" && this.readBuffer.byteLength === 0) {
      this.log("close readable end after transport closed and read buffer is empty");
      this.readStatus = "closed";
    }
    if (this.remoteReadStatus !== "closed") {
      this.remoteReadStatus = "closed";
    }
    if (this.remoteWriteStatus !== "closed") {
      this.remoteWriteStatus = "closed";
    }
    if (this.writeStatus !== "closed") {
      this.writeStatus = "closed";
    }
    if (err != null) {
      this.abort(err);
    } else {
      if (this.status === "open" || this.status === "closing") {
        this.timeline.close = Date.now();
        this.status = "closed";
        this.writeStatus = "closed";
        this.remoteWriteStatus = "closed";
        this.remoteReadStatus = "closed";
        this.dispatchEvent(new StreamCloseEvent());
      }
    }
  }
  /**
   * Called by extending classes when the remote closes its writable end
   */
  onRemoteCloseWrite() {
    if (this.remoteWriteStatus === "closed") {
      return;
    }
    this.log.trace("on remote close write");
    this.remoteWriteStatus = "closed";
    this.safeDispatchEvent("remoteCloseWrite");
    if (this.writeStatus === "closed") {
      this.onTransportClosed();
    }
  }
  /**
   * Called by extending classes when the remote closes its readable end
   */
  onRemoteCloseRead() {
    this.log.trace("on remote close read");
    this.remoteReadStatus = "closed";
    if (this.writeBuffer.byteLength > 0) {
      this.writeBuffer.consume(this.writeBuffer.byteLength);
      this.safeDispatchEvent("idle");
    }
  }
  processSendQueue() {
    if (this.writableNeedsDrain) {
      this.log.trace("not processing send queue as drain is required");
      this.checkWriteBufferLength();
      return false;
    }
    if (this.writeBuffer.byteLength === 0) {
      this.log.trace("not processing send queue as no bytes to send");
      return true;
    }
    if (this.sendingData) {
      this.log.trace("not processing send queue as already sending data");
      return true;
    }
    this.sendingData = true;
    this.log.trace("processing send queue with %d queued bytes", this.writeBuffer.byteLength);
    try {
      let canSendMore = true;
      const totalBytes = this.writeBuffer.byteLength;
      let sentBytes = 0;
      while (this.writeBuffer.byteLength > 0) {
        const end = Math.min(this.maxMessageSize ?? this.writeBuffer.byteLength, this.writeBuffer.byteLength);
        if (end === 0) {
          canSendMore = false;
          break;
        }
        const toSend = this.writeBuffer.sublist(0, end);
        const willSend = new Uint8ArrayList(toSend);
        this.writeBuffer.consume(toSend.byteLength);
        const sendResult = this.sendData(toSend);
        canSendMore = sendResult.canSendMore;
        sentBytes += sendResult.sentBytes;
        if (sendResult.sentBytes !== willSend.byteLength) {
          willSend.consume(sendResult.sentBytes);
          this.writeBuffer.prepend(willSend);
        }
        if (!canSendMore) {
          break;
        }
      }
      if (!canSendMore) {
        this.log.trace("sent %d/%d bytes, pausing sending because underlying stream is full, %d bytes left in the write buffer", sentBytes, totalBytes, this.writeBuffer.byteLength);
        this.writableNeedsDrain = true;
        this.checkWriteBufferLength();
      }
      if (this.writeBuffer.byteLength === 0) {
        this.safeDispatchEvent("idle");
      }
      return canSendMore;
    } finally {
      this.sendingData = false;
    }
  }
  dispatchReadBuffer() {
    try {
      if (this.listenerCount("message") === 0) {
        this.log.trace("not dispatching pause buffer as there are no listeners for the message event");
        return;
      }
      if (this.readBuffer.byteLength === 0) {
        this.log.trace("not dispatching pause buffer as there is no data to dispatch");
        return;
      }
      if (this.readStatus === "paused") {
        this.log.trace("not dispatching pause buffer we are paused");
        return;
      }
      if (this.readStatus === "closing" || this.readStatus === "closed") {
        this.log("dropping %d bytes because the readable end is %s", this.readBuffer.byteLength, this.readStatus);
        this.readBuffer.consume(this.readBuffer.byteLength);
        return;
      }
      const buf2 = this.readBuffer.sublist();
      this.readBuffer.consume(buf2.byteLength);
      this.dispatchEvent(new StreamMessageEvent(buf2));
    } finally {
      if (this.readBuffer.byteLength === 0 && this.remoteWriteStatus === "closed") {
        this.log("close readable end after dispatching read buffer and remote writable end is closed");
        this.readStatus = "closed";
      }
      this.checkReadBufferLength();
    }
  }
  checkReadBufferLength() {
    if (this.readBuffer.byteLength > this.maxReadBufferLength) {
      this.abort(new StreamBufferError(`Read buffer length of ${this.readBuffer.byteLength} exceeded limit of ${this.maxReadBufferLength}, read status is ${this.readStatus}`));
    }
  }
  checkWriteBufferLength() {
    if (this.maxWriteBufferLength == null) {
      return;
    }
    if (this.writeBuffer.byteLength > this.maxWriteBufferLength) {
      this.abort(new StreamBufferError(`Write buffer length of ${this.writeBuffer.byteLength} exceeded limit of ${this.maxWriteBufferLength}, write status is ${this.writeStatus}`));
    }
  }
  onMuxerNeedsDrain() {
    this.writableNeedsDrain = true;
  }
  onMuxerDrain() {
    this.safeDispatchEvent("drain");
  }
};

// ../../node_modules/@libp2p/utils/dist/src/abstract-multiaddr-connection.js
var AbstractMultiaddrConnection = class extends AbstractMessageStream {
  constructor(init) {
    super(init);
    __publicField(this, "remoteAddr");
    __publicField(this, "metricPrefix");
    __publicField(this, "metrics");
    this.metricPrefix = init.metricPrefix ?? "";
    this.metrics = init.metrics;
    this.remoteAddr = init.remoteAddr;
    this.addEventListener("close", (evt) => {
      this.metrics?.increment({ [`${this.metricPrefix}end`]: true });
      if (evt.error != null) {
        if (evt.local) {
          this.metrics?.increment({ [`${this.metricPrefix}abort`]: true });
        } else {
          this.metrics?.increment({ [`${this.metricPrefix}reset`]: true });
        }
      } else {
        if (evt.local) {
          this.metrics?.increment({ [`${this.metricPrefix}_local_close`]: true });
        } else {
          this.metrics?.increment({ [`${this.metricPrefix}_remote_close`]: true });
        }
      }
    });
  }
  async close(options2) {
    if (this.status !== "open") {
      return;
    }
    this.status = "closing";
    this.writeStatus = "closing";
    this.remoteWriteStatus = "closing";
    this.remoteReadStatus = "closing";
    if (this.sendingData || this.writeBuffer.byteLength > 0) {
      this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength);
      await pEvent(this, "idle", {
        ...options2,
        rejectionEvents: [
          "close"
        ]
      });
    }
    if (this.writableNeedsDrain) {
      this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength);
      await pEvent(this, "drain", {
        ...options2,
        rejectionEvents: [
          "close"
        ]
      });
    }
    await this.sendClose(options2);
    this.onTransportClosed();
  }
};

// ../../node_modules/@libp2p/utils/dist/src/is-promise.js
function isPromise2(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}

// ../../node_modules/@libp2p/utils/dist/src/abstract-stream-muxer.js
var AbstractStreamMuxer = class extends TypedEventEmitter {
  constructor(maConn, init) {
    super();
    __publicField(this, "streams");
    __publicField(this, "protocol");
    __publicField(this, "status");
    __publicField(this, "log");
    __publicField(this, "maConn");
    __publicField(this, "streamOptions");
    __publicField(this, "earlyStreams");
    __publicField(this, "maxEarlyStreams");
    __publicField(this, "metrics");
    this.maConn = maConn;
    this.protocol = init.protocol;
    this.streams = [];
    this.earlyStreams = [];
    this.status = "open";
    this.log = maConn.log.newScope(init.name);
    this.streamOptions = init.streamOptions;
    this.maxEarlyStreams = init.maxEarlyStreams ?? 10;
    this.metrics = init.metrics;
    const muxerMaConnOnMessage = (evt) => {
      try {
        this.onData(evt.data);
      } catch (err) {
        this.abort(err);
        this.maConn.abort(err);
      }
    };
    this.maConn.addEventListener("message", muxerMaConnOnMessage);
    const muxerMaConnOnDrain = () => {
      this.log("underlying stream drained, signal %d streams to continue writing", this.streams.length);
      this.streams.forEach((stream) => {
        stream.onMuxerDrain();
      });
    };
    this.maConn.addEventListener("drain", muxerMaConnOnDrain);
    const muxerOnMaConnClose = () => {
      this.log("underlying stream closed with status %s and %d streams", this.status, this.streams.length);
      this.onTransportClosed();
    };
    this.maConn.addEventListener("close", muxerOnMaConnClose);
  }
  send(data) {
    const result = this.maConn.send(data);
    if (result === false) {
      this.log("underlying stream saturated, signal %d streams to pause writing", this.streams.length);
      this.streams.forEach((stream) => {
        stream.onMuxerNeedsDrain();
      });
    }
    return result;
  }
  async close(options2) {
    if (this.status === "closed" || this.status === "closing") {
      return;
    }
    this.status = "closing";
    await raceSignal(Promise.all([...this.streams].map(async (s2) => {
      await s2.close(options2);
    })), options2?.signal);
    this.status = "closed";
  }
  abort(err) {
    if (this.status === "closed") {
      return;
    }
    this.status = "closing";
    [...this.streams].forEach((s2) => {
      s2.abort(err);
    });
    this.status = "closed";
  }
  onTransportClosed(err) {
    this.status = "closing";
    try {
      [...this.streams].forEach((stream) => {
        stream.onTransportClosed(err);
      });
    } catch (err2) {
      this.abort(err2);
    }
    this.status = "closed";
  }
  async createStream(options2) {
    if (this.status !== "open") {
      throw new MuxerClosedError2();
    }
    let stream = this.onCreateStream({
      ...this.streamOptions,
      ...options2
    });
    if (isPromise2(stream)) {
      stream = await stream;
    }
    this.streams.push(stream);
    this.cleanUpStream(stream);
    return stream;
  }
  /**
   * Extending classes should invoke this method when a new stream was created
   * by the remote muxer
   */
  onRemoteStream(stream) {
    this.streams.push(stream);
    this.cleanUpStream(stream);
    if (this.listenerCount("stream") === 0) {
      this.earlyStreams.push(stream);
      if (this.earlyStreams.length > this.maxEarlyStreams) {
        this.abort(new MaxEarlyStreamsError(`Too many early streams were opened - ${this.earlyStreams.length}/${this.maxEarlyStreams}`));
      }
      return;
    }
    this.safeDispatchEvent("stream", {
      detail: stream
    });
  }
  cleanUpStream(stream) {
    const muxerOnStreamEnd = (evt) => {
      const index = this.streams.findIndex((s2) => s2 === stream);
      if (index !== -1) {
        this.streams.splice(index, 1);
      }
      if (evt.error != null) {
        if (evt.local) {
          this.metrics?.increment({ [`${stream.direction}_stream_reset`]: true });
        } else {
          this.metrics?.increment({ [`${stream.direction}_stream_abort`]: true });
        }
      } else {
        this.metrics?.increment({ [`${stream.direction}_stream_end`]: true });
      }
    };
    stream.addEventListener("close", muxerOnStreamEnd);
    this.metrics?.increment({ [`${stream.direction}_stream`]: true });
  }
  addEventListener(...args) {
    super.addEventListener.apply(this, args);
    if (args[0] === "stream" && this.earlyStreams.length > 0) {
      queueMicrotask(() => {
        this.earlyStreams.forEach((stream) => {
          this.safeDispatchEvent("stream", {
            detail: stream
          });
        });
        this.earlyStreams = [];
      });
    }
  }
};

// ../../node_modules/@libp2p/utils/dist/src/abstract-stream.js
var AbstractStream = class extends AbstractMessageStream {
  constructor(init) {
    super(init);
    __publicField(this, "id");
    __publicField(this, "protocol");
    this.id = init.id;
    this.protocol = init.protocol ?? "";
  }
  async close(options2) {
    if (this.writeStatus === "closing" || this.writeStatus === "closed") {
      return;
    }
    this.writeStatus = "closing";
    if (this.sendingData || this.writeBuffer.byteLength > 0) {
      this.log("waiting for write queue to become idle before closing writable end of stream, %d unsent bytes", this.writeBuffer.byteLength);
      await pEvent(this, "idle", {
        ...options2,
        rejectionEvents: [
          "close"
        ]
      });
    }
    if (this.writableNeedsDrain) {
      this.log("waiting for write queue to drain before closing writable end of stream, %d unsent bytes, sending %s", this.writeBuffer.byteLength, this.sendingData);
      await pEvent(this, "drain", {
        ...options2,
        rejectionEvents: [
          "close"
        ]
      });
      this.log("write queue drained, closing writable end of stream, %d unsent bytes, sending %s", this.writeBuffer.byteLength, this.sendingData);
    }
    await this.sendCloseWrite(options2);
    this.writeStatus = "closed";
    this.log("closed writable end gracefully");
    if (this.remoteWriteStatus === "closed") {
      this.onTransportClosed();
    }
  }
  async closeRead(options2) {
    if (this.readStatus === "closing" || this.readStatus === "closed") {
      return;
    }
    if (this.readBuffer.byteLength > 0) {
      this.readBuffer.consume(this.readBuffer.byteLength);
    }
    this.readStatus = "closing";
    await this.sendCloseRead(options2);
    this.readStatus = "closed";
    this.log("closed readable end gracefully");
  }
};

// ../../node_modules/any-signal/dist/src/index.js
function anySignal(signals) {
  const controller = new window.AbortController();
  function onAbort() {
    const reason = signals.filter((s2) => s2?.aborted === true).map((s2) => s2?.reason).pop();
    controller.abort(reason);
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if (signal2?.aborted === true) {
      onAbort();
      break;
    }
    if (signal2?.addEventListener != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if (signal2?.removeEventListener != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// ../../node_modules/@libp2p/utils/dist/src/moving-average.js
var MovingAverage = class {
  constructor(timeSpan2) {
    __publicField(this, "movingAverage");
    __publicField(this, "variance");
    __publicField(this, "deviation");
    __publicField(this, "forecast");
    __publicField(this, "timeSpan");
    __publicField(this, "previousTime");
    this.timeSpan = timeSpan2;
    this.movingAverage = 0;
    this.variance = 0;
    this.deviation = 0;
    this.forecast = 0;
  }
  alpha(t2, pt) {
    return 1 - Math.exp(-(t2 - pt) / this.timeSpan);
  }
  push(value2, time = Date.now()) {
    if (this.previousTime != null) {
      const a2 = this.alpha(time, this.previousTime);
      const diff = value2 - this.movingAverage;
      const incr = a2 * diff;
      this.movingAverage = a2 * value2 + (1 - a2) * this.movingAverage;
      this.variance = (1 - a2) * (this.variance + diff * incr);
      this.deviation = Math.sqrt(this.variance);
      this.forecast = this.movingAverage + a2 * diff;
    } else {
      this.movingAverage = value2;
    }
    this.previousTime = time;
  }
};

// ../../node_modules/@libp2p/utils/dist/src/adaptive-timeout.js
var DEFAULT_TIMEOUT_MULTIPLIER = 1.2;
var DEFAULT_FAILURE_MULTIPLIER = 2;
var DEFAULT_MIN_TIMEOUT = 5e3;
var DEFAULT_MAX_TIMEOUT = 6e4;
var DEFAULT_INTERVAL = 5e3;
var AdaptiveTimeout = class {
  constructor(init = {}) {
    __publicField(this, "success");
    __publicField(this, "failure");
    __publicField(this, "next");
    __publicField(this, "metric");
    __publicField(this, "timeoutMultiplier");
    __publicField(this, "failureMultiplier");
    __publicField(this, "minTimeout");
    __publicField(this, "maxTimeout");
    const interval = init.interval ?? DEFAULT_INTERVAL;
    this.success = new MovingAverage(interval);
    this.failure = new MovingAverage(interval);
    this.next = new MovingAverage(interval);
    this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER;
    this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER;
    this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT;
    this.maxTimeout = init.maxTimeout ?? DEFAULT_MAX_TIMEOUT;
    if (init.metricName != null) {
      this.metric = init.metrics?.registerMetricGroup(init.metricName);
    }
  }
  getTimeoutSignal(options2 = {}) {
    let timeout = Math.round(this.next.movingAverage * (options2.timeoutFactor ?? this.timeoutMultiplier));
    if (timeout < this.minTimeout) {
      timeout = this.minTimeout;
    }
    if (timeout > this.maxTimeout) {
      timeout = this.maxTimeout;
    }
    const sendTimeout = AbortSignal.timeout(timeout);
    const timeoutSignal = anySignal([options2.signal, sendTimeout]);
    setMaxListeners(Infinity, timeoutSignal, sendTimeout);
    timeoutSignal.start = Date.now();
    timeoutSignal.timeout = timeout;
    return timeoutSignal;
  }
  cleanUp(signal) {
    const time = Date.now() - signal.start;
    if (signal.aborted) {
      this.failure.push(time);
      this.next.push(time * this.failureMultiplier);
      this.metric?.update({
        failureMovingAverage: this.failure.movingAverage,
        failureDeviation: this.failure.deviation,
        failureForecast: this.failure.forecast,
        failureVariance: this.failure.variance,
        failure: time
      });
    } else {
      this.success.push(time);
      this.next.push(time);
      this.metric?.update({
        successMovingAverage: this.success.movingAverage,
        successDeviation: this.success.deviation,
        successForecast: this.success.forecast,
        successVariance: this.success.variance,
        success: time
      });
    }
  }
};

// ../../node_modules/@multiformats/multiaddr/dist/src/errors.js
var InvalidMultiaddrError5 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMultiaddrError");
  }
};
__publicField(InvalidMultiaddrError5, "name", "InvalidMultiaddrError");
var ValidationError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ValidationError");
  }
};
__publicField(ValidationError2, "name", "ValidationError");
var InvalidParametersError5 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidParametersError");
  }
};
__publicField(InvalidParametersError5, "name", "InvalidParametersError");
var UnknownProtocolError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnknownProtocolError");
  }
};
__publicField(UnknownProtocolError2, "name", "UnknownProtocolError");

// ../../node_modules/@multiformats/multiaddr/dist/src/constants.js
var CODE_IP42 = 4;
var CODE_TCP2 = 6;
var CODE_UDP2 = 273;
var CODE_DCCP2 = 33;
var CODE_IP62 = 41;
var CODE_IP6ZONE2 = 42;
var CODE_IPCIDR2 = 43;
var CODE_DNS2 = 53;
var CODE_DNS42 = 54;
var CODE_DNS62 = 55;
var CODE_DNSADDR2 = 56;
var CODE_SCTP2 = 132;
var CODE_UDT2 = 301;
var CODE_UTP2 = 302;
var CODE_UNIX2 = 400;
var CODE_P2P2 = 421;
var CODE_ONION2 = 444;
var CODE_ONION32 = 445;
var CODE_GARLIC642 = 446;
var CODE_GARLIC322 = 447;
var CODE_TLS2 = 448;
var CODE_SNI2 = 449;
var CODE_NOISE2 = 454;
var CODE_QUIC2 = 460;
var CODE_QUIC_V12 = 461;
var CODE_WEBTRANSPORT2 = 465;
var CODE_CERTHASH2 = 466;
var CODE_HTTP2 = 480;
var CODE_HTTP_PATH2 = 481;
var CODE_HTTPS2 = 443;
var CODE_WS2 = 477;
var CODE_WSS2 = 478;
var CODE_P2P_WEBSOCKET_STAR2 = 479;
var CODE_P2P_STARDUST2 = 277;
var CODE_P2P_WEBRTC_STAR2 = 275;
var CODE_P2P_WEBRTC_DIRECT2 = 276;
var CODE_WEBRTC_DIRECT2 = 280;
var CODE_WEBRTC2 = 281;
var CODE_P2P_CIRCUIT2 = 290;
var CODE_MEMORY2 = 777;

// ../../node_modules/@multiformats/multiaddr/dist/src/utils.js
function bytesToString2(base3) {
  return (buf2) => {
    return toString2(buf2, base3);
  };
}
function stringToBytes2(base3) {
  return (buf2) => {
    return fromString2(buf2, base3);
  };
}
function bytes2port2(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset).toString();
}
function port2bytes2(port) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, typeof port === "string" ? parseInt(port) : port);
  return new Uint8Array(buf2);
}
function onion2bytes2(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = fromString2(addr[0], "base32");
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes2(port);
  return concat([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes2(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base32.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes2(port);
  return concat([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion2(buf2) {
  const addrBytes = buf2.subarray(0, buf2.length - 2);
  const portBytes = buf2.subarray(buf2.length - 2);
  const addr = toString2(addrBytes, "base32");
  const port = bytes2port2(portBytes);
  return `${addr}:${port}`;
}
var ip4ToBytes2 = function(ip) {
  ip = ip.toString().trim();
  const bytes = new Uint8Array(4);
  ip.split(/\./g).forEach((byte, index) => {
    const value2 = parseInt(byte, 10);
    if (isNaN(value2) || value2 < 0 || value2 > 255) {
      throw new InvalidMultiaddrError5("Invalid byte value in IP address");
    }
    bytes[index] = value2;
  });
  return bytes;
};
var ip6ToBytes2 = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  const sections = ip.split(":", 8);
  let i2;
  for (i2 = 0; i2 < sections.length; i2++) {
    const isv4 = isIPv4(sections[i2]);
    let v4Buffer;
    if (isv4) {
      v4Buffer = ip4ToBytes2(sections[i2]);
      sections[i2] = toString2(v4Buffer.subarray(0, 2), "base16");
    }
    if (v4Buffer != null && ++i2 < 8) {
      sections.splice(i2, 0, toString2(v4Buffer.subarray(2, 4), "base16"));
    }
  }
  if (sections[0] === "") {
    while (sections.length < 8) {
      sections.unshift("0");
    }
  } else if (sections[sections.length - 1] === "") {
    while (sections.length < 8) {
      sections.push("0");
    }
  } else if (sections.length < 8) {
    for (i2 = 0; i2 < sections.length && sections[i2] !== ""; i2++) {
    }
    const argv = [i2, 1];
    for (i2 = 9 - sections.length; i2 > 0; i2--) {
      argv.push("0");
    }
    sections.splice.apply(sections, argv);
  }
  const bytes = new Uint8Array(offset + 16);
  for (i2 = 0; i2 < sections.length; i2++) {
    if (sections[i2] === "") {
      sections[i2] = "0";
    }
    const word2 = parseInt(sections[i2], 16);
    if (isNaN(word2) || word2 < 0 || word2 > 65535) {
      throw new InvalidMultiaddrError5("Invalid byte value in IP address");
    }
    bytes[offset++] = word2 >> 8 & 255;
    bytes[offset++] = word2 & 255;
  }
  return bytes;
};
var ip4ToString2 = function(buf2) {
  if (buf2.byteLength !== 4) {
    throw new InvalidMultiaddrError5("IPv4 address was incorrect length");
  }
  const result = [];
  for (let i2 = 0; i2 < buf2.byteLength; i2++) {
    result.push(buf2[i2]);
  }
  return result.join(".");
};
var ip6ToString2 = function(buf2) {
  if (buf2.byteLength !== 16) {
    throw new InvalidMultiaddrError5("IPv6 address was incorrect length");
  }
  const result = [];
  for (let i2 = 0; i2 < buf2.byteLength; i2 += 2) {
    const byte1 = buf2[i2];
    const byte2 = buf2[i2 + 1];
    const tuple = `${byte1.toString(16).padStart(2, "0")}${byte2.toString(16).padStart(2, "0")}`;
    result.push(tuple);
  }
  const ip = result.join(":");
  try {
    const url = new URL(`http://[${ip}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError5(`Invalid IPv6 address "${ip}"`);
  }
};
function ip6StringToValue2(str) {
  try {
    const url = new URL(`http://[${str}]`);
    return url.hostname.substring(1, url.hostname.length - 1);
  } catch {
    throw new InvalidMultiaddrError5(`Invalid IPv6 address "${str}"`);
  }
}
var decoders3 = Object.values(bases).map((c2) => c2.decoder);
var anybaseDecoder2 = (function() {
  let acc = decoders3[0].or(decoders3[1]);
  decoders3.slice(2).forEach((d2) => acc = acc.or(d2));
  return acc;
})();
function mb2bytes2(mbstr) {
  return anybaseDecoder2.decode(mbstr);
}
function bytes2mb2(base3) {
  return (buf2) => {
    return base3.encoder.encode(buf2);
  };
}

// ../../node_modules/@multiformats/multiaddr/dist/src/validation.js
function integer2(value2) {
  const int = parseInt(value2);
  if (int.toString() !== value2) {
    throw new ValidationError2("Value must be an integer");
  }
}
function positive2(value2) {
  if (value2 < 0) {
    throw new ValidationError2("Value must be a positive integer, or zero");
  }
}
function maxValue2(max) {
  return (value2) => {
    if (value2 > max) {
      throw new ValidationError2(`Value must be smaller than or equal to ${max}`);
    }
  };
}
function validate2(...funcs) {
  return (value2) => {
    for (const fn of funcs) {
      fn(value2);
    }
  };
}
var validatePort2 = validate2(integer2, positive2, maxValue2(65535));

// ../../node_modules/@multiformats/multiaddr/dist/src/registry.js
var V2 = -1;
var Registry2 = class {
  constructor() {
    __publicField(this, "protocolsByCode", /* @__PURE__ */ new Map());
    __publicField(this, "protocolsByName", /* @__PURE__ */ new Map());
  }
  getProtocol(key) {
    let codec;
    if (typeof key === "string") {
      codec = this.protocolsByName.get(key);
    } else {
      codec = this.protocolsByCode.get(key);
    }
    if (codec == null) {
      throw new UnknownProtocolError2(`Protocol ${key} was unknown`);
    }
    return codec;
  }
  addProtocol(codec) {
    this.protocolsByCode.set(codec.code, codec);
    this.protocolsByName.set(codec.name, codec);
    codec.aliases?.forEach((alias) => {
      this.protocolsByName.set(alias, codec);
    });
  }
  removeProtocol(code5) {
    const codec = this.protocolsByCode.get(code5);
    if (codec == null) {
      return;
    }
    this.protocolsByCode.delete(codec.code);
    this.protocolsByName.delete(codec.name);
    codec.aliases?.forEach((alias) => {
      this.protocolsByName.delete(alias);
    });
  }
};
var registry2 = new Registry2();
var codecs3 = [{
  code: CODE_IP42,
  name: "ip4",
  size: 32,
  valueToBytes: ip4ToBytes2,
  bytesToValue: ip4ToString2,
  validate: (value2) => {
    if (!isIPv4(value2)) {
      throw new ValidationError2(`Invalid IPv4 address "${value2}"`);
    }
  }
}, {
  code: CODE_TCP2,
  name: "tcp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort2
}, {
  code: CODE_UDP2,
  name: "udp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort2
}, {
  code: CODE_DCCP2,
  name: "dccp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort2
}, {
  code: CODE_IP62,
  name: "ip6",
  size: 128,
  valueToBytes: ip6ToBytes2,
  bytesToValue: ip6ToString2,
  stringToValue: ip6StringToValue2,
  validate: (value2) => {
    if (!isIPv6(value2)) {
      throw new ValidationError2(`Invalid IPv6 address "${value2}"`);
    }
  }
}, {
  code: CODE_IP6ZONE2,
  name: "ip6zone",
  size: V2
}, {
  code: CODE_IPCIDR2,
  name: "ipcidr",
  size: 8,
  bytesToValue: bytesToString2("base10"),
  valueToBytes: stringToBytes2("base10")
}, {
  code: CODE_DNS2,
  name: "dns",
  size: V2
}, {
  code: CODE_DNS42,
  name: "dns4",
  size: V2
}, {
  code: CODE_DNS62,
  name: "dns6",
  size: V2
}, {
  code: CODE_DNSADDR2,
  name: "dnsaddr",
  size: V2
}, {
  code: CODE_SCTP2,
  name: "sctp",
  size: 16,
  valueToBytes: port2bytes2,
  bytesToValue: bytes2port2,
  validate: validatePort2
}, {
  code: CODE_UDT2,
  name: "udt"
}, {
  code: CODE_UTP2,
  name: "utp"
}, {
  code: CODE_UNIX2,
  name: "unix",
  size: V2,
  stringToValue: (str) => decodeURIComponent(str),
  valueToString: (val) => encodeURIComponent(val)
}, {
  code: CODE_P2P2,
  name: "p2p",
  aliases: ["ipfs"],
  size: V2,
  bytesToValue: bytesToString2("base58btc"),
  valueToBytes: (val) => {
    if (val.startsWith("Q") || val.startsWith("1")) {
      return stringToBytes2("base58btc")(val);
    }
    return CID.parse(val).multihash.bytes;
  }
}, {
  code: CODE_ONION2,
  name: "onion",
  size: 96,
  bytesToValue: bytes2onion2,
  valueToBytes: onion2bytes2
}, {
  code: CODE_ONION32,
  name: "onion3",
  size: 296,
  bytesToValue: bytes2onion2,
  valueToBytes: onion32bytes2
}, {
  code: CODE_GARLIC642,
  name: "garlic64",
  size: V2
}, {
  code: CODE_GARLIC322,
  name: "garlic32",
  size: V2
}, {
  code: CODE_TLS2,
  name: "tls"
}, {
  code: CODE_SNI2,
  name: "sni",
  size: V2
}, {
  code: CODE_NOISE2,
  name: "noise"
}, {
  code: CODE_QUIC2,
  name: "quic"
}, {
  code: CODE_QUIC_V12,
  name: "quic-v1"
}, {
  code: CODE_WEBTRANSPORT2,
  name: "webtransport"
}, {
  code: CODE_CERTHASH2,
  name: "certhash",
  size: V2,
  bytesToValue: bytes2mb2(base64url),
  valueToBytes: mb2bytes2
}, {
  code: CODE_HTTP2,
  name: "http"
}, {
  code: CODE_HTTP_PATH2,
  name: "http-path",
  size: V2,
  stringToValue: (str) => `/${decodeURIComponent(str)}`,
  valueToString: (val) => encodeURIComponent(val.substring(1))
}, {
  code: CODE_HTTPS2,
  name: "https"
}, {
  code: CODE_WS2,
  name: "ws"
}, {
  code: CODE_WSS2,
  name: "wss"
}, {
  code: CODE_P2P_WEBSOCKET_STAR2,
  name: "p2p-websocket-star"
}, {
  code: CODE_P2P_STARDUST2,
  name: "p2p-stardust"
}, {
  code: CODE_P2P_WEBRTC_STAR2,
  name: "p2p-webrtc-star"
}, {
  code: CODE_P2P_WEBRTC_DIRECT2,
  name: "p2p-webrtc-direct"
}, {
  code: CODE_WEBRTC_DIRECT2,
  name: "webrtc-direct"
}, {
  code: CODE_WEBRTC2,
  name: "webrtc"
}, {
  code: CODE_P2P_CIRCUIT2,
  name: "p2p-circuit"
}, {
  code: CODE_MEMORY2,
  name: "memory",
  size: V2
}];
codecs3.forEach((codec) => {
  registry2.addProtocol(codec);
});

// ../../node_modules/@multiformats/multiaddr/dist/src/components.js
function bytesToComponents(bytes) {
  const components = [];
  let i2 = 0;
  while (i2 < bytes.length) {
    const code5 = decode8(bytes, i2);
    const codec = registry2.getProtocol(code5);
    const codeLength = encodingLength2(code5);
    const size = sizeForAddr(codec, bytes, i2 + codeLength);
    let sizeLength = 0;
    if (size > 0 && codec.size === V2) {
      sizeLength = encodingLength2(size);
    }
    const componentLength = codeLength + sizeLength + size;
    const component = {
      code: code5,
      name: codec.name,
      bytes: bytes.subarray(i2, i2 + componentLength)
    };
    if (size > 0) {
      const valueOffset = i2 + codeLength + sizeLength;
      const valueBytes = bytes.subarray(valueOffset, valueOffset + size);
      component.value = codec.bytesToValue?.(valueBytes) ?? toString2(valueBytes);
    }
    components.push(component);
    i2 += componentLength;
  }
  return components;
}
function componentsToBytes(components) {
  let length4 = 0;
  const bytes = [];
  for (const component of components) {
    if (component.bytes == null) {
      const codec = registry2.getProtocol(component.code);
      const codecLength = encodingLength2(component.code);
      let valueBytes;
      let valueLength = 0;
      let valueLengthLength = 0;
      if (component.value != null) {
        valueBytes = codec.valueToBytes?.(component.value) ?? fromString2(component.value);
        valueLength = valueBytes.byteLength;
        if (codec.size === V2) {
          valueLengthLength = encodingLength2(valueLength);
        }
      }
      const bytes2 = new Uint8Array(codecLength + valueLengthLength + valueLength);
      let offset = 0;
      encodeUint8Array(component.code, bytes2, offset);
      offset += codecLength;
      if (valueBytes != null) {
        if (codec.size === V2) {
          encodeUint8Array(valueLength, bytes2, offset);
          offset += valueLengthLength;
        }
        bytes2.set(valueBytes, offset);
      }
      component.bytes = bytes2;
    }
    bytes.push(component.bytes);
    length4 += component.bytes.byteLength;
  }
  return concat(bytes, length4);
}
function stringToComponents(string2) {
  if (string2.charAt(0) !== "/") {
    throw new InvalidMultiaddrError5('String multiaddr must start with "/"');
  }
  const components = [];
  let collecting = "protocol";
  let value2 = "";
  let protocol2 = "";
  for (let i2 = 1; i2 < string2.length; i2++) {
    const char = string2.charAt(i2);
    if (char !== "/") {
      if (collecting === "protocol") {
        protocol2 += string2.charAt(i2);
      } else {
        value2 += string2.charAt(i2);
      }
    }
    const ended = i2 === string2.length - 1;
    if (char === "/" || ended) {
      const codec = registry2.getProtocol(protocol2);
      if (collecting === "protocol") {
        if (codec.size == null || codec.size === 0) {
          components.push({
            code: codec.code,
            name: codec.name
          });
          value2 = "";
          protocol2 = "";
          collecting = "protocol";
          continue;
        } else if (ended) {
          throw new InvalidMultiaddrError5(`Component ${protocol2} was missing value`);
        }
        collecting = "value";
      } else if (collecting === "value") {
        const component = {
          code: codec.code,
          name: codec.name
        };
        if (codec.size != null && codec.size !== 0) {
          if (value2 === "") {
            throw new InvalidMultiaddrError5(`Component ${protocol2} was missing value`);
          }
          component.value = codec.stringToValue?.(value2) ?? value2;
        }
        components.push(component);
        value2 = "";
        protocol2 = "";
        collecting = "protocol";
      }
    }
  }
  if (protocol2 !== "" && value2 !== "") {
    throw new InvalidMultiaddrError5("Incomplete multiaddr");
  }
  return components;
}
function componentsToString(components) {
  return `/${components.flatMap((component) => {
    if (component.value == null) {
      return component.name;
    }
    const codec = registry2.getProtocol(component.code);
    if (codec == null) {
      throw new InvalidMultiaddrError5(`Unknown protocol code ${component.code}`);
    }
    return [
      component.name,
      codec.valueToString?.(component.value) ?? component.value
    ];
  }).join("/")}`;
}
function sizeForAddr(codec, bytes, offset) {
  if (codec.size == null || codec.size === 0) {
    return 0;
  }
  if (codec.size > 0) {
    return codec.size / 8;
  }
  return decode8(bytes, offset);
}

// ../../node_modules/@multiformats/multiaddr/dist/src/multiaddr.js
var _a7, _components, _string, _bytes;
var inspect4 = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var symbol2 = /* @__PURE__ */ Symbol.for("@multiformats/multiaddr");
function toComponents(addr) {
  if (addr == null) {
    addr = "/";
  }
  if (isMultiaddr(addr)) {
    return addr.getComponents();
  }
  if (addr instanceof Uint8Array) {
    return bytesToComponents(addr);
  }
  if (typeof addr === "string") {
    addr = addr.replace(/\/(\/)+/, "/").replace(/(\/)+$/, "");
    if (addr === "") {
      addr = "/";
    }
    return stringToComponents(addr);
  }
  if (Array.isArray(addr)) {
    return addr;
  }
  throw new InvalidMultiaddrError5("Must be a string, Uint8Array, Component[], or another Multiaddr");
}
var _Multiaddr = class _Multiaddr {
  constructor(addr = "/", options2 = {}) {
    __publicField(this, _a7, true);
    __privateAdd(this, _components);
    // cache string representation
    __privateAdd(this, _string);
    // cache byte representation
    __privateAdd(this, _bytes);
    __privateSet(this, _components, toComponents(addr));
    if (options2.validate !== false) {
      validate3(this);
    }
  }
  get bytes() {
    if (__privateGet(this, _bytes) == null) {
      __privateSet(this, _bytes, componentsToBytes(__privateGet(this, _components)));
    }
    return __privateGet(this, _bytes);
  }
  toString() {
    if (__privateGet(this, _string) == null) {
      __privateSet(this, _string, componentsToString(__privateGet(this, _components)));
    }
    return __privateGet(this, _string);
  }
  toJSON() {
    return this.toString();
  }
  getComponents() {
    return [
      ...__privateGet(this, _components).map((c2) => ({ ...c2 }))
    ];
  }
  encapsulate(addr) {
    const ma = new _Multiaddr(addr);
    return new _Multiaddr([
      ...__privateGet(this, _components),
      ...ma.getComponents()
    ], {
      validate: false
    });
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s2 = this.toString();
    const i2 = s2.lastIndexOf(addrString);
    if (i2 < 0) {
      throw new InvalidParametersError5(`Address ${this.toString()} does not contain subaddress: ${addrString}`);
    }
    return new _Multiaddr(s2.slice(0, i2), {
      validate: false
    });
  }
  decapsulateCode(code5) {
    let index;
    for (let i2 = __privateGet(this, _components).length - 1; i2 > -1; i2--) {
      if (__privateGet(this, _components)[i2].code === code5) {
        index = i2;
        break;
      }
    }
    return new _Multiaddr(__privateGet(this, _components).slice(0, index), {
      validate: false
    });
  }
  equals(addr) {
    return equals3(this.bytes, addr.bytes);
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [(_a7 = symbol2, inspect4)]() {
    return `Multiaddr(${this.toString()})`;
  }
};
_components = new WeakMap();
_string = new WeakMap();
_bytes = new WeakMap();
var Multiaddr = _Multiaddr;
function validate3(addr) {
  addr.getComponents().forEach((component) => {
    const codec = registry2.getProtocol(component.code);
    if (component.value == null) {
      return;
    }
    codec.validate?.(component.value);
  });
}

// ../../node_modules/@multiformats/multiaddr/dist/src/index.js
function isMultiaddr(value2) {
  return Boolean(value2?.[symbol2]);
}
function multiaddr(addr) {
  return new Multiaddr(addr);
}

// ../../node_modules/@libp2p/utils/dist/src/multiaddr/utils.js
function getIpFromMultiaddr(ma) {
  const components = ma.getComponents();
  let index = 0;
  if (components[0]?.code === CODE_IP6ZONE2) {
    index++;
  }
  if (components[index]?.code !== CODE_IP42 && components[index]?.code !== CODE_IP62) {
    return;
  }
  return components[index]?.value;
}
function netConfigToMultiaddr(config, port, host) {
  const parts = [
    config.type,
    host ?? config.host
  ];
  if (config.protocol != null) {
    const p2 = port ?? config.port;
    if (p2 != null) {
      parts.push(config.protocol, p2);
    }
  }
  if (config.type === "ip6" && config.zone != null) {
    parts.unshift("ip6zone", config.zone);
  }
  if (config.cidr != null) {
    parts.push("ipcidr", config.cidr);
  }
  return multiaddr(`/${parts.join("/")}`);
}

// ../../node_modules/@libp2p/utils/dist/src/get-thin-waist-addresses.browser.js
function getThinWaistAddresses(ma, port) {
  if (ma == null) {
    return [];
  }
  const config = getNetConfig(ma);
  return [
    netConfigToMultiaddr(config, port)
  ];
}

// ../../node_modules/@libp2p/utils/dist/src/global-unicast-ip.js
function isGlobalUnicastIp(ip) {
  if (isIPv6(ip)) {
    return cidrContains("2000::/3", ip);
  }
  return false;
}

// ../../node_modules/@libp2p/utils/dist/src/ip-port-to-multiaddr.js
function ipPortToMultiaddr(ip, port) {
  if (typeof ip !== "string") {
    throw new InvalidParametersError2(`invalid ip provided: ${ip}`);
  }
  if (typeof port === "string") {
    port = parseInt(port);
  }
  if (isNaN(port)) {
    throw new InvalidParametersError2(`invalid port provided: ${port}`);
  }
  if (isIPv4(ip)) {
    return multiaddr(`/ip4/${ip}/tcp/${port}`);
  }
  if (isIPv6(ip)) {
    return multiaddr(`/ip6/${ip}/tcp/${port}`);
  }
  throw new InvalidParametersError2(`invalid ip:port for creating a multiaddr: ${ip}:${port}`);
}

// ../../node_modules/@libp2p/utils/dist/src/is-async-generator.js
function isAsyncGenerator(obj) {
  if (obj == null) {
    return false;
  }
  const asyncIterator = obj?.[Symbol.asyncIterator];
  if (typeof asyncIterator !== "function") {
    return false;
  }
  const instance = obj;
  return typeof instance.next === "function";
}

// ../../node_modules/@libp2p/utils/dist/src/is-generator.js
function isGenerator(obj) {
  if (obj == null) {
    return false;
  }
  const iterator = obj?.[Symbol.iterator];
  if (typeof iterator !== "function") {
    return false;
  }
  const instance = obj;
  return typeof instance.next === "function";
}

// ../../node_modules/@libp2p/utils/dist/src/stream-utils.js
var DEFAULT_MAX_BUFFER_SIZE = 4194304;
var UnwrappedError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnwrappedError");
  }
};
__publicField(UnwrappedError, "name", "UnwrappedError");
var InvalidMessageLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};
function isStream(obj) {
  return typeof obj?.closeRead === "function";
}
function isMultiaddrConnection(obj) {
  return typeof obj?.close === "function";
}
function isEOF(obj) {
  if (isStream(obj)) {
    return obj.remoteWriteStatus !== "writable" && obj.readBufferLength === 0;
  }
  if (isMultiaddrConnection(obj)) {
    return obj.status !== "open";
  }
  return false;
}
function isValid(obj) {
  return obj?.addEventListener != null && obj?.removeEventListener != null && obj?.send != null && obj?.push != null && obj?.log != null;
}
function byteStream(stream, opts) {
  const maxBufferSize = opts?.maxBufferSize ?? DEFAULT_MAX_BUFFER_SIZE;
  const readBuffer = new Uint8ArrayList();
  let hasBytes;
  let unwrapped = false;
  if (!isValid(stream)) {
    throw new InvalidParametersError2("Argument should be a Stream or a Multiaddr");
  }
  const byteStreamOnMessageListener = (evt) => {
    readBuffer.append(evt.data);
    if (readBuffer.byteLength > maxBufferSize) {
      const readBufferSize = readBuffer.byteLength;
      readBuffer.consume(readBuffer.byteLength);
      hasBytes?.reject(new Error(`Read buffer overflow - ${readBufferSize} > ${maxBufferSize}`));
    }
    hasBytes?.resolve();
  };
  stream.addEventListener("message", byteStreamOnMessageListener);
  const byteStreamOnCloseListener = (evt) => {
    if (evt.error != null) {
      hasBytes?.reject(evt.error);
    } else {
      hasBytes?.resolve();
    }
  };
  stream.addEventListener("close", byteStreamOnCloseListener);
  const byteStreamOnRemoteCloseWrite = () => {
    hasBytes?.resolve();
  };
  stream.addEventListener("remoteCloseWrite", byteStreamOnRemoteCloseWrite);
  const byteStream2 = {
    readBuffer,
    // @ts-expect-error options type prevents type inference
    async read(options2) {
      if (unwrapped === true) {
        throw new UnwrappedError("Stream was unwrapped");
      }
      if (isEOF(stream)) {
        if (options2?.bytes == null) {
          return null;
        }
        if (readBuffer.byteLength < options2.bytes) {
          stream.log.error("closed after reading %d/%d bytes", readBuffer.byteLength, options2.bytes);
          throw new UnexpectedEOFError2(`Unexpected EOF - stream closed after reading ${readBuffer.byteLength}/${options2.bytes} bytes`);
        }
      }
      const bytesToRead = options2?.bytes ?? 1;
      hasBytes = Promise.withResolvers();
      while (true) {
        if (readBuffer.byteLength >= bytesToRead) {
          hasBytes.resolve();
          break;
        }
        await raceSignal(hasBytes.promise, options2?.signal);
        if (isEOF(stream)) {
          if (readBuffer.byteLength === 0 && options2?.bytes == null) {
            return null;
          }
          break;
        }
        hasBytes = Promise.withResolvers();
      }
      const toRead = options2?.bytes ?? readBuffer.byteLength;
      if (readBuffer.byteLength < toRead) {
        if (isEOF(stream)) {
          stream.log.error("closed while reading %d/%d bytes", readBuffer.byteLength, toRead);
          throw new UnexpectedEOFError2(`Unexpected EOF - stream closed while reading ${readBuffer.byteLength}/${toRead} bytes`);
        }
        return byteStream2.read(options2);
      }
      const output = readBuffer.sublist(0, toRead);
      readBuffer.consume(toRead);
      return output;
    },
    async write(data, options2) {
      if (unwrapped === true) {
        throw new UnwrappedError("Stream was unwrapped");
      }
      if (!stream.send(data)) {
        await pEvent(stream, "drain", {
          signal: options2?.signal,
          rejectionEvents: ["close"]
        });
      }
    },
    unwrap() {
      if (unwrapped) {
        return stream;
      }
      unwrapped = true;
      stream.removeEventListener("message", byteStreamOnMessageListener);
      stream.removeEventListener("close", byteStreamOnCloseListener);
      stream.removeEventListener("remoteCloseWrite", byteStreamOnRemoteCloseWrite);
      if (readBuffer.byteLength > 0) {
        stream.log("stream unwrapped with %d unread bytes", readBuffer.byteLength);
        stream.push(readBuffer);
      }
      return stream;
    }
  };
  return byteStream2;
}
function lpStream(stream, opts = {}) {
  const bytes = byteStream(stream, opts);
  if (opts.maxDataLength != null && opts.maxLengthLength == null) {
    opts.maxLengthLength = encodingLength2(opts.maxDataLength);
  }
  const decodeLength = opts?.lengthDecoder ?? decode8;
  const encodeLength2 = opts?.lengthEncoder ?? encode7;
  const lpStream2 = {
    async read(options2) {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      while (true) {
        const buf3 = await bytes.read({
          ...options2,
          bytes: 1
        });
        if (buf3 == null) {
          break;
        }
        lengthBuffer.append(buf3);
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength < 0) {
          throw new InvalidMessageLengthError2("Invalid message length");
        }
        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw new InvalidDataLengthLengthError2(`Message length length too long - ${lengthBuffer.byteLength} > ${opts.maxLengthLength}`);
        }
        if (dataLength > -1) {
          break;
        }
      }
      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {
        throw new InvalidDataLengthError2(`Message length too long - ${dataLength} > ${opts.maxDataLength}`);
      }
      const buf2 = await bytes.read({
        ...options2,
        bytes: dataLength
      });
      if (buf2 == null) {
        stream.log.error("tried to read %d bytes but the stream closed", dataLength);
        throw new UnexpectedEOFError2(`Unexpected EOF - tried to read ${dataLength} bytes but the stream closed`);
      }
      if (buf2.byteLength !== dataLength) {
        stream.log.error("read %d/%d bytes before the stream closed", buf2.byteLength, dataLength);
        throw new UnexpectedEOFError2(`Unexpected EOF - read ${buf2.byteLength}/${dataLength} bytes before the stream closed`);
      }
      return buf2;
    },
    async write(data, options2) {
      await bytes.write(new Uint8ArrayList(encodeLength2(data.byteLength), data), options2);
    },
    async writeV(data, options2) {
      const list = new Uint8ArrayList(...data.flatMap((buf2) => [encodeLength2(buf2.byteLength), buf2]));
      await bytes.write(list, options2);
    },
    unwrap() {
      return bytes.unwrap();
    }
  };
  return lpStream2;
}
function pbStream(stream, opts) {
  const lp = lpStream(stream, opts);
  const pbStream2 = {
    read: async (proto, options2) => {
      const value2 = await lp.read(options2);
      return proto.decode(value2);
    },
    write: async (message2, proto, options2) => {
      await lp.write(proto.encode(message2), options2);
    },
    writeV: async (messages2, proto, options2) => {
      await lp.writeV(messages2.map((message2) => proto.encode(message2)), options2);
    },
    pb: (proto) => {
      return {
        read: async (options2) => pbStream2.read(proto, options2),
        write: async (d2, options2) => pbStream2.write(d2, proto, options2),
        writeV: async (d2, options2) => pbStream2.writeV(d2, proto, options2),
        unwrap: () => pbStream2
      };
    },
    unwrap: () => {
      return lp.unwrap();
    }
  };
  return pbStream2;
}
async function echo(stream, options2) {
  const log4 = stream.log.newScope("echo");
  const start2 = Date.now();
  let bytes = 0;
  try {
    for await (const buf2 of stream) {
      bytes += buf2.byteLength;
      if (!stream.send(buf2)) {
        stream.pause();
        await pEvent(stream, "drain", {
          rejectionEvents: [
            "close"
          ],
          ...options2
        });
        stream.resume();
      }
    }
    log4("echoed %d bytes in %dms", bytes, Date.now() - start2);
    await stream.close(options2);
  } catch (err) {
    stream.abort(err);
  }
}
function isMessageStream(obj) {
  return obj?.addEventListener != null;
}
function messageStreamToDuplex(stream) {
  const source = pushable();
  let onError;
  const onMessage = (evt) => {
    source.push(evt.data);
  };
  const onRemoteCloseWrite = () => {
    source.end();
    stream.removeEventListener("message", onMessage);
    stream.removeEventListener("close", onClose);
    stream.removeEventListener("remoteCloseWrite", onRemoteCloseWrite);
  };
  const onClose = (evt) => {
    source.end(evt.error);
    if (evt.error != null) {
      onError?.reject(evt.error);
    }
    stream.removeEventListener("message", onMessage);
    stream.removeEventListener("close", onClose);
    stream.removeEventListener("remoteCloseWrite", onRemoteCloseWrite);
  };
  stream.addEventListener("message", onMessage);
  stream.addEventListener("close", onClose, {
    once: true
  });
  stream.addEventListener("remoteCloseWrite", onRemoteCloseWrite, {
    once: true
  });
  return {
    source,
    async sink(source2) {
      async function* toGenerator() {
        yield* source2;
      }
      const gen = toGenerator();
      while (true) {
        onError = Promise.withResolvers();
        const { done, value: value2 } = await Promise.race([
          gen.next(),
          onError.promise
        ]);
        if (stream.writeStatus === "closing" || stream.writeStatus === "closed") {
          break;
        }
        if (value2 != null) {
          if (!stream.send(value2)) {
            await Promise.race([
              pEvent(stream, "drain", {
                rejectionEvents: [
                  "close"
                ]
              })
            ]);
          }
        }
        if (done === true) {
          break;
        }
      }
      await stream.close();
    }
  };
}
function pipe2(...input) {
  const sources = input.map((source) => {
    if (isMessageStream(source)) {
      return messageStreamToDuplex(source);
    }
    return source;
  });
  return pipe(...sources);
}

// ../../node_modules/@libp2p/utils/dist/src/length-prefixed-decoder.js
var DEFAULT_MAX_BUFFER_SIZE2 = 1024 * 1024 * 4;
var DEFAULT_MAX_DATA_LENGTH = 1024 * 1024 * 4;
var LengthPrefixedDecoder = class {
  constructor(init = {}) {
    __publicField(this, "buffer");
    __publicField(this, "maxBufferSize");
    __publicField(this, "lengthDecoder");
    __publicField(this, "maxDataLength");
    __publicField(this, "encodingLength");
    this.buffer = new Uint8ArrayList();
    this.maxBufferSize = init.maxBufferSize ?? DEFAULT_MAX_BUFFER_SIZE2;
    this.maxDataLength = init.maxDataLength ?? DEFAULT_MAX_DATA_LENGTH;
    this.lengthDecoder = init.lengthDecoder ?? decode8;
    this.encodingLength = init.encodingLength ?? encodingLength2;
  }
  /**
   * Decodes length-prefixed data
   */
  *decode(buf2) {
    this.buffer.append(buf2);
    if (this.buffer.byteLength > this.maxBufferSize) {
      throw new InvalidParametersError2(`Buffer length limit exceeded - ${this.buffer.byteLength}/${this.maxBufferSize}`);
    }
    while (true) {
      let dataLength;
      try {
        dataLength = this.lengthDecoder(this.buffer);
      } catch (err) {
        if (err instanceof RangeError) {
          break;
        }
        throw err;
      }
      if (dataLength < 0 || dataLength > this.maxDataLength) {
        throw new InvalidMessageLengthError2("Invalid message length");
      }
      const lengthLength = this.encodingLength(dataLength);
      const chunkLength = lengthLength + dataLength;
      if (this.buffer.byteLength >= chunkLength) {
        const buf3 = this.buffer.sublist(lengthLength, chunkLength);
        this.buffer.consume(chunkLength);
        if (buf3.byteLength > 0) {
          yield buf3;
        }
      } else {
        break;
      }
    }
  }
};

// ../../node_modules/@libp2p/utils/dist/src/link-local-ip.js
function isLinkLocalIp(ip) {
  if (ip.startsWith("169.254.")) {
    return true;
  }
  if (ip.toLowerCase().startsWith("fe80")) {
    return true;
  }
  return false;
}

// ../../node_modules/cborg/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value2) {
  if (value2 === null) {
    return "null";
  }
  if (value2 === void 0) {
    return "undefined";
  }
  if (value2 === true || value2 === false) {
    return "boolean";
  }
  const typeOf = typeof value2;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value2)) {
    return "Array";
  }
  if (isBuffer(value2)) {
    return "Buffer";
  }
  const objectType = getObjectType(value2);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value2) {
  return value2 && value2.constructor && value2.constructor.isBuffer && value2.constructor.isBuffer.call(null, value2);
}
function getObjectType(value2) {
  const objectTypeName = Object.prototype.toString.call(value2).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// ../../node_modules/cborg/lib/token.js
var Type = class {
  /**
   * @param {number} major
   * @param {string} name
   * @param {boolean} terminal
   */
  constructor(major, name5, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name5;
    this.terminal = terminal;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  /**
   * @param {Type} typ
   * @returns {number}
   */
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  /**
   * @param {Type} type
   * @param {any} [value]
   * @param {number} [encodedLength]
   */
  constructor(type, value2, encodedLength) {
    this.type = type;
    this.value = value2;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// ../../node_modules/cborg/lib/byte-utils.js
var useBuffer = window.process && // @ts-ignore
!window.process.browser && // @ts-ignore
window.Buffer && // @ts-ignore
typeof window.Buffer.isBuffer === "function";
var textDecoder2 = new TextDecoder();
var textEncoder2 = new TextEncoder();
function isBuffer2(buf2) {
  return useBuffer && window.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString3 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start2, end) => {
    return end - start2 > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      window.Buffer.from(bytes.subarray(start2, end)).toString("utf8")
    ) : utf8Slice(bytes, start2, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start2, end) => {
    return end - start2 > 64 ? textDecoder2.decode(bytes.subarray(start2, end)) : utf8Slice(bytes, start2, end);
  }
);
var fromString3 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string2) => {
    return string2.length > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      window.Buffer.from(string2)
    ) : utf8ToBytes2(string2);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string2) => {
    return string2.length > 64 ? textEncoder2.encode(string2) : utf8ToBytes2(string2);
  }
);
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start2, end) => {
    if (isBuffer2(bytes)) {
      return new Uint8Array(bytes.subarray(start2, end));
    }
    return bytes.slice(start2, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes, start2, end) => {
    return bytes.slice(start2, end);
  }
);
var concat2 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length4) => {
    chunks = chunks.map((c2) => c2 instanceof Uint8Array ? c2 : (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      window.Buffer.from(c2)
    ));
    return asU8A(window.Buffer.concat(chunks, length4));
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length4) => {
    const out = new Uint8Array(length4);
    let off = 0;
    for (let b of chunks) {
      if (off + b.length > out.length) {
        b = b.subarray(0, out.length - off);
      }
      out.set(b, off);
      off += b.length;
    }
    return out;
  }
);
var alloc3 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return window.Buffer.allocUnsafe(size);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return new Uint8Array(size);
  }
);
var toHex2 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} d
   * @returns {string}
   */
  (d2) => {
    if (typeof d2 === "string") {
      return d2;
    }
    return window.Buffer.from(toBytes(d2)).toString("hex");
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} d
   * @returns {string}
   */
  (d2) => {
    if (typeof d2 === "string") {
      return d2;
    }
    return Array.prototype.reduce.call(toBytes(d2), (p2, c2) => `${p2}${c2.toString(16).padStart(2, "0")}`, "");
  }
);
var fromHex2 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string|Uint8Array} hex
   * @returns {Uint8Array}
   */
  (hex) => {
    if (hex instanceof Uint8Array) {
      return hex;
    }
    return window.Buffer.from(hex, "hex");
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string|Uint8Array} hex
   * @returns {Uint8Array}
   */
  (hex) => {
    if (hex instanceof Uint8Array) {
      return hex;
    }
    if (!hex.length) {
      return new Uint8Array(0);
    }
    return new Uint8Array(hex.split("").map((c2, i2, d2) => i2 % 2 === 0 ? `0x${c2}${d2[i2 + 1]}` : "").filter(Boolean).map((e2) => parseInt(e2, 16)));
  }
);
function toBytes(obj) {
  if (obj instanceof Uint8Array && obj.constructor.name === "Uint8Array") {
    return obj;
  }
  if (obj instanceof ArrayBuffer) {
    return new Uint8Array(obj);
  }
  if (ArrayBuffer.isView(obj)) {
    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] === b2[i2]) {
      continue;
    }
    return b1[i2] < b2[i2] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes2(str) {
  const out = [];
  let p2 = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    let c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      out[p2++] = c2;
    } else if (c2 < 2048) {
      out[p2++] = c2 >> 6 | 192;
      out[p2++] = c2 & 63 | 128;
    } else if ((c2 & 64512) === 55296 && i2 + 1 < str.length && (str.charCodeAt(i2 + 1) & 64512) === 56320) {
      c2 = 65536 + ((c2 & 1023) << 10) + (str.charCodeAt(++i2) & 1023);
      out[p2++] = c2 >> 18 | 240;
      out[p2++] = c2 >> 12 & 63 | 128;
      out[p2++] = c2 >> 6 & 63 | 128;
      out[p2++] = c2 & 63 | 128;
    } else {
      out[p2++] = c2 >> 12 | 224;
      out[p2++] = c2 >> 6 & 63 | 128;
      out[p2++] = c2 & 63 | 128;
    }
  }
  return out;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}

// ../../node_modules/cborg/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  /**
   * @param {number} [chunkSize]
   */
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  /**
   * @param {Uint8Array|number[]} bytes
   */
  push(bytes) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes.length < 64 && bytes.length < this.chunkSize) {
        topChunk = alloc3(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes, 0);
      } else {
        this.chunks.push(bytes);
        this.maxCursor += bytes.length;
      }
    }
    this.cursor += bytes.length;
  }
  /**
   * @param {boolean} [reset]
   * @returns {Uint8Array}
   */
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat2(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// ../../node_modules/cborg/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// ../../node_modules/cborg/lib/0uint.js
var uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
function readUint8(data, offset, options2) {
  assertEnoughData(data, offset, 1);
  const value2 = data[offset];
  if (options2.strict === true && value2 < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint16(data, offset, options2) {
  assertEnoughData(data, offset, 2);
  const value2 = data[offset] << 8 | data[offset + 1];
  if (options2.strict === true && value2 < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint32(data, offset, options2) {
  assertEnoughData(data, offset, 4);
  const value2 = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options2.strict === true && value2 < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value2;
}
function readUint64(data, offset, options2) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value2 = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options2.strict === true && value2 < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value2 <= Number.MAX_SAFE_INTEGER) {
    return Number(value2);
  }
  if (options2.allowBigInt === true) {
    return value2;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options2) {
  return new Token(Type.uint, readUint8(data, pos + 1, options2), 2);
}
function decodeUint16(data, pos, _minor, options2) {
  return new Token(Type.uint, readUint16(data, pos + 1, options2), 3);
}
function decodeUint32(data, pos, _minor, options2) {
  return new Token(Type.uint, readUint32(data, pos + 1, options2), 5);
}
function decodeUint64(data, pos, _minor, options2) {
  return new Token(Type.uint, readUint64(data, pos + 1, options2), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([major | 24, nuint]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
    /* c8 ignore next */
    0
  );
};

// ../../node_modules/cborg/lib/1negint.js
function decodeNegint8(data, pos, _minor, options2) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options2), 2);
}
function decodeNegint16(data, pos, _minor, options2) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options2), 3);
}
function decodeNegint32(data, pos, _minor, options2) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options2), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options2) {
  const int = readUint64(data, pos + 1, options2);
  if (typeof int !== "bigint") {
    const value2 = -1 - int;
    if (value2 >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value2, 9);
    }
  }
  if (options2.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
    /* c8 ignore next */
    0
  );
};

// ../../node_modules/cborg/lib/2bytes.js
function toToken(data, pos, prefix, length4) {
  assertEnoughData(data, pos, prefix + length4);
  const buf2 = slice(data, pos + prefix, pos + prefix + length4);
  return new Token(Type.bytes, buf2, prefix + length4);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options2) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options2));
}
function decodeBytes16(data, pos, _minor, options2) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options2));
}
function decodeBytes32(data, pos, _minor, options2) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options2));
}
function decodeBytes64(data, pos, _minor, options2) {
  const l2 = readUint64(data, pos + 1, options2);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l2);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString3(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
  buf2.push(bytes);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes.length) + bytes.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}

// ../../node_modules/cborg/lib/3string.js
function toToken2(data, pos, prefix, length4, options2) {
  const totLength = prefix + length4;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString3(data, pos + prefix, pos + totLength), totLength);
  if (options2.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options2) {
  return toToken2(data, pos, 1, minor, options2);
}
function decodeString8(data, pos, _minor, options2) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options2), options2);
}
function decodeString16(data, pos, _minor, options2) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options2), options2);
}
function decodeString32(data, pos, _minor, options2) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options2), options2);
}
function decodeString64(data, pos, _minor, options2) {
  const l2 = readUint64(data, pos + 1, options2);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l2, options2);
}
var encodeString = encodeBytes;

// ../../node_modules/cborg/lib/4array.js
function toToken3(_data, _pos, prefix, length4) {
  return new Token(Type.array, length4, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options2) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options2));
}
function decodeArray16(data, pos, _minor, options2) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options2));
}
function decodeArray32(data, pos, _minor, options2) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options2));
}
function decodeArray64(data, pos, _minor, options2) {
  const l2 = readUint64(data, pos + 1, options2);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l2);
}
function decodeArrayIndefinite(data, pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/cborg/lib/5map.js
function toToken4(_data, _pos, prefix, length4) {
  return new Token(Type.map, length4, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options2) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options2));
}
function decodeMap16(data, pos, _minor, options2) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options2));
}
function decodeMap32(data, pos, _minor, options2) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options2));
}
function decodeMap64(data, pos, _minor, options2) {
  const l2 = readUint64(data, pos + 1, options2);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l2);
}
function decodeMapIndefinite(data, pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/cborg/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options2) {
  return new Token(Type.tag, readUint8(data, pos + 1, options2), 2);
}
function decodeTag16(data, pos, _minor, options2) {
  return new Token(Type.tag, readUint16(data, pos + 1, options2), 3);
}
function decodeTag32(data, pos, _minor, options2) {
  return new Token(Type.tag, readUint32(data, pos + 1, options2), 5);
}
function decodeTag64(data, pos, _minor, options2) {
  return new Token(Type.tag, readUint64(data, pos + 1, options2), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/cborg/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options2) {
  if (options2.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options2.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value2, bytes, options2) {
  if (options2) {
    if (options2.allowNaN === false && Number.isNaN(value2)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options2.allowInfinity === false && (value2 === Infinity || value2 === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value2, bytes);
}
function decodeFloat16(data, pos, _minor, options2) {
  return createToken(readFloat16(data, pos + 1), 3, options2);
}
function decodeFloat32(data, pos, _minor, options2) {
  return createToken(readFloat32(data, pos + 1), 5, options2);
}
function decodeFloat64(data, pos, _minor, options2) {
  return createToken(readFloat64(data, pos + 1), 9, options2);
}
function encodeFloat(buf2, token, options2) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options2 || options2.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options2) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options2 || options2.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// ../../node_modules/cborg/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i2 = 0; i2 <= 23; i2++) {
  jump[i2] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i2 = 32; i2 <= 55; i2++) {
  jump[i2] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i2 = 64; i2 <= 87; i2++) {
  jump[i2] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 96; i2 <= 119; i2++) {
  jump[i2] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 128; i2 <= 151; i2++) {
  jump[i2] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i2 = 160; i2 <= 183; i2++) {
  jump[i2] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i2 = 192; i2 <= 215; i2++) {
  jump[i2] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i2 = 224; i2 <= 243; i2++) {
  jump[i2] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i2 = 0; i2 < 24; i2++) {
  quick[i2] = new Token(Type.uint, i2, 1);
}
for (let i2 = -1; i2 >= -24; i2--) {
  quick[31 - i2] = new Token(Type.negint, i2, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// ../../node_modules/cborg/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
var rfc8949EncodeOptions = Object.freeze({
  float64: true,
  mapSorter: rfc8949MapSorter,
  quickEncodeToken
});
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class _Ref {
  /**
   * @param {object|any[]} obj
   * @param {Reference|undefined} parent
   */
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  /**
   * @param {object|any[]} obj
   * @returns {boolean}
   */
  includes(obj) {
    let p2 = this;
    do {
      if (p2.obj === obj) {
        return true;
      }
    } while (p2 = p2.parent);
    return false;
  }
  /**
   * @param {Reference|undefined} stack
   * @param {object|any[]} obj
   * @returns {Reference}
   */
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Array(obj, _typ, options2, refStack) {
    if (!obj.length) {
      if (options2.addBreakTokens === true) {
        return [simpleTokens.emptyArray, new Token(Type.break)];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const e2 of obj) {
      entries[i2++] = objectToTokens(e2, options2, refStack);
    }
    if (options2.addBreakTokens) {
      return [new Token(Type.array, obj.length), entries, new Token(Type.break)];
    }
    return [new Token(Type.array, obj.length), entries];
  },
  /**
   * @param {any} obj
   * @param {string} typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Object(obj, typ, options2, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length4 = isMap ? obj.size : keys.length;
    if (!length4) {
      if (options2.addBreakTokens === true) {
        return [simpleTokens.emptyMap, new Token(Type.break)];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const key of keys) {
      entries[i2++] = [
        objectToTokens(key, options2, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options2, refStack)
      ];
    }
    sortMapEntries(entries, options2);
    if (options2.addBreakTokens) {
      return [new Token(Type.map, length4), entries, new Token(Type.break)];
    }
    return [new Token(Type.map, length4), entries];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options2 = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options2 && options2.typeEncoders && /** @type {OptionalTypeEncoder} */
  options2.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options2, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options2, refStack);
}
function sortMapEntries(entries, options2) {
  if (options2.mapSorter) {
    entries.sort(options2.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function rfc8949MapSorter(e1, e2) {
  if (e1[0] instanceof Token && e2[0] instanceof Token) {
    const t1 = (
      /** @type {TokenEx} */
      e1[0]
    );
    const t2 = (
      /** @type {TokenEx} */
      e2[0]
    );
    if (!t1._keyBytes) {
      t1._keyBytes = encodeRfc8949(t1.value);
    }
    if (!t2._keyBytes) {
      t2._keyBytes = encodeRfc8949(t2.value);
    }
    return compare(t1._keyBytes, t2._keyBytes);
  }
  throw new Error("rfc8949MapSorter: complex key types are not supported yet");
}
function encodeRfc8949(data) {
  return encodeCustom(data, cborEncoders, rfc8949EncodeOptions);
}
function tokensToEncoded(buf2, tokens, encoders, options2) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options2);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options2);
  }
}
function encodeCustom(data, encoders, options2) {
  const tokens = objectToTokens(data, options2);
  if (!Array.isArray(tokens) && options2.quickEncodeToken) {
    const quickBytes = options2.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options2);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options2);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options2);
  return buf.toBytes(true);
}
function encode9(data, options2) {
  options2 = Object.assign({}, defaultEncodeOptions, options2);
  return encodeCustom(data, cborEncoders, options2);
}

// ../../node_modules/cborg/lib/decode.js
var defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
var Tokeniser = class {
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options2 = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options2;
  }
  pos() {
    return this._pos;
  }
  done() {
    return this._pos >= this.data.length;
  }
  next() {
    const byt = this.data[this._pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this._pos, minor, this.options);
    }
    this._pos += token.encodedLength;
    return token;
  }
};
var DONE = /* @__PURE__ */ Symbol.for("DONE");
var BREAK = /* @__PURE__ */ Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options2) {
  const arr = [];
  for (let i2 = 0; i2 < token.value; i2++) {
    const value2 = tokensToObject(tokeniser, options2);
    if (value2 === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value2 === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i2}, expected ${token.value})`);
    }
    arr[i2] = value2;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options2) {
  const useMaps = options2.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m2 = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i2 = 0; i2 < token.value; i2++) {
    const key = tokensToObject(tokeniser, options2);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options2.rejectDuplicateMapKeys === true) {
      if (useMaps && m2.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value2 = tokensToObject(tokeniser, options2);
    if (value2 === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m2.set(key, value2);
    } else {
      obj[key] = value2;
    }
  }
  return useMaps ? m2 : obj;
}
function tokensToObject(tokeniser, options2) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options2);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options2);
  }
  if (token.type === Type.tag) {
    if (options2.tags && typeof options2.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options2);
      return options2.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decodeFirst(data, options2) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options2 = Object.assign({}, defaultDecodeOptions, options2);
  const tokeniser = options2.tokenizer || new Tokeniser(data, options2);
  const decoded = tokensToObject(tokeniser, options2);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
function decode10(data, options2) {
  const [decoded, remainder] = decodeFirst(data, options2);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}

// ../../node_modules/@libp2p/utils/node_modules/it-length-prefixed/dist/src/constants.js
var MAX_LENGTH_LENGTH2 = 8;
var MAX_DATA_LENGTH2 = 1024 * 1024 * 4;

// ../../node_modules/@libp2p/utils/node_modules/it-length-prefixed/dist/src/errors.js
var InvalidMessageLengthError3 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError3 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError3 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};
var UnexpectedEOFError3 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// ../../node_modules/@libp2p/utils/node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable4(thing) {
  return thing[Symbol.asyncIterator] != null;
}

// ../../node_modules/@libp2p/utils/node_modules/it-length-prefixed/dist/src/encode.js
function validateMaxDataLength(chunk, maxDataLength) {
  if (chunk.byteLength > maxDataLength) {
    throw new InvalidDataLengthError3("Message length too long");
  }
}
var defaultEncoder2 = (length4) => {
  const lengthLength = encodingLength2(length4);
  const lengthBuf = allocUnsafe(lengthLength);
  encode7(length4, lengthBuf);
  defaultEncoder2.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder2.bytes = 0;
function encode10(source, options2) {
  options2 = options2 ?? {};
  const encodeLength2 = options2.lengthEncoder ?? defaultEncoder2;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH2;
  function* maybeYield(chunk) {
    validateMaxDataLength(chunk, maxDataLength);
    const length4 = encodeLength2(chunk.byteLength);
    if (length4 instanceof Uint8Array) {
      yield length4;
    } else {
      yield* length4;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable4(source)) {
    return (async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    })();
  }
  return (function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  })();
}
encode10.single = (chunk, options2) => {
  options2 = options2 ?? {};
  const encodeLength2 = options2.lengthEncoder ?? defaultEncoder2;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH2;
  validateMaxDataLength(chunk, maxDataLength);
  return new Uint8ArrayList(encodeLength2(chunk.byteLength), chunk);
};

// ../../node_modules/@libp2p/utils/node_modules/it-length-prefixed/dist/src/decode.js
var ReadMode2;
(function(ReadMode5) {
  ReadMode5[ReadMode5["LENGTH"] = 0] = "LENGTH";
  ReadMode5[ReadMode5["DATA"] = 1] = "DATA";
})(ReadMode2 || (ReadMode2 = {}));
var defaultDecoder2 = (buf2) => {
  const length4 = decode8(buf2);
  defaultDecoder2.bytes = encodingLength2(length4);
  return length4;
};
defaultDecoder2.bytes = 0;
function decode11(source, options2) {
  const buffer2 = new Uint8ArrayList();
  let mode = ReadMode2.LENGTH;
  let dataLength = -1;
  const lengthDecoder = options2?.lengthDecoder ?? defaultDecoder2;
  const maxLengthLength = options2?.maxLengthLength ?? MAX_LENGTH_LENGTH2;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH2;
  function* maybeYield() {
    while (buffer2.byteLength > 0) {
      if (mode === ReadMode2.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer2);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError3("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError3("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer2.consume(dataLengthLength);
          if (options2?.onLength != null) {
            options2.onLength(dataLength);
          }
          mode = ReadMode2.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer2.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError3("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode2.DATA) {
        if (buffer2.byteLength < dataLength) {
          break;
        }
        const data = buffer2.sublist(0, dataLength);
        buffer2.consume(dataLength);
        if (options2?.onData != null) {
          options2.onData(data);
        }
        yield data;
        mode = ReadMode2.LENGTH;
      }
    }
  }
  if (isAsyncIterable4(source)) {
    return (async function* () {
      for await (const buf2 of source) {
        buffer2.append(buf2);
        yield* maybeYield();
      }
      if (buffer2.byteLength > 0) {
        throw new UnexpectedEOFError3("Unexpected end of input");
      }
    })();
  }
  return (function* () {
    for (const buf2 of source) {
      buffer2.append(buf2);
      yield* maybeYield();
    }
    if (buffer2.byteLength > 0) {
      throw new UnexpectedEOFError3("Unexpected end of input");
    }
  })();
}
decode11.fromReader = (reader, options2) => {
  let byteLength = 1;
  const varByteSource = (async function* () {
    while (true) {
      try {
        const { done, value: value2 } = await reader.next(byteLength);
        if (done === true) {
          return;
        }
        if (value2 != null) {
          yield value2;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  })();
  const onLength = (l2) => {
    byteLength = l2;
  };
  return decode11(varByteSource, {
    ...options2 ?? {},
    onLength
  });
};

// ../../node_modules/@libp2p/utils/dist/src/mock-muxer.js
var MockMuxedStream = class extends AbstractStream {
  constructor(init) {
    super(init);
    __publicField(this, "sendMessage");
    __publicField(this, "dataQueue");
    __publicField(this, "encoding");
    this.sendMessage = init.sendMessage;
    this.encoding = init.encoding;
    this.dataQueue = new Queue({
      concurrency: 1
    });
    if (this.direction === "outbound") {
      this.sendMessage({
        id: this.id,
        type: "create",
        protocol: this.protocol
      });
    }
  }
  sendData(data) {
    const canSendMore = this.sendMessage({
      id: this.id,
      type: "data",
      chunk: data.subarray()
    });
    return {
      sentBytes: data.byteLength,
      canSendMore
    };
  }
  sendReset() {
    this.sendMessage({
      id: this.id,
      type: "reset"
    });
  }
  async sendCloseWrite(options2) {
    this.sendMessage({
      id: this.id,
      type: "closeWrite"
    });
    options2?.signal?.throwIfAborted();
  }
  async sendCloseRead(options2) {
    this.sendMessage({
      id: this.id,
      type: "closeRead"
    });
    options2?.signal?.throwIfAborted();
  }
  sendPause() {
    this.sendMessage({
      id: this.id,
      type: "pause"
    });
  }
  sendResume() {
    this.sendMessage({
      id: this.id,
      type: "resume"
    });
  }
  onRemotePaused() {
    this.dataQueue.pause();
  }
  onRemoteResumed() {
    this.dataQueue.resume();
  }
};
var MESSAGE_OVERHEAD = 30;
var MockMuxer = class extends AbstractStreamMuxer {
  constructor(maConn, init) {
    super(maConn, {
      ...init,
      protocol: "/mock-muxer/1.0.0",
      name: "mock-muxer"
    });
    __publicField(this, "input");
    __publicField(this, "maxInputQueueSize");
    __publicField(this, "encoding");
    __publicField(this, "maxMessageSize");
    __publicField(this, "nextStreamId");
    this.maxInputQueueSize = init.maxInputQueueSize ?? 1024 * 1024 * 10;
    this.maxMessageSize = (init.maxMessageSize ?? 1024 * 1024 * 4) + MESSAGE_OVERHEAD;
    this.encoding = init.encoding ?? "base64";
    this.input = pushable();
    this.sendMessage = this.sendMessage.bind(this);
    this.nextStreamId = this.maConn.direction === "outbound" ? 0 : 1;
    Promise.resolve().then(async () => {
      for await (const buf2 of decode11(this.input, {
        maxDataLength: this.maxMessageSize
      })) {
        this.onMessage(decode10(buf2.subarray()));
      }
    }).catch((err) => {
      this.abort(err);
    });
  }
  onData(data) {
    if (this.input.readableLength >= this.maxInputQueueSize) {
      this.abort(new Error(`Input queue exceeded maximum size ${this.input.readableLength} >= ${this.maxInputQueueSize}`));
      return;
    }
    this.input.push(data);
  }
  sendMessage(message2) {
    if (message2.type === "data") {
      this.log.trace("send message %o", { ...message2, chunk: `[ ${message2.chunk.byteLength} bytes ]` });
    } else {
      this.log.trace("send message %o", message2);
    }
    const buf2 = encode9(message2);
    const encoded = encode10.single(buf2, {
      maxDataLength: this.maxMessageSize
    });
    return this.send(encoded);
  }
  onMessage(message2) {
    if (message2.type === "data") {
      this.log.trace("incoming message %o", { ...message2, chunk: `[ ${message2.chunk.byteLength} bytes ]` });
    } else {
      this.log.trace("incoming message %o", message2);
    }
    let stream = this.streams.find((s2) => s2.id === message2.id);
    if (message2.type === "create") {
      if (stream != null) {
        throw new Error(`Already had stream for ${message2.id}`);
      }
      this.log.trace("create stream inbound %s", message2.id);
      stream = this._createStream(message2.id, "inbound", {
        protocol: message2.protocol
      });
      this.onRemoteStream(stream);
    }
    if (stream == null) {
      this.log.error(`no stream found for ${message2.id}`);
      return;
    }
    if (message2.type === "data") {
      stream.onData(message2.chunk);
    } else if (message2.type === "reset") {
      stream.onRemoteReset();
    } else if (message2.type === "closeWrite") {
      stream.onRemoteCloseWrite();
    } else if (message2.type === "closeRead") {
      stream.onRemoteCloseRead();
    } else if (message2.type === "pause") {
      stream.onRemotePaused();
    } else if (message2.type === "resume") {
      stream.onRemoteResumed();
    }
  }
  async onCreateStream(options2) {
    this.nextStreamId += 2;
    return this._createStream(`${this.nextStreamId}`, "outbound", options2);
  }
  _createStream(id, direction, options2) {
    this.log.trace("createStream %s %s", direction, id);
    return new MockMuxedStream({
      ...this.streamOptions,
      ...options2,
      id,
      direction,
      log: this.log.newScope(`stream:${direction}:${id}`),
      sendMessage: this.sendMessage,
      encoding: this.encoding,
      maxMessageSize: this.maxMessageSize - MESSAGE_OVERHEAD,
      protocol: ""
    });
  }
};
var MockMuxerFactory = class {
  constructor(init) {
    __publicField(this, "protocol", "/mock-muxer/1.0.0");
    __publicField(this, "init");
    this.init = init;
  }
  createStreamMuxer(maConn) {
    return new MockMuxer(maConn, {
      ...this.init
    });
  }
};
function mockMuxer(init = {}) {
  return new MockMuxerFactory(init);
}

// ../../node_modules/weald/node_modules/ms/dist/index.js
var e = 1e3, t = e * 60, n = t * 60, r = n * 24, i = r * 7, a = r * 365.25, o = a / 12;
function s(e2, t2) {
  if (typeof e2 == `string`) return l(e2);
  if (typeof e2 == `number`) return p(e2, t2);
  throw Error(`Value provided to ms() must be a string or number. value=${JSON.stringify(e2)}`);
}
var c = s;
function l(s2) {
  if (typeof s2 != `string` || s2.length === 0 || s2.length > 100) throw Error(`Value provided to ms.parse() must be a string with length between 1 and 99. value=${JSON.stringify(s2)}`);
  let c2 = /^(?<value>-?\d*\.?\d+) *(?<unit>milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|months?|mo|years?|yrs?|y)?$/i.exec(s2);
  if (!c2?.groups) return NaN;
  let { value: l2, unit: u2 = `ms` } = c2.groups, d2 = parseFloat(l2), f2 = u2.toLowerCase();
  switch (f2) {
    case `years`:
    case `year`:
    case `yrs`:
    case `yr`:
    case `y`:
      return d2 * a;
    case `months`:
    case `month`:
    case `mo`:
      return d2 * o;
    case `weeks`:
    case `week`:
    case `w`:
      return d2 * i;
    case `days`:
    case `day`:
    case `d`:
      return d2 * r;
    case `hours`:
    case `hour`:
    case `hrs`:
    case `hr`:
    case `h`:
      return d2 * n;
    case `minutes`:
    case `minute`:
    case `mins`:
    case `min`:
    case `m`:
      return d2 * t;
    case `seconds`:
    case `second`:
    case `secs`:
    case `sec`:
    case `s`:
      return d2 * e;
    case `milliseconds`:
    case `millisecond`:
    case `msecs`:
    case `msec`:
    case `ms`:
      return d2;
    default:
      throw Error(`Unknown unit "${f2}" provided to ms.parse(). value=${JSON.stringify(s2)}`);
  }
}
function u(e2) {
  return l(e2);
}
function d(s2) {
  let c2 = Math.abs(s2);
  return c2 >= a ? `${Math.round(s2 / a)}y` : c2 >= o ? `${Math.round(s2 / o)}mo` : c2 >= i ? `${Math.round(s2 / i)}w` : c2 >= r ? `${Math.round(s2 / r)}d` : c2 >= n ? `${Math.round(s2 / n)}h` : c2 >= t ? `${Math.round(s2 / t)}m` : c2 >= e ? `${Math.round(s2 / e)}s` : `${s2}ms`;
}
function f(s2) {
  let c2 = Math.abs(s2);
  return c2 >= a ? m(s2, c2, a, `year`) : c2 >= o ? m(s2, c2, o, `month`) : c2 >= i ? m(s2, c2, i, `week`) : c2 >= r ? m(s2, c2, r, `day`) : c2 >= n ? m(s2, c2, n, `hour`) : c2 >= t ? m(s2, c2, t, `minute`) : c2 >= e ? m(s2, c2, e, `second`) : `${s2} ms`;
}
function p(e2, t2) {
  if (typeof e2 != `number` || !Number.isFinite(e2)) throw Error(`Value provided to ms.format() must be of type number.`);
  return t2?.long ? f(e2) : d(e2);
}
function m(e2, t2, n2, r2) {
  let i2 = t2 >= n2 * 1.5;
  return `${Math.round(e2 / n2)} ${r2}${i2 ? `s` : ``}`;
}

// ../../node_modules/weald/dist/src/common.js
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable2;
  createDebug.enable = enable2;
  createDebug.enabled = enabled2;
  createDebug.humanize = c;
  createDebug.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash = 0;
    for (let i2 = 0; i2 < namespace.length; i2++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i2);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace, options2) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug(...args) {
      if (!debug.enabled) {
        return;
      }
      const self2 = debug;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms = curr - (prevTime || curr);
      self2.diff = ms;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      if (options2?.onLog != null) {
        options2.onLog(...args);
      }
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy;
    Object.defineProperty(debug, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable2(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i2;
    const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split2.length;
    for (i2 = 0; i2 < len; i2++) {
      if (!split2[i2]) {
        continue;
      }
      namespaces = split2[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable2() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled2(name5) {
    if (name5[name5.length - 1] === "*") {
      return true;
    }
    let i2;
    let len;
    for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
      if (createDebug.skips[i2].test(name5)) {
        return false;
      }
    }
    for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
      if (createDebug.names[i2].test(name5)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack ?? val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.setupFormatters(createDebug.formatters);
  createDebug.enable(createDebug.load());
  return createDebug;
}

// ../../node_modules/weald/dist/src/browser.js
var storage = localstorage();
var colors = [
  "#0000CC",
  "#0000FF",
  "#0033CC",
  "#0033FF",
  "#0066CC",
  "#0066FF",
  "#0099CC",
  "#0099FF",
  "#00CC00",
  "#00CC33",
  "#00CC66",
  "#00CC99",
  "#00CCCC",
  "#00CCFF",
  "#3300CC",
  "#3300FF",
  "#3333CC",
  "#3333FF",
  "#3366CC",
  "#3366FF",
  "#3399CC",
  "#3399FF",
  "#33CC00",
  "#33CC33",
  "#33CC66",
  "#33CC99",
  "#33CCCC",
  "#33CCFF",
  "#6600CC",
  "#6600FF",
  "#6633CC",
  "#6633FF",
  "#66CC00",
  "#66CC33",
  "#9900CC",
  "#9900FF",
  "#9933CC",
  "#9933FF",
  "#99CC00",
  "#99CC33",
  "#CC0000",
  "#CC0033",
  "#CC0066",
  "#CC0099",
  "#CC00CC",
  "#CC00FF",
  "#CC3300",
  "#CC3333",
  "#CC3366",
  "#CC3399",
  "#CC33CC",
  "#CC33FF",
  "#CC6600",
  "#CC6633",
  "#CC9900",
  "#CC9933",
  "#CCCC00",
  "#CCCC33",
  "#FF0000",
  "#FF0033",
  "#FF0066",
  "#FF0099",
  "#FF00CC",
  "#FF00FF",
  "#FF3300",
  "#FF3333",
  "#FF3366",
  "#FF3399",
  "#FF33CC",
  "#FF33FF",
  "#FF6600",
  "#FF6633",
  "#FF9900",
  "#FF9933",
  "#FFCC00",
  "#FFCC33"
];
function useColors() {
  if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
    return true;
  }
  if (typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/(edge|trident)\/(\d+)/) != null) {
    return false;
  }
  return typeof document !== "undefined" && document.documentElement?.style?.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  // @ts-expect-error window.console.firebug and window.console.exception are not in the types
  typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/firefox\/(\d+)/) != null && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== "undefined" && navigator.userAgent?.toLowerCase().match(/applewebkit\/(\d+)/);
}
function formatArgs(args) {
  args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + c(this.diff);
  if (!this.useColors) {
    return;
  }
  const c2 = "color: " + this.color;
  args.splice(1, 0, c2, "color: inherit");
  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, (match) => {
    if (match === "%%") {
      return;
    }
    index++;
    if (match === "%c") {
      lastC = index;
    }
  });
  args.splice(lastC, 0, c2);
}
var log = console.debug ?? console.log ?? (() => {
});
function save(namespaces) {
  try {
    if (namespaces) {
      storage?.setItem("debug", namespaces);
    } else {
      storage?.removeItem("debug");
    }
  } catch (error) {
  }
}
function load() {
  let r2;
  try {
    r2 = storage?.getItem("debug");
  } catch (error) {
  }
  if (!r2 && typeof window.process !== "undefined" && "env" in window.process) {
    r2 = window.process.env.DEBUG;
  }
  return r2;
}
function localstorage() {
  try {
    return localStorage;
  } catch (error) {
  }
}
function setupFormatters(formatters) {
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
}
var browser_default = setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log });

// ../../node_modules/weald/dist/src/index.js
var src_default2 = browser_default;

// ../../node_modules/@libp2p/logger/dist/src/utils.js
function truncatePeerId(peerId, options2 = {}) {
  const prefixLength = options2.prefixLength ?? 2;
  const suffixLength = options2.suffixLength ?? 4;
  const peerIdString = peerId.toString();
  return `${peerIdString.substring(0, prefixLength)}${peerIdString.substring(peerIdString.length, peerIdString.length - suffixLength)}`;
}

// ../../node_modules/@libp2p/logger/dist/src/index.js
src_default2.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc.baseEncode(v);
};
src_default2.formatters.t = (v) => {
  return v == null ? "undefined" : base32.baseEncode(v);
};
src_default2.formatters.m = (v) => {
  return v == null ? "undefined" : base64.baseEncode(v);
};
src_default2.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default2.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default2.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
src_default2.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function formatError(v, indent = "") {
  const message2 = notEmpty(v.message);
  const stack = notEmpty(v.stack);
  if (message2 != null && stack != null) {
    if (stack.includes(message2)) {
      return `${stack.split("\n").join(`
${indent}`)}`;
    }
    return `${message2}
${indent}${stack.split("\n").join(`
${indent}`)}`;
  }
  if (stack != null) {
    return `${stack.split("\n").join(`
${indent}`)}`;
  }
  if (message2 != null) {
    return `${message2}`;
  }
  return `${v.toString()}`;
}
function isAggregateError(err) {
  return err instanceof AggregateError || err?.name === "AggregateError" && Array.isArray(err.errors);
}
function printError(err, indent = "") {
  if (isAggregateError(err)) {
    let output = formatError(err, indent);
    if (err.errors.length > 0) {
      indent = `${indent}    `;
      output += `
${indent}${err.errors.map((err2) => `${printError(err2, `${indent}`)}`).join(`
${indent}`)}`;
    } else {
      output += `
${indent}[Error list was empty]`;
    }
    return output.trim();
  }
  return formatError(err, indent);
}
src_default2.formatters.e = (v) => {
  if (v == null) {
    return "undefined";
  }
  return printError(v);
};
function createDisabledLogger(namespace) {
  const logger2 = () => {
  };
  logger2.enabled = false;
  logger2.color = "";
  logger2.diff = 0;
  logger2.log = () => {
  };
  logger2.namespace = namespace;
  logger2.destroy = () => true;
  logger2.extend = () => logger2;
  return logger2;
}
function peerLogger(peerId, options2 = {}) {
  return prefixLogger(truncatePeerId(peerId, options2), options2);
}
function prefixLogger(prefix, options2) {
  return {
    forComponent(name5) {
      return logger(`${prefix}:${name5}`, options2);
    }
  };
}
function defaultLogger(options2) {
  return {
    forComponent(name5) {
      return logger(name5, options2);
    }
  };
}
function logger(name5, options2) {
  let trace = createDisabledLogger(`${name5}:trace`);
  if (src_default2.enabled(`${name5}:trace`) && src_default2.names.map((r2) => r2.toString()).find((n2) => n2.includes(":trace")) != null) {
    trace = src_default2(`${name5}:trace`, options2);
  }
  return Object.assign(src_default2(name5, options2), {
    error: src_default2(`${name5}:error`, options2),
    trace,
    newScope: (scope) => logger(`${name5}:${scope}`, options2)
  });
}
function disable() {
  src_default2.disable();
}
function enable(namespaces) {
  src_default2.enable(namespaces);
}
function enabled(namespaces) {
  return src_default2.enabled(namespaces);
}
function notEmpty(str) {
  if (str == null) {
    return;
  }
  str = str.trim();
  if (str.length === 0) {
    return;
  }
  return str;
}

// ../../node_modules/@libp2p/utils/dist/src/mock-stream.js
var streamId = 0;
var MockStream = class extends AbstractStream {
  constructor(init) {
    const id = `${streamId++}`;
    super({
      ...init,
      id,
      log: defaultLogger().forComponent(`libp2p:stream-pair:${init.direction}:${id}`)
    });
    __publicField(this, "local");
    __publicField(this, "remote");
    this.local = init.local;
    this.remote = init.remote;
    this.local.addEventListener("drain", () => {
      this.safeDispatchEvent("drain");
    });
    this.remote.addEventListener("message", (evt) => {
      this.onData(evt.data);
    });
    this.remote.addEventListener("reset", (evt) => {
      this.onRemoteReset();
    });
    this.remote.addEventListener("closeWrite", (evt) => {
      this.onRemoteCloseWrite();
    });
  }
  sendData(data) {
    const canSendMore = this.local.send(new StreamMessageEvent(data));
    return {
      sentBytes: data.byteLength,
      canSendMore
    };
  }
  sendReset() {
    this.local.send(new Event("reset"));
  }
  async sendCloseWrite(options2) {
    return raceSignal(new Promise((resolve, reject) => {
      this.local.send(new Event("closeWrite"));
      this.local.onIdle().then(resolve, reject);
    }), options2?.signal);
  }
  async sendCloseRead(options2) {
    return raceSignal(new Promise((resolve, reject) => {
      this.local.send(new Event("closeRead"));
      this.local.onIdle().then(resolve, reject);
    }), options2?.signal);
  }
  sendPause() {
    this.local.send(new Event("pause"));
  }
  sendResume() {
    this.local.send(new Event("resume"));
  }
  onRemotePaused() {
    this.local.pause();
  }
  onRemoteResumed() {
    this.local.resume();
  }
  onMuxerDrain() {
    this.local.resume();
  }
};

// ../../node_modules/unlimited-timeout/index.js
var MAX_TIMEOUT = 2147483647;
var brandSymbol = /* @__PURE__ */ Symbol.for("sindresorhus/unlimited-timeout#brand");
function setTimeout2(callback, delay2, ...arguments_) {
  if (typeof callback !== "function") {
    throw new TypeError("Expected callback to be a function");
  }
  delay2 ?? (delay2 = 0);
  delay2 = Number(delay2);
  let shouldUnref = false;
  const timeout = {
    [brandSymbol]: true,
    id: void 0,
    cleared: false,
    ref() {
      shouldUnref = false;
      timeout.id?.ref?.();
      return timeout;
    },
    unref() {
      shouldUnref = true;
      timeout.id?.unref?.();
      return timeout;
    }
  };
  if (delay2 === Number.POSITIVE_INFINITY || delay2 > Number.MAX_SAFE_INTEGER) {
    return timeout;
  }
  if (!Number.isFinite(delay2) || delay2 < 0) {
    delay2 = 0;
  }
  const targetTime = performance.now() + delay2;
  const schedule = (remainingDelay) => {
    if (timeout.cleared) {
      return;
    }
    if (remainingDelay <= MAX_TIMEOUT) {
      timeout.id = window.setTimeout(() => {
        if (!timeout.cleared) {
          callback(...arguments_);
        }
      }, remainingDelay);
      if (shouldUnref) {
        timeout.id?.unref?.();
      }
    } else {
      timeout.id = window.setTimeout(() => {
        const now = performance.now();
        const remaining = Math.max(0, targetTime - now);
        schedule(remaining);
      }, MAX_TIMEOUT);
      if (shouldUnref) {
        timeout.id?.unref?.();
      }
    }
  };
  schedule(delay2);
  return timeout;
}
function clearTimeout2(timeout) {
  if (!timeout || typeof timeout !== "object" || !timeout[brandSymbol]) {
    return;
  }
  timeout.cleared = true;
  if (timeout.id !== void 0) {
    window.clearTimeout(timeout.id);
    timeout.id = void 0;
  }
}
function setInterval2(callback, delay2, ...arguments_) {
  if (typeof callback !== "function") {
    throw new TypeError("Expected callback to be a function");
  }
  delay2 ?? (delay2 = 0);
  delay2 = Number(delay2);
  let shouldUnref = false;
  const interval = {
    [brandSymbol]: true,
    id: void 0,
    cleared: false,
    ref() {
      shouldUnref = false;
      interval.id?.ref?.();
      return interval;
    },
    unref() {
      shouldUnref = true;
      interval.id?.unref?.();
      return interval;
    }
  };
  if (delay2 === Number.POSITIVE_INFINITY || delay2 > Number.MAX_SAFE_INTEGER) {
    return interval;
  }
  if (!Number.isFinite(delay2) || delay2 < 0) {
    delay2 = 0;
  }
  let nextTargetTime = performance.now() + delay2;
  const schedule = (remainingDelay) => {
    if (interval.cleared) {
      return;
    }
    if (remainingDelay <= MAX_TIMEOUT) {
      interval.id = window.setTimeout(() => {
        if (interval.cleared) {
          return;
        }
        nextTargetTime += delay2;
        const now = performance.now();
        const nextDelay = Math.max(0, nextTargetTime - now);
        schedule(nextDelay);
        callback(...arguments_);
      }, remainingDelay);
      if (shouldUnref) {
        interval.id?.unref?.();
      }
    } else {
      interval.id = window.setTimeout(() => {
        const now = performance.now();
        const nextDelay = Math.max(0, nextTargetTime - now);
        schedule(nextDelay);
      }, MAX_TIMEOUT);
      if (shouldUnref) {
        interval.id?.unref?.();
      }
    }
  };
  schedule(delay2);
  return interval;
}
function clearInterval2(interval) {
  if (!interval || typeof interval !== "object" || !interval[brandSymbol]) {
    return;
  }
  interval.cleared = true;
  if (interval.id !== void 0) {
    window.clearTimeout(interval.id);
    interval.id = void 0;
  }
}

// ../../node_modules/random-int/index.js
function randomInteger(minimum, maximum) {
  if (maximum === void 0) {
    maximum = minimum;
    minimum = 0;
  }
  if (typeof minimum !== "number" || typeof maximum !== "number") {
    throw new TypeError("Expected all arguments to be numbers");
  }
  const actualMinimum = Math.min(minimum, maximum);
  const actualMaximum = Math.max(minimum, maximum);
  return Math.floor(
    Math.random() * (actualMaximum - actualMinimum + 1) + actualMinimum
  );
}

// ../../node_modules/delay/index.js
var clearMethods = /* @__PURE__ */ new WeakMap();
function createDelay({ clearTimeout: defaultClear, setTimeout: defaultSet } = {}) {
  return (milliseconds, { value: value2, signal } = {}) => {
    if (signal?.aborted) {
      return Promise.reject(signal.reason);
    }
    let timeoutId;
    let settle;
    let rejectFunction;
    const clear = defaultClear ?? clearTimeout;
    const signalListener = () => {
      clear(timeoutId);
      rejectFunction(signal.reason);
    };
    const cleanup = () => {
      if (signal) {
        signal.removeEventListener("abort", signalListener);
      }
    };
    const delayPromise = new Promise((resolve, reject) => {
      settle = () => {
        cleanup();
        resolve(value2);
      };
      rejectFunction = reject;
      timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);
    });
    if (signal) {
      signal.addEventListener("abort", signalListener, { once: true });
    }
    clearMethods.set(delayPromise, () => {
      clear(timeoutId);
      timeoutId = null;
      settle();
    });
    return delayPromise;
  };
}
var delay = createDelay({ setTimeout: setTimeout2, clearTimeout: clearTimeout2 });
var delay_default = delay;
async function rangeDelay(minimum, maximum, options2) {
  return delay(randomInteger(minimum, maximum), options2);
}
function clearDelay(promise) {
  clearMethods.get(promise)?.();
}

// ../../node_modules/@libp2p/utils/dist/src/message-queue.js
var DEFAULT_CHUNK_SIZE = 1024 * 64;
var MessageQueue = class extends TypedEventEmitter {
  constructor(init) {
    super();
    __publicField(this, "needsDrain");
    __publicField(this, "queue");
    __publicField(this, "capacity");
    __publicField(this, "delay");
    __publicField(this, "log");
    __publicField(this, "chunkSize");
    this.needsDrain = false;
    this.queue = new Queue({
      concurrency: 1
    });
    this.capacity = init.capacity ?? 5;
    this.delay = init.delay ?? 0;
    this.log = init.log;
    this.chunkSize = init.chunkSize ?? DEFAULT_CHUNK_SIZE;
    this.queue.addEventListener("idle", () => {
      if (this.needsDrain) {
        this.log("network send queue drained");
        this.needsDrain = false;
        this.safeDispatchEvent("drain");
      } else {
        this.log("network send queue idle");
      }
    });
  }
  send(evt) {
    if (isMessageEvent(evt)) {
      const data = new Uint8ArrayList(evt.data);
      while (data.byteLength > 0) {
        const end = Math.min(this.chunkSize, data.byteLength);
        const chunk = data.sublist(0, end);
        data.consume(chunk.byteLength);
        const chunkEvent = new StreamMessageEvent(chunk);
        this.queue.add(async (opts) => {
          if (this.delay > 0) {
            await raceSignal(delay_default(this.delay), opts.signal);
          }
          this.dispatchEvent(opts.evt);
        }, {
          evt: chunkEvent
        });
      }
    } else {
      this.queue.add(async (opts) => {
        if (this.delay > 0) {
          await raceSignal(delay_default(this.delay), opts.signal);
        }
        this.dispatchEvent(opts.evt);
      }, {
        evt
      });
    }
    if (this.queue.size >= this.capacity) {
      this.log("network send queue full");
      this.needsDrain = true;
      return false;
    }
    return true;
  }
  pause() {
    this.queue.pause();
  }
  resume() {
    this.queue.resume();
  }
  onIdle() {
    return this.queue.onIdle();
  }
  size() {
    return this.queue.size;
  }
};
function isMessageEvent(evt) {
  return evt?.data instanceof Uint8Array || isUint8ArrayList(evt?.data);
}

// ../../node_modules/@libp2p/utils/dist/src/multiaddr-connection-pair.js
var multiaddrConnectionId = 0;
var MockMultiaddrConnection = class extends AbstractMultiaddrConnection {
  constructor(init) {
    super(init);
    __publicField(this, "local");
    __publicField(this, "remote");
    this.local = init.local;
    this.remote = init.remote;
    this.local.addEventListener("drain", () => {
      this.safeDispatchEvent("drain");
    });
    this.remote.addEventListener("message", (evt) => {
      if (this.status !== "open") {
        return;
      }
      this.onData(evt.data);
    });
    this.remote.addEventListener("reset", (evt) => {
      if (this.status !== "open") {
        return;
      }
      this.onRemoteReset();
    });
    this.remote.addEventListener("close", (evt) => {
      this.onTransportClosed();
    });
    this.remote.addEventListener("pause", (evt) => {
      this.local.pause();
    });
    this.remote.addEventListener("resume", (evt) => {
      this.local.resume();
    });
  }
  sendData(data) {
    const canSendMore = this.local.send(new StreamMessageEvent(data));
    return {
      sentBytes: data.byteLength,
      canSendMore
    };
  }
  sendReset() {
    this.local.send(new Event("reset"));
  }
  async sendClose(options2) {
    if (this.local.needsDrain) {
      await pEvent(this.local, "drain", {
        signal: options2?.signal
      });
    }
    return raceSignal(new Promise((resolve, reject) => {
      this.local.send(new Event("close"));
      this.local.onIdle().then(resolve, reject);
    }), options2?.signal);
  }
  sendPause() {
    this.local.send(new Event("pause"));
  }
  sendResume() {
    this.local.send(new Event("resume"));
  }
};
function multiaddrConnectionPair(opts = {}) {
  const inboundId = `${multiaddrConnectionId++}`;
  const outboundId = `${multiaddrConnectionId++}`;
  const outboundLog = defaultLogger().forComponent(`libp2p:mock-maconn:outbound:${inboundId}`);
  const inboundLog = defaultLogger().forComponent(`libp2p:mock-maconn:inbound:${outboundId}`);
  const targetA = new MessageQueue({
    ...opts,
    log: outboundLog
  });
  const targetB = new MessageQueue({
    ...opts,
    log: inboundLog
  });
  return [
    new MockMultiaddrConnection({
      ...opts.outbound,
      id: outboundId,
      direction: "outbound",
      local: targetA,
      remote: targetB,
      remoteAddr: opts?.outbound?.remoteAddr ?? multiaddr(`/ip4/127.0.0.1/tcp/${outboundId}`),
      log: outboundLog
    }),
    new MockMultiaddrConnection({
      ...opts.inbound,
      id: inboundId,
      direction: "inbound",
      local: targetB,
      remote: targetA,
      remoteAddr: opts?.inbound?.remoteAddr ?? multiaddr(`/ip4/127.0.0.1/tcp/${inboundId}`),
      log: inboundLog
    })
  ];
}

// ../../node_modules/@libp2p/utils/dist/src/peer-queue.js
var PeerQueue = class extends Queue {
  has(peerId) {
    return this.find(peerId) != null;
  }
  find(peerId) {
    return this.queue.find((job) => {
      return peerId.equals(job.options.peerId);
    });
  }
};

// ../../node_modules/@libp2p/utils/dist/src/priority-queue.js
var PriorityQueue = class extends Queue {
  constructor(init = {}) {
    super({
      ...init,
      sort: (a2, b) => {
        if (a2.options.priority > b.options.priority) {
          return -1;
        }
        if (a2.options.priority < b.options.priority) {
          return 1;
        }
        return 0;
      }
    });
  }
};

// ../../node_modules/@libp2p/utils/dist/src/rate-limiter.js
var RateLimiter = class {
  constructor(opts = {}) {
    __publicField(this, "memoryStorage");
    __publicField(this, "points");
    __publicField(this, "duration");
    __publicField(this, "blockDuration");
    __publicField(this, "keyPrefix");
    this.points = opts.points ?? 4;
    this.duration = opts.duration ?? 1;
    this.blockDuration = opts.blockDuration ?? 0;
    this.keyPrefix = opts.keyPrefix ?? "rlflx";
    this.memoryStorage = new MemoryStorage();
  }
  consume(key, pointsToConsume = 1, options2 = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options2);
    let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    if (res.consumedPoints > this.points) {
      if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
        res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
      }
      throw new RateLimitError("Rate limit exceeded", res);
    }
    return res;
  }
  penalty(key, points = 1, options2 = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options2);
    const res = this.memoryStorage.incrby(rlKey, points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  reward(key, points = 1, options2 = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options2);
    const res = this.memoryStorage.incrby(rlKey, -points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  /**
   * Block any key for secDuration seconds
   *
   * @param key
   * @param secDuration
   */
  block(key, secDuration) {
    const msDuration = secDuration * 1e3;
    const initPoints = this.points + 1;
    this.memoryStorage.set(this.getKey(key), initPoints, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: initPoints,
      isFirstInDuration: false
    };
  }
  set(key, points, secDuration = 0) {
    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
    this.memoryStorage.set(this.getKey(key), points, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: points,
      isFirstInDuration: false
    };
  }
  get(key) {
    const res = this.memoryStorage.get(this.getKey(key));
    if (res != null) {
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    }
    return res;
  }
  delete(key) {
    this.memoryStorage.delete(this.getKey(key));
  }
  _getKeySecDuration(options2) {
    if (options2?.customDuration != null && options2.customDuration >= 0) {
      return options2.customDuration;
    }
    return this.duration;
  }
  getKey(key) {
    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
  }
  parseKey(rlKey) {
    return rlKey.substring(this.keyPrefix.length);
  }
};
var MemoryStorage = class {
  constructor() {
    __publicField(this, "storage");
    this.storage = /* @__PURE__ */ new Map();
  }
  incrby(key, value2, durationSec) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      if (existing.expiresAt == null || msBeforeExpires > 0) {
        existing.value += value2;
        return {
          remainingPoints: 0,
          msBeforeNext: msBeforeExpires,
          consumedPoints: existing.value,
          isFirstInDuration: false
        };
      }
      return this.set(key, value2, durationSec);
    }
    return this.set(key, value2, durationSec);
  }
  set(key, value2, durationSec) {
    const durationMs = durationSec * 1e3;
    const existing = this.storage.get(key);
    if (existing != null) {
      clearTimeout(existing.timeoutId);
    }
    const record = {
      value: value2,
      expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : void 0
    };
    this.storage.set(key, record);
    if (durationMs > 0) {
      record.timeoutId = setTimeout(() => {
        this.storage.delete(key);
      }, durationMs);
      if (record.timeoutId.unref != null) {
        record.timeoutId.unref();
      }
    }
    return {
      remainingPoints: 0,
      msBeforeNext: durationMs === 0 ? -1 : durationMs,
      consumedPoints: record.value,
      isFirstInDuration: true
    };
  }
  get(key) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      return {
        remainingPoints: 0,
        msBeforeNext: msBeforeExpires,
        consumedPoints: existing.value,
        isFirstInDuration: false
      };
    }
  }
  delete(key) {
    const record = this.storage.get(key);
    if (record != null) {
      if (record.timeoutId != null) {
        clearTimeout(record.timeoutId);
      }
      this.storage.delete(key);
      return true;
    }
    return false;
  }
};

// ../../node_modules/@libp2p/utils/dist/src/repeating-task.js
function repeatingTask(fn, interval, options2) {
  let timeout;
  let shutdownController;
  let running = false;
  function runTask() {
    const opts = {
      signal: shutdownController.signal
    };
    if (options2?.timeout != null) {
      const signal = anySignal([shutdownController.signal, AbortSignal.timeout(options2.timeout)]);
      setMaxListeners(Infinity, signal);
      opts.signal = signal;
    }
    running = true;
    Promise.resolve().then(async () => {
      await fn(opts);
    }).catch(() => {
    }).finally(() => {
      running = false;
      if (shutdownController.signal.aborted) {
        return;
      }
      timeout = setTimeout(runTask, interval);
    });
  }
  const runTaskDebounced = debounce(runTask, options2?.debounce ?? 100);
  let started = false;
  return {
    setInterval: (ms) => {
      if (interval === ms) {
        return;
      }
      interval = ms;
      if (timeout != null) {
        clearTimeout(timeout);
        timeout = setTimeout(runTask, interval);
      }
    },
    setTimeout: (ms) => {
      options2 ?? (options2 = {});
      options2.timeout = ms;
    },
    run: () => {
      if (running) {
        return;
      }
      clearTimeout(timeout);
      runTaskDebounced();
    },
    start: () => {
      if (started) {
        return;
      }
      started = true;
      shutdownController = new AbortController();
      setMaxListeners(Infinity, shutdownController.signal);
      if (options2?.runImmediately === true) {
        queueMicrotask(() => {
          runTask();
        });
      } else {
        timeout = setTimeout(runTask, interval);
      }
    },
    stop: () => {
      clearTimeout(timeout);
      shutdownController?.abort();
      started = false;
    }
  };
}

// ../../node_modules/@libp2p/utils/dist/src/stream-pair.js
async function streamPair(opts = {}) {
  const [outboundConnection, inboundConnection] = multiaddrConnectionPair({
    ...opts,
    outbound: opts.outboundConnection,
    inbound: opts.inboundConnection
  });
  const localMuxer = mockMuxer({
    streamOptions: opts.outbound
  }).createStreamMuxer(outboundConnection);
  const remoteMuxer = mockMuxer({
    streamOptions: opts.inbound
  }).createStreamMuxer(inboundConnection);
  const [inboundStream, outboundStream] = await Promise.all([
    pEvent(remoteMuxer, "stream").then((evt) => {
      return evt.detail;
    }),
    localMuxer.createStream({
      ...opts.outbound,
      protocol: opts.protocol
    })
  ]);
  return [
    outboundStream,
    inboundStream
  ];
}
async function echoStream(opts = {}) {
  const [outbound, inbound] = await streamPair(opts);
  echo(inbound);
  return outbound;
}

// ../../node_modules/@libp2p/utils/dist/src/tracked-list.js
function trackedList(config) {
  const { name: name5, metrics } = config;
  const list = [];
  metrics?.registerMetric(name5, {
    calculate: () => {
      return list.length;
    }
  });
  return list;
}

// ../../node_modules/@libp2p/utils/dist/src/tracked-map.js
var TrackedMap = class extends Map {
  constructor(init) {
    super();
    __publicField(this, "metric");
    const { name: name5, metrics } = init;
    this.metric = metrics.registerMetric(name5);
    this.updateComponentMetric();
  }
  set(key, value2) {
    super.set(key, value2);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedMap(config) {
  const { name: name5, metrics } = config;
  let map2;
  if (metrics != null) {
    map2 = new TrackedMap({ name: name5, metrics });
  } else {
    map2 = /* @__PURE__ */ new Map();
  }
  return map2;
}

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
var DUMP_SESSION_KEYS = Boolean(window.process?.env?.DUMP_SESSION_KEYS);
var CHACHA_TAG_LENGTH = 16;

// ../../node_modules/@noble/ciphers/utils.js
function isBytes2(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function abool2(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function anumber2(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function abytes2(value2, length4, title = "") {
  const bytes = isBytes2(value2);
  const len = value2?.length;
  const needsLen = length4 !== void 0;
  if (!bytes || needsLen && len !== length4) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length4}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value2}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value2;
}
function aexists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance) {
  abytes2(out, void 0, "output");
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function u82(arr) {
  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u322(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean2(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView2(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
var isLE2 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin2 = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex2(bytes) {
  abytes2(bytes);
  if (hasHexBuiltin2)
    return bytes.toHex();
  let hex = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex += hexes2[bytes[i2]];
  }
  return hex;
}
var asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase162(ch) {
  if (ch >= asciis2._0 && ch <= asciis2._9)
    return ch - asciis2._0;
  if (ch >= asciis2.A && ch <= asciis2.F)
    return ch - (asciis2.A - 10);
  if (ch >= asciis2.a && ch <= asciis2.f)
    return ch - (asciis2.a - 10);
  return;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin2)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase162(hex.charCodeAt(hi));
    const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : "0x" + hex);
}
function bytesToNumberBE2(bytes) {
  return hexToNumber2(bytesToHex2(bytes));
}
function numberToBytesBE2(n2, len) {
  return hexToBytes2(n2.toString(16).padStart(len * 2, "0"));
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function bytesToUtf8(bytes) {
  return new TextDecoder().decode(bytes);
}
function overlapBytes(a2, b) {
  return a2.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
  a2.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
  b.byteOffset < a2.byteOffset + a2.byteLength;
}
function complexOverlapBytes(input, output) {
  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
    throw new Error("complex overlap of input and output is not supported");
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    abytes2(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad = 0; i2 < arrays.length; i2++) {
    const a2 = arrays[i2];
    res.set(a2, pad);
    pad += a2.length;
  }
  return res;
}
function checkOpts2(defaults3, opts) {
  if (opts == null || typeof opts !== "object")
    throw new Error("options must be defined");
  const merged = Object.assign(defaults3, opts);
  return merged;
}
function equalBytes2(a2, b) {
  if (a2.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a2.length; i2++)
    diff |= a2[i2] ^ b[i2];
  return diff === 0;
}
var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
  function wrappedCipher(key, ...args) {
    abytes2(key, void 0, "key");
    if (!isLE2)
      throw new Error("Non little-endian hardware is not yet supported");
    if (params.nonceLength !== void 0) {
      const nonce = args[0];
      abytes2(nonce, params.varSizeNonce ? void 0 : params.nonceLength, "nonce");
    }
    const tagl = params.tagLength;
    if (tagl && args[1] !== void 0)
      abytes2(args[1], void 0, "AAD");
    const cipher = constructor(key, ...args);
    const checkOutput = (fnLength, output) => {
      if (output !== void 0) {
        if (fnLength !== 2)
          throw new Error("cipher output not supported");
        abytes2(output, void 0, "output");
      }
    };
    let called = false;
    const wrCipher = {
      encrypt(data, output) {
        if (called)
          throw new Error("cannot encrypt() twice with same key + nonce");
        called = true;
        abytes2(data);
        checkOutput(cipher.encrypt.length, output);
        return cipher.encrypt(data, output);
      },
      decrypt(data, output) {
        abytes2(data);
        if (tagl && data.length < tagl)
          throw new Error('"ciphertext" expected length bigger than tagLength=' + tagl);
        checkOutput(cipher.decrypt.length, output);
        return cipher.decrypt(data, output);
      }
    };
    return wrCipher;
  }
  Object.assign(wrappedCipher, params);
  return wrappedCipher;
};
function getOutput(expectedLength, out, onlyAligned = true) {
  if (out === void 0)
    return new Uint8Array(expectedLength);
  if (out.length !== expectedLength)
    throw new Error('"output" expected Uint8Array of length ' + expectedLength + ", got: " + out.length);
  if (onlyAligned && !isAligned32(out))
    throw new Error("invalid output, must be aligned");
  return out;
}
function u64Lengths(dataLength, aadLength, isLE3) {
  abool2(isLE3);
  const num2 = new Uint8Array(16);
  const view = createView2(num2);
  view.setBigUint64(0, BigInt(aadLength), isLE3);
  view.setBigUint64(8, BigInt(dataLength), isLE3);
  return num2;
}
function isAligned32(bytes) {
  return bytes.byteOffset % 4 === 0;
}
function copyBytes2(bytes) {
  return Uint8Array.from(bytes);
}
function randomBytes3(bytesLength = 32) {
  const cr = typeof window === "object" ? window.crypto : null;
  if (typeof cr?.getRandomValues !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr.getRandomValues(new Uint8Array(bytesLength));
}
function managedNonce(fn, randomBytes_ = randomBytes3) {
  const { nonceLength } = fn;
  anumber2(nonceLength);
  const addNonce = (nonce, ciphertext) => {
    const out = concatBytes2(nonce, ciphertext);
    ciphertext.fill(0);
    return out;
  };
  return ((key, ...args) => ({
    encrypt(plaintext) {
      abytes2(plaintext);
      const nonce = randomBytes_(nonceLength);
      const encrypted = fn(key, nonce, ...args).encrypt(plaintext);
      if (encrypted instanceof Promise)
        return encrypted.then((ct) => addNonce(nonce, ct));
      return addNonce(nonce, encrypted);
    },
    decrypt(ciphertext) {
      abytes2(ciphertext);
      const nonce = ciphertext.subarray(0, nonceLength);
      const decrypted = ciphertext.subarray(nonceLength);
      return fn(key, nonce, ...args).decrypt(decrypted);
    }
  }));
}

// ../../node_modules/@noble/ciphers/_arx.js
var encodeStr = (str) => Uint8Array.from(str.split(""), (c2) => c2.charCodeAt(0));
var sigma16 = encodeStr("expand 16-byte k");
var sigma32 = encodeStr("expand 32-byte k");
var sigma16_32 = u322(sigma16);
var sigma32_32 = u322(sigma32);
function rotl2(a2, b) {
  return a2 << b | a2 >>> 32 - b;
}
function isAligned322(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = Uint32Array.of();
function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u322(block);
  const isAligned = isAligned322(data) && isAligned322(output);
  const d32 = isAligned ? u322(data) : U32_EMPTY;
  const o32 = isAligned ? u322(output) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core(sigma, key, nonce, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take2 = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take2 === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take2; j++) {
      posj = pos + j;
      output[posj] = data[posj] ^ block[j];
    }
    pos += take2;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts2({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  anumber2(counterLength);
  anumber2(rounds);
  abool2(counterRight);
  abool2(allowShortKeys);
  return (key, nonce, data, output, counter = 0) => {
    abytes2(key, void 0, "key");
    abytes2(nonce, void 0, "nonce");
    abytes2(data, void 0, "data");
    const len = data.length;
    if (output === void 0)
      output = new Uint8Array(len);
    abytes2(output, void 0, "output");
    anumber2(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output.length < len)
      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
    const toClean = [];
    let l2 = key.length;
    let k;
    let sigma;
    if (l2 === 32) {
      toClean.push(k = copyBytes2(key));
      sigma = sigma32_32;
    } else if (l2 === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else {
      abytes2(key, 32, "arx key");
      throw new Error("invalid key size");
    }
    if (!isAligned322(nonce))
      toClean.push(nonce = copyBytes2(nonce));
    const k32 = u322(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma, k32, u322(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u322(nonce);
    runCipher(core, sigma, k32, n32, data, output, counter, rounds);
    clean2(...toClean);
    return output;
  };
}
var _XorStreamPRG = class __XorStreamPRG {
  constructor(cipher, blockLen, keyLen, nonceLen, seed) {
    __publicField(this, "blockLen");
    __publicField(this, "keyLen");
    __publicField(this, "nonceLen");
    __publicField(this, "state");
    __publicField(this, "buf");
    __publicField(this, "key");
    __publicField(this, "nonce");
    __publicField(this, "pos");
    __publicField(this, "ctr");
    __publicField(this, "cipher");
    this.cipher = cipher;
    this.blockLen = blockLen;
    this.keyLen = keyLen;
    this.nonceLen = nonceLen;
    this.state = new Uint8Array(this.keyLen + this.nonceLen);
    this.reseed(seed);
    this.ctr = 0;
    this.pos = this.blockLen;
    this.buf = new Uint8Array(this.blockLen);
    this.key = this.state.subarray(0, this.keyLen);
    this.nonce = this.state.subarray(this.keyLen);
  }
  reseed(seed) {
    abytes2(seed);
    if (!seed || seed.length === 0)
      throw new Error("entropy required");
    for (let i2 = 0; i2 < seed.length; i2++)
      this.state[i2 % this.state.length] ^= seed[i2];
    this.ctr = 0;
    this.pos = this.blockLen;
  }
  addEntropy(seed) {
    this.state.set(this.randomBytes(this.state.length));
    this.reseed(seed);
  }
  randomBytes(len) {
    anumber2(len);
    if (len === 0)
      return new Uint8Array(0);
    const out = new Uint8Array(len);
    let outPos = 0;
    if (this.pos < this.blockLen) {
      const take2 = Math.min(len, this.blockLen - this.pos);
      out.set(this.buf.subarray(this.pos, this.pos + take2), 0);
      this.pos += take2;
      outPos += take2;
      if (outPos === len)
        return out;
    }
    const blocks = Math.floor((len - outPos) / this.blockLen);
    if (blocks > 0) {
      const blockBytes = blocks * this.blockLen;
      const b = out.subarray(outPos, outPos + blockBytes);
      this.cipher(this.key, this.nonce, b, b, this.ctr);
      this.ctr += blocks;
      outPos += blockBytes;
    }
    const left = len - outPos;
    if (left > 0) {
      this.buf.fill(0);
      this.cipher(this.key, this.nonce, this.buf, this.buf, this.ctr++);
      out.set(this.buf.subarray(0, left), outPos);
      this.pos = left;
    }
    return out;
  }
  clone() {
    return new __XorStreamPRG(this.cipher, this.blockLen, this.keyLen, this.nonceLen, this.randomBytes(this.state.length));
  }
  clean() {
    this.pos = 0;
    this.ctr = 0;
    this.buf.fill(0);
    this.state.fill(0);
  }
};
var createPRG = (cipher, blockLen, keyLen, nonceLen) => {
  return (seed = randomBytes3(32)) => new _XorStreamPRG(cipher, blockLen, keyLen, nonceLen, seed);
};

// ../../node_modules/@noble/ciphers/_poly1305.js
function u8to16(a2, i2) {
  return a2[i2++] & 255 | (a2[i2++] & 255) << 8;
}
function bytesToNumberLE2(bytes) {
  return hexToNumber2(bytesToHex2(Uint8Array.from(bytes).reverse()));
}
function poly1305_small(msg, key) {
  abytes2(msg);
  abytes2(key, 32, "key");
  const POW_2_130_5 = BigInt(2) ** BigInt(130) - BigInt(5);
  const POW_2_128_1 = BigInt(2) ** BigInt(128) - BigInt(1);
  const CLAMP_R = BigInt("0x0ffffffc0ffffffc0ffffffc0fffffff");
  const r2 = bytesToNumberLE2(key.subarray(0, 16)) & CLAMP_R;
  const s2 = bytesToNumberLE2(key.subarray(16));
  let acc = BigInt(0);
  for (let i2 = 0; i2 < msg.length; i2 += 16) {
    const m2 = msg.subarray(i2, i2 + 16);
    const n2 = bytesToNumberLE2(m2) | BigInt(1) << BigInt(8 * m2.length);
    acc = (acc + n2) * r2 % POW_2_130_5;
  }
  const res = acc + s2 & POW_2_128_1;
  return numberToBytesBE2(res, 16).reverse();
}
function poly1305_computeTag_small(authKey, lengths, ciphertext, AAD) {
  const res = [];
  const updatePadded2 = (msg) => {
    res.push(msg);
    const leftover = msg.length % 16;
    if (leftover)
      res.push(new Uint8Array(16).slice(leftover));
  };
  if (AAD)
    updatePadded2(AAD);
  updatePadded2(ciphertext);
  res.push(lengths);
  return poly1305_small(concatBytes2(...res), authKey);
}
var Poly1305 = class {
  // Can be speed-up using BigUint64Array, at the cost of complexity
  constructor(key) {
    __publicField(this, "blockLen", 16);
    __publicField(this, "outputLen", 16);
    __publicField(this, "buffer", new Uint8Array(16));
    __publicField(this, "r", new Uint16Array(10));
    // Allocating 1 array with .subarray() here is slower than 3
    __publicField(this, "h", new Uint16Array(10));
    __publicField(this, "pad", new Uint16Array(8));
    __publicField(this, "pos", 0);
    __publicField(this, "finished", false);
    key = copyBytes2(abytes2(key, 32, "key"));
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i2 = 0; i2 < 8; i2++)
      this.pad[i2] = u8to16(key, 16 + 2 * i2);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r: r2 } = this;
    const r0 = r2[0];
    const r1 = r2[1];
    const r22 = r2[2];
    const r3 = r2[3];
    const r4 = r2[4];
    const r5 = r2[5];
    const r6 = r2[6];
    const r7 = r2[7];
    const r8 = r2[8];
    const r9 = r2[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c2 = 0;
    let d0 = c2 + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c2 = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r22) + h9 * (5 * r1);
    c2 += d0 >>> 13;
    d0 &= 8191;
    let d1 = c2 + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c2 = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r22);
    c2 += d1 >>> 13;
    d1 &= 8191;
    let d2 = c2 + h0 * r22 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c2 = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c2 += d2 >>> 13;
    d2 &= 8191;
    let d3 = c2 + h0 * r3 + h1 * r22 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c2 = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c2 += d3 >>> 13;
    d3 &= 8191;
    let d4 = c2 + h0 * r4 + h1 * r3 + h2 * r22 + h3 * r1 + h4 * r0;
    c2 = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c2 += d4 >>> 13;
    d4 &= 8191;
    let d5 = c2 + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r22 + h4 * r1;
    c2 = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c2 += d5 >>> 13;
    d5 &= 8191;
    let d6 = c2 + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r22;
    c2 = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c2 += d6 >>> 13;
    d6 &= 8191;
    let d7 = c2 + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c2 = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r22 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c2 += d7 >>> 13;
    d7 &= 8191;
    let d8 = c2 + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c2 = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r22 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c2 += d8 >>> 13;
    d8 &= 8191;
    let d9 = c2 + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c2 = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r22 + h8 * r1 + h9 * r0;
    c2 += d9 >>> 13;
    d9 &= 8191;
    c2 = (c2 << 2) + c2 | 0;
    c2 = c2 + d0 | 0;
    d0 = c2 & 8191;
    c2 = c2 >>> 13;
    d1 += c2;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad } = this;
    const g = new Uint16Array(10);
    let c2 = h[1] >>> 13;
    h[1] &= 8191;
    for (let i2 = 2; i2 < 10; i2++) {
      h[i2] += c2;
      c2 = h[i2] >>> 13;
      h[i2] &= 8191;
    }
    h[0] += c2 * 5;
    c2 = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c2;
    c2 = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c2;
    g[0] = h[0] + 5;
    c2 = g[0] >>> 13;
    g[0] &= 8191;
    for (let i2 = 1; i2 < 10; i2++) {
      g[i2] = h[i2] + c2;
      c2 = g[i2] >>> 13;
      g[i2] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c2 ^ 1) - 1;
    for (let i2 = 0; i2 < 10; i2++)
      g[i2] &= mask;
    mask = ~mask;
    for (let i2 = 0; i2 < 10; i2++)
      h[i2] = h[i2] & mask | g[i2];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f2 = h[0] + pad[0];
    h[0] = f2 & 65535;
    for (let i2 = 1; i2 < 8; i2++) {
      f2 = (h[i2] + pad[i2] | 0) + (f2 >>> 16) | 0;
      h[i2] = f2 & 65535;
    }
    clean2(g);
  }
  update(data) {
    aexists2(this);
    abytes2(data);
    data = copyBytes2(data);
    const { buffer: buffer2, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(buffer2, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    clean2(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(out) {
    aexists2(this);
    aoutput2(out, this);
    this.finished = true;
    const { buffer: buffer2, h } = this;
    let { pos } = this;
    if (pos) {
      buffer2[pos++] = 1;
      for (; pos < 16; pos++)
        buffer2[pos] = 0;
      this.process(buffer2, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      out[opos++] = h[i2] >>> 0;
      out[opos++] = h[i2] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(msg).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = /* @__PURE__ */ (() => wrapConstructorWithKey((key) => new Poly1305(key)))();

// ../../node_modules/@noble/ciphers/chacha.js
function chachaQR(x, a2, b, c2, d2) {
  x[a2] = x[a2] + x[b] | 0;
  x[d2] = rotl2(x[d2] ^ x[a2], 16);
  x[c2] = x[c2] + x[d2] | 0;
  x[b] = rotl2(x[b] ^ x[c2], 12);
  x[a2] = x[a2] + x[b] | 0;
  x[d2] = rotl2(x[d2] ^ x[a2], 8);
  x[c2] = x[c2] + x[d2] | 0;
  x[b] = rotl2(x[b] ^ x[c2], 7);
}
function chachaRound(x, rounds = 20) {
  for (let r2 = 0; r2 < rounds; r2 += 2) {
    chachaQR(x, 0, 4, 8, 12);
    chachaQR(x, 1, 5, 9, 13);
    chachaQR(x, 2, 6, 10, 14);
    chachaQR(x, 3, 7, 11, 15);
    chachaQR(x, 0, 5, 10, 15);
    chachaQR(x, 1, 6, 11, 12);
    chachaQR(x, 2, 7, 8, 13);
    chachaQR(x, 3, 4, 9, 14);
  }
}
var ctmp = /* @__PURE__ */ new Uint32Array(16);
function chacha(s2, k, i2, out, isHChacha = true, rounds = 20) {
  const y = Uint32Array.from([
    s2[0],
    s2[1],
    s2[2],
    s2[3],
    // "expa"   "nd 3"  "2-by"  "te k"
    k[0],
    k[1],
    k[2],
    k[3],
    // Key      Key     Key     Key
    k[4],
    k[5],
    k[6],
    k[7],
    // Key      Key     Key     Key
    i2[0],
    i2[1],
    i2[2],
    i2[3]
    // Counter  Counter Nonce   Nonce
  ]);
  const x = ctmp;
  x.set(y);
  chachaRound(x, rounds);
  if (isHChacha) {
    const xindexes = [0, 1, 2, 3, 12, 13, 14, 15];
    for (let i3 = 0; i3 < 8; i3++)
      out[i3] = x[xindexes[i3]];
  } else {
    for (let i3 = 0; i3 < 16; i3++)
      out[i3] = y[i3] + x[i3] | 0;
  }
}
var chachaCore_small = (s2, k, n2, out, cnt, rounds) => chacha(s2, k, Uint32Array.from([n2[0], n2[1], cnt, 0]), out, false, rounds);
var hchacha_small = chacha;
function chachaCore(s2, k, n2, out, cnt, rounds = 20) {
  let y00 = s2[0], y01 = s2[1], y02 = s2[2], y03 = s2[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n2[0], y14 = n2[1], y15 = n2[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r2 = 0; r2 < rounds; r2 += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s2, k, i2, out) {
  let x00 = s2[0], x01 = s2[1], x02 = s2[2], x03 = s2[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i2[0], x13 = i2[1], x14 = i2[2], x15 = i2[3];
  for (let r2 = 0; r2 < 20; r2 += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = x00;
  out[oi++] = x01;
  out[oi++] = x02;
  out[oi++] = x03;
  out[oi++] = x12;
  out[oi++] = x13;
  out[oi++] = x14;
  out[oi++] = x15;
}
var chacha20orig = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  allowShortKeys: true
});
var chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
var chacha8 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 8
});
var chacha12 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 12
});
var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
var updatePadded = (h, msg) => {
  h.update(msg);
  const leftover = msg.length % 16;
  if (leftover)
    h.update(ZEROS16.subarray(leftover));
};
var ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
function computeTag(fn, key, nonce, ciphertext, AAD) {
  if (AAD !== void 0)
    abytes2(AAD, void 0, "AAD");
  const authKey = fn(key, nonce, ZEROS32);
  const lengths = u64Lengths(ciphertext.length, AAD ? AAD.length : 0, true);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, ciphertext);
  h.update(lengths);
  const res = h.digest();
  clean2(authKey, lengths);
  return res;
}
var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
  const tagLength = 16;
  return {
    encrypt(plaintext, output) {
      const plength = plaintext.length;
      output = getOutput(plength + tagLength, output, false);
      output.set(plaintext);
      const oPlain = output.subarray(0, -tagLength);
      xorStream(key, nonce, oPlain, oPlain, 1);
      const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
      output.set(tag, plength);
      clean2(tag);
      return output;
    },
    decrypt(ciphertext, output) {
      output = getOutput(ciphertext.length - tagLength, output, false);
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag(xorStream, key, nonce, data, AAD);
      if (!equalBytes2(passedTag, tag))
        throw new Error("invalid tag");
      output.set(ciphertext.subarray(0, -tagLength));
      xorStream(key, nonce, output, output, 1);
      clean2(tag);
      return output;
    }
  };
};
var chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));
var rngChacha20 = /* @__PURE__ */ createPRG(chacha20orig, 64, 32, 8);
var rngChacha8 = /* @__PURE__ */ createPRG(chacha8, 64, 32, 12);

// ../../node_modules/@noble/hashes/hkdf.js
function extract(hash, ikm, salt) {
  ahash(hash);
  if (salt === void 0)
    salt = new Uint8Array(hash.outputLen);
  return hmac(hash, salt, ikm);
}
var HKDF_COUNTER = /* @__PURE__ */ Uint8Array.of(0);
var EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();
function expand(hash, prk, info, length4 = 32) {
  ahash(hash);
  anumber(length4, "length");
  const olen = hash.outputLen;
  if (length4 > 255 * olen)
    throw new Error("Length must be <= 255*HashLen");
  const blocks = Math.ceil(length4 / olen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  else
    abytes(info, void 0, "info");
  const okm = new Uint8Array(blocks * olen);
  const HMAC = hmac.create(hash, prk);
  const HMACTmp = HMAC._cloneInto();
  const T = new Uint8Array(HMAC.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, olen * counter);
    HMAC._cloneInto(HMACTmp);
  }
  HMAC.destroy();
  HMACTmp.destroy();
  clean(T, HKDF_COUNTER);
  return okm.slice(0, length4);
}
var hkdf = (hash, ikm, salt, info, length4) => expand(hash, extract(hash, ikm, salt), info, length4);

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/crypto/js.js
var pureJsCrypto = {
  hashSHA256(data) {
    return sha2562(data.subarray());
  },
  getHKDF(ck, ikm) {
    const prk = extract(sha2562, ikm, ck);
    const okmU8Array = expand(sha2562, prk, void 0, 96);
    const okm = okmU8Array;
    const k1 = okm.subarray(0, 32);
    const k2 = okm.subarray(32, 64);
    const k3 = okm.subarray(64, 96);
    return [k1, k2, k3];
  },
  generateX25519KeyPair() {
    const secretKey = x25519.utils.randomSecretKey();
    const publicKey2 = x25519.getPublicKey(secretKey);
    return {
      publicKey: publicKey2,
      privateKey: secretKey
    };
  },
  generateX25519KeyPairFromSeed(seed) {
    const publicKey2 = x25519.getPublicKey(seed);
    return {
      publicKey: publicKey2,
      privateKey: seed
    };
  },
  generateX25519SharedKey(privateKey, publicKey2) {
    return x25519.getSharedSecret(privateKey.subarray(), publicKey2.subarray());
  },
  chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
    return chacha20poly1305(k, nonce, ad).encrypt(plaintext.subarray());
  },
  chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
    return chacha20poly1305(k, nonce, ad).decrypt(ciphertext.subarray(), dst);
  }
};

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/crypto/index.browser.js
var defaultCrypto = pureJsCrypto;

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js
function wrapCrypto(crypto2) {
  return {
    generateKeypair: crypto2.generateX25519KeyPair,
    dh: (keypair, publicKey2) => crypto2.generateX25519SharedKey(keypair.privateKey, publicKey2).subarray(0, 32),
    encrypt: crypto2.chaCha20Poly1305Encrypt,
    decrypt: crypto2.chaCha20Poly1305Decrypt,
    hash: crypto2.hashSHA256,
    hkdf: crypto2.getHKDF
  };
}

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
var uint16BEEncode = (value2) => {
  const target = allocUnsafe(2);
  target[0] = value2 >> 8;
  target[1] = value2;
  return target;
};
uint16BEEncode.bytes = 2;
var uint16BEDecode = (data) => {
  if (data.length < 2) {
    throw RangeError("Could not decode int16BE");
  }
  if (data instanceof Uint8Array) {
    let value2 = 0;
    value2 += data[0] << 8;
    value2 += data[1];
    return value2;
  }
  return data.getUint16(0);
};
uint16BEDecode.bytes = 2;

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/metrics.js
function registerMetrics(metrics) {
  return {
    xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
      help: "Total count of noise xxHandshakes successes_"
    }),
    xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
      help: "Total count of noise xxHandshakes errors"
    }),
    encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
      help: "Total count of noise encrypted packets successfully"
    }),
    decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
      help: "Total count of noise decrypted packets"
    }),
    decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
      help: "Total count of noise decrypt errors"
    })
  };
}

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
function logLocalStaticKeys(s2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (s2) {
    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString2(s2.publicKey, "hex")}`);
    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString2(s2.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local static keys.");
  }
}
function logLocalEphemeralKeys(e2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (e2) {
    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString2(e2.publicKey, "hex")}`);
    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString2(e2.privateKey, "hex")}`);
  } else {
    keyLogger("Missing local ephemeral keys.");
  }
}
function logRemoteStaticKey(rs, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (rs) {
    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString2(rs.subarray(), "hex")}`);
  } else {
    keyLogger("Missing remote static public key.");
  }
}
function logRemoteEphemeralKey(re, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  if (re) {
    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString2(re.subarray(), "hex")}`);
  } else {
    keyLogger("Missing remote ephemeral keys.");
  }
}
function logCipherState(cs1, cs2, keyLogger) {
  if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
    return;
  }
  keyLogger(`CIPHER_STATE_1 ${cs1.n.getUint64()} ${cs1.k && toString2(cs1.k, "hex")}`);
  keyLogger(`CIPHER_STATE_2 ${cs2.n.getUint64()} ${cs2.k && toString2(cs2.k, "hex")}`);
}

// ../../node_modules/uint8arrays/dist/src/xor.js
function xor(a2, b) {
  if (a2.length !== b.length) {
    throw new Error("Inputs should have the same length");
  }
  const result = allocUnsafe(a2.length);
  for (let i2 = 0; i2 < a2.length; i2++) {
    result[i2] = a2[i2] ^ b[i2];
  }
  return asUint8Array(result);
}

// ../../node_modules/uint8arrays/dist/src/compare.js
function compare2(a2, b) {
  for (let i2 = 0; i2 < a2.byteLength; i2++) {
    if (a2[i2] < b[i2]) {
      return -1;
    }
    if (a2[i2] > b[i2]) {
      return 1;
    }
  }
  if (a2.byteLength > b.byteLength) {
    return 1;
  }
  if (a2.byteLength < b.byteLength) {
    return -1;
  }
  return 0;
}

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/errors.js
var _InvalidCryptoExchangeError = class _InvalidCryptoExchangeError extends Error {
  constructor(message2 = "Invalid crypto exchange") {
    super(message2);
    __publicField(this, "code");
    this.code = _InvalidCryptoExchangeError.code;
  }
};
__publicField(_InvalidCryptoExchangeError, "code", "ERR_INVALID_CRYPTO_EXCHANGE");
var InvalidCryptoExchangeError4 = _InvalidCryptoExchangeError;

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js
var MIN_NONCE = 0;
var MAX_NONCE = 4294967295;
var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
var Nonce = class {
  constructor(n2 = MIN_NONCE) {
    __publicField(this, "n");
    __publicField(this, "bytes");
    __publicField(this, "view");
    this.n = n2;
    this.bytes = alloc(12);
    this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
    this.view.setUint32(4, n2, true);
  }
  increment() {
    this.n++;
    this.view.setUint32(4, this.n, true);
  }
  getBytes() {
    return this.bytes;
  }
  getUint64() {
    return this.n;
  }
  assertValue() {
    if (this.n > MAX_NONCE) {
      throw new Error(ERR_MAX_NONCE);
    }
  }
};

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/protocol.js
var ZEROLEN = alloc(0);
var CipherState = class {
  constructor(crypto2, k = void 0, n2 = 0) {
    __publicField(this, "k");
    __publicField(this, "n");
    __publicField(this, "crypto");
    this.crypto = crypto2;
    this.k = k;
    this.n = new Nonce(n2);
  }
  hasKey() {
    return Boolean(this.k);
  }
  encryptWithAd(ad, plaintext) {
    if (!this.hasKey()) {
      return plaintext;
    }
    this.n.assertValue();
    const e2 = this.crypto.encrypt(plaintext, this.n.getBytes(), ad, this.k);
    this.n.increment();
    return e2;
  }
  decryptWithAd(ad, ciphertext, dst) {
    if (!this.hasKey()) {
      return ciphertext;
    }
    this.n.assertValue();
    const plaintext = this.crypto.decrypt(ciphertext, this.n.getBytes(), ad, this.k, dst);
    this.n.increment();
    return plaintext;
  }
};
var SymmetricState = class {
  constructor(crypto2, protocolName) {
    __publicField(this, "cs");
    __publicField(this, "ck");
    __publicField(this, "h");
    __publicField(this, "crypto");
    this.crypto = crypto2;
    const protocolNameBytes = fromString2(protocolName, "utf-8");
    this.h = hashProtocolName(crypto2, protocolNameBytes);
    this.ck = this.h;
    this.cs = new CipherState(crypto2);
  }
  mixKey(ikm) {
    const [ck, tempK] = this.crypto.hkdf(this.ck, ikm);
    this.ck = ck;
    this.cs = new CipherState(this.crypto, tempK);
  }
  mixHash(data) {
    this.h = this.crypto.hash(new Uint8ArrayList(this.h, data));
  }
  encryptAndHash(plaintext) {
    const ciphertext = this.cs.encryptWithAd(this.h, plaintext);
    this.mixHash(ciphertext);
    return ciphertext;
  }
  decryptAndHash(ciphertext) {
    const plaintext = this.cs.decryptWithAd(this.h, ciphertext);
    this.mixHash(ciphertext);
    return plaintext;
  }
  split() {
    const [tempK1, tempK2] = this.crypto.hkdf(this.ck, ZEROLEN);
    return [new CipherState(this.crypto, tempK1), new CipherState(this.crypto, tempK2)];
  }
};
var AbstractHandshakeState = class {
  constructor(init) {
    __publicField(this, "ss");
    __publicField(this, "s");
    __publicField(this, "e");
    __publicField(this, "rs");
    __publicField(this, "re");
    __publicField(this, "initiator");
    __publicField(this, "crypto");
    const { crypto: crypto2, protocolName, prologue, initiator, s: s2, e: e2, rs, re } = init;
    this.crypto = crypto2;
    this.ss = new SymmetricState(crypto2, protocolName);
    this.ss.mixHash(prologue);
    this.initiator = initiator;
    this.s = s2;
    this.e = e2;
    this.rs = rs;
    this.re = re;
  }
  writeE() {
    if (this.e) {
      throw new Error("ephemeral keypair is already set");
    }
    const e2 = this.crypto.generateKeypair();
    this.ss.mixHash(e2.publicKey);
    this.e = e2;
    return e2.publicKey;
  }
  writeS() {
    if (!this.s) {
      throw new Error("static keypair is not set");
    }
    return this.ss.encryptAndHash(this.s.publicKey);
  }
  writeEE() {
    if (!this.e) {
      throw new Error("ephemeral keypair is not set");
    }
    if (!this.re) {
      throw new Error("remote ephemeral public key is not set");
    }
    this.ss.mixKey(this.crypto.dh(this.e, this.re));
  }
  writeES() {
    if (this.initiator) {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.rs) {
        throw new Error("remote static public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.rs));
    } else {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.s, this.re));
    }
  }
  writeSE() {
    if (this.initiator) {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.s, this.re));
    } else {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.rs) {
        throw new Error("remote static public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.rs));
    }
  }
  readE(message2, offset = 0) {
    if (this.re) {
      throw new Error("remote ephemeral public key is already set");
    }
    if (message2.byteLength < offset + 32) {
      throw new Error("message is not long enough");
    }
    this.re = message2.sublist(offset, offset + 32);
    this.ss.mixHash(this.re);
  }
  readS(message2, offset = 0) {
    if (this.rs) {
      throw new Error("remote static public key is already set");
    }
    const cipherLength = 32 + (this.ss.cs.hasKey() ? 16 : 0);
    if (message2.byteLength < offset + cipherLength) {
      throw new Error("message is not long enough");
    }
    const temp = message2.sublist(offset, offset + cipherLength);
    this.rs = this.ss.decryptAndHash(temp);
    return cipherLength;
  }
  readEE() {
    this.writeEE();
  }
  readES() {
    this.writeES();
  }
  readSE() {
    this.writeSE();
  }
};
var XXHandshakeState = class extends AbstractHandshakeState {
  // e
  writeMessageA(payload) {
    return new Uint8ArrayList(this.writeE(), this.ss.encryptAndHash(payload));
  }
  // e, ee, s, es
  writeMessageB(payload) {
    const e2 = this.writeE();
    this.writeEE();
    const encS = this.writeS();
    this.writeES();
    return new Uint8ArrayList(e2, encS, this.ss.encryptAndHash(payload));
  }
  // s, se
  writeMessageC(payload) {
    const encS = this.writeS();
    this.writeSE();
    return new Uint8ArrayList(encS, this.ss.encryptAndHash(payload));
  }
  // e
  readMessageA(message2) {
    try {
      this.readE(message2);
      return this.ss.decryptAndHash(message2.sublist(32));
    } catch (e2) {
      throw new InvalidCryptoExchangeError4(`handshake stage 0 validation fail: ${e2.message}`);
    }
  }
  // e, ee, s, es
  readMessageB(message2) {
    try {
      this.readE(message2);
      this.readEE();
      const consumed = this.readS(message2, 32);
      this.readES();
      return this.ss.decryptAndHash(message2.sublist(32 + consumed));
    } catch (e2) {
      throw new InvalidCryptoExchangeError4(`handshake stage 1 validation fail: ${e2.message}`);
    }
  }
  // s, se
  readMessageC(message2) {
    try {
      const consumed = this.readS(message2);
      this.readSE();
      return this.ss.decryptAndHash(message2.sublist(consumed));
    } catch (e2) {
      throw new InvalidCryptoExchangeError4(`handshake stage 2 validation fail: ${e2.message}`);
    }
  }
};
function hashProtocolName(crypto2, protocolName) {
  if (protocolName.length <= 32) {
    const h = alloc(32);
    h.set(protocolName);
    return h;
  } else {
    return crypto2.hash(protocolName);
  }
}

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
var NoiseExtensions;
(function(NoiseExtensions2) {
  let _codec;
  NoiseExtensions2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.webtransportCerthashes != null) {
          for (const value2 of obj.webtransportCerthashes) {
            w.uint32(10);
            w.bytes(value2);
          }
        }
        if (obj.streamMuxers != null) {
          for (const value2 of obj.streamMuxers) {
            w.uint32(18);
            w.string(value2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          webtransportCerthashes: [],
          streamMuxers: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.webtransportCerthashes != null && obj.webtransportCerthashes.length === opts.limits.webtransportCerthashes) {
                throw new MaxLengthError('Decode error - map field "webtransportCerthashes" had too many elements');
              }
              obj.webtransportCerthashes.push(reader.bytes());
              break;
            }
            case 2: {
              if (opts.limits?.streamMuxers != null && obj.streamMuxers.length === opts.limits.streamMuxers) {
                throw new MaxLengthError('Decode error - map field "streamMuxers" had too many elements');
              }
              obj.streamMuxers.push(reader.string());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseExtensions2.encode = (obj) => {
    return encodeMessage(obj, NoiseExtensions2.codec());
  };
  NoiseExtensions2.decode = (buf2, opts) => {
    return decodeMessage(buf2, NoiseExtensions2.codec(), opts);
  };
})(NoiseExtensions || (NoiseExtensions = {}));
var NoiseHandshakePayload;
(function(NoiseHandshakePayload2) {
  let _codec;
  NoiseHandshakePayload2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.identityKey != null && obj.identityKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.identityKey);
        }
        if (obj.identitySig != null && obj.identitySig.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.identitySig);
        }
        if (obj.extensions != null) {
          w.uint32(34);
          NoiseExtensions.codec().encode(obj.extensions, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          identityKey: alloc(0),
          identitySig: alloc(0)
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.identityKey = reader.bytes();
              break;
            }
            case 2: {
              obj.identitySig = reader.bytes();
              break;
            }
            case 4: {
              obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.extensions
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  NoiseHandshakePayload2.encode = (obj) => {
    return encodeMessage(obj, NoiseHandshakePayload2.codec());
  };
  NoiseHandshakePayload2.decode = (buf2, opts) => {
    return decodeMessage(buf2, NoiseHandshakePayload2.codec(), opts);
  };
})(NoiseHandshakePayload || (NoiseHandshakePayload = {}));

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
async function createHandshakePayload(privateKey, staticPublicKey, extensions) {
  const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey));
  return NoiseHandshakePayload.encode({
    identityKey: publicKeyToProtobuf(privateKey.publicKey),
    identitySig,
    extensions
  });
}
async function decodeHandshakePayload(payloadBytes, remoteStaticKey, remoteIdentityKey) {
  try {
    const payload = NoiseHandshakePayload.decode(payloadBytes);
    const publicKey2 = publicKeyFromProtobuf(payload.identityKey);
    if (remoteIdentityKey?.equals(publicKey2) === false) {
      throw new Error(`Payload identity key ${publicKey2} does not match expected remote identity key ${remoteIdentityKey}`);
    }
    if (!remoteStaticKey) {
      throw new Error("Remote static does not exist");
    }
    const signaturePayload = getSignaturePayload(remoteStaticKey);
    if (!await publicKey2.verify(signaturePayload, payload.identitySig)) {
      throw new Error("Invalid payload signature");
    }
    return payload;
  } catch (e2) {
    throw new UnexpectedPeerError2(e2.message);
  }
}
function getSignaturePayload(publicKey2) {
  const prefix = fromString2("noise-libp2p-static-key:");
  if (publicKey2 instanceof Uint8Array) {
    return concat([prefix, publicKey2], prefix.length + publicKey2.length);
  }
  publicKey2.prepend(prefix);
  return publicKey2;
}
var EncryptedMessageStream = class extends AbstractMessageStream {
  constructor(stream, handshake, metrics) {
    super({
      log: stream.log,
      inactivityTimeout: stream.inactivityTimeout,
      maxReadBufferLength: stream.maxReadBufferLength,
      direction: stream.direction
    });
    __publicField(this, "stream");
    __publicField(this, "handshake");
    __publicField(this, "metrics");
    __publicField(this, "decoder");
    this.stream = stream;
    this.handshake = handshake;
    this.metrics = metrics;
    this.decoder = new LengthPrefixedDecoder({
      lengthDecoder: uint16BEDecode,
      maxBufferSize: 16 * 1024 * 1024,
      encodingLength: () => 2
    });
    const noiseOnMessageDecrypt = (evt) => {
      try {
        for (const buf2 of this.decoder.decode(evt.data)) {
          this.onData(this.decrypt(buf2));
        }
      } catch (err) {
        this.abort(err);
      }
    };
    this.stream.addEventListener("message", noiseOnMessageDecrypt);
    const noiseOnClose = (evt) => {
      if (evt.error != null) {
        if (evt.local === true) {
          this.abort(evt.error);
        } else {
          this.onRemoteReset();
        }
      } else {
        this.onTransportClosed();
      }
    };
    this.stream.addEventListener("close", noiseOnClose);
    const noiseOnDrain = () => {
      this.safeDispatchEvent("drain");
    };
    this.stream.addEventListener("drain", noiseOnDrain);
    const noiseOnRemoteCloseWrite = () => {
      this.onRemoteCloseWrite();
    };
    this.stream.addEventListener("remoteCloseWrite", noiseOnRemoteCloseWrite);
  }
  encrypt(chunk) {
    const output = new Uint8ArrayList();
    for (let i2 = 0; i2 < chunk.byteLength; i2 += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
      let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
      if (end > chunk.byteLength) {
        end = chunk.byteLength;
      }
      let data;
      if (chunk instanceof Uint8Array) {
        data = this.handshake.encrypt(chunk.subarray(i2, end));
      } else {
        data = this.handshake.encrypt(chunk.sublist(i2, end));
      }
      this.metrics?.encryptedPackets.increment();
      output.append(uint16BEEncode(data.byteLength));
      output.append(data);
    }
    return output;
  }
  decrypt(chunk) {
    const output = new Uint8ArrayList();
    for (let i2 = 0; i2 < chunk.byteLength; i2 += NOISE_MSG_MAX_LENGTH_BYTES) {
      let end = i2 + NOISE_MSG_MAX_LENGTH_BYTES;
      if (end > chunk.byteLength) {
        end = chunk.byteLength;
      }
      if (end - CHACHA_TAG_LENGTH < i2) {
        throw new Error("Invalid chunk");
      }
      let encrypted;
      if (chunk instanceof Uint8Array) {
        encrypted = chunk.subarray(i2, end);
      } else {
        encrypted = chunk.sublist(i2, end);
      }
      const dst = chunk.subarray(i2, end - CHACHA_TAG_LENGTH);
      try {
        const plaintext = this.handshake.decrypt(encrypted, dst);
        this.metrics?.decryptedPackets.increment();
        output.append(plaintext);
      } catch (e2) {
        this.metrics?.decryptErrors.increment();
        throw e2;
      }
    }
    return output;
  }
  close(options2) {
    return this.stream.close(options2);
  }
  sendPause() {
    this.stream.pause();
  }
  sendResume() {
    this.stream.resume();
  }
  sendReset(err) {
    this.stream.abort(err);
  }
  sendData(data) {
    return {
      sentBytes: data.byteLength,
      canSendMore: this.stream.send(this.encrypt(data))
    };
  }
};
function toMessageStream(connection, handshake, metrics) {
  return new EncryptedMessageStream(connection, handshake, metrics);
}

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/performHandshake.js
async function performHandshakeInitiator(init, options2) {
  const { log: log4, connection, crypto: crypto2, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init;
  const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
  const xx = new XXHandshakeState({
    crypto: crypto2,
    protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
    initiator: true,
    prologue,
    s: s2
  });
  logLocalStaticKeys(xx.s, log4);
  log4.trace("Stage 0 - Initiator starting to send first message.");
  await connection.write(xx.writeMessageA(ZEROLEN), options2);
  log4.trace("Stage 0 - Initiator finished sending first message.");
  logLocalEphemeralKeys(xx.e, log4);
  log4.trace("Stage 1 - Initiator waiting to receive first message from responder...");
  const plaintext = xx.readMessageB(await connection.read(options2));
  log4.trace("Stage 1 - Initiator received the message.");
  logRemoteEphemeralKey(xx.re, log4);
  logRemoteStaticKey(xx.rs, log4);
  log4.trace("Initiator going to check remote's signature...");
  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
  log4.trace("All good with the signature!");
  log4.trace("Stage 2 - Initiator sending third handshake message.");
  await connection.write(xx.writeMessageC(payload), options2);
  log4.trace("Stage 2 - Initiator sent message with signed payload.");
  const [cs1, cs2] = xx.ss.split();
  logCipherState(cs1, cs2, log4);
  return {
    payload: receivedPayload,
    encrypt: (plaintext2) => cs1.encryptWithAd(ZEROLEN, plaintext2),
    decrypt: (ciphertext, dst) => cs2.decryptWithAd(ZEROLEN, ciphertext, dst)
  };
}
async function performHandshakeResponder(init, options2) {
  const { log: log4, connection, crypto: crypto2, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init;
  const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
  const xx = new XXHandshakeState({
    crypto: crypto2,
    protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
    initiator: false,
    prologue,
    s: s2
  });
  logLocalStaticKeys(xx.s, log4);
  log4.trace("Stage 0 - Responder waiting to receive first message.");
  xx.readMessageA(await connection.read(options2));
  log4.trace("Stage 0 - Responder received first message.");
  logRemoteEphemeralKey(xx.re, log4);
  log4.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
  await connection.write(xx.writeMessageB(payload), options2);
  log4.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
  logLocalEphemeralKeys(xx.e, log4);
  log4.trace("Stage 2 - Responder waiting for third handshake message...");
  const plaintext = xx.readMessageC(await connection.read(options2));
  log4.trace("Stage 2 - Responder received the message, finished handshake.");
  const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
  const [cs1, cs2] = xx.ss.split();
  logCipherState(cs1, cs2, log4);
  return {
    payload: receivedPayload,
    encrypt: (plaintext2) => cs2.encryptWithAd(ZEROLEN, plaintext2),
    decrypt: (ciphertext, dst) => cs1.decryptWithAd(ZEROLEN, ciphertext, dst)
  };
}

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
var _a8, _b5;
_b5 = Symbol.toStringTag, _a8 = serviceCapabilities2;
var Noise = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol", "/noise");
    __publicField(this, "crypto");
    __publicField(this, "prologue");
    __publicField(this, "staticKey");
    __publicField(this, "extensions");
    __publicField(this, "metrics");
    __publicField(this, "components");
    __publicField(this, "log");
    __publicField(this, _b5, "@chainsafe/libp2p-noise");
    __publicField(this, _a8, [
      "@libp2p/connection-encryption",
      "@chainsafe/libp2p-noise"
    ]);
    const { staticNoiseKey, extensions, crypto: crypto2, prologueBytes } = init;
    const { metrics } = components;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:noise");
    const _crypto = crypto2 ?? defaultCrypto;
    this.crypto = wrapCrypto(_crypto);
    this.extensions = {
      webtransportCerthashes: [],
      ...extensions
    };
    this.metrics = metrics ? registerMetrics(metrics) : void 0;
    if (staticNoiseKey) {
      this.staticKey = _crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
    } else {
      this.staticKey = _crypto.generateX25519KeyPair();
    }
    this.prologue = prologueBytes ?? alloc(0);
  }
  /**
   * Encrypt outgoing data to the remote party (handshake as initiator)
   *
   * @param connection - streaming iterable duplex that will be encrypted
   * @param options
   * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
   * @param options.signal - Used to abort the operation
   */
  async secureOutbound(connection, options2) {
    const log4 = connection.log?.newScope("noise") ?? this.log;
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake = await this.performHandshakeInitiator(wrappedConnection, this.components.privateKey, log4, options2?.remotePeer?.publicKey, options2);
    const publicKey2 = publicKeyFromProtobuf(handshake.payload.identityKey);
    return {
      connection: toMessageStream(wrappedConnection.unwrap(), handshake, this.metrics),
      remoteExtensions: handshake.payload.extensions,
      remotePeer: peerIdFromPublicKey3(publicKey2),
      streamMuxer: options2?.skipStreamMuxerNegotiation === true ? void 0 : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)
    };
  }
  getStreamMuxer(protocols) {
    if (protocols == null || protocols.length === 0) {
      return;
    }
    const streamMuxers = this.components.upgrader.getStreamMuxers();
    if (streamMuxers != null) {
      for (const protocol2 of protocols) {
        const streamMuxer = streamMuxers.get(protocol2);
        if (streamMuxer != null) {
          return streamMuxer;
        }
      }
    }
    if (protocols.length) {
      throw new InvalidCryptoExchangeError2("Early muxer negotiation was requested but the initiator and responder had no common muxers");
    }
  }
  /**
   * Decrypt incoming data (handshake as responder).
   *
   * @param connection - streaming iterable duplex that will be encrypted
   * @param options
   * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
   * @param options.signal - Used to abort the operation
   */
  async secureInbound(connection, options2) {
    const log4 = connection.log?.newScope("noise") ?? this.log;
    const wrappedConnection = lpStream(connection, {
      lengthEncoder: uint16BEEncode,
      lengthDecoder: uint16BEDecode,
      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
    });
    const handshake = await this.performHandshakeResponder(wrappedConnection, this.components.privateKey, log4, options2?.remotePeer?.publicKey, options2);
    const publicKey2 = publicKeyFromProtobuf(handshake.payload.identityKey);
    return {
      connection: toMessageStream(wrappedConnection.unwrap(), handshake, this.metrics),
      remoteExtensions: handshake.payload.extensions,
      remotePeer: peerIdFromPublicKey3(publicKey2),
      streamMuxer: options2?.skipStreamMuxerNegotiation === true ? void 0 : this.getStreamMuxer(handshake.payload.extensions?.streamMuxers)
    };
  }
  /**
   * Perform XX handshake as initiator.
   */
  async performHandshakeInitiator(connection, privateKey, log4, remoteIdentityKey, options2) {
    let result;
    const streamMuxers = options2?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
    try {
      result = await performHandshakeInitiator({
        connection,
        privateKey,
        remoteIdentityKey,
        log: log4.newScope("xxhandshake"),
        crypto: this.crypto,
        prologue: this.prologue,
        s: this.staticKey,
        extensions: {
          streamMuxers,
          webtransportCerthashes: [],
          ...this.extensions
        }
      }, options2);
      this.metrics?.xxHandshakeSuccesses.increment();
    } catch (e2) {
      this.metrics?.xxHandshakeErrors.increment();
      throw e2;
    }
    return result;
  }
  /**
   * Perform XX handshake as responder.
   */
  async performHandshakeResponder(connection, privateKey, log4, remoteIdentityKey, options2) {
    let result;
    const streamMuxers = options2?.skipStreamMuxerNegotiation === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
    try {
      result = await performHandshakeResponder({
        connection,
        privateKey,
        remoteIdentityKey,
        log: log4.newScope("xxhandshake"),
        crypto: this.crypto,
        prologue: this.prologue,
        s: this.staticKey,
        extensions: {
          streamMuxers,
          webtransportCerthashes: [],
          ...this.extensions
        }
      }, options2);
      this.metrics?.xxHandshakeSuccesses.increment();
    } catch (e2) {
      this.metrics?.xxHandshakeErrors.increment();
      throw e2;
    }
    return result;
  }
};

// ../../node_modules/@chainsafe/libp2p-noise/dist/src/index.js
function noise(init = {}) {
  return (components) => new Noise(components, init);
}

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/frame.js
var FrameType;
(function(FrameType2) {
  FrameType2[FrameType2["Data"] = 0] = "Data";
  FrameType2[FrameType2["WindowUpdate"] = 1] = "WindowUpdate";
  FrameType2[FrameType2["Ping"] = 2] = "Ping";
  FrameType2[FrameType2["GoAway"] = 3] = "GoAway";
})(FrameType || (FrameType = {}));
var Flag;
(function(Flag2) {
  Flag2[Flag2["SYN"] = 1] = "SYN";
  Flag2[Flag2["ACK"] = 2] = "ACK";
  Flag2[Flag2["FIN"] = 4] = "FIN";
  Flag2[Flag2["RST"] = 8] = "RST";
})(Flag || (Flag = {}));
var flagCodes = Object.values(Flag).filter((x) => typeof x !== "string");
var YAMUX_VERSION = 0;
var GoAwayCode;
(function(GoAwayCode2) {
  GoAwayCode2[GoAwayCode2["NormalTermination"] = 0] = "NormalTermination";
  GoAwayCode2[GoAwayCode2["ProtocolError"] = 1] = "ProtocolError";
  GoAwayCode2[GoAwayCode2["InternalError"] = 2] = "InternalError";
})(GoAwayCode || (GoAwayCode = {}));
var HEADER_LENGTH = 12;
function stringifyHeader(header) {
  const flags = flagCodes.filter((f2) => (header.flag & f2) === f2).map((f2) => Flag[f2]).join("|");
  return `streamID=${header.streamID} type=${FrameType[header.type]} flag=${flags} length=${header.length}`;
}

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/errors.js
var ProtocolError4 = class extends Error {
  constructor(message2, reason) {
    super(message2);
    __publicField(this, "reason");
    this.name = "ProtocolError";
    this.reason = reason;
  }
};
__publicField(ProtocolError4, "name", "ProtocolError");
function isProtocolError(err) {
  return err?.reason !== null;
}
var InvalidFrameError = class extends ProtocolError4 {
  constructor(message2 = "The frame was invalid") {
    super(message2, GoAwayCode.ProtocolError);
    this.name = "InvalidFrameError";
  }
};
__publicField(InvalidFrameError, "name", "InvalidFrameError");
var UnRequestedPingError = class extends ProtocolError4 {
  constructor(message2 = "Un-requested ping error") {
    super(message2, GoAwayCode.ProtocolError);
    this.name = "UnRequestedPingError";
  }
};
__publicField(UnRequestedPingError, "name", "UnRequestedPingError");
var NotMatchingPingError = class extends ProtocolError4 {
  constructor(message2 = "Not matching ping error") {
    super(message2, GoAwayCode.ProtocolError);
    this.name = "NotMatchingPingError";
  }
};
__publicField(NotMatchingPingError, "name", "NotMatchingPingError");
var InvalidStateError = class extends Error {
  constructor(message2 = "Invalid state") {
    super(message2);
    this.name = "InvalidStateError";
  }
};
__publicField(InvalidStateError, "name", "InvalidStateError");
var StreamAlreadyExistsError = class extends ProtocolError4 {
  constructor(message2 = "Stream already exists") {
    super(message2, GoAwayCode.ProtocolError);
    this.name = "StreamAlreadyExistsError";
  }
};
__publicField(StreamAlreadyExistsError, "name", "StreamAlreadyExistsError");
var DecodeInvalidVersionError = class extends ProtocolError4 {
  constructor(message2 = "Decode invalid version") {
    super(message2, GoAwayCode.ProtocolError);
    this.name = "DecodeInvalidVersionError";
  }
};
__publicField(DecodeInvalidVersionError, "name", "DecodeInvalidVersionError");
var BothClientsError = class extends ProtocolError4 {
  constructor(message2 = "Both clients") {
    super(message2, GoAwayCode.ProtocolError);
    this.name = "BothClientsError";
  }
};
__publicField(BothClientsError, "name", "BothClientsError");
var ReceiveWindowExceededError = class extends ProtocolError4 {
  constructor(message2 = "Receive window exceeded") {
    super(message2, GoAwayCode.ProtocolError);
    this.name = "ReceiveWindowExceededError";
  }
};
__publicField(ReceiveWindowExceededError, "name", "ReceiveWindowExceededError");

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/constants.js
var PROTOCOL_ERRORS = /* @__PURE__ */ new Set([
  InvalidFrameError.name,
  UnRequestedPingError.name,
  NotMatchingPingError.name,
  StreamAlreadyExistsError.name,
  DecodeInvalidVersionError.name,
  BothClientsError.name,
  ReceiveWindowExceededError.name
]);
var INITIAL_STREAM_WINDOW = 256 * 1024;
var MAX_STREAM_WINDOW = 16 * 1024 * 1024;

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/config.js
var defaultConfig = {
  enableKeepAlive: true,
  keepAliveInterval: 3e4,
  maxInboundStreams: 1e3,
  maxOutboundStreams: 1e3,
  maxMessageSize: 64 * 1024,
  maxEarlyStreams: 10,
  streamOptions: {
    initialStreamWindowSize: INITIAL_STREAM_WINDOW,
    maxStreamWindowSize: MAX_STREAM_WINDOW,
    inactivityTimeout: 12e4,
    maxReadBufferLength: 4194304,
    maxWriteBufferLength: Infinity
  }
};
function verifyConfig(config) {
  if (config.keepAliveInterval != null && config.keepAliveInterval <= 0) {
    throw new InvalidParametersError2("keep-alive interval must be positive");
  }
  if (config.maxInboundStreams != null && config.maxInboundStreams < 0) {
    throw new InvalidParametersError2("max inbound streams must be larger or equal 0");
  }
  if (config.maxOutboundStreams != null && config.maxOutboundStreams < 0) {
    throw new InvalidParametersError2("max outbound streams must be larger or equal 0");
  }
  if (config.maxMessageSize != null && config.maxMessageSize < 1024) {
    throw new InvalidParametersError2("MaxMessageSize must be greater than a kilobyte");
  }
  if (config.streamOptions?.initialStreamWindowSize != null && config.streamOptions?.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {
    throw new InvalidParametersError2("InitialStreamWindowSize must be larger or equal 256 kB");
  }
  if (config.streamOptions?.maxStreamWindowSize != null && config.streamOptions?.initialStreamWindowSize != null && config.streamOptions?.maxStreamWindowSize < config.streamOptions?.initialStreamWindowSize) {
    throw new InvalidParametersError2("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");
  }
  if (config.streamOptions?.maxStreamWindowSize != null && config.streamOptions?.maxStreamWindowSize > 2 ** 32 - 1) {
    throw new InvalidParametersError2("MaxStreamWindowSize must be less than equal MAX_UINT32");
  }
}

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/decode.js
function isDataFrame(frame) {
  return frame.header.type === FrameType.Data && frame.data !== null;
}
var twoPow24 = 2 ** 24;
function decodeHeader(data) {
  if (data[0] !== YAMUX_VERSION) {
    throw new InvalidFrameError("Invalid frame version");
  }
  return {
    type: data[1],
    flag: (data[2] << 8) + data[3],
    streamID: data[4] * twoPow24 + (data[5] << 16) + (data[6] << 8) + data[7],
    length: data[8] * twoPow24 + (data[9] << 16) + (data[10] << 8) + data[11]
  };
}
var Decoder2 = class {
  constructor() {
    /** Buffer for in-progress frames */
    __publicField(this, "buffer");
    this.buffer = new Uint8ArrayList();
  }
  /**
   * Emits frames from the decoder source.
   *
   * Note: If `readData` is emitted, it _must_ be called before the next iteration
   * Otherwise an error is thrown
   */
  *emitFrames(buf2) {
    this.buffer.append(buf2);
    while (true) {
      const frame = this.readFrame();
      if (frame === void 0) {
        break;
      }
      yield frame;
    }
  }
  readFrame() {
    let frameSize = HEADER_LENGTH;
    if (this.buffer.byteLength < HEADER_LENGTH) {
      return;
    }
    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH));
    if (header.type === FrameType.Data) {
      frameSize += header.length;
      if (this.buffer.byteLength < frameSize) {
        return;
      }
      const data = this.buffer.sublist(HEADER_LENGTH, frameSize);
      this.buffer.consume(frameSize);
      return { header, data };
    }
    this.buffer.consume(frameSize);
    return { header };
  }
};

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/encode.js
function encodeHeader(header) {
  const frame = new Uint8Array(HEADER_LENGTH);
  frame[1] = header.type;
  frame[2] = header.flag >>> 8;
  frame[3] = header.flag;
  frame[4] = header.streamID >>> 24;
  frame[5] = header.streamID >>> 16;
  frame[6] = header.streamID >>> 8;
  frame[7] = header.streamID;
  frame[8] = header.length >>> 24;
  frame[9] = header.length >>> 16;
  frame[10] = header.length >>> 8;
  frame[11] = header.length;
  return frame;
}

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/stream.js
var StreamState;
(function(StreamState2) {
  StreamState2[StreamState2["Init"] = 0] = "Init";
  StreamState2[StreamState2["SYNSent"] = 1] = "SYNSent";
  StreamState2[StreamState2["SYNReceived"] = 2] = "SYNReceived";
  StreamState2[StreamState2["Established"] = 3] = "Established";
  StreamState2[StreamState2["Finished"] = 4] = "Finished";
  StreamState2[StreamState2["Paused"] = 5] = "Paused";
})(StreamState || (StreamState = {}));
var YamuxStream = class extends AbstractStream {
  constructor(init) {
    const initialWindowSize = init.initialStreamWindowSize ?? INITIAL_STREAM_WINDOW;
    super({
      ...init,
      maxMessageSize: initialWindowSize - HEADER_LENGTH
    });
    __publicField(this, "streamId");
    __publicField(this, "state");
    /** The number of available bytes to send */
    __publicField(this, "sendWindowCapacity");
    /** The number of bytes available to receive in a full window */
    __publicField(this, "recvWindow");
    /** The number of available bytes to receive */
    __publicField(this, "recvWindowCapacity");
    __publicField(this, "maxStreamWindowSize");
    /**
     * An 'epoch' is the time it takes to process and read data
     *
     * Used in conjunction with RTT to determine whether to increase the recvWindow
     */
    __publicField(this, "epochStart");
    __publicField(this, "getRTT");
    __publicField(this, "sendFrame");
    this.streamId = init.streamId;
    this.state = init.state;
    this.sendWindowCapacity = initialWindowSize;
    this.recvWindow = initialWindowSize;
    this.recvWindowCapacity = this.recvWindow;
    this.maxStreamWindowSize = init.maxStreamWindowSize ?? MAX_STREAM_WINDOW;
    this.epochStart = Date.now();
    this.getRTT = init.getRTT;
    this.sendFrame = init.sendFrame;
    const setStateToFinishedOnCloseListener = () => {
      this.state = StreamState.Finished;
    };
    this.addEventListener("close", setStateToFinishedOnCloseListener);
  }
  /**
   * Send a data message to the remote muxer
   */
  sendData(buf2) {
    const totalBytes = buf2.byteLength;
    let sentBytes = 0;
    let canSendMore = true;
    this.log?.trace("send window capacity is %d bytes", this.sendWindowCapacity);
    while (buf2.byteLength > 0) {
      if (this.sendWindowCapacity === 0) {
        canSendMore = false;
        this.log?.trace("sent %d/%d bytes, exhausted send window, waiting for window update", sentBytes, totalBytes);
        break;
      }
      const toSend = Math.min(this.sendWindowCapacity, buf2.byteLength);
      const flags = this.getSendFlags();
      const data = buf2.sublist(0, toSend);
      buf2.consume(toSend);
      const muxerSendMore = this.sendFrame({
        type: FrameType.Data,
        flag: flags,
        streamID: this.streamId,
        length: toSend
      }, data);
      this.sendWindowCapacity -= toSend;
      sentBytes += toSend;
      if (!muxerSendMore) {
        canSendMore = muxerSendMore;
        this.log.trace("sent %d/%d bytes, wait for muxer to have more send capacity", sentBytes, totalBytes);
        break;
      }
    }
    return {
      sentBytes,
      canSendMore
    };
  }
  /**
   * Send a reset message to the remote muxer
   */
  sendReset() {
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: Flag.RST,
      streamID: this.streamId,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be sent by this end of the stream
   */
  async sendCloseWrite() {
    const flags = this.getSendFlags() | Flag.FIN;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this.streamId,
      length: 0
    });
  }
  /**
   * Send a message to the remote muxer, informing them no more data messages
   * will be read by this end of the stream - this is a no-op on Yamux streams
   */
  async sendCloseRead(options2) {
    options2?.signal?.throwIfAborted();
  }
  /**
   * Stop sending window updates temporarily - in the interim the the remote
   * send window will exhaust and the remote will stop sending data
   */
  sendPause() {
    this.state = StreamState.Paused;
  }
  /**
   * Start sending window updates as normal
   */
  sendResume() {
    this.state = StreamState.Established;
    this.sendWindowUpdate();
  }
  /**
   * handleWindowUpdate is called when the stream receives a window update frame
   */
  handleWindowUpdate(frame) {
    this.processFlags(frame.header.flag);
    this.sendWindowCapacity += frame.header.length;
    this.maxMessageSize = this.sendWindowCapacity - HEADER_LENGTH;
    if (this.maxMessageSize < 0) {
      this.maxMessageSize = 0;
    }
    if (this.maxMessageSize === 0) {
      return;
    }
    if (this.writeBuffer.byteLength > 0) {
      this.log?.trace("window update of %d bytes allows more data to be sent, have %d bytes queued, sending data %s", frame.header.length, this.writeBuffer.byteLength, this.sendingData);
      this.safeDispatchEvent("drain");
    }
  }
  /**
   * handleData is called when the stream receives a data frame
   */
  handleData(frame) {
    if (!isDataFrame(frame)) {
      throw new InvalidFrameError("Frame was not data frame");
    }
    this.processFlags(frame.header.flag);
    if (this.recvWindowCapacity < frame.header.length) {
      throw new ReceiveWindowExceededError("Receive window exceeded");
    }
    this.recvWindowCapacity -= frame.header.length;
    this.onData(frame.data);
    this.sendWindowUpdate();
  }
  /**
   * processFlags is used to update the state of the stream based on set flags, if any.
   */
  processFlags(flags) {
    if ((flags & Flag.ACK) === Flag.ACK) {
      if (this.state === StreamState.SYNSent) {
        this.state = StreamState.Established;
      }
    }
    if ((flags & Flag.FIN) === Flag.FIN) {
      this.onRemoteCloseWrite();
    }
    if ((flags & Flag.RST) === Flag.RST) {
      this.onRemoteReset();
    }
  }
  /**
   * getSendFlags determines any flags that are appropriate
   * based on the current stream state.
   *
   * The state is updated as a side-effect.
   */
  getSendFlags() {
    switch (this.state) {
      case StreamState.Init:
        this.state = StreamState.SYNSent;
        return Flag.SYN;
      case StreamState.SYNReceived:
        this.state = StreamState.Established;
        return Flag.ACK;
      default:
        return 0;
    }
  }
  /**
   * Potentially sends a window update enabling further remote writes to take
   * place.
   */
  sendWindowUpdate() {
    if (this.state === StreamState.Paused) {
      this.epochStart = Date.now();
      return;
    }
    const flags = this.getSendFlags();
    const now = Date.now();
    const rtt = this.getRTT();
    if (flags === 0 && rtt > -1 && now - this.epochStart <= rtt * 4) {
      this.recvWindow = Math.min(this.recvWindow * 2, this.maxStreamWindowSize);
    }
    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {
      return;
    }
    const delta = this.recvWindow - this.recvWindowCapacity;
    this.recvWindowCapacity = this.recvWindow;
    this.epochStart = now;
    this.sendFrame({
      type: FrameType.WindowUpdate,
      flag: flags,
      streamID: this.streamId,
      length: delta
    });
  }
};

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js
var _a9, _b6;
function debugFrame(header) {
  return {
    type: FrameType[header.type],
    flags: [
      (header.flag & Flag.SYN) === Flag.SYN ? "SYN" : void 0,
      (header.flag & Flag.ACK) === Flag.ACK ? "ACK" : void 0,
      (header.flag & Flag.FIN) === Flag.FIN ? "FIN" : void 0,
      (header.flag & Flag.RST) === Flag.RST ? "RST" : void 0
    ].filter(Boolean),
    streamID: header.streamID,
    length: header.length
  };
}
var YAMUX_PROTOCOL_ID = "/yamux/1.0.0";
_b6 = Symbol.toStringTag, _a9 = serviceCapabilities2;
var Yamux = class {
  constructor(init = {}) {
    __publicField(this, "protocol", YAMUX_PROTOCOL_ID);
    __publicField(this, "_init");
    __publicField(this, _b6, "@chainsafe/libp2p-yamux");
    __publicField(this, _a9, [
      "@libp2p/stream-multiplexing"
    ]);
    this._init = init;
  }
  createStreamMuxer(maConn) {
    return new YamuxMuxer(maConn, {
      ...this._init
    });
  }
};
var YamuxMuxer = class extends AbstractStreamMuxer {
  constructor(maConn, init = {}) {
    super(maConn, {
      ...init,
      protocol: YAMUX_PROTOCOL_ID,
      name: "yamux"
    });
    /** The next stream id to be used when initiating a new stream */
    __publicField(this, "nextStreamID");
    /** The next ping id to be used when pinging */
    __publicField(this, "nextPingID");
    /** Tracking info for the currently active ping */
    __publicField(this, "activePing");
    /** Round trip time */
    __publicField(this, "rtt");
    /** True if client, false if server */
    __publicField(this, "client");
    __publicField(this, "localGoAway");
    __publicField(this, "remoteGoAway");
    /** Number of tracked inbound streams */
    __publicField(this, "numInboundStreams");
    /** Number of tracked outbound streams */
    __publicField(this, "numOutboundStreams");
    __publicField(this, "decoder");
    __publicField(this, "keepAlive");
    __publicField(this, "enableKeepAlive");
    __publicField(this, "keepAliveInterval");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    this.client = maConn.direction === "outbound";
    verifyConfig(init);
    this.enableKeepAlive = init.enableKeepAlive ?? defaultConfig.enableKeepAlive;
    this.keepAliveInterval = init.keepAliveInterval ?? defaultConfig.keepAliveInterval;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultConfig.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultConfig.maxOutboundStreams;
    this.decoder = new Decoder2();
    this.numInboundStreams = 0;
    this.numOutboundStreams = 0;
    this.nextStreamID = this.client ? 1 : 2;
    this.nextPingID = 0;
    this.rtt = -1;
    this.log.trace("muxer created");
    if (this.enableKeepAlive) {
      this.log.trace("muxer keepalive enabled interval=%s", this.keepAliveInterval);
      this.keepAlive = repeatingTask(async (options2) => {
        try {
          await this.ping(options2);
        } catch (err) {
          this.log.error("ping error: %s", err);
        }
      }, this.keepAliveInterval, {
        // send an initial ping to establish RTT
        runImmediately: true
      });
      this.keepAlive.start();
    }
  }
  onData(buf2) {
    for (const frame of this.decoder.emitFrames(buf2)) {
      this.handleFrame(frame);
    }
  }
  onCreateStream() {
    if (this.remoteGoAway !== void 0) {
      throw new MuxerClosedError2("Muxer closed remotely");
    }
    if (this.localGoAway !== void 0) {
      throw new MuxerClosedError2("Muxer closed locally");
    }
    const id = this.nextStreamID;
    this.nextStreamID += 2;
    if (this.numOutboundStreams >= this.maxOutboundStreams) {
      throw new TooManyOutboundProtocolStreamsError2("max outbound streams exceeded");
    }
    this.log.trace("new outgoing stream id=%s", id);
    const stream = this._newStream(id, StreamState.Init, "outbound");
    this.numOutboundStreams++;
    queueMicrotask(() => {
      stream.sendWindowUpdate();
    });
    return stream;
  }
  /**
   * Initiate a ping and wait for a response
   *
   * Note: only a single ping will be initiated at a time.
   * If a ping is already in progress, a new ping will not be initiated.
   *
   * @returns the round-trip-time in milliseconds
   */
  async ping(options2) {
    if (this.remoteGoAway !== void 0) {
      throw new MuxerClosedError2("Muxer closed remotely");
    }
    if (this.localGoAway !== void 0) {
      throw new MuxerClosedError2("Muxer closed locally");
    }
    if (this.activePing != null) {
      return raceSignal(this.activePing.promise, options2?.signal);
    }
    this.activePing = Object.assign(Promise.withResolvers(), {
      id: this.nextPingID++,
      start: Date.now()
    });
    this.sendPing(this.activePing.id);
    try {
      this.rtt = await raceSignal(this.activePing.promise, options2?.signal);
    } finally {
      this.activePing = void 0;
    }
    return this.rtt;
  }
  /**
   * Get the ping round trip time
   *
   * Note: Will return 0 if no successful ping has yet been completed
   *
   * @returns the round-trip-time in milliseconds
   */
  getRTT() {
    return this.rtt;
  }
  /**
   * Close the muxer
   */
  async close(options2 = {}) {
    if (this.status !== "open") {
      return;
    }
    try {
      const reason = options2?.reason ?? GoAwayCode.NormalTermination;
      this.log.trace("muxer close reason=%s", GoAwayCode[reason]);
      await super.close(options2);
      this.sendGoAway(reason);
    } finally {
      this.keepAlive?.stop();
    }
  }
  abort(err) {
    if (this.status !== "open") {
      return;
    }
    try {
      super.abort(err);
      let reason = GoAwayCode.InternalError;
      if (isProtocolError(err)) {
        reason = err.reason;
      }
      this.log.error("muxer abort reason=%s error=%s", reason, err);
      this.sendGoAway(reason);
    } finally {
      this.keepAlive?.stop();
    }
  }
  onTransportClosed() {
    try {
      super.onTransportClosed();
    } finally {
      this.keepAlive?.stop();
    }
  }
  /** Create a new stream */
  _newStream(streamId2, state, direction) {
    if (this.streams.find((s2) => s2.streamId === streamId2) != null) {
      throw new InvalidParametersError2("Stream already exists with that id");
    }
    const stream = new YamuxStream({
      ...this.streamOptions,
      id: `${streamId2}`,
      streamId: streamId2,
      state,
      direction,
      sendFrame: this.sendFrame.bind(this),
      log: this.log.newScope(`${direction}:${streamId2}`),
      getRTT: this.getRTT.bind(this)
    });
    stream.addEventListener("close", () => {
      this.closeStream(streamId2);
    }, {
      once: true
    });
    return stream;
  }
  /**
   * closeStream is used to close a stream once both sides have
   * issued a close.
   */
  closeStream(id) {
    if (this.client === (id % 2 === 0)) {
      this.numInboundStreams--;
    } else {
      this.numOutboundStreams--;
    }
  }
  handleFrame(frame) {
    const { streamID, type, length: length4 } = frame.header;
    this.log.trace("received frame %o", debugFrame(frame.header));
    if (streamID === 0) {
      switch (type) {
        case FrameType.Ping: {
          this.handlePing(frame.header);
          return;
        }
        case FrameType.GoAway: {
          this.handleGoAway(length4);
          return;
        }
        default:
          throw new InvalidFrameError("Invalid frame type");
      }
    } else {
      switch (frame.header.type) {
        case FrameType.Data:
        case FrameType.WindowUpdate: {
          this.handleStreamMessage(frame);
          return;
        }
        default:
          throw new InvalidFrameError("Invalid frame type");
      }
    }
  }
  handlePing(header) {
    if (header.flag === Flag.SYN) {
      this.log.trace("received ping request pingId=%s", header.length);
      this.sendPing(header.length, Flag.ACK);
    } else if (header.flag === Flag.ACK) {
      this.log.trace("received ping response pingId=%s", header.length);
      this.handlePingResponse(header.length);
    } else {
      throw new InvalidFrameError("Invalid frame flag");
    }
  }
  handlePingResponse(pingId) {
    if (this.activePing === void 0) {
      throw new UnRequestedPingError("ping not requested");
    }
    if (this.activePing.id !== pingId) {
      throw new NotMatchingPingError("ping doesn't match our id");
    }
    this.activePing.resolve(Date.now() - this.activePing.start);
  }
  handleGoAway(reason) {
    this.log.trace("received GoAway reason=%s", GoAwayCode[reason] ?? "unknown");
    this.remoteGoAway = reason;
    if (reason === GoAwayCode.NormalTermination) {
      this.onTransportClosed();
    } else {
      this.abort(new Error("Remote sent GoAway"));
    }
  }
  handleStreamMessage(frame) {
    const { streamID, flag, type } = frame.header;
    if ((flag & Flag.SYN) === Flag.SYN) {
      this.incomingStream(streamID);
    }
    const stream = this.streams.find((s2) => s2.streamId === streamID);
    if (stream === void 0) {
      this.log.trace("frame for missing stream id=%s", streamID);
      return;
    }
    switch (type) {
      case FrameType.WindowUpdate: {
        stream.handleWindowUpdate(frame);
        return;
      }
      case FrameType.Data: {
        stream.handleData(frame);
        return;
      }
      default:
        throw new Error("unreachable");
    }
  }
  incomingStream(id) {
    if (this.client !== (id % 2 === 0)) {
      throw new InvalidParametersError2("Both endpoints are clients");
    }
    if (this.streams.find((s2) => s2.streamId === id)) {
      return;
    }
    this.log.trace("new incoming stream id=%s", id);
    if (this.localGoAway !== void 0) {
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    if (this.numInboundStreams >= this.maxInboundStreams) {
      this.log("maxIncomingStreams exceeded, forcing stream reset");
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: id,
        length: 0
      });
      return;
    }
    const stream = this._newStream(id, StreamState.SYNReceived, "inbound");
    this.numInboundStreams++;
    this.onRemoteStream(stream);
  }
  sendFrame(header, data) {
    let encoded;
    if (header.type === FrameType.Data) {
      if (data == null) {
        throw new InvalidFrameError("Invalid frame");
      }
      encoded = new Uint8ArrayList(encodeHeader(header), data);
    } else {
      encoded = encodeHeader(header);
    }
    this.log.trace("sending frame %o", debugFrame(header));
    return this.send(encoded);
  }
  sendPing(pingId, flag = Flag.SYN) {
    if (flag === Flag.SYN) {
      this.log.trace("sending ping request pingId=%s", pingId);
    } else {
      this.log.trace("sending ping response pingId=%s", pingId);
    }
    this.sendFrame({
      type: FrameType.Ping,
      flag,
      streamID: 0,
      length: pingId
    });
  }
  sendGoAway(reason = GoAwayCode.NormalTermination) {
    this.log("sending GoAway reason=%s", GoAwayCode[reason]);
    this.localGoAway = reason;
    this.sendFrame({
      type: FrameType.GoAway,
      flag: 0,
      streamID: 0,
      length: reason
    });
  }
};

// ../../node_modules/@chainsafe/libp2p-yamux/dist/src/index.js
function yamux(init = {}) {
  return () => new Yamux(init);
}

// ../../node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
var code4 = (code5) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component == null) {
        return false;
      }
      if (component.code !== code5) {
        return false;
      }
      if (component.value != null) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var value = (code5, value2) => {
  return {
    match: (vals) => {
      const component = vals[0];
      if (component?.code !== code5) {
        return false;
      }
      if (component.value == null) {
        return false;
      }
      if (value2 != null && component.value !== value2) {
        return false;
      }
      return vals.slice(1);
    }
  };
};
var not = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return false;
    }
  };
};
var optional = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    }
  };
};
var or2 = (...matchers) => {
  return {
    match: (vals) => {
      let matches2;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches2 == null || result.length < matches2.length) {
          matches2 = result;
        }
      }
      if (matches2 == null) {
        return false;
      }
      return matches2;
    }
  };
};
var and = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    }
  };
};
function fmt(...matchers) {
  function match(ma) {
    if (ma == null) {
      return false;
    }
    let parts = ma.getComponents();
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches2(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matchers,
    matches: matches2,
    exactMatch
  };
}

// ../../node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var _PEER_ID = value(CODE_P2P2);
var PEER_ID = fmt(_PEER_ID);
var _DNS4 = value(CODE_DNS42);
var _DNS6 = value(CODE_DNS62);
var _DNSADDR = value(CODE_DNSADDR2);
var _DNS = value(CODE_DNS2);
var DNS4 = fmt(_DNS4, optional(value(CODE_P2P2)));
var DNS6 = fmt(_DNS6, optional(value(CODE_P2P2)));
var DNSADDR = fmt(_DNSADDR, optional(value(CODE_P2P2)));
var DNS = fmt(or2(_DNS, _DNSADDR, _DNS4, _DNS6), optional(value(CODE_P2P2)));
var _IP4 = and(value(CODE_IP42), optional(value(CODE_IPCIDR2)));
var _IP6 = and(optional(value(CODE_IP6ZONE2)), value(CODE_IP62), optional(value(CODE_IPCIDR2)));
var _IP = or2(_IP4, _IP6);
var _IP_OR_DOMAIN = or2(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
var IP_OR_DOMAIN = fmt(or2(_IP, and(or2(_DNS, _DNSADDR, _DNS4, _DNS6), optional(value(CODE_P2P2)))));
var IP4 = fmt(_IP4);
var IP6 = fmt(_IP6);
var IP = fmt(_IP);
var _TCP = and(_IP_OR_DOMAIN, value(CODE_TCP2));
var _UDP = and(_IP_OR_DOMAIN, value(CODE_UDP2));
var TCP = fmt(and(_TCP, optional(value(CODE_P2P2))));
var UDP = fmt(_UDP);
var _QUIC = and(_UDP, code4(CODE_QUIC2), optional(value(CODE_P2P2)));
var _QUIC_V1 = and(_UDP, code4(CODE_QUIC_V12), optional(value(CODE_P2P2)));
var QUIC_V0_OR_V1 = or2(_QUIC, _QUIC_V1);
var QUIC = fmt(_QUIC);
var QUIC_V1 = fmt(_QUIC_V1);
var _WEB = or2(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUIC_V1);
var _WebSockets = or2(and(_WEB, code4(CODE_WS2), optional(value(CODE_P2P2))));
var WebSockets = fmt(_WebSockets);
var _WebSocketsSecure = or2(and(_WEB, code4(CODE_WSS2), optional(value(CODE_P2P2))), and(_WEB, code4(CODE_TLS2), optional(value(CODE_SNI2)), code4(CODE_WS2), optional(value(CODE_P2P2))));
var WebSocketsSecure = fmt(_WebSocketsSecure);
var _WebRTCDirect = and(_UDP, code4(CODE_WEBRTC_DIRECT2), optional(value(CODE_CERTHASH2)), optional(value(CODE_CERTHASH2)), optional(value(CODE_P2P2)));
var WebRTCDirect = fmt(_WebRTCDirect);
var _WebTransport = and(_QUIC_V1, code4(CODE_WEBTRANSPORT2), optional(value(CODE_CERTHASH2)), optional(value(CODE_CERTHASH2)), optional(value(CODE_P2P2)));
var WebTransport = fmt(_WebTransport);
var _P2P = or2(_WebSockets, _WebSocketsSecure, and(_TCP, optional(value(CODE_P2P2))), and(QUIC_V0_OR_V1, optional(value(CODE_P2P2))), and(_IP_OR_DOMAIN, optional(value(CODE_P2P2))), _WebRTCDirect, _WebTransport, value(CODE_P2P2));
var P2P = fmt(_P2P);
var _Circuit = and(optional(_P2P), code4(CODE_P2P_CIRCUIT2), not(code4(CODE_WEBRTC2)), optional(value(CODE_P2P2)));
var Circuit = fmt(_Circuit);
var _WebRTC = or2(and(_P2P, code4(CODE_P2P_CIRCUIT2), code4(CODE_WEBRTC2), optional(value(CODE_P2P2))), and(_P2P, code4(CODE_WEBRTC2), optional(value(CODE_P2P2))), and(code4(CODE_WEBRTC2), optional(value(CODE_P2P2))));
var WebRTC = fmt(_WebRTC);
var _HTTP = or2(and(_IP_OR_DOMAIN, value(CODE_TCP2), code4(CODE_HTTP2), optional(value(CODE_P2P2))), and(_IP_OR_DOMAIN, code4(CODE_HTTP2), optional(value(CODE_P2P2))));
var HTTP = fmt(_HTTP);
var _HTTPS = and(_IP_OR_DOMAIN, or2(and(value(CODE_TCP2, "443"), code4(CODE_HTTP2)), and(value(CODE_TCP2), code4(CODE_HTTPS2)), and(value(CODE_TCP2), code4(CODE_TLS2), code4(CODE_HTTP2)), and(code4(CODE_TLS2), code4(CODE_HTTP2)), code4(CODE_TLS2), code4(CODE_HTTPS2)), optional(value(CODE_P2P2)));
var HTTPS = fmt(_HTTPS);
var _Memory = or2(and(value(CODE_MEMORY2), optional(value(CODE_P2P2))));
var Memory = fmt(_Memory);
var _Unix = or2(and(value(CODE_UNIX2), optional(value(CODE_P2P2))));
var Unix = fmt(_Unix);

// ../../node_modules/@libp2p/bootstrap/dist/src/index.js
var _a10, _b7, _c5, _d2;
var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
var DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
var Bootstrap = class extends (_d2 = TypedEventEmitter, _c5 = peerDiscoverySymbol, _b7 = Symbol.toStringTag, _a10 = serviceCapabilities2, _d2) {
  constructor(components, options2 = { list: [] }) {
    if (options2.list == null || options2.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    __publicField(this, "log");
    __publicField(this, "timer");
    __publicField(this, "list");
    __publicField(this, "timeout");
    __publicField(this, "components");
    __publicField(this, "_init");
    __publicField(this, _c5, this);
    __publicField(this, _b7, "@libp2p/bootstrap");
    __publicField(this, _a10, [
      "@libp2p/peer-discovery"
    ]);
    this.components = components;
    this.log = components.logger.forComponent("libp2p:bootstrap");
    this.timeout = options2.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
    this.list = options2.list.map((str) => multiaddr(str)).filter((ma) => {
      if (!P2P.matches(ma)) {
        this.log.error("invalid multiaddr %a", ma);
        return false;
      }
      const peerIdStr = ma.getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value;
      if (peerIdStr == null) {
        this.log.error("invalid bootstrap multiaddr without peer id");
        return false;
      }
      return true;
    }).map((ma) => {
      return {
        id: peerIdFromString3(ma.getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value ?? ""),
        multiaddrs: [ma]
      };
    });
    this._init = options2;
  }
  isStarted() {
    return Boolean(this.timer);
  }
  /**
   * Start emitting events
   */
  start() {
    if (this.isStarted()) {
      return;
    }
    this.log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
    this.timer = setTimeout(() => {
      void this._discoverBootstrapPeers().catch((err) => {
        this.log.error("failed to discover bootstrap peers - %e", err);
      });
    }, this.timeout);
  }
  /**
   * Emit each address in the list as a PeerInfo
   */
  async _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    for (const peerData of this.list) {
      await this.components.peerStore.merge(peerData.id, {
        tags: {
          [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
            value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
            ttl: this._init.tagTTL
          }
        },
        multiaddrs: peerData.multiaddrs
      });
      if (this.timer == null) {
        return;
      }
      this.safeDispatchEvent("peer", { detail: peerData });
      this.components.connectionManager.openConnection(peerData.id).catch((err) => {
        this.log.error("could not dial bootstrap peer %p - %e", peerData.id, err);
      });
    }
  }
  /**
   * Stop emitting events
   */
  stop() {
    if (this.timer != null) {
      clearTimeout(this.timer);
    }
    this.timer = void 0;
  }
};
__publicField(Bootstrap, "tag", "bootstrap");
function bootstrap(init) {
  return (components) => new Bootstrap(components, init);
}

// ../../node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope;
(function(Envelope3) {
  let _codec;
  Envelope3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.payload);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          publicKey: alloc(0),
          payloadType: alloc(0),
          payload: alloc(0),
          signature: alloc(0)
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = reader.bytes();
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope3.encode = (obj) => {
    return encodeMessage(obj, Envelope3.codec());
  };
  Envelope3.decode = (buf2, opts) => {
    return decodeMessage(buf2, Envelope3.codec(), opts);
  };
})(Envelope || (Envelope = {}));

// ../../node_modules/@libp2p/peer-record/dist/src/envelope/errors.js
var InvalidSignatureError = class extends Error {
  constructor(message2 = "Invalid signature") {
    super(message2);
    this.name = "InvalidSignatureError";
  }
};

// ../../node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var _RecordEnvelope = class _RecordEnvelope {
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(init) {
    __publicField(this, "publicKey");
    __publicField(this, "payloadType");
    __publicField(this, "payload");
    __publicField(this, "signature");
    __publicField(this, "marshaled");
    const { publicKey: publicKey2, payloadType, payload, signature } = init;
    this.publicKey = publicKey2;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = Envelope.encode({
        publicKey: publicKeyToProtobuf(this.publicKey),
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(other) {
    if (other == null) {
      return false;
    }
    return equals3(this.marshal(), other.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(domain, options2) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    return this.publicKey.verify(signData.subarray(), this.signature, options2);
  }
};
/**
 * Unmarshal a serialized Envelope protobuf message
 */
__publicField(_RecordEnvelope, "createFromProtobuf", (data) => {
  const envelopeData = Envelope.decode(data);
  const publicKey2 = publicKeyFromProtobuf(envelopeData.publicKey);
  return new _RecordEnvelope({
    publicKey: publicKey2,
    payloadType: envelopeData.payloadType,
    payload: envelopeData.payload,
    signature: envelopeData.signature
  });
});
/**
 * Seal marshals the given Record, places the marshaled bytes inside an Envelope
 * and signs it with the given peerId's private key
 */
__publicField(_RecordEnvelope, "seal", async (record, privateKey, options2) => {
  if (privateKey == null) {
    throw new Error("Missing private key");
  }
  const domain = record.domain;
  const payloadType = record.codec;
  const payload = record.marshal();
  const signData = formatSignaturePayload(domain, payloadType, payload);
  const signature = await privateKey.sign(signData.subarray(), options2);
  return new _RecordEnvelope({
    publicKey: privateKey.publicKey,
    payloadType,
    payload,
    signature
  });
});
/**
 * Open and certify a given marshaled envelope.
 * Data is unmarshaled and the signature validated for the given domain.
 */
__publicField(_RecordEnvelope, "openAndCertify", async (data, domain, options2) => {
  const envelope = _RecordEnvelope.createFromProtobuf(data);
  const valid = await envelope.validate(domain, options2);
  if (!valid) {
    throw new InvalidSignatureError("Envelope signature is not valid for the given domain");
  }
  return envelope;
});
var RecordEnvelope = _RecordEnvelope;
var formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString2(domain);
  const domainLength = encode7(domainUint8Array.byteLength);
  const payloadTypeLength = encode7(payloadType.length);
  const payloadLength = encode7(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};

// ../../node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

// ../../node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord;
(function(PeerRecord3) {
  let AddressInfo;
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            multiaddr: alloc(0)
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.multiaddr = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf2, opts) => {
      return decodeMessage(buf2, AddressInfo2.codec(), opts);
    };
  })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
  let _codec;
  PeerRecord3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.peerId != null && obj.peerId.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.peerId);
        }
        if (obj.seq != null && obj.seq !== 0n) {
          w.uint32(16);
          w.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value2 of obj.addresses) {
            w.uint32(26);
            PeerRecord3.AddressInfo.codec().encode(value2, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          peerId: alloc(0),
          seq: 0n,
          addresses: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.peerId = reader.bytes();
              break;
            }
            case 2: {
              obj.seq = reader.uint64();
              break;
            }
            case 3: {
              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.addresses$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord3.encode = (obj) => {
    return encodeMessage(obj, PeerRecord3.codec());
  };
  PeerRecord3.decode = (buf2, opts) => {
    return decodeMessage(buf2, PeerRecord3.codec(), opts);
  };
})(PeerRecord || (PeerRecord = {}));

// ../../node_modules/@libp2p/peer-record/dist/src/peer-record/utils.js
function arrayEquals(a2, b) {
  const sort2 = (a3, b2) => a3.toString().localeCompare(b2.toString());
  if (a2.length !== b.length) {
    return false;
  }
  b.sort(sort2);
  return a2.sort(sort2).every((item, index) => b[index].equals(item));
}

// ../../node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var _PeerRecord = class _PeerRecord {
  constructor(init) {
    __publicField(this, "peerId");
    __publicField(this, "multiaddrs");
    __publicField(this, "seqNumber");
    __publicField(this, "domain", _PeerRecord.DOMAIN);
    __publicField(this, "codec", _PeerRecord.CODEC);
    __publicField(this, "marshaled");
    const { peerId, multiaddrs, seqNumber } = init;
    this.peerId = peerId;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord.encode({
        peerId: this.peerId.toMultihash().bytes,
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m2) => ({
          multiaddr: m2.bytes
        }))
      });
    }
    return this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(other) {
    if (!(other instanceof _PeerRecord)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};
/**
 * Unmarshal Peer Record Protobuf
 */
__publicField(_PeerRecord, "createFromProtobuf", (buf2) => {
  const peerRecord = PeerRecord.decode(buf2);
  const peerId = peerIdFromMultihash3(decode4(peerRecord.peerId));
  const multiaddrs = (peerRecord.addresses ?? []).map((a2) => multiaddr(a2.multiaddr));
  const seqNumber = peerRecord.seq;
  return new _PeerRecord({ peerId, multiaddrs, seqNumber });
});
__publicField(_PeerRecord, "DOMAIN", ENVELOPE_DOMAIN_PEER_RECORD);
__publicField(_PeerRecord, "CODEC", ENVELOPE_PAYLOAD_TYPE_PEER_RECORD);
var PeerRecord2 = _PeerRecord;

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/constants.js
var second2 = 1e3;
var minute2 = 60 * second2;
var DEFAULT_MAX_RESERVATION_STORE_SIZE = 15;
var DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute2;
var DEFAULT_RESERVATION_CONCURRENCY = 1;
var DEFAULT_RESERVATION_COMPLETION_TIMEOUT = 5e3;
var DEFAULT_MAX_RESERVATION_QUEUE_LENGTH = 100;
var RELAY_SOURCE_TAG = "circuit-relay-source";
var KEEP_ALIVE_TAG = `${KEEP_ALIVE}-circuit-relay`;
var DEFAULT_DURATION_LIMIT = 2 * minute2;
var DEFAULT_DATA_LIMIT = BigInt(1 << 17);
var RELAY_V2_HOP_CODEC = "/libp2p/circuit/relay/0.2.0/hop";
var RELAY_V2_STOP_CODEC = "/libp2p/circuit/relay/0.2.0/stop";
var DEFAULT_HOP_TIMEOUT = 30 * second2;
var DEFAULT_ADVERT_BOOT_DELAY = 30 * second2;
var MAX_CONNECTIONS = 300;
var DEFAULT_DISCOVERY_FILTER_SIZE = 4096;
var DEFAULT_DISCOVERY_FILTER_ERROR_RATE = 1e-3;

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/pb/index.js
var HopMessage;
(function(HopMessage2) {
  let Type2;
  (function(Type3) {
    Type3["RESERVE"] = "RESERVE";
    Type3["CONNECT"] = "CONNECT";
    Type3["STATUS"] = "STATUS";
  })(Type2 = HopMessage2.Type || (HopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["RESERVE"] = 0] = "RESERVE";
    __TypeValues2[__TypeValues2["CONNECT"] = 1] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 2] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type3) {
    Type3.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type2 = HopMessage2.Type || (HopMessage2.Type = {}));
  let _codec;
  HopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          HopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer.codec().encode(obj.peer, w);
        }
        if (obj.reservation != null) {
          w.uint32(26);
          Reservation.codec().encode(obj.reservation, w);
        }
        if (obj.limit != null) {
          w.uint32(34);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(40);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {};
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = HopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.peer
              });
              break;
            }
            case 3: {
              obj.reservation = Reservation.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.reservation
              });
              break;
            }
            case 4: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.limit
              });
              break;
            }
            case 5: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HopMessage2.encode = (obj) => {
    return encodeMessage(obj, HopMessage2.codec());
  };
  HopMessage2.decode = (buf2, opts) => {
    return decodeMessage(buf2, HopMessage2.codec(), opts);
  };
})(HopMessage || (HopMessage = {}));
var StopMessage;
(function(StopMessage2) {
  let Type2;
  (function(Type3) {
    Type3["CONNECT"] = "CONNECT";
    Type3["STATUS"] = "STATUS";
  })(Type2 = StopMessage2.Type || (StopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["CONNECT"] = 0] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 1] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type3) {
    Type3.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type2 = StopMessage2.Type || (StopMessage2.Type = {}));
  let _codec;
  StopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          StopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer.codec().encode(obj.peer, w);
        }
        if (obj.limit != null) {
          w.uint32(26);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(32);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {};
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = StopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.peer
              });
              break;
            }
            case 3: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.limit
              });
              break;
            }
            case 4: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  StopMessage2.encode = (obj) => {
    return encodeMessage(obj, StopMessage2.codec());
  };
  StopMessage2.decode = (buf2, opts) => {
    return decodeMessage(buf2, StopMessage2.codec(), opts);
  };
})(StopMessage || (StopMessage = {}));
var Peer;
(function(Peer4) {
  let _codec;
  Peer4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.addrs != null) {
          for (const value2 of obj.addrs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          id: alloc(0),
          addrs: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer4.encode = (obj) => {
    return encodeMessage(obj, Peer4.codec());
  };
  Peer4.decode = (buf2, opts) => {
    return decodeMessage(buf2, Peer4.codec(), opts);
  };
})(Peer || (Peer = {}));
var Reservation;
(function(Reservation2) {
  let _codec;
  Reservation2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.expire != null && obj.expire !== 0n) {
          w.uint32(8);
          w.uint64(obj.expire);
        }
        if (obj.addrs != null) {
          for (const value2 of obj.addrs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (obj.voucher != null) {
          w.uint32(26);
          Envelope2.codec().encode(obj.voucher, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          expire: 0n,
          addrs: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.expire = reader.uint64();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            case 3: {
              obj.voucher = Envelope2.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.voucher
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Reservation2.encode = (obj) => {
    return encodeMessage(obj, Reservation2.codec());
  };
  Reservation2.decode = (buf2, opts) => {
    return decodeMessage(buf2, Reservation2.codec(), opts);
  };
})(Reservation || (Reservation = {}));
var Limit;
(function(Limit2) {
  let _codec;
  Limit2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.duration != null) {
          w.uint32(8);
          w.uint32(obj.duration);
        }
        if (obj.data != null) {
          w.uint32(16);
          w.uint64(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {};
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.duration = reader.uint32();
              break;
            }
            case 2: {
              obj.data = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Limit2.encode = (obj) => {
    return encodeMessage(obj, Limit2.codec());
  };
  Limit2.decode = (buf2, opts) => {
    return decodeMessage(buf2, Limit2.codec(), opts);
  };
})(Limit || (Limit = {}));
var Status;
(function(Status2) {
  Status2["UNUSED"] = "UNUSED";
  Status2["OK"] = "OK";
  Status2["RESERVATION_REFUSED"] = "RESERVATION_REFUSED";
  Status2["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
  Status2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
  Status2["CONNECTION_FAILED"] = "CONNECTION_FAILED";
  Status2["NO_RESERVATION"] = "NO_RESERVATION";
  Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  Status2["UNEXPECTED_MESSAGE"] = "UNEXPECTED_MESSAGE";
})(Status || (Status = {}));
var __StatusValues;
(function(__StatusValues2) {
  __StatusValues2[__StatusValues2["UNUSED"] = 0] = "UNUSED";
  __StatusValues2[__StatusValues2["OK"] = 100] = "OK";
  __StatusValues2[__StatusValues2["RESERVATION_REFUSED"] = 200] = "RESERVATION_REFUSED";
  __StatusValues2[__StatusValues2["RESOURCE_LIMIT_EXCEEDED"] = 201] = "RESOURCE_LIMIT_EXCEEDED";
  __StatusValues2[__StatusValues2["PERMISSION_DENIED"] = 202] = "PERMISSION_DENIED";
  __StatusValues2[__StatusValues2["CONNECTION_FAILED"] = 203] = "CONNECTION_FAILED";
  __StatusValues2[__StatusValues2["NO_RESERVATION"] = 204] = "NO_RESERVATION";
  __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  __StatusValues2[__StatusValues2["UNEXPECTED_MESSAGE"] = 401] = "UNEXPECTED_MESSAGE";
})(__StatusValues || (__StatusValues = {}));
(function(Status2) {
  Status2.codec = () => {
    return enumeration(__StatusValues);
  };
})(Status || (Status = {}));
var ReservationVoucher;
(function(ReservationVoucher2) {
  let _codec;
  ReservationVoucher2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.relay != null && obj.relay.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.relay);
        }
        if (obj.peer != null && obj.peer.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.peer);
        }
        if (obj.expiration != null && obj.expiration !== 0n) {
          w.uint32(24);
          w.uint64(obj.expiration);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          relay: alloc(0),
          peer: alloc(0),
          expiration: 0n
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.relay = reader.bytes();
              break;
            }
            case 2: {
              obj.peer = reader.bytes();
              break;
            }
            case 3: {
              obj.expiration = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ReservationVoucher2.encode = (obj) => {
    return encodeMessage(obj, ReservationVoucher2.codec());
  };
  ReservationVoucher2.decode = (buf2, opts) => {
    return decodeMessage(buf2, ReservationVoucher2.codec(), opts);
  };
})(ReservationVoucher || (ReservationVoucher = {}));
var Envelope2;
(function(Envelope3) {
  let _codec;
  Envelope3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null) {
          w.uint32(26);
          ReservationVoucher.codec().encode(obj.payload, w);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          publicKey: alloc(0),
          payloadType: alloc(0),
          signature: alloc(0)
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = ReservationVoucher.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.payload
              });
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope3.encode = (obj) => {
    return encodeMessage(obj, Envelope3.codec());
  };
  Envelope3.decode = (buf2, opts) => {
    return decodeMessage(buf2, Envelope3.codec(), opts);
  };
})(Envelope2 || (Envelope2 = {}));

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/errors.js
var TransferLimitError = class extends Error {
  constructor(message2 = "Transfer limit error") {
    super(message2);
    this.name = "TransferLimitError";
  }
};
var DurationLimitError = class extends Error {
  constructor(message2 = "Duration limit error") {
    super(message2);
    this.name = "DurationLimitError";
  }
};
var HadEnoughRelaysError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "HadEnoughRelaysError");
  }
};
__publicField(HadEnoughRelaysError, "name", "HadEnoughRelaysError");
var DoubleRelayError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "DoubleRelayError");
  }
};
__publicField(DoubleRelayError, "name", "DoubleRelayError");
var RelayQueueFullError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "RelayQueueFullError");
  }
};
__publicField(RelayQueueFullError, "name", "RelayQueueFullError");

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/utils.js
function countStreamBytes(source, limit, options2) {
  const limitBytes = limit.remaining;
  const abortIfStreamByteLimitExceeded = (evt) => {
    const len = BigInt(evt.data.byteLength);
    limit.remaining -= len;
    if (limit.remaining < 0) {
      source.abort(new TransferLimitError(`data limit of ${limitBytes} bytes exceeded`));
    }
  };
  source.addEventListener("message", abortIfStreamByteLimitExceeded);
}
function createLimitedRelay(src2, dst, abortSignal, reservation, options2) {
  function abortStreams(err) {
    src2.abort(err);
    dst.abort(err);
  }
  const signals = [abortSignal, reservation.signal];
  if (reservation.limit?.duration != null) {
    options2.log("limiting relayed connection duration to %dms", reservation.limit.duration);
    const durationSignal = AbortSignal.timeout(reservation.limit.duration);
    setMaxListeners(Infinity, durationSignal);
    signals.push(durationSignal);
  }
  const signal = anySignal(signals);
  setMaxListeners(Infinity, signal);
  let dataLimit;
  if (reservation.limit?.data != null) {
    dataLimit = {
      remaining: reservation.limit.data
    };
  }
  const onAbort = () => {
    let err;
    if (abortSignal.aborted) {
      err = abortSignal.reason;
    } else {
      err = new DurationLimitError(`duration limit of ${reservation.limit?.duration} ms exceeded`);
    }
    abortStreams(err);
  };
  signal.addEventListener("abort", onAbort, { once: true });
  if (dataLimit != null) {
    countStreamBytes(dst, dataLimit, options2);
    countStreamBytes(src2, dataLimit, options2);
  }
  pipe2(src2, dst, src2).catch((err) => {
    abortStreams(err);
  }).finally(() => {
    signal.clear();
  });
}
async function namespaceToCid(namespace) {
  const bytes = new TextEncoder().encode(namespace);
  const hash = await sha256.digest(bytes);
  return CID.createV0(hash);
}
function getExpirationMilliseconds(expireTimeSeconds) {
  const expireTimeMillis = expireTimeSeconds * BigInt(1e3);
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  return Number(expireTimeMillis - BigInt(currentTime));
}
var LimitTracker = class {
  constructor(limits) {
    __publicField(this, "expires");
    __publicField(this, "bytes");
    if (limits?.duration != null && limits?.duration !== 0) {
      this.expires = Date.now() + limits.duration * 1e3;
    }
    this.bytes = limits?.data;
    if (this.bytes === 0n) {
      this.bytes = void 0;
    }
    this.onData = this.onData.bind(this);
  }
  onData(buf2) {
    if (this.bytes == null) {
      return;
    }
    this.bytes -= BigInt(buf2.byteLength);
    if (this.bytes < 0n) {
      this.bytes = 0n;
    }
  }
  getLimits() {
    if (this.expires == null && this.bytes == null) {
      return;
    }
    const output = {};
    if (this.bytes != null) {
      const self2 = this;
      Object.defineProperty(output, "bytes", {
        get() {
          return self2.bytes;
        }
      });
    }
    if (this.expires != null) {
      const self2 = this;
      Object.defineProperty(output, "seconds", {
        get() {
          return Math.round(((self2.expires ?? 0) - Date.now()) / 1e3);
        }
      });
    }
    return output;
  }
};
var CircuitListen = fmt(and(P2P.matchers[0], code4(CODE_P2P_CIRCUIT2)));
var CircuitSearch = fmt(code4(CODE_P2P_CIRCUIT2));

// ../../node_modules/@libp2p/peer-collections/dist/src/util.js
function mapIterable(iter, map2) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map2(val)
      };
    }
  };
  return iterator;
}
function peerIdFromString4(str) {
  const multihash = decode4(base58btc.decode(`z${str}`));
  return peerIdFromMultihash3(multihash);
}

// ../../node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  constructor(map2) {
    __publicField(this, "map");
    this.map = /* @__PURE__ */ new Map();
    if (map2 != null) {
      for (const [key, value2] of map2.entries()) {
        this.map.set(key.toString(), { key, value: value2 });
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    return this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [val[1].key, val[1].value];
    });
  }
  forEach(fn) {
    this.map.forEach((value2, key) => {
      fn(value2.value, value2.key, this);
    });
  }
  get(peer) {
    return this.map.get(peer.toString())?.value;
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value2) {
    this.map.set(peer.toString(), { key: peer, value: value2 });
  }
  keys() {
    return mapIterable(this.map.values(), (val) => {
      return val.key;
    });
  }
  values() {
    return mapIterable(this.map.values(), (val) => val.value);
  }
  get size() {
    return this.map.size;
  }
};
function peerMap() {
  return new PeerMap();
}

// ../../node_modules/@libp2p/peer-collections/dist/src/set.js
var PeerSet = class _PeerSet {
  constructor(set) {
    __publicField(this, "set");
    this.set = /* @__PURE__ */ new Set();
    if (set != null) {
      for (const key of set) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId = peerIdFromString4(val[0]);
      return [peerId, peerId];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const peerId = peerIdFromString4(str);
      predicate(peerId, peerId, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString4(val);
    });
  }
  intersection(other) {
    const output = new _PeerSet();
    for (const peerId of other) {
      if (this.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  difference(other) {
    const output = new _PeerSet();
    for (const peerId of this) {
      if (!other.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  union(other) {
    const output = new _PeerSet();
    for (const peerId of other) {
      output.add(peerId);
    }
    for (const peerId of this) {
      output.add(peerId);
    }
    return output;
  }
};
function peerSet() {
  return new PeerSet();
}

// ../../node_modules/@libp2p/peer-collections/dist/src/filter.js
var PeerFilter = class {
  constructor(size, errorRate) {
    __publicField(this, "filter");
    this.filter = createScalableCuckooFilter(size, errorRate);
  }
  has(peerId) {
    return this.filter.has(peerId.toMultihash().bytes);
  }
  add(peerId) {
    this.filter.add(peerId.toMultihash().bytes);
  }
  remove(peerId) {
    this.filter.remove?.(peerId.toMultihash().bytes);
  }
};
function peerFilter(size, errorRate = 1e-3) {
  return new PeerFilter(size, errorRate);
}

// ../../node_modules/@libp2p/peer-collections/dist/src/tracked-map.js
var TrackedPeerMap = class extends PeerMap {
  constructor(init) {
    super();
    __publicField(this, "metric");
    const { name: name5, metrics } = init;
    this.metric = metrics.registerMetric(name5);
    this.updateComponentMetric();
  }
  set(key, value2) {
    super.set(key, value2);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedPeerMap(config) {
  const { name: name5, metrics } = config;
  let map2;
  if (metrics != null) {
    map2 = new TrackedPeerMap({ name: name5, metrics });
  } else {
    map2 = new PeerMap();
  }
  return map2;
}

// ../../node_modules/retimeable-signal/dist/src/index.js
var AbortError6 = class extends Error {
  constructor(message2, code5, name5) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.name = name5 ?? "AbortError";
    this.code = code5 ?? "ABORT_ERR";
  }
};
function retimeableSignal(ms, opts) {
  const error = new AbortError6(opts?.errorMessage, opts?.errorCode, opts?.errorName);
  const controller = new AbortController();
  const abortHandler = () => {
    controller.abort(error);
  };
  let signal = AbortSignal.timeout(ms);
  signal.addEventListener("abort", abortHandler);
  const retimerSignal = controller.signal;
  retimerSignal.reset = (newMs) => {
    signal?.removeEventListener("abort", abortHandler);
    signal = AbortSignal.timeout(newMs ?? ms);
    signal.addEventListener("abort", () => {
      controller.abort(error);
    });
  };
  retimerSignal.clear = () => {
    signal?.removeEventListener("abort", abortHandler);
    signal = void 0;
  };
  return retimerSignal;
}

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/server/reservation-store.js
var ReservationStore = class {
  constructor(components, init = {}) {
    __publicField(this, "reservations");
    __publicField(this, "maxReservations");
    __publicField(this, "applyDefaultLimit");
    __publicField(this, "reservationTtl");
    __publicField(this, "defaultDurationLimit");
    __publicField(this, "defaultDataLimit");
    __publicField(this, "log");
    this.log = components.logger.forComponent("libp2p:circuit-relay:server:reservation-store");
    this.maxReservations = init.maxReservations ?? DEFAULT_MAX_RESERVATION_STORE_SIZE;
    this.applyDefaultLimit = init.applyDefaultLimit !== false;
    this.reservationTtl = init.reservationTtl ?? DEFAULT_MAX_RESERVATION_TTL;
    this.defaultDurationLimit = init.defaultDurationLimit ?? DEFAULT_DURATION_LIMIT;
    this.defaultDataLimit = init.defaultDataLimit ?? DEFAULT_DATA_LIMIT;
    this.reservations = trackedPeerMap({
      metrics: components.metrics,
      name: "libp2p_circuit_relay_server_reservations_total"
    });
  }
  reserve(peer, addr, limit) {
    let reservation = this.reservations.get(peer);
    if (this.reservations.size >= this.maxReservations && reservation == null) {
      return { status: Status.RESERVATION_REFUSED };
    }
    const expiry = new Date(Date.now() + this.reservationTtl);
    let checkedLimit;
    if (this.applyDefaultLimit) {
      checkedLimit = limit ?? {
        data: this.defaultDataLimit,
        duration: this.defaultDurationLimit
      };
    }
    if (reservation != null) {
      this.log("refreshing reservation for client %p", peer);
      reservation.signal.reset(this.reservationTtl);
    } else {
      this.log("creating new reservation for client %p", peer);
      reservation = {
        addr,
        expiry,
        limit: checkedLimit,
        signal: retimeableSignal(this.reservationTtl)
      };
    }
    this.reservations.set(peer, reservation);
    reservation.signal.addEventListener("abort", () => {
      this.reservations.delete(peer);
    });
    return { status: Status.OK, expire: Math.round(expiry.getTime() / 1e3) };
  }
  removeReservation(peer) {
    this.reservations.delete(peer);
  }
  get(peer) {
    return this.reservations.get(peer);
  }
  clear() {
    this.reservations.clear();
  }
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/server/reservation-voucher.js
var ReservationVoucherRecord = class _ReservationVoucherRecord {
  constructor({ relay, peer, expiration }) {
    __publicField(this, "domain", "libp2p-relay-rsvp");
    __publicField(this, "codec", new Uint8Array([3, 2]));
    __publicField(this, "relay");
    __publicField(this, "peer");
    __publicField(this, "expiration");
    this.relay = relay;
    this.peer = peer;
    this.expiration = expiration;
  }
  marshal() {
    return ReservationVoucher.encode({
      relay: this.relay.toMultihash().bytes,
      peer: this.peer.toMultihash().bytes,
      expiration: BigInt(this.expiration)
    });
  }
  equals(other) {
    if (!(other instanceof _ReservationVoucherRecord)) {
      return false;
    }
    if (!this.peer.equals(other.peer)) {
      return false;
    }
    if (!this.relay.equals(other.relay)) {
      return false;
    }
    if (this.expiration !== other.expiration) {
      return false;
    }
    return true;
  }
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/server/index.js
var _a11, _b8;
var defaults = {
  maxOutboundStopStreams: MAX_CONNECTIONS
};
var CircuitRelayServer = class extends (_b8 = TypedEventEmitter, _a11 = Symbol.toStringTag, _b8) {
  /**
   * Creates an instance of Relay
   */
  constructor(components, init = {}) {
    super();
    __publicField(this, "components");
    __publicField(this, "reservationStore");
    __publicField(this, "started");
    __publicField(this, "hopTimeout");
    __publicField(this, "shutdownController");
    __publicField(this, "maxInboundHopStreams");
    __publicField(this, "maxOutboundHopStreams");
    __publicField(this, "maxOutboundStopStreams");
    __publicField(this, "log");
    __publicField(this, _a11, "@libp2p/circuit-relay-v2-server");
    this.log = components.logger.forComponent("libp2p:circuit-relay:server");
    this.components = components;
    this.started = false;
    this.hopTimeout = init?.hopTimeout ?? DEFAULT_HOP_TIMEOUT;
    this.maxInboundHopStreams = init.maxInboundHopStreams;
    this.maxOutboundHopStreams = init.maxOutboundHopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
    this.reservationStore = new ReservationStore(components, init.reservations);
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    this.onHop = this.onHop.bind(this);
  }
  isStarted() {
    return this.started;
  }
  /**
   * Start Relay service
   */
  async start() {
    if (this.started) {
      return;
    }
    await this.components.registrar.handle(RELAY_V2_HOP_CODEC, this.onHop, {
      maxInboundStreams: this.maxInboundHopStreams,
      maxOutboundStreams: this.maxOutboundHopStreams,
      runOnLimitedConnection: true
    });
    this.started = true;
  }
  /**
   * Stop Relay service
   */
  async stop() {
    this.reservationStore.clear();
    this.shutdownController.abort();
    await this.components.registrar.unhandle(RELAY_V2_HOP_CODEC);
    this.started = false;
  }
  async onHop(stream, connection) {
    this.log("received circuit v2 hop protocol stream from %p", connection.remotePeer);
    const signal = AbortSignal.timeout(this.hopTimeout);
    setMaxListeners(Infinity, signal);
    const options2 = {
      signal
    };
    const pbstr = pbStream(stream);
    try {
      const request = await pbstr.pb(HopMessage).read(options2);
      if (request?.type == null) {
        throw new Error("request was invalid, could not read from stream");
      }
      this.log("received", request.type);
      await this.handleHopProtocol({
        connection,
        stream: pbstr,
        request
      }, options2);
    } catch (err) {
      this.log.error("error while handling hop - %e", err);
      await pbstr.pb(HopMessage).write({
        type: HopMessage.Type.STATUS,
        status: Status.MALFORMED_MESSAGE
      }, options2);
      stream.abort(err);
    }
  }
  async handleHopProtocol({ stream, request, connection }, options2) {
    this.log("received hop message");
    switch (request.type) {
      case HopMessage.Type.RESERVE:
        await this.handleReserve({ stream, request, connection }, options2);
        break;
      case HopMessage.Type.CONNECT:
        await this.handleConnect({ stream, request, connection }, options2);
        break;
      default: {
        this.log.error("invalid hop request type %s via peer %p", request.type, connection.remotePeer);
        await stream.pb(HopMessage).write({ type: HopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE });
      }
    }
  }
  async handleReserve({ stream, connection }, options2) {
    const hopstr = stream.pb(HopMessage);
    this.log("hop reserve request from %p", connection.remotePeer);
    if (Circuit.exactMatch(connection.remoteAddr)) {
      this.log.error("relay reservation over circuit connection denied for peer: %p", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options2);
      return;
    }
    if (await this.components.connectionGater.denyInboundRelayReservation?.(connection.remotePeer) === true) {
      this.log.error("reservation for %p denied by connection gater", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options2);
      return;
    }
    const result = this.reservationStore.reserve(connection.remotePeer, connection.remoteAddr);
    try {
      if (result.status !== Status.OK) {
        await hopstr.write({ type: HopMessage.Type.STATUS, status: result.status }, options2);
        return;
      }
      if (result.expire != null) {
        const ttl = result.expire * 1e3 - Date.now();
        await this.components.peerStore.merge(connection.remotePeer, {
          tags: {
            [RELAY_SOURCE_TAG]: { value: 1, ttl }
          }
        }, options2);
      }
      await hopstr.write({
        type: HopMessage.Type.STATUS,
        status: Status.OK,
        reservation: await this.makeReservation(connection.remotePeer, BigInt(result.expire ?? 0)),
        limit: this.reservationStore.get(connection.remotePeer)?.limit
      }, options2);
      this.log("sent confirmation response to %s", connection.remotePeer);
      await hopstr.unwrap().unwrap().close(options2);
    } catch (err) {
      this.log.error("failed to send confirmation response to %p - %e", connection.remotePeer, err);
      this.reservationStore.removeReservation(connection.remotePeer);
      try {
        await this.components.peerStore.merge(connection.remotePeer, {
          tags: {
            [RELAY_SOURCE_TAG]: void 0
          }
        }, options2);
      } catch (err2) {
        this.log.error("failed to untag relay source peer %p - %e", connection.remotePeer, err2);
      }
    }
  }
  async makeReservation(remotePeer, expire) {
    const addrs = [];
    for (const relayAddr of this.components.addressManager.getAddresses()) {
      if (relayAddr.toString().includes("/p2p-circuit")) {
        continue;
      }
      addrs.push(relayAddr.bytes);
    }
    const envelope = await RecordEnvelope.seal(new ReservationVoucherRecord({
      peer: remotePeer,
      relay: this.components.peerId,
      expiration: expire
    }), this.components.privateKey);
    return {
      addrs,
      expire,
      voucher: {
        publicKey: publicKeyToProtobuf(envelope.publicKey),
        payloadType: envelope.payloadType,
        payload: {
          peer: remotePeer.toMultihash().bytes,
          relay: this.components.peerId.toMultihash().bytes,
          expiration: expire
        },
        signature: envelope.signature
      }
    };
  }
  async handleConnect({ stream, request, connection }, options2) {
    const hopstr = stream.pb(HopMessage);
    if (Circuit.matches(connection.remoteAddr)) {
      this.log.error("relay reservation over circuit connection denied for peer: %p", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options2);
      return;
    }
    this.log("hop connect request from %p", connection.remotePeer);
    let dstPeer;
    try {
      if (request.peer == null) {
        this.log.error("no peer info in hop connect request");
        throw new Error("no peer info in request");
      }
      request.peer.addrs.forEach(multiaddr);
      dstPeer = peerIdFromMultihash3(decode4(request.peer.id));
    } catch (err) {
      this.log.error("invalid hop connect request via peer %p - %e", connection.remotePeer, err);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, options2);
      return;
    }
    const reservation = this.reservationStore.get(dstPeer);
    if (reservation == null) {
      this.log.error("hop connect denied for destination peer %p not having a reservation for %p with status %s", dstPeer, connection.remotePeer, Status.NO_RESERVATION);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION }, options2);
      return;
    }
    if (await this.components.connectionGater.denyOutboundRelayedConnection?.(connection.remotePeer, dstPeer) === true) {
      this.log.error("hop connect for %p to %p denied by connection gater", connection.remotePeer, dstPeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options2);
      return;
    }
    const connections = this.components.connectionManager.getConnections(dstPeer);
    if (connections.length === 0) {
      this.log("hop connect denied for destination peer %p not having a connection for %p as there is no destination connection", dstPeer, connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION }, options2);
      return;
    }
    const destinationConnection = connections[0];
    const destinationStream = await this.stopHop({
      connection: destinationConnection,
      request: {
        type: StopMessage.Type.CONNECT,
        peer: {
          id: connection.remotePeer.toMultihash().bytes,
          addrs: []
        },
        limit: reservation?.limit
      }
    }, options2);
    if (destinationStream == null) {
      this.log.error("failed to open stream to destination peer %p", destinationConnection?.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.CONNECTION_FAILED }, options2);
      return;
    }
    await hopstr.write({
      type: HopMessage.Type.STATUS,
      status: Status.OK,
      limit: reservation?.limit
    }, options2);
    this.log("connection from %p to %p established - merging streams", connection.remotePeer, dstPeer);
    createLimitedRelay(stream.unwrap(), destinationStream, this.shutdownController.signal, reservation, {
      log: this.log
    });
  }
  /**
   * Send a STOP request to the target peer that the dialing peer wants to contact
   */
  async stopHop({ connection, request }, options2) {
    this.log("starting circuit relay v2 stop request to %s", connection.remotePeer);
    const stream = await connection.newStream(RELAY_V2_STOP_CODEC, {
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnLimitedConnection: true,
      ...options2
    });
    const pbstr = pbStream(stream);
    const stopstr = pbstr.pb(StopMessage);
    await stopstr.write(request, options2);
    let response;
    try {
      response = await stopstr.read(options2);
    } catch (err) {
      this.log.error("error parsing stop message response from %p - %e", connection.remotePeer, err);
    }
    if (response == null) {
      this.log.error("could not read response from %p", connection.remotePeer);
      await stream.close(options2);
      return;
    }
    if (response.status === Status.OK) {
      this.log("stop request to %p was successful", connection.remotePeer);
      return pbstr.unwrap();
    }
    this.log("stop request failed with code %d", response.status);
    await stream.close(options2);
  }
  get reservations() {
    return this.reservationStore.reservations;
  }
};

// ../../node_modules/progress-events/dist/src/index.js
var CustomProgressEvent = class extends Event {
  constructor(type, detail) {
    super(type);
    __publicField(this, "type");
    __publicField(this, "detail");
    this.type = type;
    this.detail = detail;
  }
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/transport/discovery.js
var RelayDiscovery = class extends TypedEventEmitter {
  constructor(components, init = {}) {
    super();
    __publicField(this, "components");
    __publicField(this, "started");
    __publicField(this, "running");
    __publicField(this, "topologyId");
    __publicField(this, "log");
    __publicField(this, "discoveryController");
    __publicField(this, "filter");
    __publicField(this, "queue");
    this.log = components.logger.forComponent("libp2p:circuit-relay:discover-relays");
    this.components = components;
    this.started = false;
    this.running = false;
    this.filter = init.filter;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
    this.dialPeer = this.dialPeer.bind(this);
    this.onPeer = this.onPeer.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.topologyId = await this.components.registrar.register(RELAY_V2_HOP_CODEC, {
      filter: this.filter,
      onConnect: (peerId) => {
        this.log.trace("discovered relay %p queue (length: %d, active %d)", peerId, this.queue?.size, this.queue?.running);
        this.safeDispatchEvent("relay:discover", { detail: peerId });
      }
    });
    this.started = true;
  }
  stop() {
    if (this.topologyId != null) {
      this.components.registrar.unregister(this.topologyId);
    }
    if (this.running) {
      this.stopDiscovery();
    }
    this.started = false;
  }
  /**
   * Try to listen on available hop relay connections.
   * The following order will happen while we do not have enough relays:
   *
   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected to
   * 2. Dial and try to listen on the peers we know that support hop but are not connected
   * 3. Search the network - this requires a peer routing implementation to be configured but will fail gracefully
   * 4. Dial any peers discovered - this covers when no peer routing implementation has been configured but some peer discovery mechanism is also present
   */
  startDiscovery() {
    if (this.running) {
      return;
    }
    this.log("start discovery");
    this.running = true;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
    this.components.events.addEventListener("peer:discovery", this.onPeer);
    Promise.resolve().then(async () => {
      this.log("searching peer store for relays");
      const peers = await this.components.peerStore.all({
        filters: [
          // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
          (peer) => {
            return peer.protocols.includes(RELAY_V2_HOP_CODEC);
          }
        ],
        orders: [
          // randomize
          () => Math.random() < 0.5 ? 1 : -1,
          // prefer peers we've connected to in the past
          (a2, b) => {
            const lastDialA = getLastDial(a2);
            const lastDialB = getLastDial(b);
            if (lastDialA > lastDialB) {
              return -1;
            }
            if (lastDialB > lastDialA) {
              return 1;
            }
            return 0;
          }
        ]
      });
      for (const peer of peers) {
        this.log.trace("found relay peer %p in peer store", peer.id);
        this.safeDispatchEvent("relay:discover", { detail: peer.id });
      }
      this.log("found %d relay peers in peer store", peers.length);
      const queue = this.queue = new PeerQueue({
        concurrency: 5
      });
      this.log("start random walk");
      for await (const peer of this.components.randomWalk.walk({ signal: this.discoveryController.signal })) {
        this.log.trace("found random peer %p", peer.id);
        if (queue.has(peer.id)) {
          this.log.trace("random peer %p was already in queue", peer.id);
          continue;
        }
        if (this.components.connectionManager.getConnections(peer.id)?.length > 0) {
          this.log.trace("random peer %p was already connected", peer.id);
          continue;
        }
        if (!await this.components.connectionManager.isDialable(peer.multiaddrs)) {
          this.log.trace("random peer %p was not dialable", peer.id, peer.multiaddrs.map((ma) => ma.toString()));
          continue;
        }
        if (queue.queued > 10) {
          this.log.trace("wait for space in queue for %p", peer.id);
          await queue.onSizeLessThan(10, {
            signal: this.discoveryController.signal
          });
        }
        this.log("adding random peer %p to dial queue (length: %d, active %d)", peer.id, queue.size, queue.running);
        queue.add(this.dialPeer, {
          peerId: peer.id,
          signal: this.discoveryController.signal
        }).catch((err) => {
          this.log.error("error opening connection to random peer %p - %e", peer.id, err);
        });
      }
      this.log("stop random walk");
      await queue.onIdle();
    }).catch((err) => {
      if (!this.discoveryController.signal.aborted) {
        this.log.error("failed when finding relays on the network - %e", err);
      }
    });
  }
  stopDiscovery() {
    this.log("stop discovery");
    this.running = false;
    this.discoveryController?.abort();
    this.queue?.clear();
    this.components.events.removeEventListener("peer:discovery", this.onPeer);
  }
  onPeer(evt) {
    this.log.trace("maybe dialing discovered peer %p", evt.detail.id);
    this.maybeDialPeer(evt).catch((err) => {
      this.log.trace("error dialing discovered peer %p - %e", evt.detail.id, err);
    });
  }
  async maybeDialPeer(evt) {
    if (this.queue == null) {
      return;
    }
    const peerId = evt.detail.id;
    const multiaddrs = evt.detail.multiaddrs;
    if (this.queue.has(peerId)) {
      this.log.trace("random peer %p was already in queue", peerId);
      return;
    }
    if (this.components.connectionManager.getConnections(peerId)?.length > 0) {
      this.log.trace("random peer %p was already connected", peerId);
      return;
    }
    if (!await this.components.connectionManager.isDialable(multiaddrs)) {
      this.log.trace("random peer %p was not dialable", peerId);
      return;
    }
    this.queue?.add(this.dialPeer, {
      peerId: evt.detail.id,
      signal: this.discoveryController.signal
    }).catch((err) => {
      this.log.error("error opening connection to discovered peer %p - %e", evt.detail.id, err);
    });
  }
  async dialPeer({ peerId, signal }) {
    const combinedSignal = anySignal([AbortSignal.timeout(5e3), signal]);
    setMaxListeners(Infinity, combinedSignal);
    try {
      await this.components.connectionManager.openConnection(peerId, {
        signal: combinedSignal
      });
    } finally {
      combinedSignal.clear();
    }
  }
};
function getLastDial(peer) {
  const lastDial = peer.metadata.get("last-dial-success");
  if (lastDial == null) {
    return 0;
  }
  return new Date(toString2(lastDial)).getTime();
}

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/transport/listener.js
var CircuitRelayTransportListener = class extends TypedEventEmitter {
  constructor(components, init = {}) {
    super();
    __publicField(this, "connectionManager");
    __publicField(this, "addressManager");
    __publicField(this, "reservationStore");
    __publicField(this, "listeningAddrs");
    __publicField(this, "log");
    __publicField(this, "listenTimeout");
    __publicField(this, "reservationId");
    __publicField(this, "relay");
    __publicField(this, "_onRemoveRelayPeer", (evt) => {
      this.log("relay removed %p our relay %p", evt.detail.relay, this.relay, this.relay?.equals(evt.detail.relay));
      if (this.relay?.equals(evt.detail.relay) !== true) {
        return;
      }
      this.log("relay peer removed %p", evt.detail.relay);
      this.listeningAddrs.forEach((ma) => {
        this.addressManager.removeObservedAddr(ma);
      });
      this.listeningAddrs = [];
      this.safeDispatchEvent("listening");
    });
    __publicField(this, "_onAddRelayPeer", (evt) => {
      const { details } = evt.detail;
      if (details.type === "configured") {
        return;
      }
      if (details.id !== this.reservationId) {
        return;
      }
      this.addedRelay(evt.detail);
    });
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:listener");
    this.connectionManager = components.connectionManager;
    this.addressManager = components.addressManager;
    this.reservationStore = components.reservationStore;
    this.listeningAddrs = [];
    this.listenTimeout = init.listenTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.reservationStore.addEventListener("relay:removed", this._onRemoveRelayPeer);
    this.reservationStore.addEventListener("relay:created-reservation", this._onAddRelayPeer);
  }
  async listen(addr) {
    if (CircuitSearch.exactMatch(addr)) {
      this.log("searching for circuit relay servers");
      this.reservationId = this.reservationStore.reserveRelay();
    } else if (CircuitListen.exactMatch(addr)) {
      this.log("listen on specific relay server %a", addr);
      const signal = AbortSignal.timeout(this.listenTimeout);
      setMaxListeners(Infinity, signal);
      const relayAddr = addr.decapsulate("/p2p-circuit");
      const relayConn = await this.connectionManager.openConnection(relayAddr, {
        signal
      });
      if (!this.reservationStore.hasReservation(relayConn.remotePeer)) {
        this.log("making reservation on peer %p", relayConn.remotePeer);
        const reservation = await this.reservationStore.addRelay(relayConn.remotePeer, "configured");
        this.addedRelay(reservation);
      }
    } else {
      throw new ListenError2(`Could not listen on p2p-circuit address "${addr}"`);
    }
  }
  getAddrs() {
    return [...this.listeningAddrs.values()].flat();
  }
  updateAnnounceAddrs() {
  }
  async close() {
    this.reservationStore.cancelReservations();
    this.listeningAddrs = [];
    this.reservationStore.removeEventListener("relay:removed", this._onRemoveRelayPeer);
    queueMicrotask(() => {
      this.safeDispatchEvent("close");
    });
  }
  addedRelay(reservation) {
    this.log("relay peer added %p", reservation.relay);
    this.relay = reservation.relay;
    this.listeningAddrs = reservation.details.reservation.addrs.map((buf2) => multiaddr(buf2).encapsulate("/p2p-circuit"));
    this.listeningAddrs.forEach((ma) => {
      this.addressManager.confirmObservedAddr(ma, {
        type: "transport"
      });
    });
    queueMicrotask(() => {
      this.safeDispatchEvent("listening");
    });
  }
};
function createListener(options2) {
  return new CircuitRelayTransportListener(options2);
}

// ../../node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../../node_modules/nanoid/index.browser.js
var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
var customRandom = (alphabet2, defaultSize, getRandom) => {
  let mask = (2 << Math.log2(alphabet2.length - 1)) - 1;
  let step = -~(1.6 * mask * defaultSize / alphabet2.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let j = step | 0;
      while (j--) {
        id += alphabet2[bytes[j] & mask] || "";
        if (id.length >= size) return id;
      }
    }
  };
};
var customAlphabet = (alphabet2, size = 21) => customRandom(alphabet2, size | 0, random);
var nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/transport/reservation-store.js
var _ReservationStore_instances, createReservation_fn, removeReservation_fn, checkReservationCount_fn;
var REFRESH_WINDOW = 60 * 1e3 * 10;
var REFRESH_TIMEOUT = 60 * 1e3 * 5;
var REFRESH_TIMEOUT_MIN = 30 * 1e3;
var ReservationStore2 = class extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __privateAdd(this, _ReservationStore_instances);
    __publicField(this, "peerId");
    __publicField(this, "connectionManager");
    __publicField(this, "peerStore");
    __publicField(this, "events");
    __publicField(this, "reserveQueue");
    __publicField(this, "reservations");
    __publicField(this, "pendingReservations");
    __publicField(this, "maxReservationQueueLength");
    __publicField(this, "reservationCompletionTimeout");
    __publicField(this, "started");
    __publicField(this, "log");
    __publicField(this, "relayFilter");
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:reservation-store");
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.reservations = new PeerMap();
    this.pendingReservations = [];
    this.maxReservationQueueLength = init?.maxReservationQueueLength ?? DEFAULT_MAX_RESERVATION_QUEUE_LENGTH;
    this.reservationCompletionTimeout = init?.reservationCompletionTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.started = false;
    this.relayFilter = createScalableCuckooFilter(100);
    this.reserveQueue = new PeerQueue({
      concurrency: init?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY,
      metricName: "libp2p_relay_reservation_queue",
      metrics: components.metrics
    });
    this.events.addEventListener("connection:close", (evt) => {
      const reservation = [...this.reservations.values()].find((reservation2) => reservation2.connection === evt.detail.id);
      if (reservation == null) {
        return;
      }
      __privateMethod(this, _ReservationStore_instances, removeReservation_fn).call(this, evt.detail.remotePeer).catch((err) => {
        this.log("could not remove relay %p - %e", evt.detail, err);
      });
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  afterStart() {
    void Promise.resolve().then(async () => {
      const relayPeers = await this.peerStore.all({
        filters: [(peer) => {
          return peer.tags.has(KEEP_ALIVE_TAG);
        }]
      });
      this.log("removing tag from %d old relays", relayPeers.length);
      await Promise.all(relayPeers.map(async (peer) => {
        await this.peerStore.merge(peer.id, {
          tags: {
            [KEEP_ALIVE_TAG]: void 0
          }
        });
      }));
      this.log("redialing %d old relays", relayPeers.length);
      await Promise.all(relayPeers.map(async (peer) => this.addRelay(peer.id, "discovered")));
      __privateMethod(this, _ReservationStore_instances, checkReservationCount_fn).call(this);
    }).catch((err) => {
      this.log.error("failed to clean up and redial old relays during afterStart - %e", err);
    });
  }
  stop() {
    this.reserveQueue.clear();
    this.reservations.forEach(({ timeout }) => {
      clearTimeout(timeout);
    });
    this.reservations.clear();
    this.started = false;
  }
  reserveRelay() {
    const id = nanoid();
    this.pendingReservations.push(id);
    __privateMethod(this, _ReservationStore_instances, checkReservationCount_fn).call(this);
    return id;
  }
  /**
   * If the number of current relays is beneath the configured `maxReservations`
   * value, and the passed peer id is not our own, and we have a non-relayed
   * connection to the remote, and the remote peer speaks the hop protocol, try
   * to reserve a slot on the remote peer
   */
  async addRelay(peerId, type) {
    if (this.peerId.equals(peerId)) {
      this.log.trace("not trying to use self as relay");
      throw new ListenError2("Cannot use self as relay");
    }
    if (this.reserveQueue.size > this.maxReservationQueueLength) {
      throw new RelayQueueFullError("The reservation queue is full");
    }
    const existingJob = this.reserveQueue.find(peerId);
    if (existingJob != null) {
      this.log.trace("potential relay peer %p is already in the reservation queue", peerId);
      return existingJob.join();
    }
    if (this.relayFilter.has(peerId.toMultihash().bytes)) {
      throw new ListenError2("The relay was previously invalid");
    }
    this.log.trace("try to reserve relay slot with %p", peerId);
    return this.reserveQueue.add(async () => {
      const start2 = Date.now();
      try {
        const existingReservation = this.reservations.get(peerId);
        if (existingReservation != null) {
          const connections = this.connectionManager.getConnections(peerId);
          let connected = false;
          if (connections.length === 0) {
            this.log("already have relay reservation with %p but we are no longer connected", peerId);
          }
          if (connections.map((conn) => conn.id).includes(existingReservation.connection)) {
            this.log("already have relay reservation with %p and the original connection is still open", peerId);
            connected = true;
          }
          if (connected && getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {
            this.log("already have relay reservation with %p but we are still connected and it does not expire soon", peerId);
            return {
              relay: peerId,
              details: existingReservation
            };
          }
          await __privateMethod(this, _ReservationStore_instances, removeReservation_fn).call(this, peerId);
        }
        if (type === "discovered" && this.pendingReservations.length === 0) {
          throw new HadEnoughRelaysError("Not making reservation on discovered relay because we do not need any more relays");
        }
        const signal = AbortSignal.timeout(this.reservationCompletionTimeout);
        setMaxListeners(Infinity, signal);
        const connection = await this.connectionManager.openConnection(peerId, {
          signal
        });
        if (Circuit.matches(connection.remoteAddr)) {
          throw new DoubleRelayError("not creating reservation over relayed connection");
        }
        const reservation = await __privateMethod(this, _ReservationStore_instances, createReservation_fn).call(this, connection, {
          signal
        });
        const expiration = getExpirationMilliseconds(reservation.expire);
        this.log("created reservation on relay peer %p, expiry date is %s", peerId, new Date(Date.now() + expiration).toString());
        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);
        const timeout = setTimeout(() => {
          this.log("refresh reservation to relay %p", peerId);
          this.addRelay(peerId, type).catch(async (err) => {
            this.log.error("could not refresh reservation to relay %p - %e", peerId, err);
            await __privateMethod(this, _ReservationStore_instances, removeReservation_fn).call(this, peerId);
          }).catch((err) => {
            this.log.error("could not remove expired reservation to relay %p - %e", peerId, err);
          });
        }, timeoutDuration);
        let res;
        if (type === "discovered") {
          const id = this.pendingReservations.pop();
          if (id == null) {
            throw new HadEnoughRelaysError("Made reservation on relay but did not need any more discovered relays");
          }
          res = {
            timeout,
            reservation,
            type,
            connection: connection.id,
            id
          };
        } else {
          res = {
            timeout,
            reservation,
            type,
            connection: connection.id
          };
        }
        this.reservations.set(peerId, res);
        await this.peerStore.merge(peerId, {
          tags: {
            [KEEP_ALIVE_TAG]: {
              value: 1,
              ttl: expiration
            }
          }
        });
        __privateMethod(this, _ReservationStore_instances, checkReservationCount_fn).call(this);
        const result = {
          relay: peerId,
          details: res
        };
        this.safeDispatchEvent("relay:created-reservation", {
          detail: result
        });
        return result;
      } catch (err) {
        if (!(type === "discovered" && err.name === "HadEnoughRelaysError")) {
          this.log.error("could not reserve slot on %p after %dms - %e", peerId, Date.now() - start2, err);
        }
        if (err.name === "DialError" || err.name === "UnsupportedProtocolError") {
          this.relayFilter.add(peerId.toMultihash().bytes);
        }
        __privateMethod(this, _ReservationStore_instances, removeReservation_fn).call(this, peerId).catch((err2) => {
          this.log.error("could not remove reservation on %p after reserving slot failed - %e", peerId, err2);
        });
        throw err;
      }
    }, {
      peerId
    });
  }
  hasReservation(peerId) {
    return this.reservations.has(peerId);
  }
  getReservation(peerId) {
    return this.reservations.get(peerId)?.reservation;
  }
  reservationCount(type) {
    if (type == null) {
      return this.reservations.size;
    }
    return [...this.reservations.values()].reduce((acc, curr) => {
      if (curr.type === type) {
        acc++;
      }
      return acc;
    }, 0);
  }
  cancelReservations() {
    [...this.reservations.values()].forEach((reservation) => {
      clearTimeout(reservation.timeout);
    });
    this.reservations.clear();
  }
};
_ReservationStore_instances = new WeakSet();
createReservation_fn = async function(connection, options2) {
  options2.signal?.throwIfAborted();
  this.log("requesting reservation from %p", connection.remotePeer);
  const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options2);
  const pbstr = pbStream(stream);
  const hopstr = pbstr.pb(HopMessage);
  this.log.trace("send RESERVE to %p", connection.remotePeer);
  await hopstr.write({ type: HopMessage.Type.RESERVE }, options2);
  let response;
  try {
    this.log.trace("reading response from %p", connection.remotePeer);
    response = await hopstr.read(options2);
  } catch (err) {
    stream.abort(err);
    throw err;
  } finally {
    if (stream.status !== "closed") {
      await stream.close(options2);
    }
  }
  this.log.trace("read response %s", response.status);
  if (response.status === Status.OK && response.reservation != null) {
    const addresses = /* @__PURE__ */ new Set();
    addresses.add(connection.remoteAddr.toString());
    for (const buf2 of response.reservation.addrs) {
      let ma = multiaddr(buf2);
      if (ma.getComponents().find((c2) => c2.code === CODE_P2P2) == null) {
        ma = ma.encapsulate(`/p2p/${connection.remotePeer}`);
      }
      ma = multiaddr(ma.toString().replace(`/p2p/${connection.remotePeer}/p2p/${connection.remotePeer}`, `/p2p/${connection.remotePeer}`));
      addresses.add(ma.toString());
    }
    response.reservation.addrs = [...addresses].map((str) => multiaddr(str).bytes);
    return response.reservation;
  }
  const errMsg = `reservation failed with status ${response.status ?? "undefined"}`;
  this.log.error(errMsg);
  throw new Error(errMsg);
};
removeReservation_fn = async function(peerId) {
  const reservation = this.reservations.get(peerId);
  if (reservation == null) {
    return;
  }
  this.log("removing relay reservation with %p from local store", peerId);
  clearTimeout(reservation.timeout);
  this.reservations.delete(peerId);
  if (reservation.type === "discovered") {
    this.pendingReservations.push(reservation.id);
  }
  await this.peerStore.merge(peerId, {
    tags: {
      [KEEP_ALIVE_TAG]: void 0
    }
  });
  this.safeDispatchEvent("relay:removed", {
    detail: {
      relay: peerId,
      details: reservation
    }
  });
  __privateMethod(this, _ReservationStore_instances, checkReservationCount_fn).call(this);
};
checkReservationCount_fn = function() {
  if (this.pendingReservations.length === 0) {
    this.log.trace("have discovered enough relays");
    this.reserveQueue.clear();
    this.safeDispatchEvent("relay:found-enough-relays");
    return;
  }
  this.relayFilter = createScalableCuckooFilter(100);
  this.log("not discovered enough relays %d/%d", this.reservations.size, this.pendingReservations.length);
  this.safeDispatchEvent("relay:not-enough-relays");
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/transport/stream-to-conn.js
var StreamMultiaddrConnection = class extends AbstractMultiaddrConnection {
  constructor(init) {
    super({
      ...init,
      direction: init.stream.direction
    });
    __publicField(this, "stream");
    __publicField(this, "init");
    this.init = init;
    this.stream = init.stream;
    this.stream.addEventListener("close", (evt) => {
      this.onTransportClosed(evt.error);
    });
    this.stream.addEventListener("remoteCloseWrite", (evt) => {
      this.onRemoteCloseWrite();
      this.close().catch((err) => {
        this.abort(err);
      });
    });
    this.stream.addEventListener("message", (evt) => {
      init.onDataRead?.(evt.data);
      this.onData(evt.data);
    });
    this.stream.addEventListener("drain", () => {
      this.safeDispatchEvent("drain");
    });
  }
  sendData(data) {
    this.init.onDataWrite?.(data);
    return {
      sentBytes: data.byteLength,
      canSendMore: this.stream.send(data)
    };
  }
  async sendClose(options2) {
    await this.stream.close(options2);
  }
  sendReset() {
    this.stream.abort(new Error("An error occurred"));
  }
  sendPause() {
    this.stream.pause();
  }
  sendResume() {
    this.stream.resume();
  }
};
function streamToMaConnection(init) {
  return new StreamMultiaddrConnection(init);
}

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/transport/index.js
var _a12, _b9, _c6, _d3;
var isValidStop = (request) => {
  if (request.peer == null) {
    return false;
  }
  try {
    request.peer.addrs.forEach(multiaddr);
  } catch {
    return false;
  }
  return true;
};
var defaults2 = {
  maxInboundStopStreams: MAX_CONNECTIONS,
  maxOutboundStopStreams: MAX_CONNECTIONS,
  stopTimeout: 3e4
};
var CircuitRelayTransport = class {
  constructor(components, init = {}) {
    __publicField(this, "components");
    __publicField(this, "discovery");
    __publicField(this, "reservationStore");
    __publicField(this, "maxInboundStopStreams");
    __publicField(this, "maxOutboundStopStreams");
    __publicField(this, "started");
    __publicField(this, "log");
    __publicField(this, "shutdownController");
    __publicField(this, _d3, "@libp2p/circuit-relay-v2-transport");
    __publicField(this, _c6, [
      "@libp2p/transport",
      "@libp2p/circuit-relay-v2-transport"
    ]);
    __publicField(this, _a12, true);
    this.components = components;
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport");
    this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults2.maxInboundStopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults2.maxOutboundStopStreams;
    this.shutdownController = new AbortController();
    this.discovery = new RelayDiscovery(components, {
      filter: init.discoveryFilter ?? peerFilter(DEFAULT_DISCOVERY_FILTER_SIZE, DEFAULT_DISCOVERY_FILTER_ERROR_RATE)
    });
    this.discovery.addEventListener("relay:discover", (evt) => {
      this.reservationStore.addRelay(evt.detail, "discovered").catch((err) => {
        if (err.name !== "HadEnoughRelaysError" && err.name !== "RelayQueueFullError") {
          this.log.error("could not add discovered relay %p - %e", evt.detail, err);
        }
      });
    });
    this.reservationStore = new ReservationStore2(components, init);
    this.reservationStore.addEventListener("relay:not-enough-relays", () => {
      this.discovery?.startDiscovery();
    });
    this.reservationStore.addEventListener("relay:found-enough-relays", () => {
      this.discovery?.stopDiscovery();
    });
    this.started = false;
    this.onStop = this.onStop.bind(this);
  }
  get [(_d3 = Symbol.toStringTag, _c6 = serviceCapabilities2, _b9 = serviceDependencies2, _a12 = transportSymbol, _b9)]() {
    if (this.discovery != null) {
      return [
        "@libp2p/identify"
      ];
    }
    return [];
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    await this.components.registrar.handle(RELAY_V2_STOP_CODEC, this.onStop, {
      maxInboundStreams: this.maxInboundStopStreams,
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnLimitedConnection: true
    });
    await start(this.discovery, this.reservationStore);
    this.started = true;
  }
  async stop() {
    this.shutdownController.abort();
    await stop(this.discovery, this.reservationStore);
    await this.components.registrar.unhandle(RELAY_V2_STOP_CODEC);
    this.started = false;
  }
  /**
   * Dial a peer over a relay
   */
  async dial(ma, options2) {
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getComponents().find((c2) => c2.code === CODE_P2P2)?.value;
    const destinationId = destinationAddr.getComponents().find((c2) => c2.code === CODE_P2P2)?.value;
    if (relayId == null || destinationId == null) {
      const errMsg = `ircuit relay dial to ${ma.toString()} failed as address did not have both relay and destination PeerIDs`;
      this.log.error(`c${errMsg}`);
      throw new DialError2(`C${errMsg}`);
    }
    const relayPeer = peerIdFromString3(relayId);
    const destinationPeer = peerIdFromString3(destinationId);
    const relayConnections = this.components.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.components.peerStore.merge(relayPeer, {
        multiaddrs: [relayAddr]
      });
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:open-connection"));
      relayConnection = await this.components.connectionManager.openConnection(relayPeer, options2);
    } else {
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:reuse-connection"));
    }
    let stream;
    try {
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:open-hop-stream"));
      stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC, options2);
      const hopstr = pbStream(stream).pb(HopMessage);
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:write-connect-message"));
      await hopstr.write({
        type: HopMessage.Type.CONNECT,
        peer: {
          id: destinationPeer.toMultihash().bytes,
          addrs: [multiaddr(destinationAddr).bytes]
        }
      }, options2);
      options2.onProgress?.(new CustomProgressEvent("circuit-relay:read-connect-response"));
      const status = await hopstr.read(options2);
      if (status.status !== Status.OK) {
        throw new InvalidMessageError2(`failed to connect via relay with status ${status?.status?.toString() ?? "undefined"}`);
      }
      const limits = new LimitTracker(status.limit);
      const maConn = streamToMaConnection({
        stream: hopstr.unwrap().unwrap(),
        remoteAddr: ma,
        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`),
        onDataRead: limits.onData,
        onDataWrite: limits.onData,
        log: stream.log.newScope("circuit-relay:connection")
      });
      const conn = await this.components.upgrader.upgradeOutbound(maConn, {
        ...options2,
        limits: limits.getLimits()
      });
      conn.log("outbound relayed connection established to %p with limits %o, over connection %s", conn.remotePeer, status.limit ?? "none", relayConnection.id);
      return conn;
    } catch (err) {
      this.log.error("circuit relay dial to destination %p via relay %p failed - %e", destinationPeer, relayPeer, err);
      stream?.abort(err);
      throw err;
    }
  }
  /**
   * Create a listener
   */
  createListener(options2) {
    return createListener({
      peerId: this.components.peerId,
      connectionManager: this.components.connectionManager,
      addressManager: this.components.addressManager,
      reservationStore: this.reservationStore,
      logger: this.components.logger
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return CircuitListen.exactMatch(ma) || CircuitSearch.exactMatch(ma);
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit.exactMatch(ma);
    });
  }
  /**
   * An incoming STOP request means a remote peer wants to dial us via a relay
   */
  async onStop(stream, connection) {
    const signal = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
    try {
      if (!this.reservationStore.hasReservation(connection.remotePeer)) {
        try {
          this.log("dialed via relay we did not have a reservation on, start listening on that relay address");
          await this.components.transportManager.listen([connection.remoteAddr.encapsulate("/p2p-circuit")]);
        } catch (err) {
          this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on - %e", err);
        }
      }
      const stopStream = pbStream(stream).pb(StopMessage);
      const request = await stopStream.read({
        signal
      });
      this.log("new circuit relay v2 stop stream from %p with type %s", connection.remotePeer, request.type);
      if (request?.type === void 0) {
        this.log.error("type was missing from circuit v2 stop protocol request from %s", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      if (request.type !== StopMessage.Type.CONNECT) {
        this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      if (!isValidStop(request)) {
        this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      const remotePeerId = peerIdFromMultihash3(decode4(request.peer.id));
      if (await this.components.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId) === true) {
        this.log.error("connection gater denied inbound relayed connection from %p", connection.remotePeer);
        await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {
          signal
        });
        await stream.close({
          signal
        });
        return;
      }
      this.log.trace("sending success response to %p", connection.remotePeer);
      await stopStream.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {
        signal
      });
      const limits = new LimitTracker(request.limit);
      const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);
      const localAddr = this.components.addressManager.getAddresses()[0];
      const maConn = streamToMaConnection({
        stream: stopStream.unwrap().unwrap(),
        remoteAddr,
        localAddr,
        onDataRead: limits.onData,
        onDataWrite: limits.onData,
        log: stream.log.newScope("circuit-relay:connection")
      });
      await this.components.upgrader.upgradeInbound(maConn, {
        limits: limits.getLimits(),
        signal
      });
      maConn.log("inbound relayed connection established to %p with limits %o, over connection %s", remotePeerId, request.limit ?? "none", connection.id);
    } finally {
      signal?.clear();
    }
  }
};

// ../../node_modules/@libp2p/circuit-relay-v2/dist/src/index.js
function circuitRelayServer(init = {}) {
  return (components) => {
    return new CircuitRelayServer(components, init);
  };
}
function circuitRelayTransport(init = {}) {
  return (components) => {
    return new CircuitRelayTransport(components, init);
  };
}

// ../../node_modules/@libp2p/dcutr/dist/src/pb/message.js
var HolePunch;
(function(HolePunch2) {
  let Type2;
  (function(Type3) {
    Type3["UNUSED"] = "UNUSED";
    Type3["CONNECT"] = "CONNECT";
    Type3["SYNC"] = "SYNC";
  })(Type2 = HolePunch2.Type || (HolePunch2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["UNUSED"] = 0] = "UNUSED";
    __TypeValues2[__TypeValues2["CONNECT"] = 100] = "CONNECT";
    __TypeValues2[__TypeValues2["SYNC"] = 300] = "SYNC";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type3) {
    Type3.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type2 = HolePunch2.Type || (HolePunch2.Type = {}));
  let _codec;
  HolePunch2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          HolePunch2.Type.codec().encode(obj.type, w);
        }
        if (obj.observedAddresses != null) {
          for (const value2 of obj.observedAddresses) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          observedAddresses: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = HolePunch2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              if (opts.limits?.observedAddresses != null && obj.observedAddresses.length === opts.limits.observedAddresses) {
                throw new MaxLengthError('Decode error - map field "observedAddresses" had too many elements');
              }
              obj.observedAddresses.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HolePunch2.encode = (obj) => {
    return encodeMessage(obj, HolePunch2.codec());
  };
  HolePunch2.decode = (buf2, opts) => {
    return decodeMessage(buf2, HolePunch2.codec(), opts);
  };
})(HolePunch || (HolePunch = {}));

// ../../node_modules/@libp2p/dcutr/dist/src/utils.js
function isPublicAndDialable(ma, transportManager) {
  if (Circuit.matches(ma)) {
    return false;
  }
  const transport = transportManager.dialTransportForMultiaddr(ma);
  if (transport == null) {
    return false;
  }
  if (DNS.matches(ma)) {
    return true;
  }
  if (!IP.matches(ma)) {
    return false;
  }
  return !isPrivate(ma);
}

// ../../node_modules/@libp2p/dcutr/dist/src/dcutr.js
var _a13, _b10;
var MAX_DCUTR_MESSAGE_SIZE = 1024 * 4;
var DCUTR_DIAL_PRIORITY = 100;
var defaultValues = {
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L27
  timeout: 5e3,
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L28
  retries: 3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1
};
_b10 = Symbol.toStringTag, _a13 = serviceDependencies2;
var DefaultDCUtRService = class {
  constructor(components, init) {
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "retries");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "peerStore");
    __publicField(this, "registrar");
    __publicField(this, "connectionManager");
    __publicField(this, "addressManager");
    __publicField(this, "transportManager");
    __publicField(this, "topologyId");
    __publicField(this, "log");
    __publicField(this, _b10, "@libp2p/dcutr");
    __publicField(this, _a13, [
      "@libp2p/identify"
    ]);
    this.log = components.logger.forComponent("libp2p:dcutr");
    this.started = false;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.timeout = init.timeout ?? defaultValues.timeout;
    this.retries = init.retries ?? defaultValues.retries;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams;
    this.handleIncomingUpgrade = this.handleIncomingUpgrade.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.topologyId = await this.registrar.register(multicodec2, {
      notifyOnLimitedConnection: true,
      onConnect: (peerId, connection) => {
        if (!Circuit.exactMatch(connection.remoteAddr)) {
          return;
        }
        if (connection.direction !== "inbound") {
          return;
        }
        this.upgradeInbound(connection).catch((err) => {
          this.log.error("error during outgoing DCUtR attempt - %e", err);
        });
      }
    });
    await this.registrar.handle(multicodec2, this.handleIncomingUpgrade, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: true
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(multicodec2);
    if (this.topologyId != null) {
      this.registrar.unregister(this.topologyId);
    }
    this.started = false;
  }
  /**
   * Perform the inbound connection upgrade as B
   *
   * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
   */
  async upgradeInbound(relayedConnection) {
    if (await this.attemptUnilateralConnectionUpgrade(relayedConnection)) {
      return;
    }
    let stream;
    for (let i2 = 0; i2 < this.retries; i2++) {
      const options2 = {
        signal: AbortSignal.timeout(this.timeout)
      };
      try {
        stream = await relayedConnection.newStream([multicodec2], {
          signal: options2.signal,
          runOnLimitedConnection: true
        });
        const pb = pbStream(stream, {
          maxDataLength: MAX_DCUTR_MESSAGE_SIZE
        }).pb(HolePunch);
        this.log("B sending connect to %p", relayedConnection.remotePeer);
        const connectTimer = Date.now();
        await pb.write({
          type: HolePunch.Type.CONNECT,
          observedAddresses: this.addressManager.getAddresses().map((ma) => ma.bytes)
        }, options2);
        this.log("B receiving connect from %p", relayedConnection.remotePeer);
        const connect2 = await pb.read(options2);
        if (connect2.type !== HolePunch.Type.CONNECT) {
          this.log("A sent wrong message type");
          throw new InvalidMessageError2("DCUtR message type was incorrect");
        }
        const multiaddrs = this.getDialableMultiaddrs(connect2.observedAddresses);
        if (multiaddrs.length === 0) {
          this.log("A did not have any dialable multiaddrs");
          throw new InvalidMessageError2("DCUtR connect message had no multiaddrs");
        }
        const rtt = Date.now() - connectTimer;
        this.log("A sending sync, rtt %dms", rtt);
        await pb.write({
          type: HolePunch.Type.SYNC,
          observedAddresses: []
        }, options2);
        this.log("A waiting for half RTT");
        await delay_default(rtt / 2);
        this.log("B dialing", multiaddrs);
        const conn = await this.connectionManager.openConnection(multiaddrs, {
          signal: options2.signal,
          priority: DCUTR_DIAL_PRIORITY,
          force: true,
          initiator: false
        });
        this.log("DCUtR to %p succeeded to address %a, closing relayed connection", relayedConnection.remotePeer, conn.remoteAddr);
        await relayedConnection.close(options2);
        break;
      } catch (err) {
        this.log.error("error while attempting DCUtR on attempt %d of %d - %e", i2 + 1, this.retries, err);
        stream?.abort(err);
        if (i2 === this.retries) {
          throw err;
        }
      } finally {
        if (stream != null) {
          await stream.close(options2);
        }
      }
    }
  }
  /**
   * This is performed when A has dialed B via a relay but A also has a public
   * address that B can dial directly
   */
  async attemptUnilateralConnectionUpgrade(relayedConnection) {
    const peerInfo = await this.peerStore.get(relayedConnection.remotePeer);
    const publicAddresses = peerInfo.addresses.map((address) => {
      const ma = address.multiaddr;
      if (ma.getComponents().find((c2) => c2.code === CODE_P2P2)?.value == null) {
        return ma.encapsulate(`/p2p/${relayedConnection.remotePeer}`);
      }
      return ma;
    }).filter((ma) => {
      return isPublicAndDialable(ma, this.transportManager);
    });
    if (publicAddresses.length > 0) {
      const signal = AbortSignal.timeout(this.timeout);
      try {
        this.log("attempting unilateral connection upgrade to %a", publicAddresses);
        const connection = await this.connectionManager.openConnection(publicAddresses, {
          signal,
          force: true
        });
        if (Circuit.exactMatch(connection.remoteAddr)) {
          throw new Error("Could not open a new, non-limited, connection");
        }
        this.log("unilateral connection upgrade to %p succeeded via %a, closing relayed connection", relayedConnection.remotePeer, connection.remoteAddr);
        await relayedConnection.close({
          signal
        });
        return true;
      } catch (err) {
        this.log.error("unilateral connection upgrade to %p on addresses %a failed - %e", relayedConnection.remotePeer, publicAddresses, err);
      }
    } else {
      this.log("peer %p has no public addresses, not attempting unilateral connection upgrade", relayedConnection.remotePeer);
    }
    return false;
  }
  /**
   * Perform the connection upgrade as A
   *
   * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
   */
  async handleIncomingUpgrade(stream, relayedConnection) {
    const options2 = {
      signal: AbortSignal.timeout(this.timeout)
    };
    const pb = pbStream(stream, {
      maxDataLength: MAX_DCUTR_MESSAGE_SIZE
    }).pb(HolePunch);
    this.log("A receiving connect");
    const connect2 = await pb.read(options2);
    if (connect2.type !== HolePunch.Type.CONNECT) {
      this.log("B sent wrong message type");
      throw new InvalidMessageError2("DCUtR message type was incorrect");
    }
    if (connect2.observedAddresses.length === 0) {
      this.log("B sent no multiaddrs");
      throw new InvalidMessageError2("DCUtR connect message had no multiaddrs");
    }
    const multiaddrs = this.getDialableMultiaddrs(connect2.observedAddresses);
    if (multiaddrs.length === 0) {
      this.log("B had no dialable multiaddrs in %o", connect2.observedAddresses.map((b) => multiaddr(b)));
      throw new InvalidMessageError2("DCUtR connect message had no dialable multiaddrs");
    }
    this.log("A sending connect");
    await pb.write({
      type: HolePunch.Type.CONNECT,
      observedAddresses: this.addressManager.getAddresses().map((ma) => ma.bytes)
    });
    this.log("A receiving sync");
    const sync = await pb.read(options2);
    if (sync.type !== HolePunch.Type.SYNC) {
      throw new InvalidMessageError2("DCUtR message type was incorrect");
    }
    this.log("A dialing", multiaddrs);
    const connection = await this.connectionManager.openConnection(multiaddrs, {
      signal: options2.signal,
      priority: DCUTR_DIAL_PRIORITY,
      force: true
    });
    this.log("DCUtR to %p succeeded via %a, closing relayed connection", relayedConnection.remotePeer, connection.remoteAddr);
    await relayedConnection.close(options2);
    await stream.close(options2);
  }
  /**
   * Takes the `addr` and converts it to a Multiaddr if possible
   */
  getDialableMultiaddrs(addrs) {
    const output = [];
    for (const addr of addrs) {
      if (addr == null || addr.length === 0) {
        continue;
      }
      try {
        const ma = multiaddr(addr);
        if (!isPublicAndDialable(ma, this.transportManager)) {
          continue;
        }
        output.push(ma);
      } catch {
      }
    }
    return output;
  }
};

// ../../node_modules/@libp2p/dcutr/dist/src/index.js
var multicodec2 = "/libp2p/dcutr";
function dcutr(init = {}) {
  return (components) => new DefaultDCUtRService(components, init);
}

// ../../node_modules/@libp2p/floodsub/dist/src/constants.js
var pubSubSymbol2 = /* @__PURE__ */ Symbol.for("@libp2p/pubsub");

// ../../node_modules/p-queue/node_modules/eventemitter3/index.mjs
var import_index9 = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index9.default;

// ../../node_modules/p-timeout/index.js
var TimeoutError5 = class _TimeoutError extends Error {
  constructor(message2, options2) {
    super(message2, options2);
    __publicField(this, "name", "TimeoutError");
    Error.captureStackTrace?.(this, _TimeoutError);
  }
};
var getAbortedReason2 = (signal) => signal.reason ?? new DOMException("This operation was aborted.", "AbortError");
function pTimeout2(promise, options2) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout },
    signal
  } = options2;
  let timer;
  let abortHandler;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (signal?.aborted) {
      reject(getAbortedReason2(signal));
      return;
    }
    if (signal) {
      abortHandler = () => {
        reject(getAbortedReason2(signal));
      };
      signal.addEventListener("abort", abortHandler, { once: true });
    }
    promise.then(resolve, reject);
    if (milliseconds === Number.POSITIVE_INFINITY) {
      return;
    }
    const timeoutError = new TimeoutError5();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message2 === false) {
        resolve();
      } else if (message2 instanceof Error) {
        reject(message2);
      } else {
        timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
    if (abortHandler && signal) {
      signal.removeEventListener("abort", abortHandler);
    }
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// ../../node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value2, comparator) {
  let first = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first + step;
    if (comparator(array[it], value2) <= 0) {
      first = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}

// ../../node_modules/p-queue/dist/priority-queue.js
var _queue;
var PriorityQueue2 = class {
  constructor() {
    __privateAdd(this, _queue, []);
  }
  enqueue(run, options2) {
    const { priority = 0, id } = options2 ?? {};
    const element = {
      priority,
      id,
      run
    };
    if (this.size === 0 || __privateGet(this, _queue)[this.size - 1].priority >= priority) {
      __privateGet(this, _queue).push(element);
      return;
    }
    const index = lowerBound(__privateGet(this, _queue), element, (a2, b) => b.priority - a2.priority);
    __privateGet(this, _queue).splice(index, 0, element);
  }
  setPriority(id, priority) {
    const index = __privateGet(this, _queue).findIndex((element) => element.id === id);
    if (index === -1) {
      throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
    }
    const [item] = __privateGet(this, _queue).splice(index, 1);
    this.enqueue(item.run, { priority, id });
  }
  dequeue() {
    const item = __privateGet(this, _queue).shift();
    return item?.run;
  }
  filter(options2) {
    return __privateGet(this, _queue).filter((element) => element.priority === options2.priority).map((element) => element.run);
  }
  get size() {
    return __privateGet(this, _queue).length;
  }
};
_queue = new WeakMap();

// ../../node_modules/p-queue/dist/index.js
var _carryoverIntervalCount, _isIntervalIgnored, _intervalCount, _intervalCap, _rateLimitedInInterval, _rateLimitFlushScheduled, _interval, _intervalEnd, _lastExecutionTime, _intervalId, _timeoutId, _queue2, _queueClass, _pending, _concurrency, _isPaused, _idAssigner, _runningTasks, _PQueue_instances, doesIntervalAllowAnother_get, doesConcurrentAllowAnother_get, next_fn, onResumeInterval_fn, isIntervalPaused_get, createIntervalTimeout_fn, clearIntervalTimer_fn, clearTimeoutTimer_fn, tryToStartAnother_fn, initializeIntervalIfNeeded_fn, onInterval_fn, processQueue_fn, onEvent_fn, setupRateLimitTracking_fn, scheduleRateLimitUpdate_fn, updateRateLimitState_fn;
var PQueue = class extends import_index9.default {
  constructor(options2) {
    super();
    __privateAdd(this, _PQueue_instances);
    __privateAdd(this, _carryoverIntervalCount);
    __privateAdd(this, _isIntervalIgnored);
    __privateAdd(this, _intervalCount, 0);
    __privateAdd(this, _intervalCap);
    __privateAdd(this, _rateLimitedInInterval, false);
    __privateAdd(this, _rateLimitFlushScheduled, false);
    __privateAdd(this, _interval);
    __privateAdd(this, _intervalEnd, 0);
    __privateAdd(this, _lastExecutionTime, 0);
    __privateAdd(this, _intervalId);
    __privateAdd(this, _timeoutId);
    __privateAdd(this, _queue2);
    __privateAdd(this, _queueClass);
    __privateAdd(this, _pending, 0);
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    __privateAdd(this, _concurrency);
    __privateAdd(this, _isPaused);
    // Use to assign a unique identifier to a promise function, if not explicitly specified
    __privateAdd(this, _idAssigner, 1n);
    // Track currently running tasks for debugging
    __privateAdd(this, _runningTasks, /* @__PURE__ */ new Map());
    /**
        Get or set the default timeout for all tasks. Can be changed at runtime.
    
        Operations will throw a `TimeoutError` if they don't complete within the specified time.
    
        The timeout begins when the operation is dequeued and starts execution, not while it's waiting in the queue.
    
        @example
        ```
        const queue = new PQueue({timeout: 5000});
    
        // Change timeout for all future tasks
        queue.timeout = 10000;
        ```
        */
    __publicField(this, "timeout");
    options2 = {
      carryoverIntervalCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue2,
      ...options2
    };
    if (!(typeof options2.intervalCap === "number" && options2.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options2.intervalCap?.toString() ?? ""}\` (${typeof options2.intervalCap})`);
    }
    if (options2.interval === void 0 || !(Number.isFinite(options2.interval) && options2.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options2.interval?.toString() ?? ""}\` (${typeof options2.interval})`);
    }
    __privateSet(this, _carryoverIntervalCount, options2.carryoverIntervalCount ?? options2.carryoverConcurrencyCount ?? false);
    __privateSet(this, _isIntervalIgnored, options2.intervalCap === Number.POSITIVE_INFINITY || options2.interval === 0);
    __privateSet(this, _intervalCap, options2.intervalCap);
    __privateSet(this, _interval, options2.interval);
    __privateSet(this, _queue2, new options2.queueClass());
    __privateSet(this, _queueClass, options2.queueClass);
    this.concurrency = options2.concurrency;
    if (options2.timeout !== void 0 && !(Number.isFinite(options2.timeout) && options2.timeout > 0)) {
      throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${options2.timeout}\` (${typeof options2.timeout})`);
    }
    this.timeout = options2.timeout;
    __privateSet(this, _isPaused, options2.autoStart === false);
    __privateMethod(this, _PQueue_instances, setupRateLimitTracking_fn).call(this);
  }
  get concurrency() {
    return __privateGet(this, _concurrency);
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __privateSet(this, _concurrency, newConcurrency);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
  }
  /**
      Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
  
      For example, this can be used to prioritize a promise function to run earlier.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '', {priority: 1});
      queue.add(async () => '', {priority: 0, id: ''});
      queue.add(async () => '', {priority: 1});
      queue.add(async () => '', {priority: 1});
  
      queue.setPriority('', 2);
      ```
  
      In this case, the promise function with `id: ''` runs second.
  
      You can also deprioritize a promise function to delay its execution:
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '', {priority: 1});
      queue.add(async () => '', {priority: 1, id: ''});
      queue.add(async () => '');
      queue.add(async () => '', {priority: 0});
  
      queue.setPriority('', -1);
      ```
      Here, the promise function with `id: ''` executes last.
      */
  setPriority(id, priority) {
    if (typeof priority !== "number" || !Number.isFinite(priority)) {
      throw new TypeError(`Expected \`priority\` to be a finite number, got \`${priority}\` (${typeof priority})`);
    }
    __privateGet(this, _queue2).setPriority(id, priority);
  }
  async add(function_, options2 = {}) {
    options2.id ?? (options2.id = (__privateWrapper(this, _idAssigner)._++).toString());
    options2 = {
      timeout: this.timeout,
      ...options2
    };
    return new Promise((resolve, reject) => {
      const taskSymbol = /* @__PURE__ */ Symbol(`task-${options2.id}`);
      __privateGet(this, _queue2).enqueue(async () => {
        __privateWrapper(this, _pending)._++;
        __privateGet(this, _runningTasks).set(taskSymbol, {
          id: options2.id,
          priority: options2.priority ?? 0,
          // Match priority-queue default
          startTime: Date.now(),
          timeout: options2.timeout
        });
        let eventListener;
        try {
          try {
            options2.signal?.throwIfAborted();
          } catch (error) {
            if (!__privateGet(this, _isIntervalIgnored)) {
              __privateWrapper(this, _intervalCount)._--;
            }
            __privateGet(this, _runningTasks).delete(taskSymbol);
            throw error;
          }
          let operation = function_({ signal: options2.signal });
          if (options2.timeout) {
            operation = pTimeout2(Promise.resolve(operation), {
              milliseconds: options2.timeout,
              message: `Task timed out after ${options2.timeout}ms (queue has ${__privateGet(this, _pending)} running, ${__privateGet(this, _queue2).size} waiting)`
            });
          }
          if (options2.signal) {
            const { signal } = options2;
            operation = Promise.race([operation, new Promise((_resolve, reject2) => {
              eventListener = () => {
                reject2(signal.reason);
              };
              signal.addEventListener("abort", eventListener, { once: true });
            })]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          reject(error);
          this.emit("error", error);
        } finally {
          if (eventListener) {
            options2.signal?.removeEventListener("abort", eventListener);
          }
          __privateGet(this, _runningTasks).delete(taskSymbol);
          queueMicrotask(() => {
            __privateMethod(this, _PQueue_instances, next_fn).call(this);
          });
        }
      }, options2);
      this.emit("add");
      __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
    });
  }
  async addAll(functions, options2) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options2)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__privateGet(this, _isPaused)) {
      return this;
    }
    __privateSet(this, _isPaused, false);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __privateSet(this, _isPaused, true);
  }
  /**
  Clear the queue.
  */
  clear() {
    __privateSet(this, _queue2, new (__privateGet(this, _queueClass))());
    __privateMethod(this, _PQueue_instances, updateRateLimitState_fn).call(this);
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__privateGet(this, _queue2).size === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__privateGet(this, _queue2).size < limit) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "next", () => __privateGet(this, _queue2).size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__privateGet(this, _pending) === 0 && __privateGet(this, _queue2).size === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "idle");
  }
  /**
      The difference with `.onIdle` is that `.onPendingZero` only waits for currently running tasks to finish, ignoring queued tasks.
  
      @returns A promise that settles when all currently running tasks have completed; `queue.pending === 0`.
      */
  async onPendingZero() {
    if (__privateGet(this, _pending) === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "pendingZero");
  }
  /**
  @returns A promise that settles when the queue becomes rate-limited due to intervalCap.
  */
  async onRateLimit() {
    if (this.isRateLimited) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "rateLimit");
  }
  /**
  @returns A promise that settles when the queue is no longer rate-limited.
  */
  async onRateLimitCleared() {
    if (!this.isRateLimited) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "rateLimitCleared");
  }
  /**
      @returns A promise that rejects when any task in the queue errors.
  
      Use with `Promise.race([queue.onError(), queue.onIdle()])` to fail fast on the first error while still resolving normally when the queue goes idle.
  
      Important: The promise returned by `add()` still rejects. You must handle each `add()` promise (for example, `.catch(() => {})`) to avoid unhandled rejections.
  
      @example
      ```
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 2});
  
      queue.add(() => fetchData(1)).catch(() => {});
      queue.add(() => fetchData(2)).catch(() => {});
      queue.add(() => fetchData(3)).catch(() => {});
  
      // Stop processing on first error
      try {
          await Promise.race([
              queue.onError(),
              queue.onIdle()
          ]);
      } catch (error) {
          queue.pause(); // Stop processing remaining tasks
          console.error('Queue failed:', error);
      }
      ```
      */
  // eslint-disable-next-line @typescript-eslint/promise-function-async
  async onError() {
    return new Promise((_resolve, reject) => {
      const handleError = (error) => {
        this.off("error", handleError);
        reject(error);
      };
      this.on("error", handleError);
    });
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __privateGet(this, _queue2).size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options2) {
    return __privateGet(this, _queue2).filter(options2).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __privateGet(this, _pending);
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __privateGet(this, _isPaused);
  }
  /**
  Whether the queue is currently rate-limited due to intervalCap.
  */
  get isRateLimited() {
    return __privateGet(this, _rateLimitedInInterval);
  }
  /**
      Whether the queue is saturated. Returns `true` when:
      - All concurrency slots are occupied and tasks are waiting, OR
      - The queue is rate-limited and tasks are waiting
  
      Useful for detecting backpressure and potential hanging tasks.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 2});
  
      // Backpressure handling
      if (queue.isSaturated) {
          console.log('Queue is saturated, waiting for capacity...');
          await queue.onSizeLessThan(queue.concurrency);
      }
  
      // Monitoring for stuck tasks
      setInterval(() => {
          if (queue.isSaturated) {
              console.warn(`Queue saturated: ${queue.pending} running, ${queue.size} waiting`);
          }
      }, 60000);
      ```
      */
  get isSaturated() {
    return __privateGet(this, _pending) === __privateGet(this, _concurrency) && __privateGet(this, _queue2).size > 0 || this.isRateLimited && __privateGet(this, _queue2).size > 0;
  }
  /**
      The tasks currently being executed. Each task includes its `id`, `priority`, `startTime`, and `timeout` (if set).
  
      Returns an array of task info objects.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 2});
  
      // Add tasks with IDs for better debugging
      queue.add(() => fetchUser(123), {id: 'user-123'});
      queue.add(() => fetchPosts(456), {id: 'posts-456', priority: 1});
  
      // Check what's running
      console.log(queue.runningTasks);
      // => [{
      //   id: 'user-123',
      //   priority: 0,
      //   startTime: 1759253001716,
      //   timeout: undefined
      // }, {
      //   id: 'posts-456',
      //   priority: 1,
      //   startTime: 1759253001916,
      //   timeout: undefined
      // }]
      ```
      */
  get runningTasks() {
    return [...__privateGet(this, _runningTasks).values()].map((task) => ({ ...task }));
  }
};
_carryoverIntervalCount = new WeakMap();
_isIntervalIgnored = new WeakMap();
_intervalCount = new WeakMap();
_intervalCap = new WeakMap();
_rateLimitedInInterval = new WeakMap();
_rateLimitFlushScheduled = new WeakMap();
_interval = new WeakMap();
_intervalEnd = new WeakMap();
_lastExecutionTime = new WeakMap();
_intervalId = new WeakMap();
_timeoutId = new WeakMap();
_queue2 = new WeakMap();
_queueClass = new WeakMap();
_pending = new WeakMap();
_concurrency = new WeakMap();
_isPaused = new WeakMap();
_idAssigner = new WeakMap();
_runningTasks = new WeakMap();
_PQueue_instances = new WeakSet();
doesIntervalAllowAnother_get = function() {
  return __privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalCount) < __privateGet(this, _intervalCap);
};
doesConcurrentAllowAnother_get = function() {
  return __privateGet(this, _pending) < __privateGet(this, _concurrency);
};
next_fn = function() {
  __privateWrapper(this, _pending)._--;
  if (__privateGet(this, _pending) === 0) {
    this.emit("pendingZero");
  }
  __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
  this.emit("next");
};
onResumeInterval_fn = function() {
  __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
  __privateSet(this, _timeoutId, void 0);
};
isIntervalPaused_get = function() {
  const now = Date.now();
  if (__privateGet(this, _intervalId) === void 0) {
    const delay2 = __privateGet(this, _intervalEnd) - now;
    if (delay2 < 0) {
      if (__privateGet(this, _lastExecutionTime) > 0) {
        const timeSinceLastExecution = now - __privateGet(this, _lastExecutionTime);
        if (timeSinceLastExecution < __privateGet(this, _interval)) {
          __privateMethod(this, _PQueue_instances, createIntervalTimeout_fn).call(this, __privateGet(this, _interval) - timeSinceLastExecution);
          return true;
        }
      }
      __privateSet(this, _intervalCount, __privateGet(this, _carryoverIntervalCount) ? __privateGet(this, _pending) : 0);
    } else {
      __privateMethod(this, _PQueue_instances, createIntervalTimeout_fn).call(this, delay2);
      return true;
    }
  }
  return false;
};
createIntervalTimeout_fn = function(delay2) {
  if (__privateGet(this, _timeoutId) !== void 0) {
    return;
  }
  __privateSet(this, _timeoutId, setTimeout(() => {
    __privateMethod(this, _PQueue_instances, onResumeInterval_fn).call(this);
  }, delay2));
};
clearIntervalTimer_fn = function() {
  if (__privateGet(this, _intervalId)) {
    clearInterval(__privateGet(this, _intervalId));
    __privateSet(this, _intervalId, void 0);
  }
};
clearTimeoutTimer_fn = function() {
  if (__privateGet(this, _timeoutId)) {
    clearTimeout(__privateGet(this, _timeoutId));
    __privateSet(this, _timeoutId, void 0);
  }
};
tryToStartAnother_fn = function() {
  if (__privateGet(this, _queue2).size === 0) {
    __privateMethod(this, _PQueue_instances, clearIntervalTimer_fn).call(this);
    this.emit("empty");
    if (__privateGet(this, _pending) === 0) {
      __privateMethod(this, _PQueue_instances, clearTimeoutTimer_fn).call(this);
      this.emit("idle");
    }
    return false;
  }
  let taskStarted = false;
  if (!__privateGet(this, _isPaused)) {
    const canInitializeInterval = !__privateGet(this, _PQueue_instances, isIntervalPaused_get);
    if (__privateGet(this, _PQueue_instances, doesIntervalAllowAnother_get) && __privateGet(this, _PQueue_instances, doesConcurrentAllowAnother_get)) {
      const job = __privateGet(this, _queue2).dequeue();
      if (!__privateGet(this, _isIntervalIgnored)) {
        __privateWrapper(this, _intervalCount)._++;
        __privateMethod(this, _PQueue_instances, scheduleRateLimitUpdate_fn).call(this);
      }
      this.emit("active");
      __privateSet(this, _lastExecutionTime, Date.now());
      job();
      if (canInitializeInterval) {
        __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
      }
      taskStarted = true;
    }
  }
  return taskStarted;
};
initializeIntervalIfNeeded_fn = function() {
  if (__privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalId) !== void 0) {
    return;
  }
  __privateSet(this, _intervalId, setInterval(() => {
    __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  }, __privateGet(this, _interval)));
  __privateSet(this, _intervalEnd, Date.now() + __privateGet(this, _interval));
};
onInterval_fn = function() {
  if (__privateGet(this, _intervalCount) === 0 && __privateGet(this, _pending) === 0 && __privateGet(this, _intervalId)) {
    __privateMethod(this, _PQueue_instances, clearIntervalTimer_fn).call(this);
  }
  __privateSet(this, _intervalCount, __privateGet(this, _carryoverIntervalCount) ? __privateGet(this, _pending) : 0);
  __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
  __privateMethod(this, _PQueue_instances, scheduleRateLimitUpdate_fn).call(this);
};
/**
Executes all queued functions until it reaches the limit.
*/
processQueue_fn = function() {
  while (__privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this)) {
  }
};
onEvent_fn = async function(event, filter2) {
  return new Promise((resolve) => {
    const listener = () => {
      if (filter2 && !filter2()) {
        return;
      }
      this.off(event, listener);
      resolve();
    };
    this.on(event, listener);
  });
};
setupRateLimitTracking_fn = function() {
  if (__privateGet(this, _isIntervalIgnored)) {
    return;
  }
  this.on("add", () => {
    if (__privateGet(this, _queue2).size > 0) {
      __privateMethod(this, _PQueue_instances, scheduleRateLimitUpdate_fn).call(this);
    }
  });
  this.on("next", () => {
    __privateMethod(this, _PQueue_instances, scheduleRateLimitUpdate_fn).call(this);
  });
};
scheduleRateLimitUpdate_fn = function() {
  if (__privateGet(this, _isIntervalIgnored) || __privateGet(this, _rateLimitFlushScheduled)) {
    return;
  }
  __privateSet(this, _rateLimitFlushScheduled, true);
  queueMicrotask(() => {
    __privateSet(this, _rateLimitFlushScheduled, false);
    __privateMethod(this, _PQueue_instances, updateRateLimitState_fn).call(this);
  });
};
updateRateLimitState_fn = function() {
  const previous = __privateGet(this, _rateLimitedInInterval);
  const shouldBeRateLimited = !__privateGet(this, _isIntervalIgnored) && __privateGet(this, _intervalCount) >= __privateGet(this, _intervalCap) && __privateGet(this, _queue2).size > 0;
  if (shouldBeRateLimited !== previous) {
    __privateSet(this, _rateLimitedInInterval, shouldBeRateLimited);
    this.emit(shouldBeRateLimited ? "rateLimit" : "rateLimitCleared");
  }
};

// ../../node_modules/@libp2p/floodsub/dist/src/cache.js
var SimpleTimeCache2 = class {
  constructor(options2) {
    __publicField(this, "entries");
    __publicField(this, "validityMs");
    __publicField(this, "lastPruneTime", 0);
    this.entries = /* @__PURE__ */ new Map();
    this.validityMs = options2.validityMs;
  }
  put(key, value2) {
    this.entries.set(key, { value: value2, validUntilMs: Date.now() + this.validityMs });
    this.prune();
  }
  prune() {
    const now = Date.now();
    if (now - this.lastPruneTime < 200) {
      return;
    }
    this.lastPruneTime = now;
    for (const [k, v] of this.entries.entries()) {
      if (v.validUntilMs < now) {
        this.entries.delete(k);
      } else {
        break;
      }
    }
  }
  has(key) {
    return this.entries.has(key);
  }
  get(key) {
    const value2 = this.entries.get(key);
    return value2 != null && value2.validUntilMs >= Date.now() ? value2.value : void 0;
  }
  clear() {
    this.entries = /* @__PURE__ */ new Map();
    this.lastPruneTime = 0;
  }
};

// ../../node_modules/@libp2p/floodsub/dist/src/message/rpc.js
var RPC2;
(function(RPC4) {
  let SubOpts;
  (function(SubOpts2) {
    let _codec2;
    SubOpts2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.subscribe != null) {
            w.uint32(8);
            w.bool(obj.subscribe);
          }
          if (obj.topic != null) {
            w.uint32(18);
            w.string(obj.topic);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.subscribe = reader.bool();
                break;
              }
              case 2: {
                obj.topic = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    SubOpts2.encode = (obj) => {
      return encodeMessage(obj, SubOpts2.codec());
    };
    SubOpts2.decode = (buf2, opts) => {
      return decodeMessage(buf2, SubOpts2.codec(), opts);
    };
  })(SubOpts = RPC4.SubOpts || (RPC4.SubOpts = {}));
  let Message4;
  (function(Message5) {
    let _codec2;
    Message5.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.from != null) {
            w.uint32(10);
            w.bytes(obj.from);
          }
          if (obj.data != null) {
            w.uint32(18);
            w.bytes(obj.data);
          }
          if (obj.sequenceNumber != null) {
            w.uint32(26);
            w.bytes(obj.sequenceNumber);
          }
          if (obj.topic != null) {
            w.uint32(34);
            w.string(obj.topic);
          }
          if (obj.signature != null) {
            w.uint32(42);
            w.bytes(obj.signature);
          }
          if (obj.key != null) {
            w.uint32(50);
            w.bytes(obj.key);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.from = reader.bytes();
                break;
              }
              case 2: {
                obj.data = reader.bytes();
                break;
              }
              case 3: {
                obj.sequenceNumber = reader.bytes();
                break;
              }
              case 4: {
                obj.topic = reader.string();
                break;
              }
              case 5: {
                obj.signature = reader.bytes();
                break;
              }
              case 6: {
                obj.key = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Message5.encode = (obj) => {
      return encodeMessage(obj, Message5.codec());
    };
    Message5.decode = (buf2, opts) => {
      return decodeMessage(buf2, Message5.codec(), opts);
    };
  })(Message4 = RPC4.Message || (RPC4.Message = {}));
  let _codec;
  RPC4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.subscriptions != null) {
          for (const value2 of obj.subscriptions) {
            w.uint32(10);
            RPC4.SubOpts.codec().encode(value2, w);
          }
        }
        if (obj.messages != null) {
          for (const value2 of obj.messages) {
            w.uint32(18);
            RPC4.Message.codec().encode(value2, w);
          }
        }
        if (obj.control != null) {
          w.uint32(26);
          ControlMessage.codec().encode(obj.control, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          subscriptions: [],
          messages: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.subscriptions != null && obj.subscriptions.length === opts.limits.subscriptions) {
                throw new MaxLengthError('Decode error - map field "subscriptions" had too many elements');
              }
              obj.subscriptions.push(RPC4.SubOpts.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.subscriptions$
              }));
              break;
            }
            case 2: {
              if (opts.limits?.messages != null && obj.messages.length === opts.limits.messages) {
                throw new MaxLengthError('Decode error - map field "messages" had too many elements');
              }
              obj.messages.push(RPC4.Message.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.messages$
              }));
              break;
            }
            case 3: {
              obj.control = ControlMessage.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.control
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  RPC4.encode = (obj) => {
    return encodeMessage(obj, RPC4.codec());
  };
  RPC4.decode = (buf2, opts) => {
    return decodeMessage(buf2, RPC4.codec(), opts);
  };
})(RPC2 || (RPC2 = {}));
var ControlMessage;
(function(ControlMessage2) {
  let _codec;
  ControlMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.ihave != null) {
          for (const value2 of obj.ihave) {
            w.uint32(10);
            ControlIHave.codec().encode(value2, w);
          }
        }
        if (obj.iwant != null) {
          for (const value2 of obj.iwant) {
            w.uint32(18);
            ControlIWant.codec().encode(value2, w);
          }
        }
        if (obj.graft != null) {
          for (const value2 of obj.graft) {
            w.uint32(26);
            ControlGraft.codec().encode(value2, w);
          }
        }
        if (obj.prune != null) {
          for (const value2 of obj.prune) {
            w.uint32(34);
            ControlPrune.codec().encode(value2, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          ihave: [],
          iwant: [],
          graft: [],
          prune: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.ihave != null && obj.ihave.length === opts.limits.ihave) {
                throw new MaxLengthError('Decode error - map field "ihave" had too many elements');
              }
              obj.ihave.push(ControlIHave.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.ihave$
              }));
              break;
            }
            case 2: {
              if (opts.limits?.iwant != null && obj.iwant.length === opts.limits.iwant) {
                throw new MaxLengthError('Decode error - map field "iwant" had too many elements');
              }
              obj.iwant.push(ControlIWant.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.iwant$
              }));
              break;
            }
            case 3: {
              if (opts.limits?.graft != null && obj.graft.length === opts.limits.graft) {
                throw new MaxLengthError('Decode error - map field "graft" had too many elements');
              }
              obj.graft.push(ControlGraft.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.graft$
              }));
              break;
            }
            case 4: {
              if (opts.limits?.prune != null && obj.prune.length === opts.limits.prune) {
                throw new MaxLengthError('Decode error - map field "prune" had too many elements');
              }
              obj.prune.push(ControlPrune.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.prune$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ControlMessage2.encode = (obj) => {
    return encodeMessage(obj, ControlMessage2.codec());
  };
  ControlMessage2.decode = (buf2, opts) => {
    return decodeMessage(buf2, ControlMessage2.codec(), opts);
  };
})(ControlMessage || (ControlMessage = {}));
var ControlIHave;
(function(ControlIHave2) {
  let _codec;
  ControlIHave2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.topic != null) {
          w.uint32(10);
          w.string(obj.topic);
        }
        if (obj.messageIDs != null) {
          for (const value2 of obj.messageIDs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          messageIDs: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.topic = reader.string();
              break;
            }
            case 2: {
              if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {
                throw new MaxLengthError('Decode error - map field "messageIDs" had too many elements');
              }
              obj.messageIDs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ControlIHave2.encode = (obj) => {
    return encodeMessage(obj, ControlIHave2.codec());
  };
  ControlIHave2.decode = (buf2, opts) => {
    return decodeMessage(buf2, ControlIHave2.codec(), opts);
  };
})(ControlIHave || (ControlIHave = {}));
var ControlIWant;
(function(ControlIWant2) {
  let _codec;
  ControlIWant2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.messageIDs != null) {
          for (const value2 of obj.messageIDs) {
            w.uint32(10);
            w.bytes(value2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          messageIDs: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {
                throw new MaxLengthError('Decode error - map field "messageIDs" had too many elements');
              }
              obj.messageIDs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ControlIWant2.encode = (obj) => {
    return encodeMessage(obj, ControlIWant2.codec());
  };
  ControlIWant2.decode = (buf2, opts) => {
    return decodeMessage(buf2, ControlIWant2.codec(), opts);
  };
})(ControlIWant || (ControlIWant = {}));
var ControlGraft;
(function(ControlGraft2) {
  let _codec;
  ControlGraft2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.topic != null) {
          w.uint32(10);
          w.string(obj.topic);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {};
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.topic = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ControlGraft2.encode = (obj) => {
    return encodeMessage(obj, ControlGraft2.codec());
  };
  ControlGraft2.decode = (buf2, opts) => {
    return decodeMessage(buf2, ControlGraft2.codec(), opts);
  };
})(ControlGraft || (ControlGraft = {}));
var ControlPrune;
(function(ControlPrune2) {
  let _codec;
  ControlPrune2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.topic != null) {
          w.uint32(10);
          w.string(obj.topic);
        }
        if (obj.peers != null) {
          for (const value2 of obj.peers) {
            w.uint32(18);
            PeerInfo.codec().encode(value2, w);
          }
        }
        if (obj.backoff != null) {
          w.uint32(24);
          w.uint64(obj.backoff);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          peers: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.topic = reader.string();
              break;
            }
            case 2: {
              if (opts.limits?.peers != null && obj.peers.length === opts.limits.peers) {
                throw new MaxLengthError('Decode error - map field "peers" had too many elements');
              }
              obj.peers.push(PeerInfo.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.peers$
              }));
              break;
            }
            case 3: {
              obj.backoff = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ControlPrune2.encode = (obj) => {
    return encodeMessage(obj, ControlPrune2.codec());
  };
  ControlPrune2.decode = (buf2, opts) => {
    return decodeMessage(buf2, ControlPrune2.codec(), opts);
  };
})(ControlPrune || (ControlPrune = {}));
var PeerInfo;
(function(PeerInfo3) {
  let _codec;
  PeerInfo3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.peerID != null) {
          w.uint32(10);
          w.bytes(obj.peerID);
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(18);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {};
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.peerID = reader.bytes();
              break;
            }
            case 2: {
              obj.signedPeerRecord = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerInfo3.encode = (obj) => {
    return encodeMessage(obj, PeerInfo3.codec());
  };
  PeerInfo3.decode = (buf2, opts) => {
    return decodeMessage(buf2, PeerInfo3.codec(), opts);
  };
})(PeerInfo || (PeerInfo = {}));

// ../../node_modules/@libp2p/floodsub/dist/src/peer-streams.js
var PeerStreams = class extends TypedEventEmitter {
  constructor(peerId) {
    super();
    __publicField(this, "peerId");
    /**
     * An AbortController for controlled shutdown of the inbound stream
     */
    __publicField(this, "shutDownController");
    // messages sent by the remote
    __publicField(this, "inboundPb");
    // messages we send
    __publicField(this, "outboundPb");
    this.peerId = peerId;
    this.shutDownController = new AbortController();
  }
  attachInboundStream(stream, streamOpts) {
    this.inboundPb = pbStream(stream, streamOpts).pb(RPC2);
    Promise.resolve().then(async () => {
      while (true) {
        if (this.inboundPb == null) {
          return;
        }
        const message2 = await this.inboundPb.read({
          signal: this.shutDownController.signal
        });
        this.safeDispatchEvent("message", {
          detail: message2
        });
      }
    }).catch((err) => {
      this.inboundPb?.unwrap().unwrap().abort(err);
    });
  }
  attachOutboundStream(stream, streamOpts) {
    this.outboundPb = pbStream(stream, streamOpts).pb(RPC2);
  }
  /**
   * Send a message to this peer
   */
  write(message2) {
    if (this.outboundPb == null) {
      return;
    }
    this.outboundPb.write(message2, {
      signal: this.shutDownController.signal
    }).catch((err) => {
      this.outboundPb?.unwrap().unwrap().abort(err);
    });
  }
  /**
   * Closes the open connection to peer
   */
  close() {
    this.shutDownController.abort();
    Promise.all([
      this.inboundPb?.unwrap().unwrap().close().catch((err) => {
        this.inboundPb?.unwrap().unwrap().abort(err);
      }),
      this.outboundPb?.unwrap().unwrap().close().catch((err) => {
        this.inboundPb?.unwrap().unwrap().abort(err);
      })
    ]).finally(() => {
      this.safeDispatchEvent("close");
    });
  }
};

// ../../node_modules/@libp2p/floodsub/dist/src/utils.js
function randomSeqno2() {
  return BigInt(`0x${toString2(randomBytes2(8), "base16")}`);
}
var msgId2 = (key, seqno) => {
  const seqnoBytes = fromString2(seqno.toString(16).padStart(16, "0"), "base16");
  const keyBytes = publicKeyToProtobuf(key);
  const msgId3 = new Uint8Array(keyBytes.byteLength + seqnoBytes.length);
  msgId3.set(keyBytes, 0);
  msgId3.set(seqnoBytes, keyBytes.byteLength);
  return msgId3;
};
var noSignMsgId2 = (data) => {
  return sha256.encode(data);
};
var anyMatch2 = (a2, b) => {
  let bHas;
  if (Array.isArray(b)) {
    bHas = (val) => b.includes(val);
  } else {
    bHas = (val) => b.has(val);
  }
  for (const val of a2) {
    if (bHas(val)) {
      return true;
    }
  }
  return false;
};
var isSigned2 = async (message2) => {
  if (message2.sequenceNumber == null || message2.from == null || message2.signature == null) {
    return false;
  }
  const fromID = peerIdFromMultihash3(decode4(message2.from));
  if (fromID.publicKey != null) {
    return true;
  }
  if (message2.key != null) {
    const signingKey = message2.key;
    const signingID = peerIdFromPublicKey3(publicKeyFromProtobuf(signingKey));
    return signingID.equals(fromID);
  }
  return false;
};
var toMessage2 = async (message2) => {
  if (message2.from == null) {
    throw new InvalidMessageError2("RPC message was missing from");
  }
  if (!await isSigned2(message2)) {
    return {
      type: "unsigned",
      topic: message2.topic ?? "",
      data: message2.data ?? new Uint8Array(0)
    };
  }
  const from3 = peerIdFromMultihash3(decode4(message2.from));
  const key = message2.key ?? from3.publicKey;
  if (key == null) {
    throw new InvalidMessageError2("RPC message was missing public key");
  }
  const msg = {
    type: "signed",
    from: from3,
    topic: message2.topic ?? "",
    sequenceNumber: bigIntFromBytes2(message2.sequenceNumber ?? new Uint8Array(0)),
    data: message2.data ?? new Uint8Array(0),
    signature: message2.signature ?? new Uint8Array(0),
    key: key instanceof Uint8Array ? publicKeyFromProtobuf(key) : key
  };
  return msg;
};
var toRpcMessage2 = (message2) => {
  if (message2.type === "signed") {
    return {
      from: message2.from.toMultihash().bytes,
      data: message2.data,
      sequenceNumber: bigIntToBytes2(message2.sequenceNumber),
      topic: message2.topic,
      signature: message2.signature,
      key: message2.key ? publicKeyToProtobuf(message2.key) : void 0
    };
  }
  return {
    data: message2.data,
    topic: message2.topic
  };
};
var bigIntToBytes2 = (num2) => {
  let str = num2.toString(16);
  if (str.length % 2 !== 0) {
    str = `0${str}`;
  }
  return fromString2(str, "base16");
};
var bigIntFromBytes2 = (num2) => {
  return BigInt(`0x${toString2(num2, "base16")}`);
};

// ../../node_modules/@libp2p/floodsub/dist/src/sign.js
var SignPrefix2 = fromString2("libp2p-pubsub:");
async function signMessage(privateKey, message2, encode13) {
  const outputMessage = {
    type: "signed",
    topic: message2.topic,
    data: message2.data,
    sequenceNumber: message2.sequenceNumber,
    from: peerIdFromPrivateKey3(privateKey)
  };
  const bytes = concat([
    SignPrefix2,
    encode13(toRpcMessage2(outputMessage)).subarray()
  ]);
  outputMessage.signature = await privateKey.sign(bytes);
  outputMessage.key = privateKey.publicKey;
  return outputMessage;
}
async function verifySignature(message2, encode13) {
  if (message2.type !== "signed") {
    throw new Error('Message type must be "signed" to be verified');
  }
  if (message2.signature == null) {
    throw new Error("Message must contain a signature to be verified");
  }
  if (message2.from == null) {
    throw new Error("Message must contain a from property to be verified");
  }
  const bytes = concat([
    SignPrefix2,
    encode13({
      ...toRpcMessage2(message2),
      signature: void 0,
      key: void 0
    }).subarray()
  ]);
  const pubKey = messagePublicKey(message2);
  return pubKey.verify(bytes, message2.signature);
}
function messagePublicKey(message2) {
  if (message2.type !== "signed") {
    throw new Error('Message type must be "signed" to have a public key');
  }
  if (message2.from == null) {
    throw new Error("Could not get the public key from the originator id");
  }
  if (message2.key != null) {
    return message2.key;
  }
  if (message2.from.publicKey != null) {
    return message2.from.publicKey;
  }
  throw new Error("Could not get the public key from the originator id");
}

// ../../node_modules/@libp2p/floodsub/dist/src/floodsub.js
var _a14, _b11, _c7, _d4, _e;
var FloodSub = class extends (_e = TypedEventEmitter, _d4 = pubSubSymbol2, _c7 = Symbol.toStringTag, _b11 = serviceCapabilities2, _a14 = serviceDependencies2, _e) {
  constructor(components, init) {
    super();
    __publicField(this, "log");
    __publicField(this, "started");
    /**
     * Map of topics to which peers are subscribed to
     */
    __publicField(this, "topics");
    /**
     * List of our subscriptions
     */
    __publicField(this, "subscriptions");
    /**
     * Map of peer streams
     */
    __publicField(this, "peers");
    /**
     * The signature policy to follow by default
     */
    __publicField(this, "globalSignaturePolicy");
    /**
     * If router can relay received messages, even if not subscribed
     */
    __publicField(this, "canRelayMessage");
    /**
     * if publish should emit to self, if subscribed
     */
    __publicField(this, "emitSelf");
    /**
     * Topic validator map
     *
     * Keyed by topic
     * Topic validators are functions with the following input:
     */
    __publicField(this, "topicValidators");
    __publicField(this, "queue");
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "_registrarTopologyId");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "seenCache");
    __publicField(this, _d4, true);
    __publicField(this, _c7, "@libp2p/floodsub");
    __publicField(this, _b11, [
      "@libp2p/pubsub"
    ]);
    __publicField(this, _a14, [
      "@libp2p/identify"
    ]);
    this.log = components.logger.forComponent("libp2p:floodsub");
    this.components = components;
    this.protocol = init.protocol ?? protocol;
    this.started = false;
    this.topics = /* @__PURE__ */ new Map();
    this.subscriptions = /* @__PURE__ */ new Set();
    this.peers = new PeerMap();
    this.globalSignaturePolicy = init.globalSignaturePolicy === "StrictNoSign" ? "StrictNoSign" : "StrictSign";
    this.canRelayMessage = init.canRelayMessage ?? true;
    this.emitSelf = init.emitSelf ?? false;
    this.topicValidators = /* @__PURE__ */ new Map();
    this.queue = new PQueue({
      concurrency: init.messageProcessingConcurrency ?? 10
    });
    this.maxInboundStreams = init.maxInboundStreams ?? 1;
    this.maxOutboundStreams = init.maxOutboundStreams ?? 1;
    this.seenCache = new SimpleTimeCache2({
      validityMs: init?.seenTTL ?? 3e4
    });
    this._onIncomingStream = this._onIncomingStream.bind(this);
    this._onPeerConnected = this._onPeerConnected.bind(this);
    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
  }
  // LIFECYCLE METHODS
  /**
   * Register the pubsub protocol onto the libp2p node.
   */
  async start() {
    if (this.started) {
      return;
    }
    this.log("starting");
    await this.components.registrar.handle(this.protocol, this._onIncomingStream, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams
    });
    this._registrarTopologyId = await this.components.registrar.register(this.protocol, {
      onConnect: this._onPeerConnected,
      onDisconnect: this._onPeerDisconnected
    });
    this.log("started");
    this.started = true;
  }
  /**
   * Unregister the pubsub protocol and the streams with other peers will be closed.
   */
  async stop() {
    if (!this.started) {
      return;
    }
    const registrar = this.components.registrar;
    if (this._registrarTopologyId != null) {
      registrar.unregister(this._registrarTopologyId);
    }
    await registrar.unhandle(this.protocol);
    this.log("stopping");
    for (const peerStreams of this.peers.values()) {
      peerStreams.close();
    }
    this.peers.clear();
    this.subscriptions = /* @__PURE__ */ new Set();
    this.started = false;
    this.log("stopped");
  }
  isStarted() {
    return this.started;
  }
  /**
   * On an inbound stream opened
   */
  _onIncomingStream(stream, connection) {
    const peerStreams = this.addPeer(connection.remotePeer, stream);
    peerStreams.attachInboundStream(stream);
  }
  /**
   * Registrar notifies an established connection with pubsub protocol
   */
  async _onPeerConnected(peerId, conn) {
    this.log("connected %p", peerId);
    if (conn.streams.find((stream2) => stream2.direction === "outbound" && stream2.protocol === this.protocol)) {
      this.log("outbound pubsub stream already present on connection from %p", peerId);
      return;
    }
    const stream = await conn.newStream(this.protocol);
    const peerStreams = this.addPeer(peerId, stream);
    peerStreams.attachOutboundStream(stream);
    this.send(peerId, {
      subscriptions: Array.from(this.subscriptions).map((sub) => sub.toString()),
      subscribe: true
    });
  }
  /**
   * Registrar notifies a closing connection with pubsub protocol
   */
  _onPeerDisconnected(peerId, conn) {
    this.log("connection ended %p", peerId);
    this._removePeer(peerId);
  }
  /**
   * Notifies the router that a peer has been connected
   */
  addPeer(peerId, stream) {
    const existing = this.peers.get(peerId);
    if (existing != null) {
      return existing;
    }
    this.log("new peer %p", peerId);
    const peerStreams = new PeerStreams(peerId);
    this.peers.set(peerId, peerStreams);
    peerStreams.addEventListener("message", (evt) => {
      const rpcMsg = evt.detail;
      const messages2 = [];
      for (const msg of rpcMsg.messages ?? []) {
        if (msg.from == null || msg.data == null || msg.topic == null) {
          this.log("message from %p was missing from, data or topic fields, dropping", peerId);
          continue;
        }
        messages2.push({
          from: msg.from,
          data: msg.data,
          topic: msg.topic,
          sequenceNumber: msg.sequenceNumber ?? void 0,
          signature: msg.signature ?? void 0,
          key: msg.key ?? void 0
        });
      }
      this.processRpc(peerStreams, {
        subscriptions: (rpcMsg.subscriptions ?? []).map((sub) => ({
          subscribe: Boolean(sub.subscribe),
          topic: sub.topic ?? ""
        })),
        messages: messages2
      }).catch((err) => {
        this.log(err);
      });
    });
    peerStreams.addEventListener("close", () => this._removePeer(peerId), {
      once: true
    });
    return peerStreams;
  }
  /**
   * Notifies the router that a peer has been disconnected
   */
  _removePeer(peerId) {
    const peerStreams = this.peers.get(peerId);
    if (peerStreams == null) {
      return;
    }
    peerStreams.close();
    this.log("delete peer %p", peerId);
    this.peers.delete(peerId);
    for (const peers of this.topics.values()) {
      peers.delete(peerId);
    }
  }
  /**
   * Handles an rpc request from a peer
   */
  async processRpc(peerStream, rpc) {
    this.log("rpc from %p", peerStream.peerId);
    const { subscriptions, messages: messages2 } = rpc;
    if (subscriptions != null && subscriptions.length > 0) {
      this.log("subscription update from %p", peerStream.peerId);
      subscriptions.forEach((subOpt) => {
        this.processRpcSubOpt(peerStream.peerId, subOpt);
      });
      super.dispatchEvent(new CustomEvent("subscription-change", {
        detail: {
          peerId: peerStream.peerId,
          subscriptions: subscriptions.map(({ topic, subscribe }) => ({
            topic: `${topic ?? ""}`,
            subscribe: Boolean(subscribe)
          }))
        }
      }));
    }
    if (messages2 != null && messages2.length > 0) {
      this.log("messages from %p", peerStream.peerId);
      this.queue.addAll(messages2.map((message2) => async () => {
        if (message2.topic == null || !this.subscriptions.has(message2.topic) && !this.canRelayMessage) {
          this.log("received message we didn't subscribe to. Dropping.");
          return false;
        }
        try {
          const msg = await toMessage2(message2);
          await this.processMessage(peerStream.peerId, msg);
        } catch (err) {
          this.log.error("failed to queue messages from %p - %e", peerStream.peerId, err);
        }
      })).catch((err) => {
        this.log(err);
      });
    }
    return true;
  }
  /**
   * Handles a subscription change from a peer
   */
  processRpcSubOpt(id, subOpt) {
    const t2 = subOpt.topic;
    if (t2 == null) {
      return;
    }
    let topicSet = this.topics.get(t2);
    if (topicSet == null) {
      topicSet = new PeerSet();
      this.topics.set(t2, topicSet);
    }
    if (subOpt.subscribe === true) {
      topicSet.add(id);
    } else {
      topicSet.delete(id);
    }
  }
  /**
   * Handles a message from a peer
   */
  async processMessage(from3, msg) {
    if (this.components.peerId.equals(from3) && !this.emitSelf) {
      return;
    }
    const seqno = await this.getMsgId(msg);
    const msgIdStr = toString2(seqno, "base64");
    if (this.seenCache.has(msgIdStr)) {
      return;
    }
    this.seenCache.put(msgIdStr, true);
    try {
      await this.validate(from3, msg);
    } catch (err) {
      this.log("Message is invalid, dropping it. %O", err);
      return;
    }
    if (this.subscriptions.has(msg.topic)) {
      const isFromSelf = this.components.peerId.equals(from3);
      if (!isFromSelf || this.emitSelf) {
        super.dispatchEvent(new CustomEvent("message", {
          detail: msg
        }));
      }
    }
    await this.publishMessage(from3, msg);
  }
  /**
   * The default msgID implementation
   * Child class can override this.
   */
  getMsgId(msg) {
    const signaturePolicy = this.globalSignaturePolicy;
    switch (signaturePolicy) {
      case "StrictSign":
        if (msg.type !== "signed") {
          throw new InvalidMessageError2('Message type should be "signed" when signature policy is StrictSign but it was not');
        }
        if (msg.sequenceNumber == null) {
          throw new InvalidMessageError2("Need sequence number when signature policy is StrictSign but it was missing");
        }
        if (msg.key == null) {
          throw new InvalidMessageError2("Need key when signature policy is StrictSign but it was missing");
        }
        return msgId2(msg.key, msg.sequenceNumber);
      case "StrictNoSign":
        return noSignMsgId2(msg.data);
      default:
        throw new InvalidMessageError2("Cannot get message id: unhandled signature policy");
    }
  }
  /**
   * Encode RPC object into a Uint8Array.
   * This can be override to use a custom router protobuf.
   */
  encodeMessage(rpc) {
    return RPC2.Message.encode(rpc);
  }
  /**
   * Send an rpc object to a peer
   */
  send(peer, data) {
    const { messages: messages2, subscriptions, subscribe } = data;
    this.sendRpc(peer, {
      subscriptions: (subscriptions ?? []).map((str) => ({ topic: str, subscribe: Boolean(subscribe) })),
      messages: (messages2 ?? []).map(toRpcMessage2)
    });
  }
  /**
   * Send an rpc object to a peer
   */
  sendRpc(peer, rpc) {
    const peerStreams = this.peers.get(peer);
    if (peerStreams == null) {
      this.log.error("cannot send RPC to %p as there are no streams to it available", peer);
      return;
    }
    peerStreams.write(rpc);
  }
  /**
   * Validates the given message. The signature will be checked for authenticity.
   * Throws an error on invalid messages
   */
  async validate(from3, message2) {
    const signaturePolicy = this.globalSignaturePolicy;
    switch (signaturePolicy) {
      case "StrictNoSign":
        if (message2.type !== "unsigned") {
          throw new InvalidMessageError2('Message type should be "unsigned" when signature policy is StrictNoSign but it was not');
        }
        if (message2.signature != null) {
          throw new InvalidMessageError2("StrictNoSigning: signature should not be present");
        }
        if (message2.key != null) {
          throw new InvalidMessageError2("StrictNoSigning: key should not be present");
        }
        if (message2.sequenceNumber != null) {
          throw new InvalidMessageError2("StrictNoSigning: seqno should not be present");
        }
        break;
      case "StrictSign":
        if (message2.type !== "signed") {
          throw new InvalidMessageError2('Message type should be "signed" when signature policy is StrictSign but it was not');
        }
        if (message2.signature == null) {
          throw new InvalidMessageError2("StrictSigning: Signing required and no signature was present");
        }
        if (message2.sequenceNumber == null) {
          throw new InvalidMessageError2("StrictSigning: Signing required and no sequenceNumber was present");
        }
        if (!await verifySignature(message2, this.encodeMessage.bind(this))) {
          throw new InvalidMessageError2("StrictSigning: Invalid message signature");
        }
        break;
      default:
        throw new InvalidMessageError2("Cannot validate message: unhandled signature policy");
    }
    const validatorFn = this.topicValidators.get(message2.topic);
    if (validatorFn != null) {
      const result = await validatorFn(from3, message2);
      if (result === TopicValidatorResult2.Reject || result === TopicValidatorResult2.Ignore) {
        throw new InvalidMessageError2("Message validation failed");
      }
    }
  }
  /**
   * Normalizes the message and signs it, if signing is enabled.
   * Should be used by the routers to create the message to send.
   */
  async buildMessage(message2) {
    const signaturePolicy = this.globalSignaturePolicy;
    switch (signaturePolicy) {
      case "StrictSign":
        return signMessage(this.components.privateKey, message2, this.encodeMessage.bind(this));
      case "StrictNoSign":
        return Promise.resolve({
          type: "unsigned",
          ...message2
        });
      default:
        throw new InvalidMessageError2("Cannot build message: unhandled signature policy");
    }
  }
  // API METHODS
  /**
   * Get a list of the peer-ids that are subscribed to one topic.
   */
  getSubscribers(topic) {
    if (!this.started) {
      throw new NotStartedError2("not started yet");
    }
    if (topic == null) {
      throw new InvalidParametersError2("Topic is required");
    }
    const peersInTopic = this.topics.get(topic.toString());
    if (peersInTopic == null) {
      return [];
    }
    return Array.from(peersInTopic.values());
  }
  /**
   * Publishes messages to all subscribed peers
   */
  async publish(topic, data) {
    if (!this.started) {
      throw new Error("Pubsub has not started");
    }
    const message2 = {
      from: this.components.peerId,
      topic,
      data: data ?? new Uint8Array(0),
      sequenceNumber: randomSeqno2()
    };
    this.log("publish topic: %s from: %p data: %m", topic, message2.from, message2.data);
    const rpcMessage = await this.buildMessage(message2);
    let emittedToSelf = false;
    if (this.emitSelf) {
      if (this.subscriptions.has(topic)) {
        emittedToSelf = true;
        super.dispatchEvent(new CustomEvent("message", {
          detail: rpcMessage
        }));
      }
    }
    const result = await this.publishMessage(this.components.peerId, rpcMessage);
    if (emittedToSelf) {
      result.recipients = [...result.recipients, this.components.peerId];
    }
    return result;
  }
  /**
   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.
   * For example, a Floodsub implementation might simply publish each message to each topic for every peer.
   *
   * `sender` might be this peer, or we might be forwarding a message on behalf of another peer, in which case sender
   * is the peer we received the message from, which may not be the peer the message was created by.
   */
  async publishMessage(from3, message2) {
    const peers = this.getSubscribers(message2.topic);
    const recipients = [];
    if (peers == null || peers.length === 0) {
      this.log("no peers are subscribed to topic %s", message2.topic);
      return { recipients };
    }
    peers.forEach((id) => {
      if (this.components.peerId.equals(id)) {
        this.log("not sending message on topic %s to myself", message2.topic);
        return;
      }
      if (id.equals(from3)) {
        this.log("not sending message on topic %s to sender %p", message2.topic, id);
        return;
      }
      this.log("publish msgs on topics %s %p", message2.topic, id);
      recipients.push(id);
      this.send(id, { messages: [message2] });
    });
    return { recipients };
  }
  /**
   * Subscribes to a given topic.
   */
  subscribe(topic) {
    if (!this.started) {
      throw new Error("Pubsub has not started");
    }
    if (this.subscriptions.has(topic)) {
      return;
    }
    this.log("subscribe to topic: %s", topic);
    this.subscriptions.add(topic);
    for (const peerId of this.peers.keys()) {
      this.send(peerId, {
        subscriptions: [
          topic
        ],
        subscribe: true
      });
    }
  }
  /**
   * Unsubscribe from the given topic
   */
  unsubscribe(topic) {
    if (!this.started) {
      throw new Error("Pubsub is not started");
    }
    if (!this.subscriptions.has(topic)) {
      return;
    }
    this.log("unsubscribe from %s", topic);
    this.subscriptions.delete(topic);
    for (const peerId of this.peers.keys()) {
      this.send(peerId, {
        subscriptions: [
          topic
        ],
        subscribe: false
      });
    }
  }
  /**
   * Get the list of topics which the peer is subscribed to.
   */
  getTopics() {
    if (!this.started) {
      throw new Error("Pubsub is not started");
    }
    return Array.from(this.subscriptions);
  }
  getPeers() {
    if (!this.started) {
      throw new Error("Pubsub is not started");
    }
    return Array.from(this.peers.keys());
  }
};

// ../../node_modules/@libp2p/floodsub/dist/src/index.js
var protocol = "/floodsub/1.0.0";
var StrictSign2 = "StrictSign";
var StrictNoSign2 = "StrictNoSign";
var TopicValidatorResult2;
(function(TopicValidatorResult3) {
  TopicValidatorResult3["Accept"] = "accept";
  TopicValidatorResult3["Ignore"] = "ignore";
  TopicValidatorResult3["Reject"] = "reject";
})(TopicValidatorResult2 || (TopicValidatorResult2 = {}));
function isPubSub2(obj) {
  return Boolean(obj?.[pubSubSymbol2]);
}
function floodsub(init = {}) {
  return (components) => new FloodSub(components, init);
}

// ../../node_modules/@achingbrain/http-parser-js/http-parser.js
function HTTPParser(type) {
  if (type !== void 0 && type !== HTTPParser.REQUEST && type !== HTTPParser.RESPONSE) {
    throw new Error("type must be REQUEST or RESPONSE");
  }
  if (type === void 0) {
  } else {
    this.initialize(type);
  }
  this.maxHeaderSize = HTTPParser.maxHeaderSize;
}
HTTPParser.prototype.initialize = function(type, async_resource) {
  if (type !== HTTPParser.REQUEST && type !== HTTPParser.RESPONSE) {
    throw new Error("type must be REQUEST or RESPONSE");
  }
  this.type = type;
  this.state = type + "_LINE";
  this.info = {
    headers: [],
    upgrade: false
  };
  this.trailers = [];
  this.line = "";
  this.isChunked = false;
  this.connection = "";
  this.headerSize = 0;
  this.body_bytes = null;
  this.isUserCall = false;
  this.hadError = false;
};
HTTPParser.encoding = "ascii";
HTTPParser.maxHeaderSize = 80 * 1024;
HTTPParser.REQUEST = "REQUEST";
HTTPParser.RESPONSE = "RESPONSE";
var kOnHeaders = HTTPParser.kOnHeaders = 1;
var kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;
var kOnBody = HTTPParser.kOnBody = 3;
var kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;
HTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function() {
};
var compatMode0_12 = true;
Object.defineProperty(HTTPParser, "kOnExecute", {
  get: function() {
    compatMode0_12 = false;
    return 99;
  }
});
var methods = HTTPParser.methods = [
  "DELETE",
  "GET",
  "HEAD",
  "POST",
  "PUT",
  "CONNECT",
  "OPTIONS",
  "TRACE",
  "COPY",
  "LOCK",
  "MKCOL",
  "MOVE",
  "PROPFIND",
  "PROPPATCH",
  "SEARCH",
  "UNLOCK",
  "BIND",
  "REBIND",
  "UNBIND",
  "ACL",
  "REPORT",
  "MKACTIVITY",
  "CHECKOUT",
  "MERGE",
  "M-SEARCH",
  "NOTIFY",
  "SUBSCRIBE",
  "UNSUBSCRIBE",
  "PATCH",
  "PURGE",
  "MKCALENDAR",
  "LINK",
  "UNLINK",
  "SOURCE"
];
var method_connect = methods.indexOf("CONNECT");
HTTPParser.prototype.reinitialize = HTTPParser;
HTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.remove = HTTPParser.prototype.free = function() {
};
HTTPParser.prototype._compatMode0_11 = false;
HTTPParser.prototype.getAsyncId = function() {
  return 0;
};
var headerState = {
  REQUEST_LINE: true,
  RESPONSE_LINE: true,
  HEADER: true
};
HTTPParser.prototype.execute = function(chunk, start2, length4) {
  if (!(this instanceof HTTPParser)) {
    throw new TypeError("not a HTTPParser");
  }
  start2 = start2 || 0;
  length4 = typeof length4 === "number" ? length4 : chunk.length;
  this.chunk = chunk;
  this.offset = start2;
  var end = this.end = start2 + length4;
  try {
    while (this.offset < end) {
      if (this[this.state]()) {
        break;
      }
    }
  } catch (err) {
    if (this.isUserCall) {
      throw err;
    }
    this.hadError = true;
    return err;
  }
  this.chunk = null;
  length4 = this.offset - start2;
  if (headerState[this.state]) {
    this.headerSize += length4;
    if (this.headerSize > (this.maxHeaderSize || HTTPParser.maxHeaderSize)) {
      return new Error("max header size exceeded");
    }
  }
  return length4;
};
var stateFinishAllowed = {
  REQUEST_LINE: true,
  RESPONSE_LINE: true,
  BODY_RAW: true
};
HTTPParser.prototype.finish = function() {
  if (this.hadError) {
    return;
  }
  if (!stateFinishAllowed[this.state]) {
    return new Error("invalid state for EOF");
  }
  if (this.state === "BODY_RAW") {
    this.userCall()(this[kOnMessageComplete]());
  }
};
HTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function() {
};
HTTPParser.prototype.userCall = function() {
  this.isUserCall = true;
  var self2 = this;
  return function(ret) {
    self2.isUserCall = false;
    return ret;
  };
};
HTTPParser.prototype.nextRequest = function() {
  this.userCall()(this[kOnMessageComplete]());
  this.reinitialize(this.type);
};
HTTPParser.prototype.consumeLine = function() {
  var end = this.end, chunk = this.chunk;
  for (var i2 = this.offset; i2 < end; i2++) {
    if (chunk[i2] === 10) {
      var line = this.line + toString2(chunk.subarray(this.offset, i2), HTTPParser.encoding);
      if (line.charAt(line.length - 1) === "\r") {
        line = line.substr(0, line.length - 1);
      }
      this.line = "";
      this.offset = i2 + 1;
      return line;
    }
  }
  this.line += toString2(chunk.subarray(this.offset, this.end), HTTPParser.encoding);
  this.offset = this.end;
};
var headerExp = /^([^: \t]+):[ \t]*((?:.*[^ \t])|)/;
var headerContinueExp = /^[ \t]+(.*[^ \t])/;
HTTPParser.prototype.parseHeader = function(line, headers) {
  if (line.indexOf("\r") !== -1) {
    throw parseErrorCode("HPE_LF_EXPECTED");
  }
  var match = headerExp.exec(line);
  var k = match && match[1];
  if (k) {
    headers.push(k);
    headers.push(match[2]);
  } else {
    var matchContinue = headerContinueExp.exec(line);
    if (matchContinue && headers.length) {
      if (headers[headers.length - 1]) {
        headers[headers.length - 1] += " ";
      }
      headers[headers.length - 1] += matchContinue[1];
    }
  }
};
var requestExp = /^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/;
HTTPParser.prototype.REQUEST_LINE = function() {
  var line = this.consumeLine();
  if (!line) {
    return;
  }
  var match = requestExp.exec(line);
  if (match === null) {
    throw parseErrorCode("HPE_INVALID_CONSTANT");
  }
  this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);
  if (this.info.method === -1) {
    throw new Error("invalid request method");
  }
  this.info.url = match[2];
  this.info.versionMajor = +match[3];
  this.info.versionMinor = +match[4];
  this.body_bytes = 0;
  this.state = "HEADER";
};
var responseExp = /^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/;
HTTPParser.prototype.RESPONSE_LINE = function() {
  var line = this.consumeLine();
  if (!line) {
    return;
  }
  var match = responseExp.exec(line);
  if (match === null) {
    throw parseErrorCode("HPE_INVALID_CONSTANT");
  }
  this.info.versionMajor = +match[1];
  this.info.versionMinor = +match[2];
  var statusCode = this.info.statusCode = +match[3];
  this.info.statusMessage = match[4];
  if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {
    this.body_bytes = 0;
  }
  this.state = "HEADER";
};
HTTPParser.prototype.shouldKeepAlive = function() {
  if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {
    if (this.connection.indexOf("close") !== -1) {
      return false;
    }
  } else if (this.connection.indexOf("keep-alive") === -1) {
    return false;
  }
  if (this.body_bytes !== null || this.isChunked) {
    return true;
  }
  return false;
};
HTTPParser.prototype.HEADER = function() {
  var line = this.consumeLine();
  if (line === void 0) {
    return;
  }
  var info = this.info;
  if (line) {
    this.parseHeader(line, info.headers);
  } else {
    var headers = info.headers;
    var hasContentLength = false;
    var currentContentLengthValue;
    var hasUpgradeHeader = false;
    for (var i2 = 0; i2 < headers.length; i2 += 2) {
      switch (headers[i2].toLowerCase()) {
        case "transfer-encoding":
          this.isChunked = headers[i2 + 1].toLowerCase() === "chunked";
          break;
        case "content-length":
          currentContentLengthValue = +headers[i2 + 1];
          if (hasContentLength) {
            if (currentContentLengthValue !== this.body_bytes) {
              throw parseErrorCode("HPE_UNEXPECTED_CONTENT_LENGTH");
            }
          } else {
            hasContentLength = true;
            this.body_bytes = currentContentLengthValue;
          }
          break;
        case "connection":
          this.connection += headers[i2 + 1].toLowerCase();
          break;
        case "upgrade":
          hasUpgradeHeader = true;
          break;
      }
    }
    if (this.isChunked && hasContentLength) {
      hasContentLength = false;
      this.body_bytes = null;
    }
    if (hasUpgradeHeader && this.connection.indexOf("upgrade") != -1) {
      info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;
    } else {
      info.upgrade = info.method === method_connect;
    }
    if (this.isChunked && info.upgrade) {
      this.isChunked = false;
    }
    info.shouldKeepAlive = this.shouldKeepAlive();
    var skipBody;
    if (compatMode0_12) {
      skipBody = this.userCall()(this[kOnHeadersComplete](info));
    } else {
      skipBody = this.userCall()(this[kOnHeadersComplete](
        info.versionMajor,
        info.versionMinor,
        info.headers,
        info.method,
        info.url,
        info.statusCode,
        info.statusMessage,
        info.upgrade,
        info.shouldKeepAlive
      ));
    }
    if (skipBody === 2) {
      this.nextRequest();
      return true;
    } else if (this.isChunked && !skipBody) {
      this.state = "BODY_CHUNKHEAD";
    } else if (skipBody || this.body_bytes === 0) {
      this.nextRequest();
      return info.upgrade;
    } else if (this.body_bytes === null) {
      this.state = "BODY_RAW";
    } else {
      this.state = "BODY_SIZED";
    }
  }
};
HTTPParser.prototype.BODY_CHUNKHEAD = function() {
  var line = this.consumeLine();
  if (line === void 0) {
    return;
  }
  this.body_bytes = parseInt(line, 16);
  if (!this.body_bytes) {
    this.state = "BODY_CHUNKTRAILERS";
  } else {
    this.state = "BODY_CHUNK";
  }
};
HTTPParser.prototype.BODY_CHUNK = function() {
  var length4 = Math.min(this.end - this.offset, this.body_bytes);
  this.userCall()(this[kOnBody](this.chunk.slice(this.offset, this.offset + length4), 0, length4));
  this.offset += length4;
  this.body_bytes -= length4;
  if (!this.body_bytes) {
    this.state = "BODY_CHUNKEMPTYLINE";
  }
};
HTTPParser.prototype.BODY_CHUNKEMPTYLINE = function() {
  var line = this.consumeLine();
  if (line === void 0) {
    return;
  }
  if (line !== "") {
    throw new Error("Expected empty line");
  }
  this.state = "BODY_CHUNKHEAD";
};
HTTPParser.prototype.BODY_CHUNKTRAILERS = function() {
  var line = this.consumeLine();
  if (line === void 0) {
    return;
  }
  if (line) {
    this.parseHeader(line, this.trailers);
  } else {
    if (this.trailers.length) {
      this.userCall()(this[kOnHeaders](this.trailers, ""));
    }
    this.nextRequest();
  }
};
HTTPParser.prototype.BODY_RAW = function() {
  this.userCall()(this[kOnBody](this.chunk.slice(this.offset, this.end), 0, this.end - this.offset));
  this.offset = this.end;
};
HTTPParser.prototype.BODY_SIZED = function() {
  var length4 = Math.min(this.end - this.offset, this.body_bytes);
  this.userCall()(this[kOnBody](this.chunk.slice(this.offset, this.offset + length4), 0, length4));
  this.offset += length4;
  this.body_bytes -= length4;
  if (!this.body_bytes) {
    this.nextRequest();
  }
};
["Headers", "HeadersComplete", "Body", "MessageComplete"].forEach(function(name5) {
  var k = HTTPParser["kOn" + name5];
  Object.defineProperty(HTTPParser.prototype, "on" + name5, {
    get: function() {
      return this[k];
    },
    set: function(to) {
      this._compatMode0_11 = true;
      method_connect = "CONNECT";
      return this[k] = to;
    }
  });
});
function parseErrorCode(code5) {
  var err = new Error("Parse Error");
  err.code = code5;
  return err;
}

// ../../node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
var ASSUME_HTTP_CODES = [
  CODE_TCP2,
  CODE_DNS2,
  CODE_DNSADDR2,
  CODE_DNS42,
  CODE_DNS62
];
function extractSNI(ma) {
  return extractTuple("sni", ma)?.value;
}
function extractPort(ma) {
  const port = extractTuple("tcp", ma)?.value;
  if (port == null) {
    return "";
  }
  return `:${port}`;
}
function extractTuple(name5, ma) {
  return ma.find((component) => component.name === name5);
}
function hasTLS(ma) {
  return ma.some(({ code: code5 }) => code5 === CODE_TLS2);
}
function interpretNext(head, rest) {
  const interpreter = interpreters[head.name];
  if (interpreter == null) {
    throw new Error(`Can't interpret protocol ${head.name}`);
  }
  const restVal = interpreter(head, rest);
  if (head.code === CODE_IP62) {
    return `[${restVal}]`;
  }
  return restVal;
}
var interpreters = {
  ip4: (head, rest) => head.value,
  ip6: (head, rest) => {
    if (rest.length === 0) {
      return head.value;
    }
    return `[${head.value}]`;
  },
  tcp: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tail, rest)}:${head.value}`;
  },
  udp: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tail, rest)}:${head.value}`;
  },
  dnsaddr: (head, rest) => head.value,
  dns4: (head, rest) => head.value,
  dns6: (head, rest) => head.value,
  dns: (head, rest) => head.value,
  ipfs: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tail, rest)}`;
  },
  p2p: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tail, rest)}`;
  },
  http: (head, rest) => {
    const maHasTLS = hasTLS(rest);
    const sni = extractSNI(rest);
    const port = extractPort(rest);
    if (maHasTLS && sni != null) {
      return `https://${sni}${port}`;
    }
    const protocol2 = maHasTLS ? "https://" : "http://";
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `${protocol2}${baseVal}`;
  },
  "http-path": (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    const baseVal = interpretNext(tail, rest);
    const decodedValue = decodeURIComponent(head.value ?? "");
    return `${baseVal}${decodedValue}`;
  },
  tls: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tail, rest);
  },
  sni: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tail, rest);
  },
  https: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (head, rest) => {
    const maHasTLS = hasTLS(rest);
    const sni = extractSNI(rest);
    const port = extractPort(rest);
    if (maHasTLS && sni != null) {
      return `wss://${sni}${port}`;
    }
    const protocol2 = maHasTLS ? "wss://" : "ws://";
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `${protocol2}${baseVal}`;
  },
  wss: (head, rest) => {
    const tail = rest.pop();
    if (tail == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tail, rest);
    baseVal = baseVal?.replace("tcp://", "");
    return `wss://${baseVal}`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const components = ma.getComponents();
  const head = components.pop();
  if (head == null) {
    throw new Error("Unexpected end of multiaddr");
  }
  const interpreter = interpreters[head.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${head.name}`);
  }
  let uri = interpreter(head, components) ?? "";
  if (opts?.assumeHttp !== false && ASSUME_HTTP_CODES.includes(head.code)) {
    uri = uri.replace(/^.*:\/\//, "");
    if (head.value === "443") {
      uri = `https://${uri}`;
    } else {
      uri = `http://${uri}`;
    }
  }
  if (uri.startsWith("http://") || uri.startsWith("https://") || uri.startsWith("ws://") || uri.startsWith("wss://")) {
    uri = new URL(uri).toString();
    if (uri.endsWith("/")) {
      uri = uri.substring(0, uri.length - 1);
    }
  }
  return uri;
}

// ../../node_modules/ip-regex/index.js
var word = "[a-fA-F\\d:]";
var boundry = (options2) => options2 && options2.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6segment = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v4}$`);
var v6exact = new RegExp(`^${v6}$`);
var ipRegex = (options2) => options2 && options2.exact ? v46Exact : new RegExp(`(?:${boundry(options2)}${v4}${boundry(options2)})|(?:${boundry(options2)}${v6}${boundry(options2)})`, "g");
ipRegex.v4 = (options2) => options2 && options2.exact ? v4exact : new RegExp(`${boundry(options2)}${v4}${boundry(options2)}`, "g");
ipRegex.v6 = (options2) => options2 && options2.exact ? v6exact : new RegExp(`${boundry(options2)}${v6}${boundry(options2)}`, "g");
var ip_regex_default = ipRegex;

// ../../node_modules/function-timeout/browser.js
function functionTimeout(function_) {
  const wrappedFunction = (...arguments_) => function_(...arguments_);
  Object.defineProperty(wrappedFunction, "name", {
    value: `functionTimeout(${function_.name || "<anonymous>"})`,
    configurable: true
  });
  return wrappedFunction;
}
function isTimeoutError() {
  return false;
}

// ../../node_modules/time-span/browser.js
function timeSpan() {
  const start2 = performance.now();
  const end = () => performance.now() - start2;
  end.rounded = () => Math.round(end());
  end.seconds = () => end() / 1e3;
  end.nanoseconds = () => end() * 1e6;
  return end;
}

// ../../node_modules/is-regexp/index.js
var { toString: toString4 } = Object.prototype;
function isRegexp(value2) {
  return toString4.call(value2) === "[object RegExp]";
}

// ../../node_modules/clone-regexp/index.js
var flagMap = {
  global: "g",
  ignoreCase: "i",
  multiline: "m",
  dotAll: "s",
  sticky: "y",
  unicode: "u"
};
function clonedRegexp(regexp, options2 = {}) {
  if (!isRegexp(regexp)) {
    throw new TypeError("Expected a RegExp instance");
  }
  const flags = Object.keys(flagMap).map((flag) => (typeof options2[flag] === "boolean" ? options2[flag] : regexp[flag]) ? flagMap[flag] : "").join("");
  const clonedRegexp2 = new RegExp(options2.source || regexp.source, flags);
  clonedRegexp2.lastIndex = typeof options2.lastIndex === "number" ? options2.lastIndex : regexp.lastIndex;
  return clonedRegexp2;
}

// ../../node_modules/super-regex/index.js
var resultToMatch = (result) => ({
  match: result[0],
  index: result.index,
  groups: result.slice(1),
  namedGroups: result.groups ?? {},
  input: result.input
});
function isMatch(regex, string2, { timeout } = {}) {
  try {
    return functionTimeout(() => clonedRegexp(regex).test(string2), { timeout })();
  } catch (error) {
    if (isTimeoutError(error)) {
      return false;
    }
    throw error;
  }
}
function firstMatch(regex, string2, { timeout } = {}) {
  try {
    const result = functionTimeout(() => clonedRegexp(regex).exec(string2), { timeout })();
    if (result === null) {
      return;
    }
    return resultToMatch(result);
  } catch (error) {
    if (isTimeoutError(error)) {
      return;
    }
    throw error;
  }
}
function matches(regex, string2, { timeout = Number.POSITIVE_INFINITY, matchTimeout = Number.POSITIVE_INFINITY } = {}) {
  if (!regex.global) {
    throw new Error("The regex must have the global flag, otherwise, use `firstMatch()` instead");
  }
  return {
    *[Symbol.iterator]() {
      try {
        const matches2 = string2.matchAll(regex);
        while (true) {
          const nextMatch = functionTimeout(() => matches2.next(), { timeout: timeout !== Number.POSITIVE_INFINITY || matchTimeout !== Number.POSITIVE_INFINITY ? Math.min(timeout, matchTimeout) : void 0 });
          const end = timeSpan();
          const { value: value2, done } = nextMatch();
          timeout -= Math.ceil(end());
          if (done) {
            break;
          }
          yield resultToMatch(value2);
        }
      } catch (error) {
        if (!isTimeoutError(error)) {
          throw error;
        }
      }
    }
  };
}

// ../../node_modules/is-ip/index.js
var maxIPv4Length = 15;
var maxIPv6Length = 45;
var options = {
  timeout: 400
};
function isIP2(string2) {
  if (string2.length > maxIPv6Length) {
    return false;
  }
  return isMatch(ip_regex_default({ exact: true }), string2, options);
}
function isIPv62(string2) {
  if (string2.length > maxIPv6Length) {
    return false;
  }
  return isMatch(ip_regex_default.v6({ exact: true }), string2, options);
}
function isIPv42(string2) {
  if (string2.length > maxIPv4Length) {
    return false;
  }
  return isMatch(ip_regex_default.v4({ exact: true }), string2, options);
}
function ipVersion2(string2) {
  if (isIPv62(string2)) {
    return 6;
  }
  if (isIPv42(string2)) {
    return 4;
  }
}

// ../../node_modules/@multiformats/uri-to-multiaddr/dist/src/index.js
var portFor = {
  http: "80",
  https: "443",
  ws: "80",
  wss: "443"
};
var BROWSER_SCHEMES = ["http", "https", "ws", "wss"];
function uriToMultiaddr(uriStr, opts) {
  opts = opts ?? {};
  const defaultDnsType = opts.defaultDnsType ?? "dns";
  const { scheme, hostname, port, path } = parseUri(uriStr);
  const parts = [
    tupleForHostname(hostname, defaultDnsType),
    tupleForPort(port, scheme),
    tupleForScheme(scheme)
  ];
  if (path != null) {
    parts.push(tupleForPath(path));
  }
  const multiaddrStr = "/" + parts.filter((x) => Boolean(x)).reduce((a2, b) => a2.concat(b), []).join("/");
  return multiaddr(multiaddrStr);
}
function parseUri(uriStr) {
  const [scheme] = uriStr.split(":");
  if (!BROWSER_SCHEMES.includes(scheme)) {
    uriStr = "http" + uriStr.substring(scheme.length);
  }
  let { protocol: protocol2, hostname, port, pathname, search } = new URL(uriStr);
  if (port == null || port === "") {
    const protocolPort = portForProtocol(scheme);
    if (protocolPort != null) {
      port = protocolPort;
    }
    if (protocolPort == null && protocol2 === "http:") {
      port = "80";
    }
  }
  let path;
  if (pathname != null && pathname !== "" && pathname !== "/") {
    if (pathname.startsWith("/")) {
      pathname = pathname.substring(1);
    }
    path = pathname;
  }
  if (search != null && search !== "") {
    path = path ?? "";
    path += search;
  }
  return { scheme, hostname, port, path };
}
function tupleForHostname(hostname, defaultDnsType) {
  if (hostname == null || hostname === "") {
    return void 0;
  }
  if (isIPv42(hostname)) {
    return ["ip4", hostname];
  }
  if (isIPv62(hostname)) {
    return ["ip6", hostname];
  }
  if (hostname[0] === "[") {
    const trimmed = hostname.substring(1, hostname.length - 1);
    if (isIPv62(trimmed)) {
      return ["ip6", trimmed];
    }
  }
  return [defaultDnsType, hostname];
}
function tupleForPort(port, scheme) {
  if (port == null || port === "") {
    return void 0;
  }
  if (scheme === "udp") {
    return ["udp", port];
  }
  return ["tcp", port];
}
function tupleForScheme(scheme) {
  if (scheme.match(/^tcp$|^udp$/) != null) {
    return void 0;
  }
  if (scheme === "https") {
    return ["/tls/http"];
  }
  if (scheme === "wss") {
    return ["/tls/ws"];
  }
  return [scheme];
}
function tupleForPath(path) {
  if (path == null || path === "") {
    return void 0;
  }
  return ["http-path", encodeURIComponent(path)];
}
function portForProtocol(protocol2) {
  if (protocol2 == null || protocol2 === "" || portFor[protocol2] == null) {
    return void 0;
  }
  return portFor[protocol2];
}

// ../../node_modules/get-iterator/dist/src/index.js
function getIterator(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}

// ../../node_modules/it-to-browser-readablestream/dist/src/index.js
function itToBrowserReadableStream(source, queuingStrategy = {}) {
  const iter = getIterator(source);
  const s2 = {
    _cancelled: false,
    async start() {
      this._cancelled = false;
    },
    async pull(controller) {
      try {
        const { value: value2, done } = await iter.next();
        if (this._cancelled) {
          return;
        }
        if (done === true) {
          controller.close();
          return;
        }
        controller.enqueue(value2);
      } catch (err) {
        controller.error(err);
      }
    },
    cancel() {
      this._cancelled = true;
    }
  };
  return new window.ReadableStream(s2, queuingStrategy);
}

// ../../node_modules/multiformats/dist/src/hashes/sha1-browser.js
var sha2 = (name5) => async (data) => new Uint8Array(await crypto.subtle.digest(name5, data));
var sha12 = from2({
  name: "sha-1",
  code: 17,
  encode: sha2("SHA-1")
});

// ../../node_modules/abort-error/dist/src/index.js
var AbortError7 = class extends Error {
  constructor(message2 = "The operation was aborted", ...rest) {
    super(message2, ...rest);
    __publicField(this, "name", "AbortError");
  }
};
__publicField(AbortError7, "name", "AbortError");

// ../../node_modules/race-event/dist/src/index.js
async function raceEvent(emitter, eventName, signal, opts) {
  const error = new AbortError7(opts?.errorMessage);
  if (opts?.errorCode != null) {
    error.code = opts.errorCode;
  }
  const errorEvent = opts?.errorEvent ?? "error";
  if (signal?.aborted === true) {
    return Promise.reject(error);
  }
  return new Promise((resolve, reject) => {
    function removeListeners() {
      removeListener(signal, "abort", abortListener);
      removeListener(emitter, eventName, eventListener);
      removeListener(emitter, errorEvent, errorEventListener);
    }
    const eventListener = (evt) => {
      try {
        if (opts?.filter?.(evt) === false) {
          return;
        }
      } catch (err) {
        removeListeners();
        reject(err);
        return;
      }
      removeListeners();
      resolve(evt);
    };
    const errorEventListener = (evt) => {
      removeListeners();
      if (evt instanceof Error) {
        reject(evt);
        return;
      }
      reject(evt.detail ?? opts?.error ?? new Error(`The "${opts?.errorEvent}" event was emitted but the event had no '.detail' field. Pass an 'error' option to race-event to change this message.`));
    };
    const abortListener = () => {
      removeListeners();
      reject(error);
    };
    addListener(signal, "abort", abortListener);
    addListener(emitter, eventName, eventListener);
    addListener(emitter, errorEvent, errorEventListener);
  });
}
function addListener(emitter, event, listener) {
  if (emitter == null) {
    return;
  }
  if (isEventTarget(emitter)) {
    emitter.addEventListener(event, listener);
  } else {
    emitter.addListener(event, listener);
  }
}
function removeListener(emitter, event, listener) {
  if (emitter == null) {
    return;
  }
  if (isEventTarget(emitter)) {
    emitter.removeEventListener(event, listener);
  } else {
    emitter.removeListener(event, listener);
  }
}
function isEventTarget(emitter) {
  return typeof emitter.addEventListener === "function" && typeof emitter.removeEventListener === "function";
}

// ../../node_modules/@libp2p/http-utils/dist/src/request.js
var Request = class extends window.Request {
  constructor(input, init = {}) {
    const method = init.method ?? "GET";
    const headers = getHeaders(init);
    const body = init.body;
    if (isWebSocketUpgrade(method, headers)) {
      init.method = "UPGRADE";
    }
    super(input, init);
    Object.defineProperties(this, {
      body: {
        value: body,
        writable: false
      },
      method: {
        value: method,
        writable: false
      },
      headers: {
        value: headers,
        writable: false
      }
    });
  }
};

// ../../node_modules/@libp2p/http-utils/dist/src/constants.js
var STATUS_CODES = {
  100: "Continue",
  // RFC 7231 6.2.1
  101: "Switching Protocols",
  // RFC 7231 6.2.2
  102: "Processing",
  // RFC 2518 10.1 (obsoleted by RFC 4918)
  103: "Early Hints",
  // RFC 8297 2
  200: "OK",
  // RFC 7231 6.3.1
  201: "Created",
  // RFC 7231 6.3.2
  202: "Accepted",
  // RFC 7231 6.3.3
  203: "Non-Authoritative Information",
  // RFC 7231 6.3.4
  204: "No Content",
  // RFC 7231 6.3.5
  205: "Reset Content",
  // RFC 7231 6.3.6
  206: "Partial Content",
  // RFC 7233 4.1
  207: "Multi-Status",
  // RFC 4918 11.1
  208: "Already Reported",
  // RFC 5842 7.1
  226: "IM Used",
  // RFC 3229 10.4.1
  300: "Multiple Choices",
  // RFC 7231 6.4.1
  301: "Moved Permanently",
  // RFC 7231 6.4.2
  302: "Found",
  // RFC 7231 6.4.3
  303: "See Other",
  // RFC 7231 6.4.4
  304: "Not Modified",
  // RFC 7232 4.1
  305: "Use Proxy",
  // RFC 7231 6.4.5
  307: "Temporary Redirect",
  // RFC 7231 6.4.7
  308: "Permanent Redirect",
  // RFC 7238 3
  400: "Bad Request",
  // RFC 7231 6.5.1
  401: "Unauthorized",
  // RFC 7235 3.1
  402: "Payment Required",
  // RFC 7231 6.5.2
  403: "Forbidden",
  // RFC 7231 6.5.3
  404: "Not Found",
  // RFC 7231 6.5.4
  405: "Method Not Allowed",
  // RFC 7231 6.5.5
  406: "Not Acceptable",
  // RFC 7231 6.5.6
  407: "Proxy Authentication Required",
  // RFC 7235 3.2
  408: "Request Timeout",
  // RFC 7231 6.5.7
  409: "Conflict",
  // RFC 7231 6.5.8
  410: "Gone",
  // RFC 7231 6.5.9
  411: "Length Required",
  // RFC 7231 6.5.10
  412: "Precondition Failed",
  // RFC 7232 4.2
  413: "Payload Too Large",
  // RFC 7231 6.5.11
  414: "URI Too Long",
  // RFC 7231 6.5.12
  415: "Unsupported Media Type",
  // RFC 7231 6.5.13
  416: "Range Not Satisfiable",
  // RFC 7233 4.4
  417: "Expectation Failed",
  // RFC 7231 6.5.14
  418: "I'm a Teapot",
  // RFC 7168 2.3.3
  421: "Misdirected Request",
  // RFC 7540 9.1.2
  422: "Unprocessable Entity",
  // RFC 4918 11.2
  423: "Locked",
  // RFC 4918 11.3
  424: "Failed Dependency",
  // RFC 4918 11.4
  425: "Too Early",
  // RFC 8470 5.2
  426: "Upgrade Required",
  // RFC 2817 and RFC 7231 6.5.15
  428: "Precondition Required",
  // RFC 6585 3
  429: "Too Many Requests",
  // RFC 6585 4
  431: "Request Header Fields Too Large",
  // RFC 6585 5
  451: "Unavailable For Legal Reasons",
  // RFC 7725 3
  500: "Internal Server Error",
  // RFC 7231 6.6.1
  501: "Not Implemented",
  // RFC 7231 6.6.2
  502: "Bad Gateway",
  // RFC 7231 6.6.3
  503: "Service Unavailable",
  // RFC 7231 6.6.4
  504: "Gateway Timeout",
  // RFC 7231 6.6.5
  505: "HTTP Version Not Supported",
  // RFC 7231 6.6.6
  506: "Variant Also Negotiates",
  // RFC 2295 8.1
  507: "Insufficient Storage",
  // RFC 4918 11.5
  508: "Loop Detected",
  // RFC 5842 7.2
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  // RFC 2774 7
  511: "Network Authentication Required"
  // RFC 6585 6
};

// ../../node_modules/@libp2p/http-utils/dist/src/response.js
var Response2 = class extends window.Response {
  constructor(body, init = {}) {
    const headers = getHeaders(init);
    const status = init.status ?? 200;
    if (status < 200 || status > 599) {
      init.status = 200;
    }
    super(body, init);
    Object.defineProperties(this, {
      status: {
        value: status,
        writable: false
      },
      statusText: {
        value: STATUS_CODES[status],
        writable: false
      },
      headers: {
        value: headers,
        writable: false
      }
    });
  }
};

// ../../node_modules/@libp2p/http-utils/dist/src/index.js
var DNS_CODECS = ["dns", "dns4", "dns6", "dnsaddr"];
function toURL(resource, headers) {
  if (resource instanceof URL) {
    return resource;
  }
  const host = getHost(resource, headers);
  const { httpPath } = stripHTTPPath(resource);
  return new URL(`http://${host}${httpPath}`);
}
function toUint8Array(obj) {
  if (obj instanceof Uint8Array) {
    return obj;
  }
  if (obj instanceof DataView) {
    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);
  }
  return new Uint8Array(obj, 0, obj.byteLength);
}
function streamToRequest(info, stream) {
  const init = {
    method: info.method,
    headers: info.headers
  };
  if ((init.method !== "GET" || info.upgrade) && init.method !== "HEAD") {
    let source = stream;
    if (!info.upgrade) {
      source = takeBytes(stream, info.headers.get("content-length"));
    }
    init.body = itToBrowserReadableStream(source);
    init.duplex = "half";
  }
  return new Request(normalizeUrl(info).toString(), init);
}
async function responseToStream(res, stream) {
  stream.send(fromString2([
    `HTTP/1.1 ${res.status} ${res.statusText}`,
    ...writeHeaders(res.headers),
    "",
    ""
  ].join("\r\n")));
  if (res.body == null) {
    await stream.close().catch((err) => {
      stream.abort(err);
    });
    return;
  }
  const reader = res.body.getReader();
  while (true) {
    const result = await reader.read();
    if (result.value != null) {
      if (!stream.send(result.value)) {
        await stream.onDrain();
      }
    }
    if (result.done) {
      break;
    }
  }
  await stream.close().catch((err) => {
    stream.abort(err);
  });
}
var NOT_FOUND_RESPONSE = fromString2([
  "HTTP/1.1 404 Not Found",
  "Connection: close",
  "",
  ""
].join("\r\n"));
var BAD_REQUEST = fromString2([
  "HTTP/1.1 400 Bad Request",
  "Connection: close",
  "",
  ""
].join("\r\n"));
var INTERNAL_SERVER_ERROR = fromString2([
  "HTTP/1.1 500 Internal Server Error",
  "Connection: close",
  "",
  ""
].join("\r\n"));
var NOT_IMPLEMENTED_ERROR = fromString2([
  "HTTP/1.1 501 Not Implemented",
  "Connection: close",
  "",
  ""
].join("\r\n"));
function writeHeaders(headers) {
  const output = [];
  if (headers.get("Connection") == null) {
    headers.set("Connection", "close");
  }
  for (const [key, value2] of headers.entries()) {
    output.push(`${key}: ${value2}`);
  }
  return output;
}
async function* takeBytes(source, bytes) {
  bytes = parseInt(`${bytes ?? ""}`);
  if (bytes == null || isNaN(bytes)) {
    return source;
  }
  let count = 0;
  for await (const buf2 of source) {
    count += buf2.byteLength;
    if (count > bytes) {
      yield buf2.subarray(0, count - bytes);
      return;
    }
    yield buf2.subarray();
    if (count === bytes) {
      return;
    }
  }
}
function toResource(resource, path) {
  if (typeof resource === "string") {
    if (resource.startsWith("/")) {
      resource = multiaddr(resource);
    } else {
      resource = new URL(resource);
    }
  }
  if (isPeerId2(resource)) {
    resource = multiaddr(`/p2p/${resource}`);
  }
  if (resource instanceof URL) {
    if (resource.protocol === "multiaddr:") {
      resource = uriToMultiaddr(resource.toString());
    }
  }
  if (isMultiaddr(resource)) {
    resource = [resource];
  }
  if (Array.isArray(resource)) {
    for (const ma of resource) {
      const components = ma.getComponents();
      if (components.some(({ name: name5 }) => name5 === "http")) {
        const uri = multiaddrToUri(ma);
        return new URL(`${uri}${path ?? ""}`);
      }
    }
  }
  if (path == null) {
    return resource;
  }
  if (resource instanceof URL) {
    return new URL(`${resource}${path.substring(1)}`);
  }
  return resource.map((ma) => ma.encapsulate(`/http-path/${encodeURIComponent(path.substring(1))}`));
}
function getHeaders(init = {}) {
  if (init.headers instanceof Headers) {
    return init.headers;
  }
  init.headers = new Headers(init.headers);
  return init.headers;
}
function getHeader(header, headers = {}) {
  if (headers instanceof Headers) {
    return headers.get(header) ?? void 0;
  }
  if (Array.isArray(headers)) {
    return headers.find(([key, value2]) => {
      if (key === header) {
        return value2;
      }
      return void 0;
    })?.[1];
  }
  return headers[header];
}
function isValidHost(host) {
  return host != null && host !== "";
}
function getHost(addresses, headers) {
  let host;
  let port = 80;
  let protocol2 = "http:";
  if (addresses instanceof URL) {
    host = addresses.hostname;
    port = parseInt(addresses.port, 10);
    protocol2 = addresses.protocol;
  }
  if (!isValidHost(host)) {
    host = headers.get("host") ?? void 0;
  }
  if (!isValidHost(host) && Array.isArray(addresses)) {
    for (const address of addresses) {
      const components = address.getComponents();
      const filtered = components.filter(({ name: name5 }) => DNS_CODECS.includes(name5))?.[0]?.value;
      if (filtered != null) {
        host = filtered;
        break;
      }
    }
  }
  if (!isValidHost(host) && Array.isArray(addresses)) {
    for (const address of addresses) {
      const peerStr = address.getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value;
      try {
        const config = getNetConfig(address);
        if (config.port != null) {
          port = config.port;
        }
      } catch {
      }
      if (peerStr != null) {
        const peerId = peerIdFromString3(peerStr);
        host = peerId.toCID().toString(base36);
        break;
      }
    }
  }
  if (!isValidHost(host) && Array.isArray(addresses)) {
    for (const address of addresses) {
      try {
        const config = getNetConfig(address);
        if (config.host != null) {
          host = config.host;
        }
        break;
      } catch {
      }
    }
  }
  if (isValidHost(host)) {
    if (protocol2 === "http:" && port !== 80) {
      host = `${host}:${port}`;
    }
    if (protocol2 === "https:" && port !== 443) {
      host = `${host}:${port}`;
    }
    return host;
  }
  throw new InvalidParametersError2("Could not determine request host name - a request must have a host header, be made to a DNS or IP-based multiaddr or an http(s) URL");
}
function stripHTTPPath(addresses) {
  let httpPath = "/";
  addresses = addresses.map((ma) => {
    return multiaddr(ma.getComponents().filter((component) => {
      if (component.name === "http-path") {
        httpPath = component.value ?? "/";
        return false;
      }
      return true;
    }));
  });
  return {
    httpPath,
    addresses
  };
}
function normalizeMethod(method, defaultMethod = ["GET"]) {
  if (method == null) {
    return defaultMethod;
  }
  if (typeof method === "string") {
    method = [method];
  }
  return method.map((m2) => m2.toUpperCase());
}
function normalizeUrl(req) {
  const url = req.url ?? "/";
  if (url.startsWith("http")) {
    return new URL(url);
  }
  const host = getHostFromReq(req);
  return new URL(`http://${host}${url}`);
}
function getHostFromReq(req) {
  let host = req.headers?.host;
  if (host == null) {
    host = req.headers?.Host;
  }
  if (host == null && typeof req.headers.get === "function") {
    host = req.headers.get("host");
  }
  if (host == null) {
    throw new InvalidParametersError2("Could not read host");
  }
  return host;
}
function isWebSocketUpgrade(method, headers) {
  return method === "GET" && headers.get("connection")?.toLowerCase() === "upgrade" && headers.get("upgrade")?.toLowerCase() === "websocket";
}
function getHeaderFromHeaders(headers, key) {
  if (headers instanceof Headers) {
    return headers.get(key) ?? void 0;
  }
  const header = headers[key];
  if (Array.isArray(header)) {
    return header.join(",");
  }
  return header;
}
async function getServerUpgradeHeaders(headers) {
  if (getHeaderFromHeaders(headers, "sec-websocket-version") !== "13") {
    throw new ProtocolError2("Invalid version");
  }
  const secWebSocketKey = getHeaderFromHeaders(headers, "sec-websocket-key");
  if (secWebSocketKey == null) {
    throw new ProtocolError2("Missing sec-websocket-key");
  }
  const token = `${secWebSocketKey}258EAFA5-E914-47DA-95CA-C5AB0DC85B11`;
  const hash = await sha12.digest(fromString2(token));
  const webSocketAccept = base64pad.encode(hash.digest).substring(1);
  return new Headers({
    Upgrade: "websocket",
    Connection: "upgrade",
    "Sec-WebSocket-Accept": webSocketAccept
  });
}
async function readHeaders(stream, options2) {
  const parser2 = new HTTPParser("REQUEST");
  const earlyData = new Uint8ArrayList();
  let headerInfo;
  parser2[HTTPParser.kOnHeadersComplete] = (info) => {
    const headers = new Headers();
    for (let i2 = 0; i2 < info.headers.length; i2 += 2) {
      headers.set(info.headers[i2].toLowerCase(), info.headers[i2 + 1]);
    }
    headerInfo = {
      ...info,
      headers,
      raw: earlyData,
      method: HTTPParser.methods[info.method]
    };
  };
  try {
    while (true) {
      const { data } = await raceEvent(stream, "message", options2?.signal);
      const buf2 = data.subarray();
      const read3 = parser2.execute(buf2, 0, buf2.byteLength);
      if (read3 instanceof Error) {
        throw read3;
      }
      earlyData.append(buf2.subarray(0, read3));
      if (read3 < buf2.byteLength) {
        stream.push(buf2.subarray(read3));
      }
      if (headerInfo != null) {
        return headerInfo;
      }
    }
  } catch (err) {
    stream.abort(err);
  } finally {
    parser2.finish();
  }
  throw new Error("Failed to read header info from request");
}

// ../../node_modules/@libp2p/http-fetch/dist/src/errors.js
var InvalidResponseError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidResponseError");
  }
};
__publicField(InvalidResponseError, "name", "InvalidResponseError");

// ../../node_modules/@libp2p/http-fetch/dist/src/read-response.js
var nullBodyStatus = [101, 204, 205, 304];
async function readResponse(stream, resource, init) {
  const output = Promise.withResolvers();
  const body = new TransformStream();
  const writer = body.writable.getWriter();
  let headersComplete = false;
  const parser2 = new HTTPParser("RESPONSE");
  parser2.maxHeaderSize = init.maxHeaderSize ?? HTTPParser.maxHeaderSize;
  parser2[HTTPParser.kOnHeadersComplete] = (info) => {
    init.log("response headers complete");
    headersComplete = true;
    const headers = new Headers();
    for (let i2 = 0; i2 < info.headers.length; i2 += 2) {
      headers.append(info.headers[i2], info.headers[i2 + 1]);
    }
    let responseBody = body.readable;
    if (nullBodyStatus.includes(info.statusCode)) {
      body.writable.close().catch(() => {
      });
      body.readable.cancel().catch(() => {
      });
      responseBody = null;
    }
    const response = new Response2(responseBody, {
      status: info.statusCode,
      statusText: info.statusMessage,
      headers
    });
    output.resolve(response);
  };
  parser2[HTTPParser.kOnBody] = (buf2) => {
    init.log("response read body %d bytes", buf2.byteLength);
    writer.write(buf2).catch((err) => {
      output.reject(err);
    });
  };
  parser2[HTTPParser.kOnMessageComplete] = () => {
    init.log("response message complete");
    writer.close().catch((err) => {
      output.reject(err);
    });
  };
  let read3 = 0;
  stream.addEventListener("message", ({ data }) => {
    init.log("response stream read %d bytes", data.byteLength);
    read3 += data.byteLength;
    const result = parser2.execute(data.subarray(), 0, data.byteLength);
    if (result instanceof Error) {
      stream.abort(result);
      parser2.finish();
    }
  });
  stream.addEventListener("remoteCloseWrite", () => {
    if (!headersComplete) {
      output.reject(new InvalidResponseError(`Response ended before headers were received, read ${read3} bytes`));
    }
    parser2.finish();
  });
  return output.promise;
}

// ../../node_modules/@libp2p/http-fetch/dist/src/body/blob.js
function blobBody(blob, headers) {
  headers.set("Content-Length", `${blob.size}`);
  headers.set("Content-Type", blob.type != null && blob.type !== "" ? blob.type : "application/octet-stream");
  return blob.stream();
}

// ../../node_modules/@libp2p/http-fetch/dist/src/body/bytes.js
function bytesBody(bytes, headers) {
  headers.set("Content-Length", `${bytes.byteLength}`);
  headers.set("Content-Type", "application/octet-stream");
  return new ReadableStream({
    start(controller) {
      controller.enqueue(toUint8Array(bytes));
      controller.close();
    }
  });
}

// ../../node_modules/@libp2p/http-fetch/dist/src/body/form-data.js
function calculateSize(name5, entry, boundary) {
  const header = [
    `--${boundary}`
  ];
  let contentLength = 0;
  const trailingLinebreak = "\r\n".length;
  if (typeof entry === "string") {
    header.push(`Content-Disposition: form-data; name="${name5}"`, 'Content-Type: text/plain; charset="UTF-8"', `Content-Length: ${entry.length}`, "");
    contentLength = entry.length + trailingLinebreak;
  } else {
    header.push(`Content-Disposition: form-data; name="${name5}"; filename="${encodeURIComponent(entry.name)}"`, "Content-Type: application/octet-stream", `Content-Length: ${entry.size}`, "");
    contentLength = entry.size + trailingLinebreak;
  }
  const buf2 = fromString2(header.join("\r\n"));
  return buf2.byteLength + contentLength;
}
function formDataBody(formData, headers) {
  const boundary = `-----------------------------${crypto.randomUUID()}`;
  headers.set("Content-Type", `multipart/form-data; boundary=${boundary}`);
  let length4 = 0;
  for (const [name5, value2] of formData.entries()) {
    length4 += calculateSize(name5, value2, boundary);
  }
  headers.set("Content-Length", `${length4}`);
  const formDataIterator = formData.entries();
  let fileDataReader;
  function queuePart(controller, name5, entry, boundary2) {
    const header = [
      `--${boundary2}`
    ];
    if (typeof entry === "string") {
      header.push(`Content-Disposition: form-data; name="${name5}"`, 'Content-Type: text/plain; charset="UTF-8"', `Content-Length: ${entry.length}`, "", entry, "");
    } else {
      header.push(`Content-Disposition: form-data; name="${name5}"; filename="${encodeURIComponent(entry.name)}"`, "Content-Type: application/octet-stream", `Content-Length: ${entry.size}`, "");
      fileDataReader = entry.stream().getReader();
    }
    controller.enqueue(fromString2(header.join("\r\n")));
  }
  async function getNext(controller, boundary2) {
    if (fileDataReader != null) {
      const result = await fileDataReader.read();
      if (result.value != null) {
        controller.enqueue(result.value);
      }
      if (result.done) {
        controller.enqueue(fromString2("\r\n"));
        fileDataReader = void 0;
      }
      return;
    }
    const { done, value: value2 } = formDataIterator.next();
    if (value2 != null) {
      const [name5, entry] = value2;
      queuePart(controller, name5, entry, boundary2);
    }
    if (done === true) {
      controller.close();
    }
  }
  return new ReadableStream({
    async pull(controller) {
      await getNext(controller, boundary);
    }
  });
}

// ../../node_modules/@libp2p/http-fetch/dist/src/body/readable-stream.js
function readableStreamBody(stream, headers) {
  headers.set("Content-Type", "application/octet-stream");
  headers.set("Transfer-Encoding", "chunked");
  const reader = stream.getReader();
  return new ReadableStream({
    async pull(controller) {
      const { done, value: value2 } = await reader.read();
      if (value2 != null) {
        controller.enqueue(fromString2(`${value2.byteLength}\r
`));
        controller.enqueue(value2);
        controller.enqueue(fromString2("\r\n"));
      }
      if (done) {
        controller.enqueue(fromString2("0\r\n\r\n"));
        controller.close();
      }
    }
  });
}

// ../../node_modules/@libp2p/http-fetch/dist/src/body/string.js
function stringBody(str, headers) {
  headers.set("Content-Length", `${str.length}`);
  headers.set("Content-Type", 'text/plain; charset="UTF-8"');
  return new ReadableStream({
    start(controller) {
      controller.enqueue(fromString2(str));
      controller.close();
    }
  });
}

// ../../node_modules/@libp2p/http-fetch/dist/src/utils.js
function normalizeContent(body, headers) {
  if (body == null) {
    return;
  }
  if (typeof body === "string") {
    return stringBody(body, headers);
  } else if (body instanceof Blob) {
    return blobBody(body, headers);
  } else if (isBytes3(body)) {
    return bytesBody(body, headers);
  } else if (body instanceof URLSearchParams) {
    return stringBody(body.toString(), headers);
  } else if (body instanceof ReadableStream) {
    return readableStreamBody(body, headers);
  } else if (body instanceof FormData) {
    return formDataBody(body, headers);
  }
  throw new Error("Unsupported body type");
}
function isBytes3(obj) {
  if (obj == null) {
    return false;
  }
  return obj.byteLength != null;
}

// ../../node_modules/@libp2p/http-fetch/dist/src/send-request.js
async function sendRequest(stream, url, init) {
  const headers = new Headers(init.headers);
  const host = headers.get("host") ?? url.hostname;
  headers.set("host", host);
  if (headers.get("user-agent") == null) {
    headers.set("user-agent", "libp2p/fetch");
  }
  const content = normalizeContent(init.body, headers);
  const req = [
    `${init?.method?.toUpperCase() ?? "GET"} ${url.pathname ?? "/"} HTTP/1.1`,
    ...writeHeaders(headers),
    "",
    ""
  ];
  if (!stream.send(fromString2(req.join("\r\n")))) {
    await stream.onDrain({
      signal: init.signal ?? void 0
    });
  }
  if (content != null) {
    init.log("request sending body");
    await sendBody(stream, content, init);
  }
}
async function sendBody(stream, body, init) {
  const reader = body.getReader();
  while (true) {
    const { done, value: value2 } = await reader.read();
    if (value2 != null) {
      init.log("request send %d bytes", value2.byteLength);
      if (!stream.send(value2)) {
        await stream.onDrain({
          signal: init.signal ?? void 0
        });
      }
    }
    if (done) {
      init.log("request finished sending body");
      break;
    }
  }
}

// ../../node_modules/@libp2p/http-fetch/dist/src/index.js
async function fetch2(stream, resource, init = {}) {
  const log4 = stream.log.newScope("http-fetch");
  resource = typeof resource === "string" ? new URL(resource) : resource;
  const [response] = await Promise.all([
    readResponse(stream, resource, {
      ...init,
      log: log4
    }),
    sendRequest(stream, resource, {
      ...init,
      log: log4
    })
  ]);
  await stream.close({
    signal: init.signal ?? void 0
  });
  return response;
}

// ../../node_modules/@libp2p/http-websocket/dist/src/events.js
var ErrorEvent = class extends Event {
  constructor(err) {
    super("error");
    __publicField(this, "message");
    __publicField(this, "error");
    __publicField(this, "filename", "");
    __publicField(this, "lineno", 0);
    __publicField(this, "colno", 0);
    this.error = err;
    this.message = err.message;
  }
};
var CloseEvent = class extends Event {
  constructor(type, eventInitDict) {
    super(type);
    __publicField(this, "code");
    __publicField(this, "reason");
    __publicField(this, "wasClean");
    this.code = eventInitDict?.code ?? 0;
    this.reason = eventInitDict?.reason ?? "";
    this.wasClean = eventInitDict?.wasClean ?? true;
  }
};

// ../../node_modules/@libp2p/http-websocket/dist/src/message.js
var OP_CODES = {
  CONTINUATION: 0,
  TEXT: 1,
  BINARY: 2,
  CONNECTION_CLOSE: 8,
  PING: 9,
  PONG: 10
};
var MESSAGE_TYPES = {
  0: "CONTINUATION",
  1: "TEXT",
  2: "BINARY",
  8: "CONNECTION_CLOSE",
  9: "PING",
  10: "PONG"
};
var CLOSE_CODES = {
  1e3: "NORMAL_CLOSURE",
  1001: "GOING_AWAY",
  1002: "PROTOCOL_ERROR",
  1003: "UNSUPPORTED_DATA",
  1004: "RESERVED",
  1005: "NO_STATUS_RECEIVED",
  1006: "ABNORMAL_CLOSURE",
  1007: "INVALID_FRAME_PAYLOAD_DATA",
  1008: "POLICY_VIOLATION",
  1009: "MESSAGE_TOO_BIG",
  1010: "MANDATORY_EXT",
  1011: "INTERNAL_SERVER_ERROR",
  1015: "TLS_HANDSHAKE"
};
var CLOSE_MESSAGES = {
  NORMAL_CLOSURE: 1e3,
  GOING_AWAY: 1001,
  PROTOCOL_ERROR: 1002,
  UNSUPPORTED_DATA: 1003,
  RESERVED: 1004,
  NO_STATUS_RECEIVED: 1005,
  ABNORMAL_CLOSURE: 1006,
  INVALID_FRAME_PAYLOAD_DATA: 1007,
  POLICY_VIOLATION: 1008,
  MESSAGE_TOO_BIG: 1009,
  MANDATORY_EXT: 1010,
  INTERNAL_SERVER_ERROR: 1011,
  TLS_HANDSHAKE: 1015
};
function decodeMessage2(buf2) {
  let offset = 0;
  if (buf2.byteLength < offset + 1) {
    return;
  }
  const byte0 = buf2.get(offset);
  const opcode = byte0 & 15;
  offset++;
  if (MESSAGE_TYPES[opcode] == null) {
    throw new Error(`Unknown opcode: ${opcode}`);
  }
  if (buf2.byteLength < offset + 1) {
    return;
  }
  const byte1 = buf2.get(offset);
  const isMasked = (byte1 & 128) === 128;
  let length4 = byte1 & 127;
  offset++;
  if (length4 === 126) {
    if (buf2.byteLength < offset + 2) {
      return;
    }
    length4 = buf2.getUint16(offset);
    offset += 2;
  } else if (length4 === 127) {
    if (buf2.byteLength < offset + 8) {
      return;
    }
    length4 = buf2.getUint32(offset);
    offset += 8;
  }
  if (length4 === 0) {
    buf2.consume(offset);
    return {
      type: MESSAGE_TYPES[opcode]
    };
  }
  let mask;
  if (isMasked) {
    if (buf2.byteLength < offset + 4) {
      return;
    }
    mask = buf2.subarray(offset, offset + 4);
    offset += 4;
  }
  if (buf2.byteLength < offset + length4) {
    return;
  }
  let data = buf2.subarray(offset, offset + length4);
  offset += length4;
  if (mask != null) {
    data = applyMask(data, mask);
  }
  buf2.consume(offset);
  return {
    type: MESSAGE_TYPES[opcode],
    data
  };
}
function applyMask(data, mask) {
  let m2 = 0;
  for (let i2 = 0; i2 < data.byteLength; i2++) {
    data[i2] = data[i2] ^ mask[m2];
    m2++;
    if (m2 === mask.byteLength) {
      m2 = 0;
    }
  }
  return data;
}
async function* decodeMessages(source) {
  const buffer2 = new Uint8ArrayList();
  for await (const buf2 of source) {
    buffer2.append(buf2);
    const message2 = decodeMessage2(buffer2);
    if (message2 != null) {
      yield message2;
    }
  }
}
function encodeMessage2(opcode, data, maskData) {
  const fin = true;
  const message2 = new Uint8ArrayList(Uint8Array.from([
    (fin ? 128 : 0) | OP_CODES[opcode]
  ]));
  const length4 = data?.byteLength ?? 0;
  if (length4 < 126) {
    message2.append(Uint8Array.from([
      length4 | (maskData === true ? 128 : 0)
    ]));
  } else if (length4 < 65535) {
    const l2 = new Uint8ArrayList(new Uint8Array(3));
    l2.set(0, 126 | (maskData === true ? 128 : 0));
    l2.setUint16(1, length4);
    message2.append(l2);
  } else if (length4 < 18446744073709552e3) {
    const l2 = new Uint8ArrayList(new Uint8Array(9));
    l2.set(0, 127 | (maskData === true ? 128 : 0));
    l2.setUint32(1, length4);
    message2.append(l2);
  } else {
    throw new Error("Payload too large");
  }
  if (maskData === true && data != null) {
    const maskingKey = Uint8Array.from([0, 0, 0, 0]);
    message2.append(maskingKey);
    data = applyMask(data, maskingKey);
  }
  if (data != null) {
    message2.append(data);
  }
  return message2;
}

// ../../node_modules/@libp2p/http-websocket/dist/src/utils.js
function toBytes2(data) {
  if (data instanceof Uint8Array || data instanceof ArrayBuffer || data instanceof DataView) {
    return toUint8Array(data);
  }
  if (typeof data === "string") {
    return fromString2(data);
  }
  if (data instanceof Blob) {
    return data.arrayBuffer().then((buf2) => toUint8Array(buf2));
  }
  throw new InvalidParametersError2("Unsupported data type");
}
var CodeError2 = class extends Error {
  constructor(message2, code5) {
    super(message2);
    __publicField(this, "code");
    this.code = code5 ?? 0;
  }
};
async function readResponse2(stream, options2) {
  return new Promise((resolve, reject) => {
    let readHeaders2 = false;
    const parser2 = new HTTPParser("RESPONSE");
    parser2[HTTPParser.kOnHeadersComplete] = (info) => {
      readHeaders2 = true;
      const headers = [];
      for (let i2 = 0; i2 < info.headers.length; i2 += 2) {
        headers.push([info.headers[i2], info.headers[i2 + 1]]);
      }
      resolve(new Response2(null, {
        status: info.statusCode,
        statusText: info.statusMessage,
        headers: new Headers(headers)
      }));
    };
    Promise.resolve().then(async () => {
      while (true) {
        const { data } = await raceEvent(stream, "message", options2.signal);
        const buf2 = data.subarray();
        const read3 = parser2.execute(buf2, 0, buf2.byteLength);
        if (read3 instanceof Error) {
          throw read3;
        }
        if (read3 < buf2.byteLength) {
          stream.push(buf2.subarray(read3));
        }
        if (readHeaders2) {
          break;
        }
      }
    }).catch((err) => {
      reject(err);
    });
  });
}
async function* performClientUpgrade(url, protocols = [], headers) {
  const webSocketKey = base64pad.encode(crypto.getRandomValues(new Uint8Array(16))).substring(1);
  headers.set("host", url.hostname);
  headers.set("connection", "upgrade");
  headers.set("upgrade", "websocket");
  headers.set("pragma", "no-cache");
  headers.set("cache-control", "no-cache");
  headers.set("sec-websocket-version", "13");
  headers.set("sec-websocket-key", webSocketKey);
  if (protocols.length > 0) {
    headers.set("sec-websocket-protocol", protocols.join(", "));
  }
  yield fromString2([
    `GET ${url.pathname ?? "/"} HTTP/1.1`,
    ...[...headers.entries()].map(([key, value2]) => `${key}: ${value2}`),
    "",
    ""
  ].join("\r\n"));
}
async function* performServerUpgrade(headers) {
  try {
    const responseHeaders = await getServerUpgradeHeaders(headers);
    const message2 = [
      "HTTP/1.1 101 Switching Protocols",
      ...writeHeaders(responseHeaders),
      "",
      ""
    ];
    yield fromString2(message2.join("\r\n"));
  } catch {
    yield BAD_REQUEST;
  }
}
function streamToWebSocket(info, stream) {
  return new StreamWebSocket(info, stream);
}

// ../../node_modules/@libp2p/http-websocket/dist/src/websocket.js
var DATA_MESSAGES = ["BINARY", "TEXT", "CONTINUATION"];
var MAX_MESSAGE_SIZE = 10485760;
var DEFAULT_HOST = "example.com";
var HTTP_PROTOCOL = "/http/1.1";
var AbstractWebSocket = class extends TypedEventEmitter {
  constructor(url, init = {}) {
    super();
    __publicField(this, "binaryType", "arraybuffer");
    __publicField(this, "bufferedAmount", 0);
    __publicField(this, "extensions", "");
    __publicField(this, "protocol", "");
    __publicField(this, "readyState");
    __publicField(this, "url");
    __publicField(this, "CONNECTING", 0);
    __publicField(this, "OPEN", 1);
    __publicField(this, "CLOSING", 2);
    __publicField(this, "CLOSED", 3);
    __publicField(this, "_onclose");
    __publicField(this, "_onerror");
    __publicField(this, "_onmessage");
    __publicField(this, "_onopen");
    __publicField(this, "sentClose");
    __publicField(this, "isClient");
    __publicField(this, "buffer");
    __publicField(this, "maxMessageSize");
    __publicField(this, "_url");
    __publicField(this, "closeController");
    this.readyState = this.CONNECTING;
    this.url = url.pathname;
    this.sentClose = false;
    this.isClient = init.isClient ?? true;
    this.buffer = new Uint8ArrayList();
    this.closeController = new AbortController();
    this.maxMessageSize = init.maxMessageSize ?? MAX_MESSAGE_SIZE;
  }
  send(data) {
    if (this.readyState !== this.OPEN) {
      throw new Error("WebSocket was not open");
    }
    const b = toBytes2(data);
    if (isPromise2(b)) {
      b.then((b2) => {
        this._send("BINARY", b2);
      }).catch((err) => {
        this._errored(err);
      });
    } else {
      this._send("BINARY", b);
    }
  }
  _send(type, data) {
    if (this.readyState !== this.OPEN) {
      return;
    }
    const message2 = encodeMessage2(type, data, this.isClient);
    const byteLength = message2.byteLength;
    this.bufferedAmount += byteLength;
    this._write(message2, (err) => {
      this.bufferedAmount -= byteLength;
      if (err != null) {
        this._errored(err);
      }
    });
  }
  close(code5, reason) {
    if (this.readyState !== this.OPEN) {
      throw new Error("WebSocket was not open");
    }
    this.readyState = this.CLOSING;
    this.sentClose = true;
    this._send("CONNECTION_CLOSE");
  }
  _errored(err) {
    this.readyState = this.CLOSED;
    this.dispatchEvent(new ErrorEvent(err));
  }
  set onclose(listener) {
    this._onclose = listener;
    this.addEventListener("close", listener);
  }
  get onclose() {
    return this._onclose ?? null;
  }
  set onerror(listener) {
    this._onerror = listener;
    this.addEventListener("error", listener);
  }
  get onerror() {
    return this._onerror ?? null;
  }
  set onmessage(listener) {
    this._onmessage = listener;
    this.addEventListener("message", listener);
  }
  get onmessage() {
    return this._onmessage ?? null;
  }
  set onopen(listener) {
    this._onopen = listener;
    this.addEventListener("open", listener);
  }
  get onopen() {
    return this._onopen ?? null;
  }
  _push(buf2) {
    this.buffer.append(buf2);
    if (this.buffer.byteLength > this.maxMessageSize) {
      this.close(CLOSE_MESSAGES.MESSAGE_TOO_BIG, "Max message size exceeded");
      return;
    }
    while (true) {
      const message2 = decodeMessage2(this.buffer);
      if (message2 == null) {
        break;
      }
      if (DATA_MESSAGES.includes(message2.type) && message2.data != null) {
        let data;
        if (this.binaryType === "blob") {
          data = new Blob([message2.data]);
        } else {
          if (message2.data.byteOffset === 0 && message2.data.byteLength === message2.data.buffer.byteLength) {
            data = message2.data.buffer;
          } else {
            data = new ArrayBuffer(message2.data.byteLength);
            new Uint8Array(data, 0, data.byteLength).set(message2.data);
          }
        }
        this.dispatchEvent(new MessageEvent("message", {
          data,
          origin: this._url?.hostname
        }));
      }
      if (message2.type === "PING") {
        this._send("PONG", message2.data);
      }
      if (message2.type === "CONNECTION_CLOSE") {
        if (!this.sentClose) {
          this.close();
        }
        this.closeController.abort();
        this._close(void 0, () => {
          this.readyState = this.CLOSED;
          this.dispatchEvent(new CloseEvent("close"));
        });
      }
    }
  }
  /**
   * To be invoked when the underlying transport is closed by the remote end
   */
  _remoteClosed(err) {
    this.readyState = this.CLOSING;
    this._close(err, () => {
      this.readyState = this.CLOSED;
      this.dispatchEvent(new CloseEvent("close"));
    });
  }
};
var ServerWebSocket = class extends AbstractWebSocket {
  constructor(request, duplex, init = {}) {
    super(new URL(`http://${request.headers.host ?? DEFAULT_HOST}${request.url}`), {
      ...init,
      isClient: false
    });
    __publicField(this, "duplex");
    this.duplex = duplex;
    this.duplex.on("data", (buf2) => {
      this._push(buf2);
    });
    this.duplex.on("close", () => {
      this.close();
    });
    this.duplex.on("error", (err) => {
      this.close(CLOSE_MESSAGES.ABNORMAL_CLOSURE, err.message);
    });
    Promise.resolve().then(async () => {
      for await (const buf2 of performServerUpgrade(request.headers)) {
        this.duplex.write(buf2);
      }
      this.readyState = this.OPEN;
      this.dispatchEvent(new Event("open"));
    }).catch((err) => {
      this.duplex.destroy(err);
    });
  }
  _write(buf2, cb) {
    this.duplex.write(buf2.subarray(), cb);
  }
  _close(err, cb) {
    this.readyState = this.CLOSED;
    this.duplex.destroy(err);
    cb();
  }
};
var StreamWebSocket = class extends AbstractWebSocket {
  constructor(info, stream, init) {
    super(new URL(`http://${info.headers.get("host") ?? DEFAULT_HOST}${info.url}`), {
      ...init,
      isClient: false
    });
    __publicField(this, "bytes");
    this.bytes = byteStream(stream);
    Promise.resolve().then(async () => {
      for await (const buf2 of performServerUpgrade(info.headers)) {
        await this.bytes.write(buf2);
      }
      this.readyState = this.OPEN;
      this.dispatchEvent(new Event("open"));
      while (true) {
        const buf2 = await this.bytes.read();
        if (buf2 == null) {
          this._remoteClosed();
          break;
        }
        this._push(buf2);
      }
    }).catch((err) => {
      this._errored(err);
    });
  }
  _write(buf2, cb) {
    this.bytes?.write(buf2).then(() => {
      cb();
    }, (err) => {
      cb(err);
    });
  }
  _close(err, cb) {
    const stream = this.bytes?.unwrap();
    if (err != null) {
      stream?.abort(err);
      cb();
    } else {
      stream?.close().then(() => {
        cb();
      }, (err2) => {
        stream.abort(err2);
        cb();
      });
    }
  }
};
var RequestWebSocket = class extends AbstractWebSocket {
  constructor(request, writable, init = {}) {
    super(new URL(request.url), {
      ...init,
      isClient: false
    });
    __publicField(this, "writer");
    __publicField(this, "writable");
    if (request.body == null) {
      throw new InvalidParametersError2("Request body cannot be null");
    }
    this.readyState = this.OPEN;
    this.writable = writable;
    this.writer = writable.getWriter();
    const reader = request.body.getReader();
    Promise.resolve().then(async () => {
      this.dispatchEvent(new Event("open"));
      while (true) {
        const { value: value2, done } = await reader.read();
        if (value2 != null) {
          this._push(value2);
        }
        if (done) {
          this._remoteClosed();
          break;
        }
      }
    }).catch((err) => {
      this._errored(err);
    });
  }
  _write(buf2, cb) {
    this.writer?.write(buf2).then(() => {
      cb();
    }, (err) => {
      cb(err);
    });
  }
  _close(err, cb) {
    if (err != null) {
      this.writable.abort(err).then(() => {
        cb();
      }, () => {
        cb();
      });
    } else {
      this.writable.close().then(() => {
        cb();
      }, () => {
        cb();
      });
    }
  }
};
var WebSocket2 = class extends AbstractWebSocket {
  constructor(mas, url, connectionManager, init) {
    super(url, {
      ...init,
      isClient: true
    });
    __publicField(this, "stream");
    __publicField(this, "handshakeTimeout");
    __publicField(this, "drainTimeout");
    this.handshakeTimeout = init.handshakeTimeout ?? 1e4;
    this.drainTimeout = init.drainTimeout ?? 1e4;
    Promise.resolve().then(async () => {
      const signal = AbortSignal.timeout(this.handshakeTimeout);
      this.stream = await connectionManager.openStream(mas, HTTP_PROTOCOL, {
        ...init,
        signal
      });
      for await (const buf2 of performClientUpgrade(url, init.protocols, getHeaders(init))) {
        if (!this.stream.send(buf2)) {
          await this.stream.onDrain({
            signal
          });
        }
      }
      const res = await readResponse2(this.stream, {
        signal
      });
      if (res.status !== 101) {
        throw new Error("Invalid WebSocket handshake - response status " + res.status);
      }
      await init.onHandshakeResponse?.(res, {
        signal
      });
      this.protocol = res.headers.get("Sec-WebSocket-Protocol") ?? "";
      this.readyState = this.OPEN;
      this.dispatchEvent(new Event("open"));
      for await (const buf2 of this.stream) {
        this._push(buf2);
      }
    }).catch((err) => {
      this._errored(err);
    });
  }
  _write(buf2, cb) {
    if (this.stream == null) {
      cb(new Error("WebSocket was not open"));
      return;
    }
    if (!this.stream.send(buf2)) {
      this.stream.onDrain({
        signal: AbortSignal.timeout(this.drainTimeout)
      }).then(() => {
        cb();
      }, (err) => {
        cb(err);
      });
    } else {
      cb();
    }
  }
  _close(err, cb) {
    if (this.stream == null) {
      cb();
      return;
    }
    if (err != null) {
      this.stream.abort(err);
      cb();
      return;
    }
    this.stream.close().catch((err2) => {
      this.stream?.abort(err2);
    }).finally(() => {
      cb();
    });
  }
};

// ../../node_modules/@libp2p/http/dist/src/constants.js
var HTTP_PROTOCOL2 = "/http/1.1";
var PEER_ID_AUTH_SCHEME = "libp2p-PeerID";
var HTTP_PEER_ID_AUTH_PROTO = "/http-peer-id-auth/1.0.0";
var DEFAULT_COOKIE_EXPIRY_CHECK_INTERVAL = 6e4;
var WEBSOCKET_HANDLER = /* @__PURE__ */ Symbol.for("@libp2p/http/websocket-handler");

// ../../node_modules/@libp2p/http/dist/src/middleware/cookies.js
var import_cookie = __toESM(require_dist(), 1);
var Cookies = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "cookies");
    this.log = components.logger.forComponent("libp2p:http:cookies");
    this.cookies = /* @__PURE__ */ new Map();
  }
  async prepareRequest(resource, opts) {
    const credentials = opts.credentials ?? "same-origin";
    if (credentials === "omit") {
      return;
    }
    const origin = opts.headers.get("origin");
    if (origin == null || origin === "null") {
      return;
    }
    const url = toURL(resource, opts.headers);
    const cookies = (this.cookies.get(url.hostname) ?? []).filter((cookie2) => {
      if (cookie2.expires != null && cookie2.expires < Date.now()) {
        return false;
      }
      if (cookie2.path != null && !url.pathname.startsWith(cookie2.path)) {
        return false;
      }
      return true;
    }).map((cookie2) => `${cookie2.name}=${cookie2.value}`).join("; ");
    if (cookies.length > 0) {
      opts.headers.set("cookie", cookies);
    }
  }
  async processResponse(resource, opts, response) {
    const credentials = opts.credentials ?? "same-origin";
    if (credentials === "omit") {
      removeSetCookie(response);
      return;
    }
    const origin = opts.headers.get("origin");
    if (origin == null || origin === "null") {
      return;
    }
    const url = toURL(resource, opts.headers);
    for (const value2 of response.headers.getSetCookie()) {
      const cookies = [
        ...this.cookies.get(url.hostname) ?? [],
        ...toCookies(import_cookie.default.parse(value2))
      ];
      this.cookies.set(url.hostname, cookies);
    }
    removeSetCookie(response);
  }
};
function removeSetCookie(response) {
  if (response.headers.has("set-cookie")) {
    response.headers.delete("set-cookie");
  }
  return response;
}
function toCookies(parsed) {
  const metadata = {};
  const output = [];
  Object.entries(parsed).forEach(([name5, value2]) => {
    if (name5.toLowerCase() === "domain" && value2 != null) {
      metadata.domain = value2;
    }
    if (name5.toLowerCase() === "max-age" && value2 != null) {
      metadata.expires = Date.now() + parseInt(value2, 10) * 1e3;
    }
    if (!COOKIE_FIELDS.includes(name5.toLowerCase()) && value2 != null) {
      output.push({
        name: name5,
        value: value2
      });
    }
  });
  return output.map((c2) => ({
    ...c2,
    ...metadata
  }));
}
var COOKIE_FIELDS = [
  "domain",
  "expires",
  "httponly",
  "max-age",
  "partitioned",
  "path",
  "samesite",
  "secure"
];

// ../../node_modules/@libp2p/http/dist/src/middleware/origin.js
var Origin = class {
  async prepareRequest(resource, opts) {
    if (opts.headers.get("origin") != null) {
      return;
    }
    if (opts.mode === "no-cors") {
      return;
    }
    const url = toURL(resource, opts.headers);
    opts.headers.set("origin", `${url.protocol}//${url.host}`);
  }
};

// ../../node_modules/@libp2p/http/dist/src/routes/utils.js
function isInitializable(obj) {
  return typeof obj.init === "function";
}
function initializeRoute(serviceOrHandler, components) {
  if (isInitializable(serviceOrHandler)) {
    const route = serviceOrHandler;
    route.handler = serviceOrHandler.init(components);
    delete route.init;
    return route;
  }
  return serviceOrHandler;
}

// ../../node_modules/@libp2p/http/dist/src/routes/websocket.js
function webSocketRoute(route) {
  const method = normalizeMethod(route.method, ["GET"]);
  if (route.fallback == null && method.filter((method2) => method2 !== "GET").length > 0) {
    throw new InvalidParametersError2("WebSocket handlers only support the GET HTTP method");
  }
  const output = {
    ...route,
    init: (components) => {
      const next = initializeRoute(route, components);
      output[WEBSOCKET_HANDLER] = next.handler;
      return async (req) => {
        if (!isWebSocketUpgrade(req.method, req.headers)) {
          if (route?.fallback != null) {
            return route.fallback(req);
          }
          return new Response2(null, {
            status: 400
          });
        }
        const transform = new TransformStream();
        try {
          const res = new Response2(transform.readable, {
            status: 101,
            headers: await getServerUpgradeHeaders(req.headers)
          });
          const ws = new RequestWebSocket(req, transform.writable, route);
          next.handler(ws);
          return res;
        } catch (err) {
          return new Response2(null, {
            status: 500
          });
        }
      };
    }
  };
  return output;
}

// ../../node_modules/@libp2p/http/dist/src/routes/well-known.js
var WELL_KNOWN_PROTOCOLS_PATH = "/.well-known/libp2p/protocols";
function wellKnownRoute(registrar) {
  return webSocketRoute({
    path: WELL_KNOWN_PROTOCOLS_PATH,
    method: ["GET"],
    cors: true,
    handler: (ws) => {
      const map2 = JSON.stringify(registrar.getProtocolMap());
      ws.send(map2);
      ws.close();
    },
    fallback: async (req) => {
      const map2 = JSON.stringify(registrar.getProtocolMap());
      return new Response(map2, {
        headers: {
          "Content-Type": "application/json",
          "Content-Length": `${map2.length}`
        }
      });
    }
  });
}

// ../../node_modules/@libp2p/http/dist/src/registrar.js
var HTTPRegistrar = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "protocols");
    __publicField(this, "endpoint");
    this.components = components;
    this.log = components.logger.forComponent("libp2p:http:registrar");
    this.protocols = [];
    this.onStream = this.onStream.bind(this);
    this.endpoint = init.server;
    this.handle("", wellKnownRoute(this));
  }
  async start() {
    await this.components.registrar.handle(HTTP_PROTOCOL2, this.onStream.bind(this));
  }
  async stop() {
    await this.components.registrar.unhandle(HTTP_PROTOCOL2);
  }
  async onStream(stream, connection) {
    const info = await readHeaders(stream);
    if (this.canHandle(info)) {
      this.log("handling incoming request %s %s", info.method, info.url);
      const res = await this.onRequest(streamToRequest(info, stream));
      await responseToStream(res, stream);
      await stream.close();
      return;
    }
    if (this.endpoint == null) {
      this.log("cannot handle incoming request %s %s and no endpoint configured", info.method, info.url);
      stream.send(NOT_FOUND_RESPONSE);
      await stream.close();
      return;
    }
    this.log("passing incoming request %s %s to endpoint", info.method, info.url);
    this.endpoint.inject(info, stream, connection).catch((err) => {
      this.log.error("error injecting request to endpoint - %e", err);
      stream.abort(err);
    });
  }
  canHandle(req) {
    const url = normalizeUrl(req).pathname;
    if (this.protocols.find((p2) => p2.route.path === url) != null) {
      this.log.trace("can handle %s", url);
      return true;
    }
    this.log.trace("cannot handle %s", url);
    return false;
  }
  async onRequest(request) {
    this.log("incoming request %s %s", request.method, request.url);
    const handler = this.findHandler(request.url);
    if (handler == null) {
      return new Response(null, {
        status: 404
      });
    }
    let response;
    if (!handler.route.method.includes(request.method)) {
      if (request.method === "OPTIONS") {
        response = new Response(null, {
          status: 204
        });
      } else {
        response = new Response(null, {
          status: 405
        });
      }
    } else {
      response = await handler.route.handler(request);
    }
    addHeaders(response, request, handler);
    this.log("%s %s %d %s", request.method, request.url, response.status, response.statusText);
    return response;
  }
  onWebSocket(ws) {
    const handler = this.findHandler(ws.url);
    if (handler != null) {
      const wsHandler = handler.route[WEBSOCKET_HANDLER];
      if (wsHandler != null) {
        wsHandler(ws);
        return;
      }
    }
    ws.close(CLOSE_MESSAGES.NORMAL_CLOSURE);
  }
  findHandler(url) {
    const pathname = url.startsWith("/") ? url : new URL(url).pathname;
    this.log("search for handler on path %s", pathname);
    const handler = this.protocols.find((p2) => p2.route.path === pathname);
    if (handler != null) {
      this.log("found handler for HTTP protocol %s on path %s", handler.protocol, url);
    }
    return handler;
  }
  handle(protocol2, route) {
    route.path = route.path ?? protocol2;
    if (this.protocols.find((p2) => p2.protocol === protocol2) != null) {
      throw new InvalidParametersError2(`HTTP protocol handler for ${protocol2} already registered`);
    }
    if (route.path === "" || !route.path.startsWith("/")) {
      route.path = `/${route.path}`;
    }
    route.cors = route.cors ?? true;
    route.method = normalizeMethod(route.method);
    route = initializeRoute(route, this.components);
    this.protocols.push({
      protocol: protocol2,
      // @ts-expect-error optional fields are filled out above
      route
    });
    this.protocols.sort(({ route: { path: a2 } }, { route: { path: b } }) => b.length - a2.length);
  }
  unhandle(protocol2) {
    this.protocols = this.protocols.filter((p2) => p2.protocol === protocol2);
  }
  getProtocolMap() {
    const output = {};
    for (const p2 of this.protocols) {
      if (p2.protocol === "") {
        continue;
      }
      output[p2.protocol] = {
        path: p2.route.path
      };
    }
    return output;
  }
};
function addHeaders(response, request, handler) {
  const allow = [.../* @__PURE__ */ new Set(["OPTIONS", ...handler.route.method])].join(", ");
  if (handler.route.cors) {
    if (request.headers.get("Access-Control-Request-Method") != null) {
      response.headers.set("access-control-allow-methods", allow);
    }
    if (request.headers.get("Access-Control-Request-Headers") != null) {
      response.headers.set("access-control-allow-headers", request.headers.get("Access-Control-Request-Headers") ?? "");
    }
    if (request.headers.get("Origin") != null) {
      response.headers.set("access-control-allow-origin", request.headers.get("Origin") ?? "");
      response.headers.set("vary", "Origin");
    }
  }
  if (request.method === "OPTIONS") {
    response.headers.set("allow", allow);
  }
}

// ../../node_modules/@libp2p/http/dist/src/utils.js
async function prepareAndSendRequest(resource, opts, sendRequest2) {
  for (const middleware of opts.middleware) {
    await middleware.prepareRequest?.(resource, opts);
  }
  return sendRequest2();
}
async function prepareAndConnect(resource, opts, connect2) {
  for (const middleware of opts.middleware) {
    await middleware.prepareRequest?.(resource, opts);
  }
  return connect2();
}
async function processResponse(resource, opts, response) {
  for (const middleware of opts.middleware) {
    await middleware.processResponse?.(resource, opts, response);
  }
  return response;
}

// ../../node_modules/@libp2p/http/dist/src/http.browser.js
var _a15, _b12;
_b12 = Symbol.toStringTag, _a15 = serviceCapabilities2;
var HTTP2 = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "httpRegistrar");
    __publicField(this, "origin");
    __publicField(this, "cookies");
    __publicField(this, _b12, "@libp2p/http");
    __publicField(this, _a15, [
      "@libp2p/http"
    ]);
    this.components = components;
    this.log = components.logger.forComponent("libp2p:http");
    this.httpRegistrar = new HTTPRegistrar(components, init);
    this.origin = new Origin();
    this.cookies = new Cookies(components, init);
  }
  async start() {
    await start(this.httpRegistrar);
  }
  async stop() {
    await stop(this.httpRegistrar);
  }
  agent(...args) {
    throw new UnsupportedOperationError2("This method is not supported in browsers");
  }
  dispatcher(...args) {
    throw new UnsupportedOperationError2("This method is not supported in browsers");
  }
  async connect(resource, init = {}) {
    const url = toResource(resource);
    const headers = getHeaders(init);
    const opts = {
      ...init,
      headers,
      method: "GET",
      middleware: init.middleware?.map((fn) => fn(this.components)) ?? []
    };
    headers.set("connection", "upgrade");
    headers.set("upgrade", "websocket");
    return prepareAndConnect(url, opts, async () => {
      if (url instanceof URL) {
        const socket = new window.WebSocket(url, init.protocols);
        socket.binaryType = "arraybuffer";
        return socket;
      }
      const { addresses, httpPath } = stripHTTPPath(url);
      return new WebSocket2(addresses, new URL(`http://${getHost(url, opts.headers)}${decodeURIComponent(httpPath)}`), this.components.connectionManager, opts);
    });
  }
  async fetch(resource, init = {}) {
    const url = toResource(resource);
    const opts = {
      ...init,
      headers: getHeaders(init),
      method: "GET",
      middleware: [
        this.origin,
        this.cookies,
        ...init.middleware?.map((fn) => fn(this.components)) ?? []
      ]
    };
    const response = await prepareAndSendRequest(url, opts, async () => {
      return this.sendRequest(url, init);
    });
    return processResponse(url, opts, response);
  }
  async connectProtocol(resource, protocol2, init) {
    const path = await this.getProtocolPath(resource, protocol2, init);
    const url = toResource(resource, path);
    return this.connect(url, init);
  }
  async fetchProtocol(resource, protocol2, init = {}) {
    const path = await this.getProtocolPath(resource, protocol2, init);
    const url = toResource(resource, path);
    return this.fetch(url, init);
  }
  async getSupportedProtocols(resource, options2 = {}) {
    const url = toResource(resource, WELL_KNOWN_PROTOCOLS_PATH);
    const resp = await this.fetch(url, {
      method: "GET",
      headers: {
        Accept: "application/json"
      },
      signal: options2.signal
    });
    if (resp.status !== 200) {
      throw new Error(`Unexpected status code: ${resp.status}`);
    }
    return resp.json();
  }
  async getProtocolPath(peer, protocol2, options2 = {}) {
    const peerMeta = await this.getSupportedProtocols(peer, options2);
    if (peerMeta[protocol2] == null) {
      throw new Error(`Peer does not serve protocol: ${protocol2}`);
    }
    return peerMeta[protocol2].path;
  }
  canHandle(req) {
    return this.httpRegistrar.canHandle(req);
  }
  async onRequest(req) {
    return this.httpRegistrar.onRequest(req);
  }
  onWebSocket(ws) {
    this.httpRegistrar.onWebSocket(ws);
  }
  handle(protocol2, handler) {
    this.httpRegistrar.handle(protocol2, handler);
  }
  unhandle(protocol2) {
    this.httpRegistrar.unhandle(protocol2);
  }
  getProtocolMap() {
    return this.httpRegistrar.getProtocolMap();
  }
  async sendRequest(resource, init) {
    if (resource instanceof URL) {
      this.log("making request to %s with global fetch");
      return window.fetch(resource, init);
    }
    this.log("making request to %s with libp2p fetch", resource);
    const host = getHost(resource, getHeaders(init));
    const { addresses, httpPath } = stripHTTPPath(resource);
    const connection = await this.components.connectionManager.openConnection(addresses, {
      signal: init.signal ?? void 0
    });
    const stream = await connection.newStream(HTTP_PROTOCOL2, {
      signal: init.signal ?? void 0
    });
    return fetch2(stream, new URL(`http://${host}${decodeURIComponent(httpPath)}`), init);
  }
};

// ../../node_modules/@libp2p/http-peer-id-auth/dist/src/utils.js
var MAX_AUTH_HEADER_SIZE = 2048;
function generateChallenge() {
  const randomBytes4 = new Uint8Array(32);
  crypto.getRandomValues(randomBytes4);
  return toString2(randomBytes4, "base64urlpad");
}
function encodeAuthParams(params) {
  const encodedParams = Object.entries(params).map(([key, value2]) => `${key}="${value2}"`).join(", ");
  return `${PEER_ID_AUTH_SCHEME2} ${encodedParams}`;
}
async function sign2(key, prefix, partsToSign) {
  const dataToSign = genDataToSign(prefix, partsToSign);
  return key.sign(dataToSign);
}
async function verify(key, prefix, partsToSign, sig) {
  const dataToSign = genDataToSign(prefix, partsToSign);
  return key.verify(dataToSign, sig);
}
var textEncoder3 = new TextEncoder();
function sizeOfPart([k, v]) {
  return k.length + 1 + v.length;
}
function genDataToSign(prefix, partsToSign) {
  partsToSign.sort((a2, b) => a2[0].localeCompare(b[0]));
  const size = partsToSign.reduce((acc, p2) => acc + encodingLength2(sizeOfPart(p2)) + sizeOfPart(p2), prefix.length);
  const out = new Uint8Array(size);
  let offset = 0;
  const res = textEncoder3.encodeInto(prefix, out);
  offset += res.written;
  for (const [k, v] of partsToSign) {
    const len = sizeOfPart([k, v]);
    encodeUint8Array(len, out, offset);
    offset += encodingLength2(len);
    let res2 = textEncoder3.encodeInto(k, out.subarray(offset));
    offset += res2.written;
    res2 = textEncoder3.encodeInto("=", out.subarray(offset));
    offset += res2.written;
    if (typeof v === "string") {
      res2 = textEncoder3.encodeInto(v, out.subarray(offset));
      offset += res2.written;
    } else {
      out.set(v, offset);
      offset += v.length;
    }
  }
  return out;
}
function decodeAuthorizationHeader(header) {
  if (header.length < PEER_ID_AUTH_SCHEME2.length + 1) {
    throw new InvalidMessageError2("Authorization header too short");
  }
  if (header.length > MAX_AUTH_HEADER_SIZE) {
    throw new InvalidMessageError2("Authorization header too long");
  }
  if (!header.includes(PEER_ID_AUTH_SCHEME2)) {
    throw new InvalidMessageError2("No peer id auth scheme found");
  }
  const rest = header.substring(PEER_ID_AUTH_SCHEME2.length).trim();
  const params = {};
  const regex = /(\w[^=]+)="([^"]+)"/g;
  let match;
  while ((match = regex.exec(rest)) !== null) {
    params[match[1]] = match[2];
  }
  return params;
}
async function genOpaque(privateKey, unwrapped) {
  return signBox(privateKey, unwrapped);
}
async function unwrapOpaque(publicKey2, data) {
  const unwrapped = await verifyBox(publicKey2, data.opaque);
  if (typeof unwrapped.challengeClient !== "string" || typeof unwrapped.hostname !== "string" || typeof unwrapped.creationTime !== "number") {
    throw new Error("Invalid opaque");
  }
  return unwrapped;
}
async function signBox(key, data) {
  const dataSerialized = JSON.stringify(data);
  const dataBytes = fromString2(dataSerialized);
  const sig = await key.sign(dataBytes);
  const jsonStr = JSON.stringify({
    val: toString2(dataBytes, "base64urlpad"),
    sig: toString2(sig, "base64urlpad")
  });
  return toString2(fromString2(jsonStr), "base64urlpad");
}
async function verifyBox(key, data) {
  const { sig, val } = JSON.parse(toString2(fromString2(data, "base64urlpad")));
  const valBytes = fromString2(val, "base64urlpad");
  const sigValid = await key.verify(valBytes, fromString2(sig, "base64urlpad"));
  if (!sigValid) {
    throw new Error("Invalid signature");
  }
  const valStr = toString2(valBytes);
  return JSON.parse(valStr);
}
async function genBearerToken(serverKey, clientPeerId, hostname) {
  return signBox(serverKey, {
    peer: clientPeerId.toString(),
    h: hostname,
    t: Date.now()
  });
}

// ../../node_modules/@libp2p/http-peer-id-auth/dist/src/validation.js
function validateOpaqueData(opaque, hostname, tokenTTL) {
  if (opaque.hostname !== hostname) {
    throw new InvalidMessageError2("Invalid hostname");
  }
  if (opaque.challengeClient == null) {
    throw new InvalidMessageError2("Missing challenge-client");
  }
  if (Date.now() - opaque.creationTime > tokenTTL) {
    throw new InvalidMessageError2("Token expired");
  }
}

// ../../node_modules/@libp2p/http-peer-id-auth/dist/src/server.js
function isClientChallenge(obj) {
  if (obj == null) {
    return false;
  }
  return typeof obj["challenge-server"] === "string" && typeof obj["public-key"] === "string";
}
function isOpaqueData(obj) {
  if (obj == null) {
    return false;
  }
  return typeof obj.opaque === "string" && typeof obj.sig === "string";
}
function isServerChallengeResponse(obj) {
  if (obj == null) {
    return false;
  }
  return typeof obj["challenge-server"] === "string" && typeof obj["public-key"] === "string" && typeof obj.opaque === "string" && typeof obj.sig === "string";
}
async function issueBearerToken(data, hostname, serverKey, tokenTTL) {
  const opaque = await unwrapOpaque(serverKey.publicKey, data);
  validateOpaqueData(opaque, hostname, tokenTTL);
  if (opaque.clientPublicKey == null) {
    throw new InvalidMessageError2("Missing client public key");
  }
  const clientPublicKey = publicKeyFromProtobuf(fromString2(opaque.clientPublicKey, "base64urlpad"));
  const clientPeerId = peerIdFromPublicKey3(clientPublicKey);
  const valid = await verify(clientPublicKey, PEER_ID_AUTH_SCHEME2, [
    ["challenge-client", opaque.challengeClient],
    ["hostname", hostname],
    ["server-public-key", publicKeyToProtobuf(serverKey.publicKey)]
  ], fromString2(data.sig, "base64urlpad"));
  if (!valid) {
    throw new InvalidMessageError2("Invalid signature");
  }
  return {
    peerId: clientPeerId,
    info: encodeAuthParams({
      bearer: await genBearerToken(serverKey, clientPeerId, hostname)
    })
  };
}
async function respondToClientChallenge(clientChallenge, hostname, serverKey) {
  const clientPublicKey = publicKeyFromProtobuf(fromString2(clientChallenge["public-key"], "base64urlpad"));
  const clientPeerId = peerIdFromPublicKey3(clientPublicKey);
  const sig = await sign2(serverKey, PEER_ID_AUTH_SCHEME2, [
    ["challenge-server", clientChallenge["challenge-server"]],
    ["client-public-key", publicKeyToProtobuf(clientPublicKey)],
    ["hostname", hostname]
  ]);
  const challenge2 = generateChallenge();
  return {
    peerId: clientPeerId,
    authenticate: encodeAuthParams({
      "challenge-client": challenge2,
      "public-key": toString2(publicKeyToProtobuf(serverKey.publicKey), "base64urlpad"),
      sig: toString2(sig, "base64urlpad"),
      opaque: await genOpaque(serverKey, {
        challengeClient: challenge2,
        creationTime: Date.now(),
        hostname,
        clientPublicKey: clientChallenge["public-key"]
      })
    })
  };
}
async function respondToServerChallengeResponse(response, hostname, serverKey) {
  const clientPublicKey = publicKeyFromProtobuf(fromString2(response["public-key"], "base64urlpad"));
  const clientPeerId = peerIdFromPublicKey3(clientPublicKey);
  const sig = await sign2(serverKey, PEER_ID_AUTH_SCHEME2, [
    ["challenge-server", response["challenge-server"]],
    ["client-public-key", publicKeyToProtobuf(clientPublicKey)],
    ["hostname", hostname]
  ]);
  return {
    peerId: clientPeerId,
    info: encodeAuthParams({
      sig: toString2(sig, "base64urlpad"),
      bearer: await genBearerToken(serverKey, clientPeerId, hostname)
    })
  };
}
async function unwrapBearerToken(token, expectedHostname, privateKey, tokenTTL) {
  const unwrapped = await verifyBox(privateKey.publicKey, token.bearer);
  if (typeof unwrapped.peer !== "string" || typeof unwrapped.h !== "string" || typeof unwrapped.t !== "number") {
    throw new InvalidMessageError2("Invalid bearer token");
  }
  if (unwrapped.h !== expectedHostname) {
    throw new InvalidMessageError2("Invalid hostname");
  }
  if (Date.now() - unwrapped.t > (tokenTTL ?? DEFAULT_AUTH_TOKEN_TTL)) {
    throw new InvalidMessageError2("Token expired");
  }
  return peerIdFromString3(unwrapped.peer);
}

// ../../node_modules/@libp2p/http-peer-id-auth/dist/src/index.js
var PEER_ID_AUTH_SCHEME2 = "libp2p-PeerID";
var HTTP_PEER_ID_AUTH_PROTOCOL = "/http-peer-id-auth/1.0.0";
var DEFAULT_AUTH_TOKEN_TTL = 60 * 60 * 1e3;
function isBearerToken(obj) {
  if (obj == null) {
    return false;
  }
  return typeof obj.bearer === "string";
}
async function createServerChallenge(hostname, serverKey) {
  const challenge2 = generateChallenge();
  return encodeAuthParams({
    "challenge-client": challenge2,
    "public-key": toString2(publicKeyToProtobuf(serverKey.publicKey), "base64urlpad"),
    opaque: await genOpaque(serverKey, {
      challengeClient: challenge2,
      hostname,
      creationTime: Date.now()
    })
  });
}
async function serverResponds(authHeader, hostname, serverKey, tokenTTL = DEFAULT_AUTH_TOKEN_TTL) {
  const authFields = decodeAuthorizationHeader(authHeader);
  if (isServerChallengeResponse(authFields)) {
    return respondToServerChallengeResponse(authFields, hostname, serverKey);
  }
  if (isClientChallenge(authFields)) {
    return respondToClientChallenge(authFields, hostname, serverKey);
  }
  if (isOpaqueData(authFields)) {
    return issueBearerToken(authFields, hostname, serverKey, tokenTTL);
  }
  if (isBearerToken(authFields)) {
    return {
      peerId: await unwrapBearerToken(authFields, hostname, serverKey, tokenTTL)
    };
  }
  throw new InvalidMessageError2("Client sent invalid message");
}

// ../../node_modules/@libp2p/http/dist/src/routes/peer-id-auth.js
var DEFAULT_AUTH_TOKEN_TTL2 = 60 * 60 * 1e3;
var PeerIdAuth = class {
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "log");
    __publicField(this, "tokenTTL");
    __publicField(this, "verifyHostname");
    __publicField(this, "requireAuth");
    this.components = components;
    this.log = components.logger.forComponent("libp2p:http:server-peer-id-auth");
    this.tokenTTL = init.tokenTTL ?? DEFAULT_AUTH_TOKEN_TTL2;
    this.requireAuth = init.requireAuth ?? true;
    this.verifyHostname = init.verifyHostname ?? (() => true);
  }
  async authenticateRequest(hostname, method, authHeader) {
    if (!await this.verifyHostname(hostname)) {
      this.log.error("hostname verification failed");
      return { status: 400 };
    }
    if (authHeader == null || authHeader === "") {
      if (method === "OPTIONS" || this.requireAuth === false) {
        return { status: 200 };
      }
      return this.returnChallenge(hostname);
    }
    try {
      const result = await serverResponds(authHeader, hostname, this.components.privateKey, this.tokenTTL);
      const headers = new Headers();
      let status = 200;
      if (result.info != null) {
        headers.set("authentication-info", result.info);
        headers.set("access-control-expose-headers", "authentication-info");
      }
      if (result.authenticate != null) {
        status = 401;
        headers.set("www-authenticate", result.authenticate);
        headers.set("access-control-expose-headers", "www-authenticate");
      }
      return {
        status,
        headers,
        peer: result.peerId
      };
    } catch (err) {
      this.log.error("failed to respond to client challenge - %e", err);
      if (err.name === "InvalidMessageError") {
        return { status: 400 };
      }
      if (err.name === "NotAuthenticatedError") {
        return this.returnChallenge(hostname);
      }
      throw err;
    }
  }
  async returnChallenge(hostname) {
    return {
      status: 401,
      headers: new Headers({
        "www-authenticate": await createServerChallenge(hostname, this.components.privateKey),
        "access-control-expose-headers": "www-authenticate"
      })
    };
  }
};
function isOptionalAuth(obj) {
  return obj.requireAuth === false;
}
async function authenticate(req, authResult, handlerMethods, next) {
  const authIsOptional = isOptionalAuth(next);
  if (!authIsOptional && (authResult.peer == null || authResult.status !== 200)) {
    return new Response(void 0, {
      status: authResult.status,
      headers: authResult.headers
    });
  }
  if (!handlerMethods.includes(req.method)) {
    let res;
    if (req.method === "OPTIONS") {
      res = new Response(void 0, {
        status: 204,
        headers: authResult.headers
      });
    } else {
      res = new Response(void 0, {
        status: 405
      });
    }
    if (authResult.headers !== void 0) {
      for (const [key, value2] of authResult.headers) {
        res.headers.set(key, value2);
      }
    }
    return res;
  }
  return next.handler(req, authResult.peer);
}
function authenticatedRoute(handler) {
  const handlerMethods = normalizeMethod(handler.method);
  return {
    path: handler.path,
    method: ["OPTIONS", ...handlerMethods],
    cors: handler.cors,
    init: (components) => {
      const auth = new PeerIdAuth(components, handler);
      const next = initializeRoute(handler, components);
      return async (req) => {
        const authResult = await auth.authenticateRequest(readHostname(req), req.method, req.headers.get("Authorization"));
        return authenticate(req, authResult, handlerMethods, next);
      };
    }
  };
}
function authenticatedWebSocketRoute(handler) {
  const handlerMethods = normalizeMethod(handler.method);
  const output = {
    path: handler.path,
    method: ["OPTIONS", ...handlerMethods],
    cors: handler.cors,
    init: (components) => {
      const auth = new PeerIdAuth(components, handler);
      const next = initializeRoute(handler, components);
      output[WEBSOCKET_HANDLER] = (ws) => {
        auth.authenticateRequest(readHostname(ws), "", readProtocol(ws)).then((authResult) => {
          next.handler(ws, authResult.peer);
        }).catch(() => {
          ws.close();
        });
      };
      return async (req) => {
        const authResult = await auth.authenticateRequest(readHostname(req), req.method, readAuthorization(req) ?? readSecWebSocketProtocol(req));
        return authenticate(req, authResult, handlerMethods, {
          ...next,
          handler: async (req2, peerId) => {
            const wsRoute = initializeRoute(webSocketRoute({
              ...next,
              handler: (ws) => {
                next.handler(ws, peerId);
              },
              fallback: next.fallback == null ? void 0 : async (req3) => {
                return authenticate(req3, authResult, handlerMethods, {
                  ...next,
                  handler: async (res, peerId2) => {
                    if (next.fallback == null) {
                      return new Response(void 0, {
                        status: 500
                      });
                    }
                    return next.fallback(res, peerId2);
                  }
                });
              }
            }), components);
            return wsRoute.handler(req2);
          }
        });
      };
    }
  };
  return output;
}
function readHostname(req) {
  const url = new URL(req.url);
  let hostname = url.hostname;
  if (url.port === "" || url.port === void 0) {
    return hostname;
  }
  if (url.protocol === "http:" && url.port !== "80") {
    hostname += ":" + url.port;
  }
  if (url.protocol === "https:" && url.port !== "443") {
    hostname += ":" + url.port;
  }
  if (hostname === "") {
    throw new Error("No hostname");
  }
  return hostname;
}
function readAuthorization(req) {
  const authorization = req.headers.get("Authorization");
  if (authorization == null) {
    return;
  }
  return authorization;
}
var SEC_WEBSOCKET_PROTOCOL_PREFIX = "authorization=";
function readSecWebSocketProtocol(req) {
  const protocol2 = req.headers.get("Sec-WebSocket-Protocol");
  if (protocol2 == null) {
    return;
  }
  const protos = protocol2.split(",");
  const authorization = protos.filter((p2) => p2.startsWith(SEC_WEBSOCKET_PROTOCOL_PREFIX)).pop();
  if (authorization != null) {
    req.headers.set("Sec-WebSocket-Protocol", protos.filter((p2) => !p2.startsWith(SEC_WEBSOCKET_PROTOCOL_PREFIX)).join(","));
  }
  if (authorization == null) {
    return;
  }
  return atob(authorization.substring(SEC_WEBSOCKET_PROTOCOL_PREFIX.length));
}
function readProtocol(ws) {
  const protocol2 = ws.protocol;
  if (protocol2 == null) {
    return;
  }
  const protos = protocol2.split(",");
  const authorization = protos.filter((p2) => p2.startsWith(SEC_WEBSOCKET_PROTOCOL_PREFIX)).pop();
  if (authorization != null) {
    ws.protocol = protos.filter((p2) => !p2.startsWith(SEC_WEBSOCKET_PROTOCOL_PREFIX)).join(",");
  }
  if (authorization == null) {
    return;
  }
  return atob(authorization.substring(SEC_WEBSOCKET_PROTOCOL_PREFIX.length));
}

// ../../node_modules/@libp2p/http/dist/src/index.js
function http(init = {}) {
  return (components) => new HTTP2(components, init);
}

// ../../node_modules/@libp2p/http-ping/dist/src/ping.js
var _a16, _b13;
var PING_SIZE = 32;
_b13 = Symbol.toStringTag, _a16 = serviceDependencies2;
var PingHTTPService = class {
  constructor(components, init = {}) {
    __publicField(this, "components");
    __publicField(this, "log");
    __publicField(this, "init");
    __publicField(this, _b13, "@libp2p/ping-http");
    __publicField(this, _a16, [
      "@libp2p/http"
    ]);
    this.components = components;
    this.log = components.logger.forComponent("libp2p:http:ping");
    this.init = init;
    this.onHTTPRequest = this.onHTTPRequest.bind(this);
    this.onWebSocket = this.onWebSocket.bind(this);
  }
  start() {
    this.components.http.handle(HTTP_PING_PROTOCOL, authenticatedWebSocketRoute({
      ...this.init,
      requireAuth: this.init.requireAuth ?? false,
      method: ["GET", "POST"],
      handler: this.onWebSocket,
      fallback: this.onHTTPRequest
    }));
  }
  stop() {
    this.components.http.unhandle(HTTP_PING_PROTOCOL);
  }
  async onHTTPRequest(req) {
    this.log("incoming HTTP ping request");
    if (req.body == null) {
      this.log.error("body was null");
      return new Response(null, { status: 400 });
    }
    const ab = await req.arrayBuffer();
    const buf2 = new Uint8Array(ab, 0, ab.byteLength);
    if (buf2.byteLength !== PING_SIZE) {
      this.log.error("ping data length was incorrect - expected %d got %d", PING_SIZE, buf2.byteLength);
      return new Response(null, { status: 400 });
    }
    return new Response(buf2, {
      headers: {
        "Content-Type": "application/octet-stream",
        "Content-Length": `${PING_SIZE}`
      }
    });
  }
  onWebSocket(ws) {
    this.log("incoming WebSocket ping request");
    ws.addEventListener("message", (evt) => {
      const buf2 = new Uint8Array(evt.data, 0, evt.data.byteLength);
      if (buf2.length !== PING_SIZE) {
        this.log.error("ping data length was incorrect - expected %d got %d", PING_SIZE, buf2.byteLength);
        ws.close(400);
        return;
      }
      ws.send(buf2);
      ws.close();
    });
  }
  async ping(peer, options2 = {}) {
    const start2 = Date.now();
    const buf2 = new Uint8Array(PING_SIZE);
    crypto.getRandomValues(buf2);
    this.log("ping %s", peer);
    const output = await raceSignal(isPingWebSocketOptions(options2) ? this.webSocketPing(peer, buf2, options2) : this.httpPing(peer, buf2, options2), options2?.signal ?? void 0);
    const respBuf = new Uint8Array(output, 0, output.byteLength);
    if (respBuf.length !== PING_SIZE) {
      throw new ProtocolError2(`Unexpected response size: ${respBuf.length}`);
    }
    if (!equals3(respBuf, buf2)) {
      throw new ProtocolError2("Ping body mismatch");
    }
    return Date.now() - start2;
  }
  async httpPing(peer, buf2, options2) {
    const res = await this.components.http.fetchProtocol(peer, HTTP_PING_PROTOCOL, {
      ...options2,
      method: "POST",
      body: buf2,
      signal: options2.signal ?? void 0
    });
    if (res.status !== 200) {
      throw new ProtocolError2(`Unexpected status code: ${res.status}`);
    }
    return res.arrayBuffer();
  }
  async webSocketPing(peer, buf2, options2) {
    const socket = await this.components.http.connectProtocol(peer, HTTP_PING_PROTOCOL, {
      ...options2,
      signal: options2.signal ?? void 0
    });
    if (socket.readyState !== WebSocket.OPEN) {
      await raceEvent(socket, "open", options2.signal ?? void 0);
      this.log("websocket connection to %s open", peer);
    }
    const p2 = new Promise((resolve, reject) => {
      socket.addEventListener("message", (evt) => {
        this.log("received ping response from %s", peer);
        resolve(evt.data);
      });
      socket.addEventListener("error", (evt) => {
        this.log("ping to %s errored - %e", peer, evt.error ?? evt);
        reject(new Error("An error occurred"));
      });
      socket.addEventListener("close", () => {
        this.log("ping to %a closed prematurely", peer);
        reject(new Error("The WebSocket was closed before the pong was received"));
      });
    });
    this.log("send ping message to %s", peer);
    socket.send(buf2);
    return p2;
  }
};
function isPingWebSocketOptions(obj) {
  return obj?.webSocket === true;
}

// ../../node_modules/@libp2p/http-ping/dist/src/index.js
var HTTP_PING_PROTOCOL = "/http-ping/1";
function pingHTTP(init = {}) {
  return (components) => new PingHTTPService(components, init);
}

// ../../node_modules/it-drain/dist/src/index.js
function isAsyncIterable5(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain(source) {
  if (isAsyncIterable5(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
var src_default3 = drain;

// ../../node_modules/it-parallel/dist/src/index.js
var CustomEvent2 = window.CustomEvent ?? Event;
async function* parallel(source, options2 = {}) {
  let concurrency = options2.concurrency ?? Infinity;
  if (concurrency < 1) {
    concurrency = Infinity;
  }
  const ordered = options2.ordered ?? false;
  const emitter = new EventTarget();
  const ops = [];
  let slotAvailable = pDefer();
  let resultAvailable = pDefer();
  let sourceFinished = false;
  let sourceErr;
  let opErred = false;
  emitter.addEventListener("task-complete", () => {
    resultAvailable.resolve();
  });
  void Promise.resolve().then(async () => {
    try {
      for await (const task of source) {
        if (ops.length === concurrency) {
          slotAvailable = pDefer();
          await slotAvailable.promise;
        }
        if (opErred) {
          break;
        }
        const op = {
          done: false
        };
        ops.push(op);
        task().then((result) => {
          op.done = true;
          op.ok = true;
          op.value = result;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        }, (err) => {
          op.done = true;
          op.err = err;
          emitter.dispatchEvent(new CustomEvent2("task-complete"));
        });
      }
      sourceFinished = true;
      emitter.dispatchEvent(new CustomEvent2("task-complete"));
    } catch (err) {
      sourceErr = err;
      emitter.dispatchEvent(new CustomEvent2("task-complete"));
    }
  });
  function valuesAvailable() {
    if (ordered) {
      return ops[0]?.done;
    }
    return Boolean(ops.find((op) => op.done));
  }
  function* yieldOrderedValues() {
    while (ops.length > 0 && ops[0].done) {
      const op = ops[0];
      ops.shift();
      if (op.ok) {
        yield op.value;
      } else {
        opErred = true;
        slotAvailable.resolve();
        throw op.err;
      }
      slotAvailable.resolve();
    }
  }
  function* yieldUnOrderedValues() {
    while (valuesAvailable()) {
      for (let i2 = 0; i2 < ops.length; i2++) {
        if (ops[i2].done) {
          const op = ops[i2];
          ops.splice(i2, 1);
          i2--;
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
    }
  }
  while (true) {
    if (!valuesAvailable()) {
      resultAvailable = pDefer();
      await resultAvailable.promise;
    }
    if (sourceErr != null) {
      throw sourceErr;
    }
    if (ordered) {
      yield* yieldOrderedValues();
    } else {
      yield* yieldUnOrderedValues();
    }
    if (sourceErr != null) {
      throw sourceErr;
    }
    if (sourceFinished && ops.length === 0) {
      break;
    }
  }
}

// ../../node_modules/@libp2p/identify/dist/src/consts.js
var PROTOCOL_VERSION = "ipfs/0.1.0";
var MULTICODEC_IDENTIFY = "/ipfs/id/1.0.0";
var MULTICODEC_IDENTIFY_PUSH = "/ipfs/id/push/1.0.0";
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var MAX_PUSH_CONCURRENCY = 32;
var PUSH_DEBOUNCE_MS = 1e3;

// ../../node_modules/@libp2p/identify/dist/src/pb/message.js
var Identify;
(function(Identify3) {
  let _codec;
  Identify3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value2 of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value2 of obj.protocols) {
            w.uint32(26);
            w.string(value2);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 5: {
              obj.protocolVersion = reader.string();
              break;
            }
            case 6: {
              obj.agentVersion = reader.string();
              break;
            }
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.listenAddrs != null && obj.listenAddrs.length === opts.limits.listenAddrs) {
                throw new MaxLengthError('Decode error - map field "listenAddrs" had too many elements');
              }
              obj.listenAddrs.push(reader.bytes());
              break;
            }
            case 4: {
              obj.observedAddr = reader.bytes();
              break;
            }
            case 3: {
              if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 8: {
              obj.signedPeerRecord = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify3.encode = (obj) => {
    return encodeMessage(obj, Identify3.codec());
  };
  Identify3.decode = (buf2, opts) => {
    return decodeMessage(buf2, Identify3.codec(), opts);
  };
})(Identify || (Identify = {}));

// ../../node_modules/@libp2p/identify/dist/src/utils.js
var defaultValues2 = {
  protocolPrefix: "ipfs",
  timeout: 5e3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxObservedAddresses: 10,
  maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,
  runOnConnectionOpen: true,
  runOnSelfUpdate: true,
  runOnLimitedConnection: true,
  concurrency: MAX_PUSH_CONCURRENCY
};
function getCleanMultiaddr(addr) {
  if (addr != null && addr.length > 0) {
    try {
      return multiaddr(addr);
    } catch {
    }
  }
}
async function consumeIdentifyMessage(peerStore, events, log4, connection, message2) {
  log4("received identify from %p", connection.remotePeer);
  if (message2 == null) {
    throw new InvalidMessageError2("message was null or undefined");
  }
  const peer = {};
  if (message2.listenAddrs.length > 0) {
    peer.addresses = message2.listenAddrs.map((buf2) => ({
      isCertified: false,
      multiaddr: multiaddr(buf2)
    }));
  }
  if (message2.protocols.length > 0) {
    peer.protocols = message2.protocols;
  }
  if (message2.publicKey != null) {
    const publicKey2 = publicKeyFromProtobuf(message2.publicKey);
    const peerId = peerIdFromPublicKey3(publicKey2);
    if (!peerId.equals(connection.remotePeer)) {
      throw new InvalidMessageError2("public key did not match remote PeerId");
    }
    peer.publicKey = publicKey2;
  }
  let output;
  if (message2.signedPeerRecord != null) {
    log4.trace("received signedPeerRecord from %p", connection.remotePeer);
    let peerRecordEnvelope2 = message2.signedPeerRecord;
    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope2, PeerRecord2.DOMAIN);
    let peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    const envelopePeer = peerIdFromCID3(envelope.publicKey.toCID());
    if (!peerRecord.peerId.equals(envelopePeer)) {
      throw new InvalidMessageError2("signing key does not match PeerId in the PeerRecord");
    }
    if (!connection.remotePeer.equals(peerRecord.peerId)) {
      throw new InvalidMessageError2("signing key does not match remote PeerId");
    }
    let existingPeer;
    try {
      existingPeer = await peerStore.get(peerRecord.peerId);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if (existingPeer != null) {
      peer.metadata = existingPeer.metadata;
      if (existingPeer.peerRecordEnvelope != null) {
        const storedEnvelope = RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
        const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          log4("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          peerRecord = storedRecord;
          peerRecordEnvelope2 = existingPeer.peerRecordEnvelope;
        }
      }
    }
    peer.peerRecordEnvelope = peerRecordEnvelope2;
    peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
      isCertified: true,
      multiaddr: multiaddr2
    }));
    output = {
      seq: peerRecord.seqNumber,
      addresses: peerRecord.multiaddrs
    };
  } else {
    log4("%p did not send a signed peer record", connection.remotePeer);
  }
  log4.trace("patching %p with", connection.remotePeer, peer);
  await peerStore.patch(connection.remotePeer, peer);
  if (message2.agentVersion != null || message2.protocolVersion != null) {
    const metadata = {};
    if (message2.agentVersion != null) {
      metadata.AgentVersion = fromString2(message2.agentVersion);
    }
    if (message2.protocolVersion != null) {
      metadata.ProtocolVersion = fromString2(message2.protocolVersion);
    }
    log4.trace("merging %p metadata", connection.remotePeer, metadata);
    await peerStore.merge(connection.remotePeer, {
      metadata
    });
  }
  const result = {
    peerId: connection.remotePeer,
    protocolVersion: message2.protocolVersion,
    agentVersion: message2.agentVersion,
    publicKey: message2.publicKey,
    listenAddrs: message2.listenAddrs.map((buf2) => multiaddr(buf2)),
    observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
    protocols: message2.protocols,
    signedPeerRecord: output,
    connection
  };
  events.safeDispatchEvent("peer:identify", { detail: result });
  return result;
}
var AbstractIdentify = class {
  constructor(components, init) {
    __publicField(this, "host");
    __publicField(this, "components");
    __publicField(this, "protocol");
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "maxMessageSize");
    __publicField(this, "maxObservedAddresses");
    __publicField(this, "runOnLimitedConnection");
    __publicField(this, "log");
    this.protocol = init.protocol;
    this.started = false;
    this.components = components;
    this.log = init.log;
    this.timeout = init.timeout ?? defaultValues2.timeout;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues2.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues2.maxOutboundStreams;
    this.maxMessageSize = init.maxMessageSize ?? defaultValues2.maxMessageSize;
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues2.maxObservedAddresses;
    this.runOnLimitedConnection = init.runOnLimitedConnection ?? defaultValues2.runOnLimitedConnection;
    this.host = {
      protocolVersion: `${init.protocolPrefix ?? defaultValues2.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: components.nodeInfo.userAgent
    };
    this.handleProtocol = this.handleProtocol.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.peerStore.merge(this.components.peerId, {
      metadata: {
        AgentVersion: fromString2(this.host.agentVersion),
        ProtocolVersion: fromString2(this.host.protocolVersion)
      }
    });
    await this.components.registrar.handle(this.protocol, this.handleProtocol, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
};

// ../../node_modules/@libp2p/identify/dist/src/identify-push.js
var _a17, _b14;
var IdentifyPush = class extends (_b14 = AbstractIdentify, _a17 = serviceCapabilities2, _b14) {
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues2.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify-push")
    });
    __publicField(this, "connectionManager");
    __publicField(this, "concurrency");
    __publicField(this, "_push");
    __publicField(this, _a17, [
      "@libp2p/identify-push"
    ]);
    this.connectionManager = components.connectionManager;
    this.concurrency = init.concurrency ?? defaultValues2.concurrency;
    this._push = debounce(this.sendPushMessage.bind(this), init.debounce ?? PUSH_DEBOUNCE_MS);
    if (init.runOnSelfUpdate ?? defaultValues2.runOnSelfUpdate) {
      components.events.addEventListener("self:peer:update", (evt) => {
        this.push().catch((err) => {
          this.log.error("error pushing updates to peers - %e", err);
        });
      });
    }
  }
  /**
   * Calls `push` on all peer connections
   */
  async push() {
    this._push();
  }
  async sendPushMessage() {
    if (!this.isStarted()) {
      return;
    }
    try {
      const listenAddresses = this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(CODE_P2P2));
      const peerRecord = new PeerRecord2({
        peerId: this.components.peerId,
        multiaddrs: listenAddresses
      });
      const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.components.privateKey);
      const supportedProtocols = this.components.registrar.getProtocols();
      const peer = await this.components.peerStore.get(this.components.peerId);
      const agentVersion = toString2(peer.metadata.get("AgentVersion") ?? fromString2(this.host.agentVersion));
      const protocolVersion = toString2(peer.metadata.get("ProtocolVersion") ?? fromString2(this.host.protocolVersion));
      const self2 = this;
      async function* pushToConnections() {
        for (const connection of self2.connectionManager.getConnections()) {
          const peer2 = await self2.components.peerStore.get(connection.remotePeer);
          if (!peer2.protocols.includes(self2.protocol)) {
            continue;
          }
          yield async () => {
            let stream;
            const signal = AbortSignal.timeout(self2.timeout);
            setMaxListeners(Infinity, signal);
            try {
              stream = await connection.newStream(self2.protocol, {
                signal,
                runOnLimitedConnection: self2.runOnLimitedConnection
              });
              const pb = pbStream(stream, {
                maxDataLength: self2.maxMessageSize
              }).pb(Identify);
              await pb.write({
                listenAddrs: listenAddresses.map((ma) => ma.bytes),
                signedPeerRecord: signedPeerRecord.marshal(),
                protocols: supportedProtocols,
                agentVersion,
                protocolVersion
              }, {
                signal
              });
              await stream.close({
                signal
              });
            } catch (err) {
              const log4 = stream?.log.newScope("identify-push");
              log4?.error("could not push identify update to peer", err);
              stream?.abort(err);
            }
          };
        }
      }
      await src_default3(parallel(pushToConnections(), {
        concurrency: this.concurrency
      }));
    } catch (err) {
      this.log.error("error pushing updates to peers - %e", err);
    }
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async handleProtocol(stream, connection) {
    const log4 = stream.log.newScope("identify-push");
    if (this.components.peerId.equals(connection.remotePeer)) {
      throw new Error("received push from ourselves?");
    }
    const options2 = {
      signal: AbortSignal.timeout(this.timeout)
    };
    const pb = pbStream(stream, {
      maxDataLength: this.maxMessageSize
    }).pb(Identify);
    const message2 = await pb.read(options2);
    await stream.close(options2);
    await consumeIdentifyMessage(this.components.peerStore, this.components.events, log4, connection, message2);
    log4.trace("handled push from %p", connection.remotePeer);
  }
};

// ../../node_modules/@libp2p/identify/dist/src/identify.js
var _a18, _b15;
var Identify2 = class extends (_b15 = AbstractIdentify, _a18 = serviceCapabilities2, _b15) {
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues2.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify")
    });
    __publicField(this, _a18, [
      "@libp2p/identify"
    ]);
    if (init.runOnConnectionOpen ?? defaultValues2.runOnConnectionOpen) {
      components.events.addEventListener("connection:open", (evt) => {
        const connection = evt.detail;
        this.identify(connection).catch(() => {
        });
      });
    }
  }
  async _identify(connection, options2 = {}) {
    let stream;
    let log4;
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      options2 = {
        ...options2,
        signal
      };
    }
    this.log("run identify on new connection %a", connection.remoteAddr);
    try {
      stream = await connection.newStream(this.protocol, {
        ...options2,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      log4 = stream.log.newScope("identify");
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options2);
      await pb.unwrap().unwrap().close(options2);
      return message2;
    } catch (err) {
      log4?.error("identify failed - %e", err);
      stream?.abort(err);
      throw err;
    }
  }
  async identify(connection, options2 = {}) {
    const message2 = await this._identify(connection, options2);
    const { publicKey: publicKey2, protocols, observedAddr } = message2;
    if (publicKey2 == null) {
      throw new InvalidMessageError2("Public key was missing from identify message");
    }
    const key = publicKeyFromProtobuf(publicKey2);
    const id = peerIdFromCID3(key.toCID());
    if (!connection.remotePeer.equals(id)) {
      throw new InvalidMessageError2("Identified peer does not match the expected peer");
    }
    if (this.components.peerId.equals(id)) {
      throw new InvalidMessageError2("Identified peer is our own peer id?");
    }
    this.maybeAddObservedAddress(observedAddr);
    this.log("completed for peer %p and protocols %o", id, protocols);
    return consumeIdentifyMessage(this.components.peerStore, this.components.events, this.log, connection, message2);
  }
  maybeAddObservedAddress(observedAddr) {
    const cleanObservedAddr = getCleanMultiaddr(observedAddr);
    if (cleanObservedAddr == null) {
      return;
    }
    this.log.trace("our observed address was %a", cleanObservedAddr);
    if (isPrivate(cleanObservedAddr)) {
      return;
    }
    const tuples = cleanObservedAddr.getComponents();
    if ((tuples[0].code === CODE_IP62 || tuples[0].code === CODE_IP6ZONE2 && tuples[1].code === CODE_IP62) && !isGlobalUnicast(cleanObservedAddr)) {
      this.log.trace("our observed address was IPv6 but not a global unicast address");
      return;
    }
    if (TCP.exactMatch(cleanObservedAddr)) {
      return;
    }
    this.log.trace("storing the observed address");
    this.components.addressManager.addObservedAddr(cleanObservedAddr);
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async handleProtocol(stream, connection) {
    const log4 = stream.log.newScope("identify");
    log4("responding to identify");
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    const peerData = await this.components.peerStore.get(this.components.peerId, {
      signal
    });
    const multiaddrs = this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(CODE_P2P2));
    let signedPeerRecord = peerData.peerRecordEnvelope;
    if (multiaddrs.length > 0 && signedPeerRecord == null) {
      const peerRecord = new PeerRecord2({
        peerId: this.components.peerId,
        multiaddrs
      });
      const envelope = await RecordEnvelope.seal(peerRecord, this.components.privateKey, {
        signal
      });
      signedPeerRecord = envelope.marshal().subarray();
    }
    let observedAddr = connection.remoteAddr.bytes;
    if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
      observedAddr = void 0;
    }
    const pb = pbStream(stream).pb(Identify);
    log4("send response");
    await pb.write({
      protocolVersion: this.host.protocolVersion,
      agentVersion: this.host.agentVersion,
      publicKey: publicKeyToProtobuf(this.components.privateKey.publicKey),
      listenAddrs: multiaddrs.map((addr) => addr.bytes),
      signedPeerRecord,
      observedAddr,
      protocols: peerData.protocols
    }, {
      signal
    });
    log4("close write");
    await pb.unwrap().unwrap().close({
      signal
    });
  }
};

// ../../node_modules/@libp2p/identify/dist/src/index.js
function identify(init = {}) {
  return (components) => new Identify2(components, init);
}
function identifyPush(init = {}) {
  return (components) => new IdentifyPush(components, init);
}

// ../../node_modules/@libp2p/interface-transport/dist/src/index.js
var symbol3 = /* @__PURE__ */ Symbol.for("@libp2p/transport");
function isTransport2(other) {
  return other != null && Boolean(other[symbol3]);
}
var FaultTolerance2;
(function(FaultTolerance3) {
  FaultTolerance3[FaultTolerance3["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance3[FaultTolerance3["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance2 || (FaultTolerance2 = {}));

// ../../node_modules/@libp2p/kad-dht/dist/src/constants.js
var second3 = 1e3;
var minute3 = 60 * second3;
var hour = 60 * minute3;
var PROTOCOL = "/ipfs/kad/1.0.0";
var PROVIDERS_VALIDITY = 48 * hour;
var PROVIDERS_CLEANUP_INTERVAL = hour;
var REPROVIDE_THRESHOLD = 24 * hour;
var REPROVIDE_CONCURRENCY = 10;
var REPROVIDE_MAX_QUEUE_SIZE = 16384;
var REPROVIDE_INTERVAL = hour;
var REPROVIDE_TIMEOUT = hour;
var READ_MESSAGE_TIMEOUT = 10 * second3;
var ON_PEER_CONNECT_TIMEOUT = 10 * second3;
var GET_MANY_RECORD_COUNT = 16;
var K2 = 20;
var ALPHA = 10;
var QUERY_SELF_INTERVAL = 5 * minute3;
var QUERY_SELF_INITIAL_INTERVAL = second3;
var QUERY_SELF_TIMEOUT = 5 * second3;
var TABLE_REFRESH_INTERVAL = 5 * minute3;
var TABLE_REFRESH_QUERY_TIMEOUT = 30 * second3;
var DEFAULT_QUERY_TIMEOUT = 180 * second3;
var KEEP_ALIVE_TAG2 = `${KEEP_ALIVE}-kad-dht`;

// ../../node_modules/@libp2p/record/dist/src/record.js
var Record;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.key != null && obj.key.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.key);
        }
        if (obj.value != null && obj.value.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (obj.timeReceived != null && obj.timeReceived !== "") {
          w.uint32(42);
          w.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          key: alloc(0),
          value: alloc(0),
          timeReceived: ""
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.key = reader.bytes();
              break;
            }
            case 2: {
              obj.value = reader.bytes();
              break;
            }
            case 5: {
              obj.timeReceived = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf2, opts) => {
    return decodeMessage(buf2, Record3.codec(), opts);
  };
})(Record || (Record = {}));

// ../../node_modules/@libp2p/record/dist/src/utils.js
function toRFC3339(time) {
  const year = time.getUTCFullYear();
  const month = String(time.getUTCMonth() + 1).padStart(2, "0");
  const day = String(time.getUTCDate()).padStart(2, "0");
  const hour2 = String(time.getUTCHours()).padStart(2, "0");
  const minute4 = String(time.getUTCMinutes()).padStart(2, "0");
  const seconds = String(time.getUTCSeconds()).padStart(2, "0");
  const milliseconds = time.getUTCMilliseconds();
  const nanoseconds = String(milliseconds * 1e3 * 1e3).padStart(9, "0");
  return `${year}-${month}-${day}T${hour2}:${minute4}:${seconds}.${nanoseconds}Z`;
}
function parseRFC3339(time) {
  const rfc3339Matcher = new RegExp(
    // 2006-01-02T
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m2 = String(time).trim().match(rfc3339Matcher);
  if (m2 == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m2[1], 10);
  const month = parseInt(m2[2], 10) - 1;
  const date = parseInt(m2[3], 10);
  const hour2 = parseInt(m2[4], 10);
  const minute4 = parseInt(m2[5], 10);
  const second4 = parseInt(m2[6], 10);
  const millisecond = parseInt(m2[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour2, minute4, second4, millisecond));
}

// ../../node_modules/@libp2p/record/dist/src/index.js
var Libp2pRecord = class _Libp2pRecord {
  constructor(key, value2, timeReceived) {
    __publicField(this, "key");
    __publicField(this, "value");
    __publicField(this, "timeReceived");
    if (!(key instanceof Uint8Array)) {
      throw new Error("key must be a Uint8Array");
    }
    if (!(value2 instanceof Uint8Array)) {
      throw new Error("value must be a Uint8Array");
    }
    this.key = key;
    this.value = value2;
    this.timeReceived = timeReceived;
  }
  serialize() {
    return Record.encode(this.prepareSerialize());
  }
  /**
   * Return the object format ready to be given to the protobuf library.
   */
  prepareSerialize() {
    return {
      key: this.key,
      value: this.value,
      timeReceived: toRFC3339(this.timeReceived)
    };
  }
  /**
   * Decode a protobuf encoded record
   */
  static deserialize(raw) {
    const rec = Record.decode(raw);
    return new _Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));
  }
  /**
   * Create a record from the raw object returned from the protobuf library
   */
  static fromDeserialized(obj) {
    const receivedTime = parseRFC3339(obj.timeReceived);
    if (obj.key == null) {
      throw new Error("key missing from deserialized object");
    }
    if (obj.value == null) {
      throw new Error("value missing from deserialized object");
    }
    const rec = new _Libp2pRecord(obj.key, obj.value, receivedTime);
    return rec;
  }
};

// ../../node_modules/it-peekable/dist/src/index.js
function peekable(iterable) {
  const [iterator, symbol4] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value2) => {
      queue.push(value2);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol4]() {
      return this;
    }
  };
}
var src_default4 = peekable;

// ../../node_modules/it-map/dist/src/index.js
function isAsyncIterable6(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function map(source, func) {
  let index = 0;
  if (isAsyncIterable6(source)) {
    return (async function* () {
      for await (const val of source) {
        yield func(val, index++);
      }
    })();
  }
  const peekable2 = src_default4(source);
  const { value: value2, done } = peekable2.next();
  if (done === true) {
    return (function* () {
    })();
  }
  const res = func(value2, index++);
  if (typeof res.then === "function") {
    return (async function* () {
      yield await res;
      for (const val of peekable2) {
        yield func(val, index++);
      }
    })();
  }
  const fn = func;
  return (function* () {
    yield res;
    for (const val of peekable2) {
      yield fn(val, index++);
    }
  })();
}
var src_default5 = map;

// ../../node_modules/@libp2p/kad-dht/dist/src/errors.js
var QueryError = class extends Error {
  constructor(message2 = "Query error") {
    super(message2);
    this.name = "QueryError";
  }
};
var InvalidRecordError = class extends Error {
  constructor(message2 = "Invalid record") {
    super(message2);
    this.name = "InvalidRecordError";
  }
};
var MissingSelectorError = class extends Error {
  constructor(message2 = "No selector function configured for prefix") {
    super(message2);
    this.name = "MissingSelectorError";
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/message/dht.js
var Record2;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.key != null) {
          w.uint32(10);
          w.bytes(obj.key);
        }
        if (obj.value != null) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (obj.author != null) {
          w.uint32(26);
          w.bytes(obj.author);
        }
        if (obj.signature != null) {
          w.uint32(34);
          w.bytes(obj.signature);
        }
        if (obj.timeReceived != null) {
          w.uint32(42);
          w.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {};
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.key = reader.bytes();
              break;
            }
            case 2: {
              obj.value = reader.bytes();
              break;
            }
            case 3: {
              obj.author = reader.bytes();
              break;
            }
            case 4: {
              obj.signature = reader.bytes();
              break;
            }
            case 5: {
              obj.timeReceived = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf2, opts) => {
    return decodeMessage(buf2, Record3.codec(), opts);
  };
})(Record2 || (Record2 = {}));
var MessageType;
(function(MessageType2) {
  MessageType2["PUT_VALUE"] = "PUT_VALUE";
  MessageType2["GET_VALUE"] = "GET_VALUE";
  MessageType2["ADD_PROVIDER"] = "ADD_PROVIDER";
  MessageType2["GET_PROVIDERS"] = "GET_PROVIDERS";
  MessageType2["FIND_NODE"] = "FIND_NODE";
  MessageType2["PING"] = "PING";
})(MessageType || (MessageType = {}));
var __MessageTypeValues;
(function(__MessageTypeValues2) {
  __MessageTypeValues2[__MessageTypeValues2["PUT_VALUE"] = 0] = "PUT_VALUE";
  __MessageTypeValues2[__MessageTypeValues2["GET_VALUE"] = 1] = "GET_VALUE";
  __MessageTypeValues2[__MessageTypeValues2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
  __MessageTypeValues2[__MessageTypeValues2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
  __MessageTypeValues2[__MessageTypeValues2["FIND_NODE"] = 4] = "FIND_NODE";
  __MessageTypeValues2[__MessageTypeValues2["PING"] = 5] = "PING";
})(__MessageTypeValues || (__MessageTypeValues = {}));
(function(MessageType2) {
  MessageType2.codec = () => {
    return enumeration(__MessageTypeValues);
  };
})(MessageType || (MessageType = {}));
var ConnectionType;
(function(ConnectionType2) {
  ConnectionType2["NOT_CONNECTED"] = "NOT_CONNECTED";
  ConnectionType2["CONNECTED"] = "CONNECTED";
  ConnectionType2["CAN_CONNECT"] = "CAN_CONNECT";
  ConnectionType2["CANNOT_CONNECT"] = "CANNOT_CONNECT";
})(ConnectionType || (ConnectionType = {}));
var __ConnectionTypeValues;
(function(__ConnectionTypeValues2) {
  __ConnectionTypeValues2[__ConnectionTypeValues2["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CONNECTED"] = 1] = "CONNECTED";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CAN_CONNECT"] = 2] = "CAN_CONNECT";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
})(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
(function(ConnectionType2) {
  ConnectionType2.codec = () => {
    return enumeration(__ConnectionTypeValues);
  };
})(ConnectionType || (ConnectionType = {}));
var PeerInfo2;
(function(PeerInfo3) {
  let _codec;
  PeerInfo3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.multiaddrs != null) {
          for (const value2 of obj.multiaddrs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (obj.connection != null) {
          w.uint32(24);
          ConnectionType.codec().encode(obj.connection, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          id: alloc(0),
          multiaddrs: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.multiaddrs != null && obj.multiaddrs.length === opts.limits.multiaddrs) {
                throw new MaxLengthError('Decode error - map field "multiaddrs" had too many elements');
              }
              obj.multiaddrs.push(reader.bytes());
              break;
            }
            case 3: {
              obj.connection = ConnectionType.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerInfo3.encode = (obj) => {
    return encodeMessage(obj, PeerInfo3.codec());
  };
  PeerInfo3.decode = (buf2, opts) => {
    return decodeMessage(buf2, PeerInfo3.codec(), opts);
  };
})(PeerInfo2 || (PeerInfo2 = {}));
var Message;
(function(Message4) {
  let _codec;
  Message4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null && __MessageTypeValues[obj.type] !== 0) {
          w.uint32(8);
          MessageType.codec().encode(obj.type, w);
        }
        if (obj.clusterLevel != null) {
          w.uint32(80);
          w.int32(obj.clusterLevel);
        }
        if (obj.key != null) {
          w.uint32(18);
          w.bytes(obj.key);
        }
        if (obj.record != null) {
          w.uint32(26);
          w.bytes(obj.record);
        }
        if (obj.closer != null) {
          for (const value2 of obj.closer) {
            w.uint32(66);
            PeerInfo2.codec().encode(value2, w);
          }
        }
        if (obj.providers != null) {
          for (const value2 of obj.providers) {
            w.uint32(74);
            PeerInfo2.codec().encode(value2, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          type: MessageType.PUT_VALUE,
          closer: [],
          providers: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = MessageType.codec().decode(reader);
              break;
            }
            case 10: {
              obj.clusterLevel = reader.int32();
              break;
            }
            case 2: {
              obj.key = reader.bytes();
              break;
            }
            case 3: {
              obj.record = reader.bytes();
              break;
            }
            case 8: {
              if (opts.limits?.closer != null && obj.closer.length === opts.limits.closer) {
                throw new MaxLengthError('Decode error - map field "closer" had too many elements');
              }
              obj.closer.push(PeerInfo2.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.closer$
              }));
              break;
            }
            case 9: {
              if (opts.limits?.providers != null && obj.providers.length === opts.limits.providers) {
                throw new MaxLengthError('Decode error - map field "providers" had too many elements');
              }
              obj.providers.push(PeerInfo2.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.providers$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message4.encode = (obj) => {
    return encodeMessage(obj, Message4.codec());
  };
  Message4.decode = (buf2, opts) => {
    return decodeMessage(buf2, Message4.codec(), opts);
  };
})(Message || (Message = {}));

// ../../node_modules/@libp2p/kad-dht/dist/src/query/events.js
function sendQueryEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "SEND_QUERY",
    type: 0,
    messageName: fields.type,
    messageType: fields.type
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:send-query", { detail: event }));
  return event;
}
function peerResponseEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "PEER_RESPONSE",
    type: 1,
    messageName: fields.messageType,
    closer: fields.closer ?? [],
    providers: fields.providers ?? []
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:peer-response", { detail: event }));
  return event;
}
function finalPeerEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "FINAL_PEER",
    type: 2
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:final-peer", { detail: event }));
  return event;
}
function queryErrorEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "QUERY_ERROR",
    type: 3
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:query-error", { detail: event }));
  return event;
}
function providerEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "PROVIDER",
    type: 4
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:provider", { detail: event }));
  return event;
}
function valueEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "VALUE",
    type: 5
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:value", { detail: event }));
  return event;
}
function addPeerEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "ADD_PEER",
    type: 6
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:add-peer", { detail: event }));
  return event;
}
function dialPeerEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "DIAL_PEER",
    type: 7
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:dial-peer", { detail: event }));
  return event;
}
function pathEndedEvent(fields, options2 = {}) {
  const event = {
    ...fields,
    name: "PATH_ENDED",
    type: 8
  };
  options2.onProgress?.(new CustomEvent("kad-dht:query:path-ended", { detail: event }));
  return event;
}

// ../../node_modules/@libp2p/kad-dht/dist/src/record/selectors.js
function bestRecord(selectors2, k, records) {
  if (records.length === 0) {
    throw new InvalidParametersError2("No records given");
  }
  const kStr = toString2(k);
  const parts = kStr.split("/");
  if (parts.length < 3) {
    throw new InvalidParametersError2("Record key does not have a selector function");
  }
  const selector = selectors2[parts[1].toString()];
  if (selector == null) {
    throw new MissingSelectorError(`No selector function configured for key type "${parts[1]}"`);
  }
  if (records.length === 1) {
    return 0;
  }
  return selector(k, records);
}
function publicKey(k, records) {
  return 0;
}
var selectors = {
  pk: publicKey
};

// ../../node_modules/@libp2p/kad-dht/dist/src/record/validators.js
async function verifyRecord(validators2, record, options2) {
  const key = record.key;
  const keyString = toString2(key);
  const parts = keyString.split("/");
  if (parts.length < 3) {
    return;
  }
  const validator = validators2[parts[1].toString()];
  if (validator == null) {
    throw new InvalidParametersError2(`No validator available for key type "${parts[1]}"`);
  }
  await validator(key, record.value, options2);
}
var validatePublicKeyRecord = async (key, publicKey2, options2) => {
  if (!(key instanceof Uint8Array)) {
    throw new InvalidParametersError2('"key" must be a Uint8Array');
  }
  if (key.byteLength < 5) {
    throw new InvalidParametersError2("Invalid public key record");
  }
  const prefix = toString2(key.subarray(0, 4));
  if (prefix !== "/pk/") {
    throw new InvalidParametersError2("key was not prefixed with /pk/");
  }
  const pubKey = publicKeyFromProtobuf(publicKey2);
  const keyHash = key.slice(4);
  if (!equals3(keyHash, pubKey.toMultihash().bytes)) {
    throw new InvalidParametersError2("public key does not match passed in key");
  }
};
var validators = {
  pk: validatePublicKeyRecord
};

// ../../node_modules/interface-datastore/dist/src/key.js
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class _Key {
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s2, clean3) {
    __publicField(this, "_buf");
    if (typeof s2 === "string") {
      this._buf = fromString2(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean3 == null) {
      clean3 = true;
    }
    if (clean3) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString2(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new _Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes = new Uint8Array(this._buf.byteLength + 1);
      bytes.fill(pathSep, 0, 1);
      bytes.set(this._buf, 1);
      this._buf = bytes;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i2 = 0; i2 < list1.length; i2++) {
      if (list2.length < i2 + 1) {
        return false;
      }
      const c1 = list1[i2];
      const c2 = list2[i2];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /**
   * Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s2) {
    return new _Key(this.toString() + ":" + s2);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p2 = this.parent().toString();
    if (!p2.endsWith(pathSepS)) {
      p2 += pathSepS;
    }
    p2 += this.type();
    return new _Key(p2);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS);
    }
    return new _Key(list.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}

// ../../node_modules/@libp2p/kad-dht/dist/src/utils.js
var PK_PREFIX = fromString2("/pk/");
function removePrivateAddressesMapper(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      return !isPrivate(multiaddr2);
    })
  };
}
function removePublicAddressesMapper(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      return isPrivate(multiaddr2);
    })
  };
}
function passthroughMapper(info) {
  return info;
}
async function convertBuffer(buf2, options2) {
  const multihash = await sha256.digest(buf2);
  options2?.signal?.throwIfAborted();
  return multihash.digest;
}
async function convertPeerId(peerId, options2) {
  return convertBuffer(peerId.toMultihash().bytes, options2);
}
function bufferToKey(buf2) {
  return new Key("/" + toString2(buf2, "base32"), false);
}
function bufferToRecordKey(prefix, buf2) {
  return new Key(`${prefix}/${toString2(buf2, "base32")}`, false);
}
function keyForPublicKey(peerId) {
  return concat([
    PK_PREFIX,
    peerId.toMultihash().bytes
  ]);
}
function isPublicKeyKey(key) {
  return toString2(key.subarray(0, 4)) === "/pk/";
}
function isIPNSKey(key) {
  return toString2(key.subarray(0, 4)) === "/ipns/";
}
function fromPublicKeyKey(key) {
  const multihash = decode4(key.subarray(4));
  return peerIdFromMultihash3(multihash);
}
function uint8ArrayToBigInt(buf2) {
  return BigInt(`0x${Array.from(buf2).map((val) => val.toString(16).padStart(2, "0")).join("")}`);
}
function createPutRecord(key, value2) {
  const timeReceived = /* @__PURE__ */ new Date();
  const rec = new Libp2pRecord(key, value2, timeReceived);
  return rec.serialize();
}
function parseProviderKey(key) {
  const parts = key.toString().split("/");
  const peerIdStr = parts.pop();
  const cidStr = parts.pop();
  if (peerIdStr == null || cidStr == null) {
    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);
  }
  return {
    cid: CID.createV1(code3, decode4(fromString2(cidStr, "base32"))),
    peerId: peerIdFromString3(peerIdStr)
  };
}
function toProviderKey(prefix, cid, peerId) {
  const cidStr = typeof cid === "string" ? cid : toString2(cid.multihash.bytes, "base32");
  const parts = [
    prefix,
    cidStr
  ];
  if (peerId != null) {
    parts.push(peerId.toString());
  }
  return new Key(parts.join("/"));
}
function readProviderTime(buf2) {
  return new Date(decode8(buf2));
}
function timeOperationGenerator(fn, operationMetrics, type) {
  return async function* (...args) {
    const stopSuccessTimer = operationMetrics.queryTime?.timer(type);
    const stopErrorTimer = operationMetrics.errorTime?.timer(type);
    let errored = false;
    try {
      operationMetrics.queries?.increment({ [type]: true });
      yield* fn(...args);
    } catch (err) {
      errored = true;
      stopErrorTimer?.();
      operationMetrics.errors?.increment({ [type]: true });
      throw err;
    } finally {
      operationMetrics.queries?.decrement({ [type]: true });
      if (!errored) {
        stopSuccessTimer?.();
      }
    }
  };
}
function timeOperationMethod(fn, operationMetrics, type) {
  return async function(...args) {
    const stopSuccessTimer = operationMetrics?.queryTime?.timer(type);
    const stopErrorTimer = operationMetrics?.errorTime?.timer(type);
    let errored = false;
    try {
      operationMetrics.queries?.increment({ [type]: true });
      return await fn(...args);
    } catch (err) {
      errored = true;
      stopErrorTimer?.();
      operationMetrics.errors?.increment({ [type]: true });
      throw err;
    } finally {
      operationMetrics.queries?.decrement({ [type]: true });
      if (!errored) {
        stopSuccessTimer?.();
      }
    }
  };
}

// ../../node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
var ContentFetching = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "validators");
    __publicField(this, "selectors");
    __publicField(this, "peerRouting");
    __publicField(this, "queryManager");
    __publicField(this, "network");
    __publicField(this, "datastorePrefix");
    const { validators: validators2, selectors: selectors2, peerRouting, queryManager, network, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:content-fetching`);
    this.datastorePrefix = `${init.datastorePrefix}/record`;
    this.validators = validators2;
    this.selectors = selectors2;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.network = network;
    this.get = components.metrics?.traceFunction("libp2p.kadDHT.get", this.get.bind(this), {
      optionsIndex: 1
    }) ?? this.get;
    this.put = components.metrics?.traceFunction("libp2p.kadDHT.put", this.put.bind(this), {
      optionsIndex: 2
    }) ?? this.put;
  }
  /**
   * Attempt to retrieve the value for the given key from
   * the local datastore
   */
  async getLocal(key, options2) {
    this.log("getLocal %b", key);
    const dsKey = bufferToRecordKey(this.datastorePrefix, key);
    this.log("fetching record for key %k", dsKey);
    const raw = await this.components.datastore.get(dsKey, options2);
    this.log("found %k in local datastore", dsKey);
    const rec = Libp2pRecord.deserialize(raw);
    await verifyRecord(this.validators, rec, options2);
    return rec;
  }
  /**
   * Send the best record found to any peers that have an out of date record
   */
  async *sendCorrectionRecord(key, vals, best, options2) {
    this.log("sendCorrection for %b", key);
    const fixupRec = createPutRecord(key, best);
    for (const { value: value2, from: from3 } of vals) {
      if (equals3(value2, best)) {
        this.log("record was ok");
        continue;
      }
      if (this.components.peerId.equals(from3)) {
        try {
          const dsKey = bufferToRecordKey(this.datastorePrefix, key);
          this.log(`Storing corrected record for key ${dsKey.toString()}`);
          await this.components.datastore.put(dsKey, fixupRec.subarray(), options2);
        } catch (err) {
          this.log.error("failed error correcting self - %e", err);
        }
        continue;
      }
      let sentCorrection = false;
      const request = {
        type: MessageType.PUT_VALUE,
        key,
        record: fixupRec
      };
      for await (const event of this.network.sendRequest(from3, request, options2)) {
        if (event.name === "PEER_RESPONSE" && event.record != null && equals3(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {
          sentCorrection = true;
        }
        yield event;
      }
      if (!sentCorrection) {
        throw new QueryError("Could not send correction");
      }
      this.log.error("failed error correcting entry");
    }
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value2, options2) {
    this.log("put key %b value %b", key, value2);
    const record = createPutRecord(key, value2);
    const dsKey = bufferToRecordKey(this.datastorePrefix, key);
    this.log(`storing record for key ${dsKey.toString()}`);
    await this.components.datastore.put(dsKey, record.subarray(), options2);
    yield* pipe(this.peerRouting.getClosestPeers(key, {
      ...options2,
      signal: options2.signal
    }), (source) => src_default5(source, (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events = [];
        const msg = {
          type: MessageType.PUT_VALUE,
          key,
          record
        };
        this.log("send put to %p", event.peer.id);
        for await (const putEvent of this.network.sendRequest(event.peer.id, msg, {
          ...options2,
          path: event.path
        })) {
          events.push(putEvent);
          if (putEvent.name !== "PEER_RESPONSE") {
            continue;
          }
          if (!(putEvent.record != null && equals3(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {
            events.push(queryErrorEvent({
              from: event.peer.id,
              error: new QueryError("Value not put correctly"),
              path: putEvent.path
            }, options2));
          }
        }
        return events;
      };
    }), (source) => parallel(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events of source) {
        yield* events;
      }
    });
  }
  /**
   * Get the value to the given key
   */
  async *get(key, options2) {
    this.log("get %b", key);
    const vals = [];
    for await (const event of this.getMany(key, options2)) {
      if (event.name === "VALUE") {
        vals.push(event);
        continue;
      }
      yield event;
    }
    if (vals.length === 0) {
      return;
    }
    const records = vals.map((v) => v.value);
    let i2 = 0;
    try {
      i2 = bestRecord(this.selectors, key, records);
    } catch (err) {
      if (err.name !== "InvalidParametersError") {
        throw err;
      }
    }
    const best = records[i2];
    this.log("GetValue %b %b", key, best);
    if (best == null) {
      throw new NotFoundError2("Best value was not found");
    }
    yield* this.sendCorrectionRecord(key, vals, best, {
      ...options2,
      path: {
        index: -1,
        queued: 0,
        running: 0,
        total: 0
      }
    });
    yield vals[i2];
  }
  /**
   * Get the `n` values to the given key without sorting
   */
  async *getMany(key, options2 = {}) {
    this.log("getMany values for %b", key);
    try {
      const localRec = await this.getLocal(key, options2);
      yield valueEvent({
        value: localRec.value,
        from: this.components.peerId,
        path: {
          index: -1,
          running: 0,
          queued: 0,
          total: 0
        }
      }, options2);
    } catch (err) {
      this.log("error getting local value for %b", key, err);
    }
    const self2 = this;
    const getValueQuery = async function* ({ peer, signal, path }) {
      for await (const event of self2.peerRouting.getValueOrPeers(peer.id, key, {
        ...options2,
        signal,
        path
      })) {
        yield event;
        if (event.name === "PEER_RESPONSE" && event.record != null) {
          yield valueEvent({
            from: peer.id,
            value: event.record.value,
            path
          }, options2);
        }
      }
    };
    yield* this.queryManager.run(key, getValueQuery, options2);
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/message/utils.js
function toPbPeerInfo(peer, connection) {
  const output = {
    id: peer.id.toMultihash().bytes,
    multiaddrs: (peer.multiaddrs ?? []).map((m2) => m2.bytes),
    connection
  };
  return output;
}
function fromPbPeerInfo(peer) {
  if (peer.id == null) {
    throw new Error("Invalid peer in message");
  }
  const multihash = decode4(peer.id);
  return {
    id: peerIdFromMultihash3(multihash),
    multiaddrs: (peer.multiaddrs ?? []).map((a2) => multiaddr(a2))
  };
}

// ../../node_modules/@libp2p/kad-dht/dist/src/content-routing/index.js
var ContentRouting = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "network");
    __publicField(this, "peerRouting");
    __publicField(this, "queryManager");
    __publicField(this, "routingTable");
    __publicField(this, "providers");
    const { network, peerRouting, queryManager, routingTable, providers, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:content-routing`);
    this.network = network;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.providers = providers;
    this.findProviders = components.metrics?.traceFunction("libp2p.kadDHT.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1,
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PROVIDER") {
          attrs.providers ?? (attrs.providers = []);
          attrs.providers.push(...event.providers.map((info) => info.id.toString()));
        }
        return attrs;
      }
    }) ?? this.findProviders;
    this.provide = components.metrics?.traceFunction("libp2p.kadDHT.provide", this.provide.bind(this), {
      optionsIndex: 1,
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PEER_RESPONSE" && event.messageName === "ADD_PROVIDER") {
          attrs.providers ?? (attrs.providers = []);
          attrs.providers.push(event.from.toString());
        }
        return attrs;
      }
    }) ?? this.provide;
  }
  /**
   * Announce to the network that we can provide the value for a given key and
   * are contactable on the given multiaddrs
   */
  async *provide(key, multiaddrs, options2 = {}) {
    this.log("provide %s", key);
    const target = key.multihash.bytes;
    await this.providers.addProvider(key, this.components.peerId, options2);
    const msg = {
      type: MessageType.ADD_PROVIDER,
      key: target,
      providers: [
        toPbPeerInfo({
          id: this.components.peerId,
          multiaddrs
        })
      ]
    };
    let sent = 0;
    const self2 = this;
    async function* publishProviderRecord(event) {
      try {
        self2.log("sending provider record for %s to %p", key, event.peer.id);
        for await (const addProviderEvent of self2.network.sendMessage(event.peer.id, msg, {
          ...options2,
          path: event.path
        })) {
          if (addProviderEvent.name === "PEER_RESPONSE") {
            self2.log("sent provider record for %s to %p", key, event.peer.id);
            sent++;
          }
          yield addProviderEvent;
        }
      } catch (err) {
        self2.log.error("error sending provide record to peer %p - %e", event.peer.id, err);
        yield queryErrorEvent({
          from: event.peer.id,
          error: err,
          path: event.path
        }, options2);
      }
    }
    const events = pushable({
      objectMode: true
    });
    const queue = new Queue({
      concurrency: ALPHA
    });
    queue.addEventListener("idle", () => {
      events.end();
    });
    queue.addEventListener("failure", (event) => {
      this.log.error("error publishing provider record to peer - %e", event.detail.error);
    });
    queue.add(async () => {
      const finalPeerEvents = [];
      for await (const event of this.peerRouting.getClosestPeers(target, options2)) {
        events.push(event);
        if (event.name !== "FINAL_PEER") {
          continue;
        }
        finalPeerEvents.push(event);
      }
      finalPeerEvents.forEach((event) => {
        queue.add(async () => {
          for await (const notifyEvent of publishProviderRecord(event)) {
            events.push(notifyEvent);
          }
        }).catch((err) => {
          this.log.error("error publishing provider record to peer - %e", err);
        });
      });
    }).catch((err) => {
      events.end(err);
    });
    yield* events;
    this.log("sent provider records to %d peers", sent);
  }
  /**
   * Search the dht for up to `K` providers of the given CID.
   */
  async *findProviders(key, options2) {
    const toFind = this.routingTable.kBucketSize;
    let found = 0;
    const target = key.multihash.bytes;
    const self2 = this;
    this.log("findProviders %c", key);
    const provs = await this.providers.getProviders(key, options2);
    if (provs.length > 0) {
      const providers2 = [];
      for (const peerId of provs.slice(0, toFind)) {
        try {
          const peer = await this.components.peerStore.get(peerId, options2);
          providers2.push({
            id: peerId,
            multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
          });
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
          this.log("no peer store entry for %p", peerId);
        }
      }
      yield peerResponseEvent({
        from: this.components.peerId,
        messageType: MessageType.GET_PROVIDERS,
        providers: providers2,
        path: {
          index: -1,
          queued: 0,
          running: 0,
          total: 0
        }
      }, options2);
      yield providerEvent({
        from: this.components.peerId,
        providers: providers2,
        path: {
          index: -1,
          queued: 0,
          running: 0,
          total: 0
        }
      }, options2);
      found += providers2.length;
      if (found >= toFind) {
        return;
      }
    }
    const findProvidersQuery = async function* ({ peer, signal, path }) {
      const request = {
        type: MessageType.GET_PROVIDERS,
        key: target
      };
      yield* self2.network.sendRequest(peer.id, request, {
        ...options2,
        signal,
        path
      });
    };
    const providers = new PeerSet(provs);
    for await (const event of this.queryManager.run(target, findProvidersQuery, options2)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        this.log("Found %d provider entries for %c and %d closer peers", event.providers.length, key, event.closer.length);
        const newProviders = [];
        for (const peer of event.providers) {
          if (providers.has(peer.id)) {
            continue;
          }
          providers.add(peer.id);
          newProviders.push(peer);
        }
        if (newProviders.length > 0) {
          yield providerEvent({
            from: event.from,
            providers: newProviders,
            path: event.path
          }, options2);
          found += newProviders.length;
          if (found >= toFind) {
            return;
          }
        }
      }
    }
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/network.js
var Network = class extends TypedEventEmitter {
  /**
   * Create a new network
   */
  constructor(components, init) {
    super();
    __publicField(this, "log");
    __publicField(this, "protocol");
    __publicField(this, "running");
    __publicField(this, "components");
    __publicField(this, "timeout");
    __publicField(this, "metrics");
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:network`);
    this.running = false;
    this.protocol = init.protocol;
    this.timeout = new AdaptiveTimeout({
      ...init.timeout ?? {},
      metrics: components.metrics,
      metricName: `${init.metricsPrefix}_network_message_send_times_milliseconds`
    });
    this.metrics = {
      operations: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_outbound_rpc_requests_total`),
      errors: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_outbound_rpc_errors_total`)
    };
    this.sendRequest = components.metrics?.traceFunction("libp2p.kadDHT.sendRequest", this.sendRequest.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs([to, message2], attrs) {
        return {
          ...attrs,
          to: to.toString(),
          "message type": `${message2.type}`
        };
      },
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PEER_RESPONSE") {
          if (event.providers.length > 0) {
            event.providers.forEach((value2, index) => {
              attrs[`providers-${index}`] = value2.id.toString();
            });
          }
          if (event.closer.length > 0) {
            event.closer.forEach((value2, index) => {
              attrs[`closer-${index}`] = value2.id.toString();
            });
          }
        }
        return attrs;
      }
    }) ?? this.sendRequest;
    this.sendMessage = components.metrics?.traceFunction("libp2p.kadDHT.sendMessage", this.sendMessage.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs([to, message2], attrs) {
        return {
          ...attrs,
          to: to.toString(),
          "message type": `${message2.type}`
        };
      },
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PEER_RESPONSE") {
          if (event.providers.length > 0) {
            event.providers.forEach((value2, index) => {
              attrs[`providers-${index}`] = value2.id.toString();
            });
          }
          if (event.closer.length > 0) {
            event.closer.forEach((value2, index) => {
              attrs[`closer-${index}`] = value2.id.toString();
            });
          }
        }
        return attrs;
      }
    }) ?? this.sendMessage;
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
  }
  /**
   * Stop all network activity
   */
  async stop() {
    this.running = false;
  }
  /**
   * Is the network online?
   */
  isStarted() {
    return this.running;
  }
  /**
   * Send a request and read a response
   */
  async *sendRequest(to, msg, options2) {
    if (!this.running) {
      return;
    }
    const type = msg.type;
    if (type == null) {
      throw new InvalidParametersError2("Message type was missing");
    }
    let stream;
    const signal = this.timeout.getTimeoutSignal(options2);
    options2 = {
      ...options2,
      signal
    };
    try {
      this.metrics.operations?.increment({ [type]: true });
      this.log("dialling %p", to);
      yield dialPeerEvent({ peer: to, path: options2.path }, options2);
      stream = await this.components.connectionManager.openStream(to, this.protocol, options2);
      this.log("sending %s to %p", msg.type, to);
      yield sendQueryEvent({ to, type, path: options2.path }, options2);
      const response = await this._writeReadMessage(stream, msg, options2);
      stream.close(options2).catch((err) => {
        this.log.error("error closing stream to %p - %e", to, err);
        stream?.abort(err);
      });
      yield peerResponseEvent({
        from: to,
        messageType: response.type,
        closer: response.closer.map(fromPbPeerInfo),
        providers: response.providers.map(fromPbPeerInfo),
        record: response.record == null ? void 0 : Libp2pRecord.deserialize(response.record),
        path: options2.path
      }, options2);
    } catch (err) {
      this.metrics.errors?.increment({ [type]: true });
      stream?.abort(err);
      if (options2.signal?.aborted !== true) {
        this.log.error("could not send %s to %p - %e", msg.type, to, err);
      }
      yield queryErrorEvent({ from: to, error: err, path: options2.path }, options2);
    } finally {
      this.timeout.cleanUp(signal);
    }
  }
  /**
   * Sends a message without expecting an answer
   */
  async *sendMessage(to, msg, options2) {
    if (!this.running) {
      return;
    }
    const type = msg.type;
    if (type == null) {
      throw new InvalidParametersError2("Message type was missing");
    }
    let stream;
    const signal = this.timeout.getTimeoutSignal(options2);
    options2 = {
      ...options2,
      signal
    };
    try {
      this.metrics.operations?.increment({ [type]: true });
      this.log("dialling %p", to);
      yield dialPeerEvent({ peer: to, path: options2.path }, options2);
      stream = await this.components.connectionManager.openStream(to, this.protocol, options2);
      this.log("sending %s to %p", msg.type, to);
      yield sendQueryEvent({ to, type, path: options2.path }, options2);
      await this._writeMessage(stream, msg, options2);
      stream.close(options2).catch((err) => {
        this.log.error("error closing stream to %p - %e", to, err);
        stream?.abort(err);
      });
      yield peerResponseEvent({ from: to, messageType: type, path: options2.path }, options2);
    } catch (err) {
      this.metrics.errors?.increment({ [type]: true });
      stream?.abort(err);
      yield queryErrorEvent({ from: to, error: err, path: options2.path }, options2);
    } finally {
      this.timeout.cleanUp(signal);
    }
  }
  /**
   * Write a message to the given stream
   */
  async _writeMessage(stream, msg, options2) {
    const pb = pbStream(stream);
    await pb.write(msg, Message, options2);
  }
  /**
   * Write a message and read a response
   */
  async _writeReadMessage(stream, msg, options2) {
    const pb = pbStream(stream);
    await pb.write(msg, Message, options2);
    const message2 = await pb.read(Message, options2);
    message2.closer.forEach((peerData) => {
      this.safeDispatchEvent("peer", {
        detail: fromPbPeerInfo(peerData)
      });
    });
    message2.providers.forEach((peerData) => {
      this.safeDispatchEvent("peer", {
        detail: fromPbPeerInfo(peerData)
      });
    });
    return message2;
  }
};

// ../../node_modules/uint8arrays/dist/src/xor-compare.js
function xorCompare(a2, b) {
  if (a2.byteLength !== b.byteLength) {
    throw new Error("Inputs should have the same length");
  }
  for (let i2 = 0; i2 < a2.byteLength; i2++) {
    if (a2[i2] === b[i2]) {
      continue;
    }
    return a2[i2] < b[i2] ? -1 : 1;
  }
  return 0;
}

// ../../node_modules/@libp2p/kad-dht/dist/src/peer-distance-list.js
var PeerDistanceList = class {
  constructor(originDhtKey, capacity) {
    /**
     * The DHT key from which distance is calculated
     */
    __publicField(this, "originDhtKey");
    /**
     * The maximum size of the list
     */
    __publicField(this, "capacity");
    __publicField(this, "peerDistances");
    this.originDhtKey = originDhtKey;
    this.capacity = capacity;
    this.peerDistances = [];
  }
  /**
   * The length of the list
   */
  get length() {
    return this.peerDistances.length;
  }
  /**
   * The peers in the list, in order of distance from the origin key
   */
  get peers() {
    return [...this.peerDistances];
  }
  /**
   * Add a peerId to the list.
   */
  async add(peer, path = { index: -1, queued: 0, running: 0, total: 0 }, options2) {
    const dhtKey = await convertPeerId(peer.id, options2);
    this.addWithKadId(peer, dhtKey, path);
  }
  /**
   * Add a peerId to the list.
   */
  addWithKadId(peer, kadId, path = { index: -1, queued: 0, running: 0, total: 0 }) {
    if (this.peerDistances.find((pd) => pd.peer.id.equals(peer.id)) != null) {
      return;
    }
    const el = {
      peer,
      distance: xor(this.originDhtKey, kadId),
      path
    };
    if (this.peerDistances.length === this.capacity) {
      const lastPeer = this.peerDistances[this.peerDistances.length - 1];
      if (lastPeer != null && xorCompare(el.distance, lastPeer.distance) !== -1) {
        return;
      }
    }
    let added = false;
    for (let j = 0; j < this.peerDistances.length; j++) {
      const distance = xorCompare(this.peerDistances[j].distance, el.distance);
      if (distance === 0 || distance === 1) {
        added = true;
        this.peerDistances.splice(j, 0, el);
        break;
      }
    }
    if (!added) {
      this.peerDistances.push(el);
    }
    this.peerDistances = this.peerDistances.slice(0, this.capacity);
  }
  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   */
  async isCloser(peerId, options2) {
    if (this.length === 0) {
      return true;
    }
    const dhtKey = await convertPeerId(peerId, options2);
    const dhtKeyXor = xor(dhtKey, this.originDhtKey);
    const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
    return xorCompare(dhtKeyXor, furthestDistance) === -1;
  }
  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   */
  async anyCloser(peerIds, options2) {
    if (peerIds.length === 0) {
      return false;
    }
    return Promise.any(peerIds.map(async (peerId) => this.isCloser(peerId, options2)));
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
var PeerRouting = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "routingTable");
    __publicField(this, "network");
    __publicField(this, "validators");
    __publicField(this, "queryManager");
    __publicField(this, "components");
    this.routingTable = init.routingTable;
    this.network = init.network;
    this.validators = init.validators;
    this.queryManager = init.queryManager;
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:peer-routing`);
    this.findPeer = components.metrics?.traceFunction("libp2p.kadDHT.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1
    }) ?? this.findPeer;
    this.getClosestPeers = components.metrics?.traceFunction("libp2p.kadDHT.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1
    }) ?? this.getClosestPeers;
  }
  /**
   * Look if we are connected to a peer with the given id.
   * Returns its id and addresses, if found, otherwise `undefined`.
   */
  async findPeerLocal(peer, options2) {
    let peerData;
    const p2 = await this.routingTable.find(peer, options2);
    if (p2 != null) {
      this.log("findPeerLocal found %p in routing table", peer);
      try {
        peerData = await this.components.peerStore.get(p2, options2);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
    }
    if (peerData == null) {
      try {
        peerData = await this.components.peerStore.get(peer, options2);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
    }
    if (peerData != null) {
      this.log("findPeerLocal found %p in peer store", peer);
      return {
        id: peerData.id,
        multiaddrs: peerData.addresses.map((address) => address.multiaddr)
      };
    }
    return void 0;
  }
  /**
   * Get a value via rpc call for the given parameters
   */
  async *_getValueSingle(peer, key, options2) {
    const msg = {
      type: MessageType.GET_VALUE,
      key
    };
    yield* this.network.sendRequest(peer, msg, options2);
  }
  /**
   * Get the public key directly from a node
   */
  async *getPublicKeyFromNode(peer, options2 = {}) {
    const pkKey = keyForPublicKey(peer);
    const path = {
      index: -1,
      queued: 0,
      running: 0,
      total: 0
    };
    for await (const event of this._getValueSingle(peer, pkKey, {
      ...options2,
      path
    })) {
      yield event;
      if (event.name === "PEER_RESPONSE" && event.record != null) {
        const publicKey2 = publicKeyFromProtobuf(event.record.value);
        const recPeer = peerIdFromPublicKey3(publicKey2);
        if (!recPeer.equals(peer)) {
          throw new InvalidPublicKeyError2("public key does not match id");
        }
        if (recPeer.publicKey == null) {
          throw new InvalidPublicKeyError2("public key missing");
        }
        yield valueEvent({
          from: peer,
          value: event.record.value,
          path
        }, options2);
      }
    }
    throw new QueryError(`Node not responding with its public key: ${peer.toString()}`);
  }
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options2 = {}) {
    this.log("findPeer %p", id);
    if (options2.useCache !== false) {
      const pi = await this.findPeerLocal(id, options2);
      if (pi != null) {
        this.log("found local");
        yield finalPeerEvent({
          from: this.components.peerId,
          peer: pi,
          path: {
            index: -1,
            queued: 0,
            running: 0,
            total: 0
          }
        }, options2);
        return;
      }
    }
    let foundPeer = false;
    if (options2.useNetwork !== false) {
      const self2 = this;
      const findPeerQuery = async function* ({ peer, signal, path }) {
        const request = {
          type: MessageType.FIND_NODE,
          key: id.toMultihash().bytes
        };
        for await (const event of self2.network.sendRequest(peer.id, request, {
          ...options2,
          signal,
          path
        })) {
          yield event;
          if (event.name === "PEER_RESPONSE") {
            const match = event.closer.find((p2) => p2.id.equals(id));
            if (match != null) {
              yield finalPeerEvent({
                from: event.from,
                peer: match,
                path: event.path
              }, options2);
            }
          }
        }
      };
      for await (const event of this.queryManager.run(id.toMultihash().bytes, findPeerQuery, options2)) {
        if (event.name === "FINAL_PEER") {
          foundPeer = true;
        }
        yield event;
      }
    }
    if (!foundPeer) {
      throw new NotFoundError2("Not found");
    }
  }
  /**
   * Kademlia 'FIND_NODE' operation on a key, which could be the bytes from a
   * multihash or a peer ID
   */
  async *getClosestPeers(key, options2 = {}) {
    this.log("getClosestPeers to %b", key);
    const kadId = await convertBuffer(key, options2);
    const peers = new PeerDistanceList(kadId, this.routingTable.kBucketSize);
    const self2 = this;
    const getCloserPeersQuery = async function* ({ peer, path, peerKadId, signal }) {
      self2.log("getClosestPeers asking %p", peer.id);
      const request = {
        type: MessageType.FIND_NODE,
        key
      };
      yield* self2.network.sendRequest(peer.id, request, {
        ...options2,
        signal,
        path
      });
      peers.addWithKadId(peer, peerKadId, path);
    };
    yield* this.queryManager.run(key, getCloserPeersQuery, options2);
    this.log("found %d peers close to %b", peers.length, key);
    for (let { peer, path } of peers.peers) {
      try {
        if (peer.multiaddrs.length === 0) {
          peer = await self2.components.peerStore.getInfo(peer.id, options2);
        }
        if (peer.multiaddrs.length === 0) {
          continue;
        }
        yield finalPeerEvent({
          from: this.components.peerId,
          peer: await self2.components.peerStore.getInfo(peer.id, options2),
          path: {
            index: path.index,
            queued: 0,
            running: 0,
            total: 0
          }
        }, options2);
      } catch {
        continue;
      }
    }
  }
  /**
   * Query a particular peer for the value for the given key.
   * It will either return the value or a list of closer peers.
   *
   * Note: The peerStore is updated with new addresses found for the given peer.
   */
  async *getValueOrPeers(peer, key, options2) {
    for await (const event of this._getValueSingle(peer, key, options2)) {
      if (event.name === "PEER_RESPONSE") {
        if (event.record != null) {
          try {
            await this._verifyRecordOnline(event.record, options2);
          } catch (err) {
            const errMsg = "invalid record received, discarded";
            this.log(errMsg);
            yield queryErrorEvent({
              from: event.from,
              error: new QueryError(errMsg),
              path: options2.path
            }, options2);
            continue;
          }
        }
      }
      yield event;
    }
  }
  /**
   * Verify a record, fetching missing public keys from the network.
   * Throws an error if the record is invalid.
   */
  async _verifyRecordOnline(record, options2) {
    if (record.timeReceived == null) {
      throw new InvalidRecordError("invalid record received");
    }
    await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived), options2);
  }
  /**
   * Get the peers in our routing table that are closest to the passed key
   */
  async getClosestPeersOffline(key, options2) {
    const output = [];
    try {
      const multihash = decode4(key);
      const targetPeerId = peerIdFromMultihash3(multihash);
      const peer = await this.components.peerStore.get(targetPeerId, options2);
      output.push({
        id: peer.id,
        multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      });
    } catch {
    }
    const keyKadId = await convertBuffer(key, options2);
    const ids = this.routingTable.closestPeers(keyKadId, options2);
    for (const peerId of ids) {
      try {
        output.push(await this.components.peerStore.getInfo(peerId, options2));
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
    }
    if (output.length > 0) {
      this.log("getClosestPeersOffline returning the %d closest peer(s) we know to %b", output.length, key);
    } else {
      this.log("getClosestPeersOffline could not any peers close to %b with %d peers in the routing table", key, this.routingTable.size);
    }
    return output;
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/providers.js
var Providers = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "datastore");
    __publicField(this, "datastorePrefix");
    this.log = components.logger.forComponent(`${init.logPrefix}:providers`);
    this.datastorePrefix = `${init.datastorePrefix}/provider`;
    this.datastore = components.datastore;
  }
  /**
   * Add a new provider for the given CID
   */
  async addProvider(cid, provider, options2) {
    this.log.trace("%p provides %s", provider, cid);
    await this.writeProviderEntry(cid, provider, options2);
  }
  /**
   * Remove a provider for the given CID
   */
  async removeProvider(cid, provider, options2) {
    const key = toProviderKey(this.datastorePrefix, cid, provider);
    this.log.trace("%p no longer provides %s", provider, cid);
    await this.datastore.delete(key, options2);
  }
  /**
   * Get a list of providers for the given CID
   */
  async getProviders(cid, options2) {
    this.log.trace("get providers for %c", cid);
    const provs = await this.loadProviders(cid, options2);
    this.log.trace("got %d providers for %c", provs.size, cid);
    return [...provs.keys()];
  }
  /**
   * Write a provider into the given store
   */
  async writeProviderEntry(cid, peerId, options2) {
    const key = toProviderKey(this.datastorePrefix, cid, peerId);
    const buffer2 = encode7(options2?.time?.getTime() ?? Date.now());
    await this.datastore.put(key, buffer2, options2);
  }
  /**
   * Load providers for the given CID from the store
   */
  async loadProviders(cid, options2) {
    const providers = new PeerMap();
    const key = toProviderKey(this.datastorePrefix, cid);
    for await (const entry of this.datastore.query({ prefix: key.toString() }, options2)) {
      const { peerId } = parseProviderKey(entry.key);
      providers.set(peerId, readProviderTime(entry.value));
    }
    return providers;
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/query/query-path.js
async function* queryPath(options2) {
  const { key, startingPeers, ourPeerId, query, alpha, path, numPaths, log: log4, peersSeen, connectionManager, signal } = options2;
  const events = pushable({
    objectMode: true
  });
  const queue = new Queue({
    concurrency: alpha,
    sort: (a2, b) => xorCompare(a2.options.distance, b.options.distance)
  });
  queue.addEventListener("idle", () => {
    events.push(pathEndedEvent({
      path: {
        index: path,
        queued: queue.queued,
        running: queue.running,
        total: queue.size
      }
    }, options2));
    events.end();
  });
  queue.addEventListener("failure", (evt) => {
    log4.error("error during query - %e", evt.detail.error);
  });
  const onAbort = () => {
    queue.abort();
    events.end(new AbortError2());
  };
  signal.addEventListener("abort", onAbort);
  try {
    let queryPeer = function(peer, peerKadId) {
      if (peer == null) {
        return;
      }
      peersSeen.add(peer.id.toMultihash().bytes);
      const peerXor = xor(peerKadId, kadId);
      queue.add(async () => {
        try {
          for await (const event of query({
            ...options2,
            key,
            peer,
            path: {
              index: path,
              queued: queue.queued,
              running: queue.running,
              total: queue.size
            },
            numPaths,
            peerKadId,
            signal
          })) {
            if (event.name === "PEER_RESPONSE") {
              for (const closerPeer of event.closer) {
                if (peersSeen.has(closerPeer.id.toMultihash().bytes)) {
                  log4("already seen %p in query", closerPeer.id);
                  continue;
                }
                if (ourPeerId.equals(closerPeer.id)) {
                  log4("not querying ourselves");
                  continue;
                }
                if (!await connectionManager.isDialable(closerPeer.multiaddrs)) {
                  log4("not querying undialable peer");
                  continue;
                }
                const closerPeerKadId = await convertPeerId(closerPeer.id, {
                  signal
                });
                const closerPeerXor = xor(closerPeerKadId, kadId);
                if (xorCompare(closerPeerXor, peerXor) !== -1) {
                  log4("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer.id);
                  continue;
                }
                log4("querying closer peer %p", closerPeer.id);
                queryPeer(closerPeer, closerPeerKadId);
              }
            }
            events.push({
              ...event,
              path: {
                index: path,
                queued: queue.queued,
                running: queue.running,
                total: queue.size
              }
            });
          }
        } catch (err) {
          events.push(queryErrorEvent({
            from: peer.id,
            error: err,
            path: {
              index: path,
              queued: queue.queued,
              running: queue.running - 1,
              total: queue.size - 1
            }
          }, options2));
        }
      }, {
        distance: peerXor
      }).catch((err) => {
        log4.error("error during query - %e", err);
      });
    };
    const kadId = await convertBuffer(key, {
      signal
    });
    await Promise.all(startingPeers.map(async (startingPeer) => {
      queryPeer({ id: startingPeer, multiaddrs: [] }, await convertPeerId(startingPeer, {
        signal
      }));
    }));
    yield* events;
  } finally {
    signal.removeEventListener("abort", onAbort);
  }
}

// ../../node_modules/@libp2p/kad-dht/dist/src/query/manager.js
var QueryManager = class {
  constructor(components, init) {
    __publicField(this, "disjointPaths");
    __publicField(this, "alpha");
    __publicField(this, "shutDownController");
    __publicField(this, "running");
    __publicField(this, "logger");
    __publicField(this, "peerId");
    __publicField(this, "connectionManager");
    __publicField(this, "routingTable");
    __publicField(this, "initialQuerySelfHasRun");
    __publicField(this, "logPrefix");
    __publicField(this, "allowQueryWithZeroPeers");
    this.logPrefix = init.logPrefix;
    this.disjointPaths = init.disjointPaths ?? K2;
    this.alpha = init.alpha ?? ALPHA;
    this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
    this.routingTable = init.routingTable;
    this.logger = components.logger;
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.allowQueryWithZeroPeers = init.allowQueryWithZeroPeers ?? false;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    this.running = false;
  }
  isStarted() {
    return this.running;
  }
  /**
   * Starts the query manager
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
  }
  /**
   * Stops all queries
   */
  async stop() {
    this.running = false;
    this.shutDownController.abort();
  }
  async *run(key, queryFunc, options2 = {}) {
    if (!this.running) {
      throw new Error("QueryManager not started");
    }
    if (options2.signal == null) {
      const signal2 = AbortSignal.timeout(DEFAULT_QUERY_TIMEOUT);
      setMaxListeners(Infinity, signal2);
      options2 = {
        ...options2,
        signal: signal2
      };
    }
    const queryEarlyExitController = new AbortController();
    const signal = anySignal([
      this.shutDownController.signal,
      queryEarlyExitController.signal,
      options2.signal
    ]);
    setMaxListeners(Infinity, signal, queryEarlyExitController.signal);
    const log4 = this.logger.forComponent(`${this.logPrefix}:query:` + toString2(key, "base58btc"));
    let queryFinished = false;
    try {
      if (this.routingTable.size === 0 && !this.allowQueryWithZeroPeers) {
        log4("routing table was empty, waiting for some peers before running%s query", options2.isSelfQuery === true ? " self" : "");
        await pEvent(this.routingTable, "peer:add", {
          signal,
          filter: (event) => !this.peerId.equals(event.detail)
        });
        log4("routing table has peers, continuing with%s query", options2.isSelfQuery === true ? " self" : "");
      }
      if (options2.isSelfQuery !== true && this.initialQuerySelfHasRun != null) {
        log4("waiting for initial self query before continuing");
        await raceSignal(this.initialQuerySelfHasRun.promise, signal);
        this.initialQuerySelfHasRun = void 0;
      }
      log4("query:start");
      const id = await convertBuffer(key, {
        signal
      });
      const peers = this.routingTable.closestPeers(id, {
        count: this.routingTable.kBucketSize
      });
      const peersToQuery = peers.sort(() => {
        if (Math.random() > 0.5) {
          return 1;
        }
        return -1;
      }).reduce((acc, curr, index) => {
        acc[index % this.disjointPaths].push(curr);
        return acc;
      }, new Array(this.disjointPaths).fill(0).map(() => [])).filter((peers2) => peers2.length > 0);
      if (peers.length === 0) {
        log4.error("running query with no peers");
        return;
      }
      const peersSeen = createScalableCuckooFilter(1024);
      const paths = peersToQuery.map((peer, index) => {
        return queryPath({
          ...options2,
          key,
          startingPeers: peer,
          ourPeerId: this.peerId,
          signal,
          query: queryFunc,
          path: index,
          numPaths: peersToQuery.length,
          alpha: this.alpha,
          log: log4,
          peersSeen,
          onProgress: options2.onProgress,
          connectionManager: this.connectionManager
        });
      });
      for await (const event of src_default(...paths)) {
        if (event.name === "QUERY_ERROR") {
          log4.error("query error - %e", event.error);
        }
        if (event.name === "PEER_RESPONSE") {
          for (const peer of [...event.closer, ...event.providers]) {
            if (!await this.connectionManager.isDialable(peer.multiaddrs, {
              signal
            })) {
              continue;
            }
            await this.routingTable.add(peer.id, {
              signal
            });
          }
        }
        signal.throwIfAborted();
        yield event;
      }
      queryFinished = true;
    } catch (err) {
      if (this.running) {
        throw err;
      }
    } finally {
      if (!queryFinished) {
        log4("query exited early");
        queryEarlyExitController.abort();
      }
      signal.clear();
      log4("query finished");
    }
  }
};

// ../../node_modules/it-length/dist/src/index.js
function isAsyncIterable7(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function length3(source) {
  if (isAsyncIterable7(source)) {
    return (async () => {
      let count = 0;
      for await (const _ of source) {
        count++;
      }
      return count;
    })();
  } else {
    let count = 0;
    for (const _ of source) {
      count++;
    }
    return count;
  }
}
var src_default6 = length3;

// ../../node_modules/it-take/dist/src/index.js
function isAsyncIterable8(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take(source, limit) {
  if (isAsyncIterable8(source)) {
    return (async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    })();
  }
  return (function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  })();
}
var src_default7 = take;

// ../../node_modules/@libp2p/kad-dht/dist/src/query-self.js
var QuerySelf = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, "peerRouting");
    __publicField(this, "events");
    __publicField(this, "count");
    __publicField(this, "interval");
    __publicField(this, "initialInterval");
    __publicField(this, "queryTimeout");
    __publicField(this, "running");
    __publicField(this, "timeoutId");
    __publicField(this, "controller");
    __publicField(this, "initialQuerySelfHasRun");
    __publicField(this, "querySelfPromise");
    this.peerId = components.peerId;
    this.log = components.logger.forComponent(`${init.logPrefix}:query-self`);
    this.events = components.events;
    this.running = false;
    this.peerRouting = init.peerRouting;
    this.count = init.count ?? K2;
    this.interval = init.interval ?? QUERY_SELF_INTERVAL;
    this.initialInterval = init.initialInterval ?? QUERY_SELF_INITIAL_INTERVAL;
    this.queryTimeout = init.queryTimeout ?? QUERY_SELF_TIMEOUT;
    this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
    this.querySelf = timeOperationMethod(this.querySelf.bind(this), init.operationMetrics, "SELF_QUERY");
  }
  isStarted() {
    return this.running;
  }
  start() {
    if (this.running) {
      return;
    }
    this.running = true;
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.querySelf().catch((err) => {
        this.log.error("error running self-query - %e", err);
      });
    }, this.initialInterval);
  }
  stop() {
    this.running = false;
    if (this.timeoutId != null) {
      clearTimeout(this.timeoutId);
    }
    if (this.controller != null) {
      this.controller.abort();
    }
  }
  async querySelf() {
    if (!this.running) {
      this.log("skip self-query because we are not started");
      return;
    }
    if (this.querySelfPromise != null) {
      this.log("joining existing self query");
      return this.querySelfPromise.promise;
    }
    this.querySelfPromise = pDefer();
    if (this.running) {
      this.controller = new AbortController();
      const signals = [this.controller.signal];
      if (this.initialQuerySelfHasRun == null) {
        const timeoutSignal = AbortSignal.timeout(this.queryTimeout);
        setMaxListeners(Infinity, timeoutSignal);
        signals.push(timeoutSignal);
      }
      const signal = anySignal(signals);
      setMaxListeners(Infinity, signal, this.controller.signal);
      try {
        this.log("run self-query, look for %d peers timing out after %dms", this.count, this.queryTimeout);
        const start2 = Date.now();
        const peers = await pipe(this.peerRouting.getClosestPeers(this.peerId.toMultihash().bytes, {
          signal,
          isSelfQuery: true
        }), (source) => src_default7(source, this.count), async (source) => src_default6(source));
        signal?.throwIfAborted();
        const duration = Date.now() - start2;
        this.log("self-query found %d peers in %dms", peers, duration);
        this.events.dispatchEvent(new CustomEvent("kad-dht:query:self", {
          detail: {
            peers,
            duration
          }
        }));
      } catch (err) {
        this.log.error("self-query error - %e", err);
      } finally {
        signal.clear();
        if (this.initialQuerySelfHasRun != null) {
          this.initialQuerySelfHasRun.resolve();
          this.initialQuerySelfHasRun = void 0;
        }
      }
    }
    this.querySelfPromise.resolve();
    this.querySelfPromise = void 0;
    if (!this.running) {
      return;
    }
    this.timeoutId = setTimeout(() => {
      this.querySelf().catch((err) => {
        this.log.error("error running self-query - %e", err);
      });
    }, this.interval);
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/reprovider.js
var Reprovider = class extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __publicField(this, "log");
    __publicField(this, "reprovideQueue");
    __publicField(this, "maxQueueSize");
    __publicField(this, "datastore");
    __publicField(this, "timeout");
    __publicField(this, "reprovideTimeout");
    __publicField(this, "running");
    __publicField(this, "shutdownController");
    __publicField(this, "reprovideThreshold");
    __publicField(this, "contentRouting");
    __publicField(this, "datastorePrefix");
    __publicField(this, "addressManager");
    __publicField(this, "validity");
    __publicField(this, "interval");
    __publicField(this, "peerId");
    this.log = components.logger.forComponent(`${init.logPrefix}:reprovider`);
    this.peerId = components.peerId;
    this.reprovideQueue = new Queue({
      concurrency: init.concurrency ?? REPROVIDE_CONCURRENCY,
      metrics: components.metrics,
      metricName: `${init.metricsPrefix}_reprovide_queue`
    });
    this.reprovideTimeout = new AdaptiveTimeout({
      ...init.timeout ?? {},
      metrics: components.metrics,
      metricName: `${init.metricsPrefix}_reprovide_timeout_milliseconds`
    });
    this.datastore = components.datastore;
    this.addressManager = components.addressManager;
    this.datastorePrefix = `${init.datastorePrefix}/provider`;
    this.reprovideThreshold = init.threshold ?? REPROVIDE_THRESHOLD;
    this.maxQueueSize = init.maxQueueSize ?? REPROVIDE_MAX_QUEUE_SIZE;
    this.validity = init.validity ?? PROVIDERS_VALIDITY;
    this.interval = init.interval ?? REPROVIDE_INTERVAL;
    this.contentRouting = init.contentRouting;
    this.running = false;
    this.reprovide = timeOperationMethod(this.reprovide.bind(this), init.operationMetrics, "PROVIDE");
  }
  start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    this.timeout = setTimeout(() => {
      this.processRecords({
        signal: AbortSignal.timeout(REPROVIDE_TIMEOUT)
      }).catch((err) => {
        this.log.error("error running process to reprovide/cleanup - %e", err);
      });
    }, this.interval);
  }
  stop() {
    this.running = false;
    this.reprovideQueue.clear();
    clearTimeout(this.timeout);
    this.shutdownController?.abort();
  }
  /**
   * Check all provider records. Delete them if they have expired, reprovide
   * them if the provider is us and the expiry is within the reprovide window.
   */
  async processRecords(options2) {
    try {
      this.safeDispatchEvent("reprovide:start");
      this.log("starting reprovide/cleanup");
      for await (const entry of this.datastore.query({
        prefix: this.datastorePrefix
      }, options2)) {
        try {
          const { cid, peerId } = parseProviderKey(entry.key);
          const created = readProviderTime(entry.value).getTime();
          const expires = created + this.validity;
          const now = Date.now();
          const expired = now > expires;
          const isSelf = this.peerId.equals(peerId);
          this.log.trace("comparing: %d (now) < %d (expires) = %s %s", now, expires, expired, expired ? "(expired)" : "(valid)");
          if (expired && !isSelf) {
            await this.datastore.delete(entry.key, options2);
          }
          if (this.shouldReprovide(isSelf, expires)) {
            this.log("reproviding %c as it is within the reprovide threshold (%d)", cid, this.reprovideThreshold);
            this.queueReprovide(cid).catch((err) => {
              this.log.error("could not reprovide %c - %e", cid, err);
            });
          }
        } catch (err) {
          this.log.error("error processing datastore key %s - %s", entry.key, err.message);
        }
      }
      this.log("reprovide/cleanup successful");
    } finally {
      this.safeDispatchEvent("reprovide:end");
      if (this.running) {
        this.log("queuing next re-provide/cleanup run in %d ms", this.interval);
        this.timeout = setTimeout(() => {
          this.processRecords({
            signal: AbortSignal.timeout(REPROVIDE_TIMEOUT)
          }).catch((err) => {
            this.log.error("error running re-provide - %e", err);
          });
        }, this.interval);
      }
    }
  }
  /**
   * Determines if a record should be reprovided
   */
  shouldReprovide(isSelf, expires) {
    if (!isSelf) {
      return false;
    }
    const now = Date.now();
    if (expires < now) {
      return true;
    }
    return expires - now < this.reprovideThreshold;
  }
  async queueReprovide(cid, options2) {
    if (!this.running) {
      return;
    }
    this.log.trace("waiting for queue capacity before adding %c to re-provide queue", cid);
    await this.reprovideQueue.onSizeLessThan(this.maxQueueSize, options2);
    const existingJob = this.reprovideQueue.queue.find((job) => job.options.cid.equals(cid));
    if (existingJob != null) {
      this.log.trace("not adding %c to re-provide queue - already in queue", cid);
      return existingJob.join();
    }
    this.log.trace("adding %c to re-provide queue", cid);
    this.reprovideQueue.add(async (options3) => {
      options3.signal?.throwIfAborted();
      if (!this.running) {
        return;
      }
      this.log.trace("re-providing %c", cid);
      const signal = this.reprovideTimeout.getTimeoutSignal(options3);
      try {
        await this.reprovide(options3.cid, options3);
      } finally {
        this.reprovideTimeout.cleanUp(signal);
      }
      this.log.trace("re-provided %c", cid);
    }, {
      signal: this.shutdownController?.signal,
      cid
    }).catch((err) => {
      this.log.error("could not re-provide key %c - %e", cid, err);
    });
  }
  async reprovide(cid, options2) {
    await src_default3(this.contentRouting.provide(cid, this.addressManager.getAddresses(), options2));
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/routing-table/closest-peers.js
var PEER_SET_SIZE = 20;
var REFRESH_INTERVAL = 5e3;
var KAD_CLOSE_TAG_NAME = "kad-close";
var KAD_CLOSE_TAG_VALUE = 50;
var ClosestPeers = class {
  constructor(components, init) {
    __publicField(this, "routingTable");
    __publicField(this, "components");
    __publicField(this, "closestPeers");
    __publicField(this, "newPeers");
    __publicField(this, "refreshInterval");
    __publicField(this, "peerSetSize");
    __publicField(this, "timeout");
    __publicField(this, "closeTagName");
    __publicField(this, "closeTagValue");
    __publicField(this, "log");
    __publicField(this, "running");
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);
    this.routingTable = init.routingTable;
    this.refreshInterval = init.refreshInterval ?? REFRESH_INTERVAL;
    this.peerSetSize = init.peerSetSize ?? PEER_SET_SIZE;
    this.closeTagName = init.closeTagName ?? KAD_CLOSE_TAG_NAME;
    this.closeTagValue = init.closeTagValue ?? KAD_CLOSE_TAG_VALUE;
    this.closestPeers = new PeerSet();
    this.onPeerPing = this.onPeerPing.bind(this);
    this.running = false;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    const targetKadId = await convertPeerId(this.components.peerId);
    this.newPeers = new PeerDistanceList(targetKadId, this.peerSetSize);
    this.routingTable.addEventListener("peer:ping", this.onPeerPing);
    this.timeout = setInterval(() => {
      this.updatePeerTags().catch((err) => {
        this.log.error("error updating peer tags - %e", err);
      });
    }, this.refreshInterval);
  }
  stop() {
    this.running = false;
    this.routingTable.removeEventListener("peer:ping", this.onPeerPing);
    clearTimeout(this.timeout);
  }
  onPeerPing(event) {
    this.newPeers?.add({ id: event.detail, multiaddrs: [] }).catch((err) => {
      this.log.error("error adding peer to distance list - %e", err);
    });
  }
  async updatePeerTags() {
    const newClosest = new PeerSet(this.newPeers?.peers.map(({ peer }) => peer.id));
    const added = newClosest.difference(this.closestPeers);
    const removed = this.closestPeers.difference(newClosest);
    this.closestPeers = newClosest;
    await Promise.all([
      ...[...added].map(async (peerId) => {
        await this.components.peerStore.merge(peerId, {
          tags: {
            [this.closeTagName]: {
              value: this.closeTagValue
            },
            [KEEP_ALIVE_TAG2]: {
              value: 1
            }
          }
        });
      }),
      ...[...removed].map(async (peerId) => {
        await this.components.peerStore.merge(peerId, {
          tags: {
            [this.closeTagName]: void 0,
            [KEEP_ALIVE_TAG2]: void 0
          }
        });
      })
    ]);
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/routing-table/k-bucket.js
function isLeafBucket(obj) {
  return Array.isArray(obj?.peers);
}
var KBucket = class {
  constructor(components, options2) {
    __publicField(this, "peerId");
    __publicField(this, "root");
    __publicField(this, "localPeer");
    __publicField(this, "prefixLength");
    __publicField(this, "splitThreshold");
    __publicField(this, "kBucketSize");
    __publicField(this, "numberOfNodesToPing");
    __publicField(this, "lastPingThreshold");
    __publicField(this, "ping");
    __publicField(this, "verify");
    __publicField(this, "onAdd");
    __publicField(this, "onRemove");
    __publicField(this, "onMove");
    __publicField(this, "addingPeerMap");
    this.peerId = components.peerId;
    this.prefixLength = options2.prefixLength ?? PREFIX_LENGTH;
    this.kBucketSize = options2.kBucketSize ?? KBUCKET_SIZE;
    this.splitThreshold = options2.splitThreshold ?? this.kBucketSize;
    this.numberOfNodesToPing = options2.numberOfOldContactsToPing ?? PING_OLD_CONTACT_COUNT;
    this.lastPingThreshold = options2.lastPingThreshold ?? LAST_PING_THRESHOLD;
    this.ping = options2.ping;
    this.verify = options2.verify;
    this.onAdd = options2.onAdd;
    this.onRemove = options2.onRemove;
    this.addingPeerMap = trackedPeerMap({
      name: `${options2.metricsPrefix}_adding_peer_map`,
      metrics: components.metrics
    });
    this.root = {
      prefix: "",
      depth: 0,
      peers: []
    };
  }
  async start() {
    await this.addSelfPeer(this.peerId);
  }
  stop() {
    this.addingPeerMap.clear();
    this.root = {
      prefix: "",
      depth: 0,
      peers: []
    };
  }
  async addSelfPeer(peerId, options2) {
    this.localPeer = {
      peerId,
      kadId: await convertPeerId(peerId, options2),
      lastPing: Date.now()
    };
  }
  /**
   * Adds a contact to the trie
   */
  async add(peerId, options2) {
    const peer = {
      peerId,
      kadId: await convertPeerId(peerId, options2),
      lastPing: 0
    };
    const existingPromise = this.addingPeerMap.get(peerId);
    if (existingPromise != null) {
      return existingPromise;
    }
    try {
      const p2 = this._add(peer, options2);
      this.addingPeerMap.set(peerId, p2);
      await p2;
    } finally {
      this.addingPeerMap.delete(peerId);
    }
  }
  async _add(peer, options2) {
    const bucket = this._determineBucket(peer.kadId);
    if (this._indexOf(bucket, peer.kadId) > -1) {
      return;
    }
    if (bucket.peers.length === this.splitThreshold && bucket.depth < this.prefixLength) {
      await this._split(bucket, options2);
      await this._add(peer, options2);
      return;
    }
    if (bucket.peers.length < this.kBucketSize) {
      if (!needsPing(peer, this.lastPingThreshold)) {
        bucket.peers.push(peer);
        await this.onAdd?.(peer, bucket, options2);
        return;
      }
      const result = await this.verify(peer, options2);
      if (result) {
        peer.lastPing = Date.now();
        await this._add(peer, options2);
      }
      return;
    }
    const toPing = bucket.peers.filter((peer2) => {
      if (peer2.peerId.equals(this.localPeer?.peerId)) {
        return false;
      }
      if (peer2.lastPing > Date.now() - this.lastPingThreshold) {
        return false;
      }
      return true;
    }).sort((a2, b) => {
      if (a2.lastPing < b.lastPing) {
        return -1;
      }
      if (a2.lastPing > b.lastPing) {
        return 1;
      }
      return 0;
    }).slice(0, this.numberOfNodesToPing);
    let evicted = false;
    for await (const toEvict of this.ping(toPing, options2)) {
      evicted = true;
      await this.remove(toEvict.kadId, options2);
    }
    if (!evicted) {
      return;
    }
    await this._add(peer, options2);
  }
  /**
   * Get 0-n closest contacts to the provided node id. "Closest" here means:
   * closest according to the XOR metric of the contact node id.
   *
   * @param {Uint8Array} id - Contact node id
   * @returns {Generator<Peer, void, undefined>} Array Maximum of n closest contacts to the node id
   */
  *closest(id, options2) {
    const list = new PeerDistanceList(id, options2?.count ?? this.kBucketSize);
    for (const peer of this.toIterable()) {
      if (options2?.exclude?.some((p2) => p2.equals(peer.peerId)) === true) {
        continue;
      }
      list.addWithKadId({ id: peer.peerId, multiaddrs: [] }, peer.kadId);
    }
    yield* src_default5(list.peers, ({ peer }) => peer.id);
  }
  /**
   * Counts the total number of contacts in the tree.
   *
   * @returns {number} The number of contacts held in the tree
   */
  count() {
    function countBucket(bucket) {
      if (isLeafBucket(bucket)) {
        return bucket.peers.length;
      }
      let count = 0;
      if (bucket.left != null) {
        count += countBucket(bucket.left);
      }
      if (bucket.right != null) {
        count += countBucket(bucket.right);
      }
      return count;
    }
    return countBucket(this.root);
  }
  /**
   * Get a contact by its exact ID.
   * If this is a leaf, loop through the bucket contents and return the correct
   * contact if we have it or null if not. If this is an inner node, determine
   * which branch of the tree to traverse and repeat.
   *
   * @param {Uint8Array} kadId - The ID of the contact to fetch.
   * @returns {Peer | undefined} The contact if available, otherwise null
   */
  get(kadId) {
    const bucket = this._determineBucket(kadId);
    const index = this._indexOf(bucket, kadId);
    return bucket.peers[index];
  }
  /**
   * Removes contact with the provided id.
   *
   * @param {Uint8Array} kadId - The ID of the contact to remove
   */
  async remove(kadId, options2) {
    const bucket = this._determineBucket(kadId);
    const index = this._indexOf(bucket, kadId);
    if (index > -1) {
      const peer = bucket.peers.splice(index, 1)[0];
      await this.onRemove?.(peer, bucket, options2);
    }
  }
  /**
   * Similar to `toArray()` but instead of buffering everything up into an
   * array before returning it, yields contacts as they are encountered while
   * walking the tree.
   *
   * @returns {Iterable} All of the contacts in the tree, as an iterable
   */
  *toIterable() {
    function* iterate2(bucket) {
      if (isLeafBucket(bucket)) {
        yield* bucket.peers;
        return;
      }
      yield* iterate2(bucket.left);
      yield* iterate2(bucket.right);
    }
    yield* iterate2(this.root);
  }
  /**
   * Default distance function. Finds the XOR distance between firstId and
   * secondId.
   *
   * @param  {Uint8Array} firstId - Uint8Array containing first id.
   * @param  {Uint8Array} secondId - Uint8Array containing second id.
   * @returns {number} Integer The XOR distance between firstId and secondId.
   */
  distance(firstId, secondId) {
    return BigInt("0x" + toString2(xor(firstId, secondId), "base16"));
  }
  /**
   * Determines whether the id at the bitIndex is 0 or 1
   * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
   *
   * @param {Uint8Array} kadId - Id to compare localNodeId with
   * @returns {LeafBucket} left leaf if id at bitIndex is 0, right leaf otherwise.
   */
  _determineBucket(kadId) {
    const bitString = toString2(kadId, "base2");
    function findBucket(bucket, bitIndex = 0) {
      if (isLeafBucket(bucket)) {
        return bucket;
      }
      const bit = bitString[bitIndex];
      if (bit === "0") {
        return findBucket(bucket.left, bitIndex + 1);
      }
      return findBucket(bucket.right, bitIndex + 1);
    }
    return findBucket(this.root);
  }
  /**
   * Returns the index of the contact with provided
   * id if it exists, returns -1 otherwise.
   *
   * @param {object} bucket - internal object that has 2 leafs: left and right
   * @param {Uint8Array} kadId - KadId of peer
   * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
   */
  _indexOf(bucket, kadId) {
    return bucket.peers.findIndex((peer) => equals3(peer.kadId, kadId));
  }
  /**
   * Modify the bucket, turn it from a leaf bucket to an internal bucket
   *
   * @param {any} bucket - bucket for splitting
   */
  async _split(bucket, options2) {
    const left = {
      prefix: "0",
      depth: bucket.depth + 1,
      peers: []
    };
    const right = {
      prefix: "1",
      depth: bucket.depth + 1,
      peers: []
    };
    for (const peer of bucket.peers) {
      const bitString = toString2(peer.kadId, "base2");
      if (bitString[bucket.depth] === "0") {
        left.peers.push(peer);
        await this.onMove?.(peer, bucket, left, options2);
      } else {
        right.peers.push(peer);
        await this.onMove?.(peer, bucket, right, options2);
      }
    }
    convertToInternalBucket(bucket, left, right);
  }
};
function convertToInternalBucket(bucket, left, right) {
  delete bucket.peers;
  bucket.left = left;
  bucket.right = right;
  if (bucket.prefix === "") {
    delete bucket.depth;
    delete bucket.prefix;
  }
  return true;
}
function needsPing(peer, threshold) {
  return peer.lastPing < Date.now() - threshold;
}

// ../../node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
var KBUCKET_SIZE = 20;
var PREFIX_LENGTH = 6;
var PING_NEW_CONTACT_TIMEOUT = 2e3;
var PING_NEW_CONTACT_CONCURRENCY = 20;
var PING_NEW_CONTACT_MAX_QUEUE_SIZE = 100;
var PING_OLD_CONTACT_COUNT = 3;
var PING_OLD_CONTACT_TIMEOUT = 2e3;
var PING_OLD_CONTACT_CONCURRENCY = 20;
var PING_OLD_CONTACT_MAX_QUEUE_SIZE = 100;
var KAD_PEER_TAG_NAME = "kad-peer";
var KAD_PEER_TAG_VALUE = 1;
var LAST_PING_THRESHOLD = 6e5;
var POPULATE_FROM_DATASTORE_ON_START = true;
var POPULATE_FROM_DATASTORE_LIMIT = 1e3;
var RoutingTable = class extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __publicField(this, "kBucketSize");
    __publicField(this, "kb");
    __publicField(this, "network");
    __publicField(this, "closestPeerTagger");
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "running");
    __publicField(this, "pingNewContactTimeout");
    __publicField(this, "pingNewContactQueue");
    __publicField(this, "pingOldContactTimeout");
    __publicField(this, "pingOldContactQueue");
    __publicField(this, "populateFromDatastoreOnStart");
    __publicField(this, "populateFromDatastoreLimit");
    __publicField(this, "protocol");
    __publicField(this, "peerTagName");
    __publicField(this, "peerTagValue");
    __publicField(this, "metrics");
    __publicField(this, "shutdownController");
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);
    this.kBucketSize = init.kBucketSize ?? KBUCKET_SIZE;
    this.running = false;
    this.protocol = init.protocol;
    this.network = init.network;
    this.peerTagName = init.peerTagName ?? KAD_PEER_TAG_NAME;
    this.peerTagValue = init.peerTagValue ?? KAD_PEER_TAG_VALUE;
    this.pingOldContacts = this.pingOldContacts.bind(this);
    this.verifyNewContact = this.verifyNewContact.bind(this);
    this.peerAdded = this.peerAdded.bind(this);
    this.peerRemoved = this.peerRemoved.bind(this);
    this.populateFromDatastoreOnStart = init.populateFromDatastoreOnStart ?? POPULATE_FROM_DATASTORE_ON_START;
    this.populateFromDatastoreLimit = init.populateFromDatastoreLimit ?? POPULATE_FROM_DATASTORE_LIMIT;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    this.pingOldContactQueue = new PeerQueue({
      concurrency: init.pingOldContactConcurrency ?? PING_OLD_CONTACT_CONCURRENCY,
      metricName: `${init.metricsPrefix}_ping_old_contact_queue`,
      metrics: this.components.metrics,
      maxSize: init.pingOldContactMaxQueueSize ?? PING_OLD_CONTACT_MAX_QUEUE_SIZE
    });
    this.pingOldContactTimeout = new AdaptiveTimeout({
      ...init.pingOldContactTimeout ?? {},
      metrics: this.components.metrics,
      metricName: `${init.metricsPrefix}_routing_table_ping_old_contact_time_milliseconds`
    });
    this.pingNewContactQueue = new PeerQueue({
      concurrency: init.pingNewContactConcurrency ?? PING_NEW_CONTACT_CONCURRENCY,
      metricName: `${init.metricsPrefix}_ping_new_contact_queue`,
      metrics: this.components.metrics,
      maxSize: init.pingNewContactMaxQueueSize ?? PING_NEW_CONTACT_MAX_QUEUE_SIZE
    });
    this.pingNewContactTimeout = new AdaptiveTimeout({
      ...init.pingNewContactTimeout ?? {},
      metrics: this.components.metrics,
      metricName: `${init.metricsPrefix}_routing_table_ping_new_contact_time_milliseconds`
    });
    this.kb = new KBucket(components, {
      kBucketSize: init.kBucketSize,
      prefixLength: init.prefixLength,
      splitThreshold: init.splitThreshold,
      numberOfOldContactsToPing: init.numberOfOldContactsToPing,
      lastPingThreshold: init.lastPingThreshold,
      ping: this.pingOldContacts,
      verify: this.verifyNewContact,
      onAdd: this.peerAdded,
      onRemove: this.peerRemoved,
      metricsPrefix: init.metricsPrefix
    });
    this.closestPeerTagger = new ClosestPeers(this.components, {
      logPrefix: init.logPrefix,
      routingTable: this,
      peerSetSize: init.closestPeerSetSize,
      refreshInterval: init.closestPeerSetRefreshInterval,
      closeTagName: init.closeTagName,
      closeTagValue: init.closeTagValue
    });
    if (this.components.metrics != null) {
      this.metrics = {
        routingTableSize: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_size`),
        routingTableKadBucketTotal: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_total`),
        routingTableKadBucketAverageOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_average_occupancy`),
        routingTableKadBucketMinOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_min_occupancy`),
        routingTableKadBucketMaxOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_max_occupancy`),
        routingTableKadBucketMaxDepth: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_max_depth`),
        kadBucketEvents: this.components.metrics.registerCounterGroup(`${init.metricsPrefix}_kad_bucket_events_total`)
      };
    }
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    await start(this.closestPeerTagger, this.kb);
  }
  async afterStart() {
    let peerStorePeers = 0;
    Promise.resolve().then(async () => {
      if (!this.populateFromDatastoreOnStart) {
        return;
      }
      const signal = anySignal([
        this.shutdownController.signal,
        AbortSignal.timeout(2e4)
      ]);
      setMaxListeners(Infinity, signal);
      try {
        for (const peer of await this.components.peerStore.all({
          filters: [(peer2) => {
            return peer2.protocols.includes(this.protocol) && peer2.tags.has(KAD_PEER_TAG_NAME);
          }],
          limit: this.populateFromDatastoreLimit,
          signal
        })) {
          if (!this.running) {
            return;
          }
          try {
            await this.add(peer.id, {
              signal
            });
            peerStorePeers++;
          } catch (err) {
            this.log("failed to add peer %p to routing table, removing kad-dht peer tags - %e");
            await this.components.peerStore.merge(peer.id, {
              tags: {
                [this.peerTagName]: void 0
              }
            });
          }
        }
      } finally {
        signal.clear();
      }
      this.log("added %d peer store peers to the routing table", peerStorePeers);
    }).catch((err) => {
      this.log.error("error adding %d, peer store peers to the routing table - %e", peerStorePeers, err);
    });
  }
  async stop() {
    this.running = false;
    await stop(this.closestPeerTagger, this.kb);
    this.pingOldContactQueue.abort();
    this.pingNewContactQueue.abort();
    this.shutdownController.abort();
  }
  async peerAdded(peer, bucket, options2) {
    if (!this.components.peerId.equals(peer.peerId)) {
      await this.components.peerStore.merge(peer.peerId, {
        tags: {
          [this.peerTagName]: {
            value: this.peerTagValue
          }
        }
      }, options2);
    }
    this.updateMetrics();
    this.metrics?.kadBucketEvents.increment({ peer_added: true });
    this.safeDispatchEvent("peer:add", { detail: peer.peerId });
  }
  async peerRemoved(peer, bucket, options2) {
    if (!this.components.peerId.equals(peer.peerId)) {
      await this.components.peerStore.merge(peer.peerId, {
        tags: {
          [this.peerTagName]: void 0
        }
      }, options2);
    }
    this.updateMetrics();
    this.metrics?.kadBucketEvents.increment({ peer_removed: true });
    this.safeDispatchEvent("peer:remove", { detail: peer.peerId });
  }
  /**
   * Called on the `ping` event from `k-bucket` when a bucket is full
   * and cannot split.
   *
   * `oldContacts.length` is defined by the `numberOfNodesToPing` param
   * passed to the `k-bucket` constructor.
   *
   * `oldContacts` will not be empty and is the list of contacts that
   * have not been contacted for the longest.
   */
  async *pingOldContacts(oldContacts, options2) {
    if (!this.running) {
      return;
    }
    const jobs = [];
    for (const oldContact of oldContacts) {
      if (this.kb.get(oldContact.kadId) == null) {
        this.log("asked to ping contact %p that was not in routing table", oldContact.peerId);
        continue;
      }
      this.metrics?.kadBucketEvents.increment({ ping_old_contact: true });
      jobs.push(async () => {
        const existingJob = this.pingOldContactQueue.find(oldContact.peerId);
        if (existingJob != null) {
          this.log("asked to ping contact %p was already being pinged", oldContact.peerId);
          const result2 = await existingJob.join(options2);
          if (!result2) {
            return oldContact;
          }
          return;
        }
        const result = await this.pingOldContactQueue.add(async (options3) => {
          const signal = this.pingOldContactTimeout.getTimeoutSignal();
          const signals = anySignal([
            signal,
            this.shutdownController.signal,
            options3?.signal
          ]);
          setMaxListeners(Infinity, signal, signals);
          try {
            return await this.pingContact(oldContact, options3);
          } catch {
            this.metrics?.kadBucketEvents.increment({ ping_old_contact_error: true });
            return true;
          } finally {
            this.pingOldContactTimeout.cleanUp(signal);
            signals.clear();
          }
        }, {
          peerId: oldContact.peerId,
          signal: options2?.signal
        });
        if (!result) {
          return oldContact;
        }
      });
    }
    for await (const peer of parallel(jobs)) {
      if (peer != null) {
        yield peer;
      }
    }
  }
  async verifyNewContact(contact, options2) {
    const signal = this.pingNewContactTimeout.getTimeoutSignal();
    const signals = anySignal([
      signal,
      this.shutdownController.signal,
      options2?.signal
    ]);
    setMaxListeners(Infinity, signal, signals);
    try {
      const job = this.pingNewContactQueue.find(contact.peerId);
      if (job != null) {
        this.log("joining existing ping to add new peer %p to routing table", contact.peerId);
        return await job.join({
          signal: signals
        });
      } else {
        return await this.pingNewContactQueue.add(async (options3) => {
          this.metrics?.kadBucketEvents.increment({ ping_new_contact: true });
          this.log("pinging new peer %p before adding to routing table", contact.peerId);
          return this.pingContact(contact, options3);
        }, {
          peerId: contact.peerId,
          signal: signals
        });
      }
    } catch (err) {
      this.log.trace("tried to add peer %p but they were not online", contact.peerId);
      this.metrics?.kadBucketEvents.increment({ ping_new_contact_error: true });
      return false;
    } finally {
      this.pingNewContactTimeout.cleanUp(signal);
      signals.clear();
    }
  }
  async pingContact(contact, options2) {
    let stream;
    try {
      this.log("pinging contact %p", contact.peerId);
      await this.components.ping.ping(contact.peerId, options2);
      this.log("contact %p ping ok", contact.peerId);
      this.safeDispatchEvent("peer:ping", {
        detail: contact.peerId
      });
      return true;
    } catch (err) {
      this.log("error pinging old contact %p - %e", contact.peerId, err);
      stream?.abort(err);
      return false;
    }
  }
  /**
   * Amount of currently stored peers
   */
  get size() {
    if (this.kb == null) {
      return 0;
    }
    return this.kb.count();
  }
  /**
   * Find a specific peer by id
   */
  async find(peer, options2) {
    const kadId = await convertPeerId(peer, options2);
    return this.kb.get(kadId)?.peerId;
  }
  /**
   * Retrieve the closest peers to the given kadId
   */
  closestPeer(kadId) {
    const res = this.closestPeers(kadId, {
      count: 1
    });
    if (res.length > 0) {
      return res[0];
    }
    return void 0;
  }
  /**
   * Retrieve the `count`-closest peers to the given kadId
   */
  closestPeers(kadId, options2) {
    if (this.kb == null) {
      return [];
    }
    return [...this.kb.closest(kadId, options2)];
  }
  /**
   * Add or update the routing table with the given peer
   */
  async add(peerId, options2) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    await this.kb.add(peerId, options2);
  }
  /**
   * Remove a given peer from the table
   */
  async remove(peer, options2) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const kadId = await convertPeerId(peer, options2);
    await this.kb.remove(kadId, options2);
  }
  updateMetrics() {
    if (this.metrics == null || this.kb == null) {
      return;
    }
    let size = 0;
    let buckets = 0;
    let maxDepth = 0;
    let minOccupancy = 20;
    let maxOccupancy = 0;
    function count(bucket) {
      if (isLeafBucket(bucket)) {
        if (bucket.depth > maxDepth) {
          maxDepth = bucket.depth;
        }
        buckets++;
        size += bucket.peers.length;
        if (bucket.peers.length < minOccupancy) {
          minOccupancy = bucket.peers.length;
        }
        if (bucket.peers.length > maxOccupancy) {
          maxOccupancy = bucket.peers.length;
        }
        return;
      }
      count(bucket.left);
      count(bucket.right);
    }
    count(this.kb.root);
    this.metrics.routingTableSize.update(size);
    this.metrics.routingTableKadBucketTotal.update(buckets);
    this.metrics.routingTableKadBucketAverageOccupancy.update(Math.round(size / buckets));
    this.metrics.routingTableKadBucketMinOccupancy.update(minOccupancy);
    this.metrics.routingTableKadBucketMaxOccupancy.update(maxOccupancy);
    this.metrics.routingTableKadBucketMaxDepth.update(maxDepth);
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/routing-table/generated-prefix-list-browser.js
var generated_prefix_list_browser_default = [
  77591,
  22417,
  43971,
  28421,
  740,
  29829,
  71467,
  228973,
  196661,
  78537,
  27689,
  36431,
  44415,
  14362,
  19456,
  106025,
  96308,
  2882,
  49509,
  21149,
  87173,
  131409,
  75844,
  23676,
  121838,
  30291,
  17492,
  2953,
  7564,
  110620,
  129477,
  127283,
  53113,
  72417,
  165166,
  109690,
  21200,
  102125,
  24049,
  71504,
  90342,
  25307,
  72039,
  26812,
  26715,
  32264,
  133800,
  71161,
  88956,
  171987,
  51779,
  24425,
  16671,
  30251,
  186294,
  247761,
  14202,
  2121,
  8465,
  35024,
  4876,
  85917,
  169730,
  3638,
  256836,
  96184,
  943,
  18678,
  6583,
  52907,
  35807,
  112254,
  214097,
  18796,
  11595,
  9243,
  23554,
  887,
  268203,
  382004,
  24590,
  111335,
  11625,
  16619,
  29039,
  102425,
  69006,
  97976,
  92362,
  32552,
  63717,
  41433,
  128974,
  137630,
  59943,
  10019,
  13986,
  35430,
  33665,
  108037,
  43799,
  43280,
  38195,
  29078,
  58629,
  18265,
  14425,
  46832,
  235538,
  40830,
  77881,
  110717,
  58937,
  3463,
  325358,
  51300,
  47623,
  117252,
  19007,
  10170,
  20540,
  91237,
  294813,
  4951,
  79841,
  56232,
  36270,
  128547,
  69209,
  66275,
  100156,
  32063,
  73531,
  34439,
  80937,
  28892,
  44466,
  88595,
  216307,
  32583,
  49620,
  16605,
  82127,
  45807,
  21630,
  78726,
  20235,
  40163,
  111007,
  96926,
  5567,
  72083,
  21665,
  58844,
  39419,
  179767,
  48328,
  42662,
  51550,
  5251,
  37811,
  49608,
  81056,
  50854,
  55513,
  20922,
  18891,
  197409,
  164656,
  32593,
  71449,
  220474,
  58919,
  85682,
  67854,
  13758,
  35066,
  3565,
  61905,
  214793,
  119572,
  141419,
  21504,
  10302,
  27354,
  67003,
  46131,
  32668,
  15165,
  64871,
  34450,
  17821,
  2757,
  11452,
  34189,
  5160,
  12257,
  85523,
  560,
  53385,
  65887,
  119549,
  135620,
  312353,
  115979,
  122356,
  10867,
  193231,
  124537,
  54783,
  90675,
  120791,
  4715,
  142253,
  50943,
  17271,
  43358,
  25331,
  4917,
  120566,
  34580,
  12878,
  33786,
  160528,
  32523,
  4869,
  301307,
  104817,
  81491,
  23276,
  8832,
  97911,
  31265,
  52065,
  7998,
  49622,
  9715,
  43998,
  34091,
  84587,
  20664,
  69041,
  29419,
  53205,
  10838,
  58288,
  116145,
  6185,
  5154,
  141795,
  35924,
  21307,
  144738,
  43730,
  12085,
  8279,
  10002,
  119,
  133779,
  199668,
  72938,
  31768,
  39176,
  67875,
  38453,
  9700,
  44144,
  4121,
  116048,
  41733,
  12868,
  82669,
  92308,
  128,
  34262,
  11332,
  7712,
  90764,
  36141,
  13553,
  71312,
  77470,
  117314,
  96549,
  49135,
  23602,
  54468,
  28605,
  6327,
  62308,
  17171,
  67531,
  21319,
  14105,
  894,
  107722,
  46157,
  8503,
  51069,
  100472,
  45138,
  15246,
  14577,
  35609,
  191464,
  1757,
  13364,
  161349,
  32067,
  91705,
  81144,
  52339,
  5408,
  91066,
  21983,
  14157,
  100545,
  4372,
  26630,
  129112,
  1423,
  29676,
  213626,
  4397,
  88436,
  99190,
  6877,
  49958,
  26122,
  114348,
  60661,
  29818,
  293118,
  50042,
  179738,
  16400,
  163423,
  89627,
  31040,
  43973,
  36638,
  45952,
  5153,
  1894,
  109322,
  1898,
  134021,
  12402,
  112077,
  68309,
  190269,
  69866,
  31938,
  107383,
  11522,
  105232,
  11248,
  14868,
  39852,
  71707,
  186525,
  16530,
  38162,
  106212,
  11700,
  5130,
  16608,
  26998,
  59586,
  108399,
  230033,
  43683,
  48135,
  82179,
  2073,
  5015,
  196684,
  189293,
  16378,
  23452,
  8301,
  35640,
  11632,
  214551,
  29240,
  57644,
  33137,
  91949,
  55157,
  52384,
  117313,
  5090,
  17717,
  89668,
  49363,
  82238,
  241035,
  66216,
  29066,
  184088,
  97206,
  62820,
  26595,
  4241,
  135635,
  173672,
  8202,
  459,
  71355,
  146294,
  29587,
  3008,
  135385,
  141203,
  14803,
  6634,
  45094,
  69362,
  50925,
  546,
  51884,
  62011,
  83296,
  234584,
  44515,
  56050,
  89476,
  87751,
  19373,
  12691,
  149923,
  19794,
  13833,
  35846,
  87557,
  58339,
  2884,
  19145,
  25647,
  12224,
  11024,
  77338,
  64608,
  122297,
  53025,
  7205,
  36189,
  36294,
  170779,
  21750,
  7739,
  173883,
  75192,
  35664,
  224240,
  113121,
  30181,
  26267,
  27036,
  117827,
  92015,
  106516,
  55628,
  203549,
  67949,
  60462,
  60844,
  35911,
  20457,
  1820,
  920,
  19773,
  8738,
  73173,
  181993,
  38521,
  98254,
  76257,
  46008,
  92796,
  5384,
  26868,
  151566,
  22124,
  2411,
  15919,
  186872,
  180021,
  28099,
  152961,
  78811,
  80237,
  62352,
  102653,
  74259,
  184890,
  16792,
  123702,
  224945,
  29940,
  19512,
  75283,
  14059,
  112691,
  92811,
  233329,
  20411,
  138569,
  53341,
  109802,
  50600,
  134528,
  66747,
  5529,
  166531,
  31578,
  64732,
  67189,
  1596,
  126357,
  967,
  167999,
  206598,
  109752,
  119431,
  207825,
  78791,
  91938,
  10301,
  27311,
  24233,
  252343,
  28831,
  32812,
  66002,
  112267,
  90895,
  8786,
  8095,
  16824,
  22866,
  21813,
  60507,
  174833,
  19549,
  130985,
  117051,
  52110,
  6938,
  81923,
  123864,
  38061,
  919,
  18680,
  53534,
  46739,
  112893,
  161529,
  85429,
  26761,
  11900,
  81121,
  91968,
  15390,
  217947,
  56524,
  1713,
  6654,
  37089,
  85630,
  138866,
  61850,
  16491,
  75577,
  16884,
  98296,
  73523,
  6140,
  44645,
  6062,
  36366,
  29844,
  57946,
  37932,
  42472,
  5266,
  20834,
  19309,
  33753,
  127182,
  134259,
  35810,
  41805,
  45878,
  312001,
  14881,
  47757,
  49251,
  120050,
  44252,
  3708,
  25856,
  107864,
  120347,
  1228,
  36550,
  41682,
  34496,
  47025,
  8393,
  173365,
  246526,
  12894,
  161607,
  35670,
  90785,
  126572,
  2095,
  124731,
  157033,
  58694,
  554,
  12786,
  9642,
  4817,
  16136,
  47864,
  174698,
  66992,
  4639,
  69284,
  10625,
  40710,
  27763,
  51738,
  30404,
  264105,
  137904,
  109882,
  52487,
  42824,
  57514,
  2740,
  10479,
  146799,
  107390,
  16586,
  88038,
  174951,
  9410,
  16185,
  44158,
  5568,
  40658,
  46108,
  12763,
  97385,
  26175,
  108859,
  664,
  230732,
  67470,
  46663,
  14395,
  50750,
  141320,
  93140,
  15361,
  47997,
  55784,
  6791,
  307840,
  118569,
  107326,
  18056,
  58281,
  260415,
  54691,
  8790,
  73332,
  45633,
  7511,
  45674,
  143373,
  14031,
  11799,
  94491,
  35646,
  96544,
  14560,
  26049,
  32983,
  25791,
  83814,
  42094,
  231370,
  63955,
  139212,
  2359,
  169908,
  3108,
  183486,
  105867,
  28197,
  32941,
  124968,
  26402,
  88267,
  149768,
  23053,
  3078,
  19091,
  52924,
  25383,
  19209,
  111548,
  97361,
  3959,
  24880,
  235061,
  9099,
  24921,
  161254,
  151405,
  20508,
  7159,
  34381,
  20133,
  11434,
  74036,
  19974,
  34769,
  36585,
  1076,
  22454,
  17354,
  38727,
  235160,
  111547,
  96454,
  117448,
  156940,
  91330,
  37299,
  7310,
  26915,
  117060,
  51369,
  22620,
  61861,
  322264,
  106850,
  111694,
  15091,
  2624,
  40345,
  300446,
  177064,
  1707,
  27389,
  54792,
  327783,
  132669,
  183543,
  59003,
  17744,
  20603,
  151134,
  106923,
  53084,
  71803,
  279424,
  319816,
  11579,
  21946,
  16728,
  38274,
  72711,
  5085,
  83391,
  88646,
  40159,
  25027,
  34680,
  10752,
  12988,
  54126,
  30365,
  18338,
  100445,
  230674,
  44874,
  84974,
  143877,
  123253,
  139372,
  28082,
  91477,
  144002,
  13096,
  219729,
  46016,
  50029,
  42377,
  14601,
  6660,
  58244,
  58978,
  23918,
  88206,
  113611,
  64452,
  17541,
  41032,
  10942,
  12021,
  49189,
  10978,
  40175,
  37156,
  10947,
  71709,
  106894,
  112538,
  57007,
  137486,
  150608,
  152719,
  40615,
  7746,
  279716,
  13101,
  19524,
  28708,
  40578,
  72320,
  1096,
  182051,
  94527,
  51275,
  22833,
  45164,
  81917,
  77519,
  48508,
  5421,
  140302,
  37845,
  149830,
  5587,
  27579,
  5357,
  428725,
  248187,
  6326,
  206760,
  39814,
  32585,
  89923,
  44341,
  288753,
  284443,
  96368,
  31201,
  94189,
  119504,
  20359,
  52073,
  103216,
  179,
  27934,
  32801,
  96035,
  34111,
  34309,
  101326,
  18198,
  20704,
  210266,
  37643,
  27880,
  141873,
  106e3,
  19414,
  56614,
  167714,
  66483,
  107885,
  86602,
  4379,
  20796,
  75467,
  4987,
  5017,
  118857,
  26003,
  34308,
  114428,
  29198,
  6686,
  29697,
  73632,
  3739,
  69795,
  16798,
  41504,
  7207,
  30722,
  21436,
  36735,
  28067,
  28545,
  3239,
  11221,
  36031,
  41889,
  100010,
  19247,
  317673,
  29495,
  174554,
  6424,
  129725,
  53845,
  94986,
  7955,
  59676,
  2604,
  191497,
  19735,
  102214,
  62954,
  23844,
  11872,
  179525,
  261436,
  34492,
  428,
  78404,
  142035,
  16747,
  17246,
  27578,
  37021,
  33672,
  57944,
  26056,
  135760,
  2369,
  61674,
  122066,
  31327,
  19374,
  157065,
  40553,
  130982,
  69619,
  71290,
  38855,
  72100,
  92903,
  95940,
  51422,
  165999,
  65713,
  57873,
  50726,
  7288,
  20272,
  2081,
  42326,
  22624,
  81120,
  57914,
  79352,
  19447,
  1684,
  72302,
  11774,
  302559,
  161481,
  96396,
  13692,
  414988,
  3721,
  79066,
  56627,
  46883,
  21150,
  11747,
  12184,
  5856,
  113458,
  176117,
  84416,
  52079,
  27933,
  3354,
  59765,
  141359,
  2212,
  216309,
  2555,
  23458,
  196722,
  142463,
  45701,
  44548,
  28798,
  19418,
  215,
  29916,
  9396,
  10574,
  114226,
  84475,
  13520,
  18694,
  34056,
  4524,
  90302,
  62930,
  13539,
  19407,
  77209,
  7728,
  38088,
  9535,
  2263,
  23875,
  183945,
  17750,
  26274,
  67172,
  10585,
  28042,
  22199,
  7478,
  51331,
  66030,
  26774,
  192929,
  31434,
  25850,
  50197,
  52926,
  178158,
  4679,
  181256,
  70184,
  229600,
  9959,
  105594,
  72158,
  73974,
  2726,
  35085,
  78087,
  23284,
  35568,
  51713,
  155676,
  5401,
  27254,
  11966,
  17569,
  223253,
  71993,
  103357,
  111477,
  55722,
  30504,
  26034,
  46774,
  35392,
  36285,
  214814,
  41143,
  163465,
  1051,
  16094,
  81044,
  6636,
  76489,
  179102,
  20712,
  39178,
  35683,
  125177,
  54219,
  30617,
  52994,
  25324,
  50123,
  2543,
  87529,
  58995,
  10688,
  125199,
  12388,
  60158,
  125481,
  131646,
  7642,
  133350,
  65874,
  3438,
  97277,
  101450,
  10075,
  56344,
  116821,
  50778,
  60547,
  98016,
  106135,
  13859,
  14255,
  16300,
  77373,
  173521,
  8285,
  45932,
  37426,
  4054,
  114295,
  55947,
  7703,
  39114,
  52,
  51119,
  128135,
  19714,
  60715,
  9554,
  50492,
  88180,
  2823,
  118271,
  52993,
  122625,
  97919,
  23859,
  37895,
  25040,
  33614,
  32102,
  20431,
  3577,
  9275,
  15686,
  43031,
  157741,
  110358,
  1884,
  40291,
  125391,
  13736,
  5008,
  64881,
  87336,
  77381,
  70711,
  43032,
  49155,
  118587,
  70494,
  4318,
  10168,
  30126,
  12580,
  10524,
  280104,
  104001,
  145413,
  2862,
  84140,
  6603,
  106005,
  13566,
  12780,
  11251,
  42830,
  571,
  179910,
  82443,
  13146,
  469,
  42714,
  32591,
  265217,
  424024,
  92553,
  54721,
  134100,
  6007,
  15242,
  114681,
  59030,
  16718,
  85465,
  200214,
  85982,
  55174,
  165013,
  23493,
  56964,
  82529,
  109150,
  32706,
  27568,
  82442,
  5350,
  14976,
  13165,
  44890,
  60021,
  21343,
  33978,
  17264,
  4655,
  22328,
  27819,
  75730,
  16567,
  55483,
  14510,
  17926,
  45827,
  150609,
  3704,
  7385,
  272531,
  161543,
  76904,
  122163,
  52405,
  2039,
  19165,
  41623,
  14423,
  228354,
  3369,
  176360,
  85491,
  7122,
  35789,
  303724,
  4465,
  13628,
  2233,
  55311,
  118771,
  20713,
  10006,
  221519,
  45115,
  71021,
  35650,
  29775,
  7337,
  10864,
  20665,
  21142,
  1746,
  15080,
  1624,
  32449,
  10905,
  105743,
  229797,
  7701,
  3940,
  22997,
  178467,
  57208,
  389057,
  39683,
  59403,
  63344,
  63125,
  54847,
  69691,
  18336,
  56448,
  3362,
  37202,
  18282,
  29648,
  138224,
  35867,
  10495,
  5911,
  28814,
  26653,
  31514,
  176702,
  26550,
  45621,
  11734,
  4525,
  40543,
  73944,
  121080,
  27858,
  155561,
  14887,
  44670,
  30742,
  8796,
  107455,
  113472,
  56369,
  75581,
  183777,
  240095,
  133699,
  153299,
  8768,
  160464,
  26058,
  49078,
  103971,
  21875,
  71486,
  44888,
  17156,
  9678,
  89541,
  123019,
  102337,
  3972,
  83930,
  21245,
  87852,
  109660,
  287918,
  183019,
  686,
  10100,
  39177,
  283941,
  11274,
  24736,
  26793,
  26214,
  25995,
  77011,
  141580,
  4070,
  23742,
  46285,
  46632,
  30700,
  26669,
  19056,
  35951,
  115575,
  174034,
  56097,
  35463,
  87425,
  24575,
  44245,
  38701,
  82317,
  85922,
  281616,
  100333,
  147697,
  61503,
  7730,
  84330,
  8530,
  59917,
  61597,
  17173,
  9092,
  32658,
  90288,
  193136,
  39023,
  20381,
  56654,
  31132,
  7779,
  1919,
  1375,
  117128,
  30819,
  11169,
  40938,
  23935,
  115201,
  101155,
  151034,
  4835,
  11231,
  74550,
  89388,
  59951,
  91704,
  107312,
  167882,
  115062,
  12732,
  72738,
  88703,
  464019,
  158267,
  57995,
  60496,
  737,
  14371,
  123867,
  4174,
  243339,
  159946,
  7568,
  16025,
  134556,
  110916,
  38103,
  191,
  80226,
  88794,
  29688,
  27230,
  10454,
  76308,
  57647,
  77409,
  113483,
  66864,
  14745,
  19808,
  12023,
  46583,
  84805,
  16015,
  17102,
  2231,
  20611,
  3547,
  95740,
  250131,
  34559,
  108894,
  8498,
  15853,
  159169,
  148920,
  20942,
  2813,
  93160,
  45188,
  210613,
  45531,
  52587,
  149062,
  39782,
  28194,
  57849,
  60965,
  84954,
  89766,
  84453,
  100927,
  16501,
  27658,
  165311,
  103841,
  54192,
  207341,
  19558,
  20084,
  319622,
  5672,
  205467,
  98462,
  61849,
  36279,
  13609,
  147177,
  24726,
  165015,
  209489,
  59591,
  31157,
  6551,
  117580,
  75060,
  141146,
  277310,
  21072,
  22023,
  106474,
  63041,
  137443,
  122965,
  68371,
  5383,
  42146,
  98961,
  113467,
  30863,
  23794,
  4843,
  99630,
  30392,
  82679,
  13699,
  241612,
  33601,
  93146,
  24319,
  18643,
  32155,
  95669,
  40440,
  15333,
  34089,
  67799,
  142144,
  58245,
  38633,
  114531,
  117400,
  77861,
  188726,
  5507,
  2568,
  8853,
  10987,
  107222,
  2663,
  2421,
  11530,
  13345,
  30075,
  41785,
  118661,
  104786,
  17459,
  12490,
  16281,
  71936,
  193555,
  17431,
  5944,
  71758,
  26485,
  77317,
  20803,
  367167,
  158,
  7362,
  93430,
  11735,
  172445,
  46002,
  11532,
  54482,
  930,
  62911,
  2235,
  23004,
  179236,
  4764,
  101859,
  208113,
  22477,
  55163,
  95579,
  14098,
  67320,
  162556,
  90709,
  156949,
  3826,
  57492,
  4025,
  34092,
  87442,
  104565,
  6718,
  186015,
  28214,
  14209,
  10039,
  107186,
  233912,
  58877,
  81637,
  55265,
  39828,
  6194,
  145813,
  50831,
  105849,
  4974,
  88319,
  122296,
  10272,
  197216,
  95714,
  51540,
  72418,
  23324,
  91555,
  8743,
  140452,
  250249,
  51666,
  34124,
  7229,
  38592,
  129641,
  78169,
  174242,
  22464,
  149964,
  51450,
  14034,
  10026,
  95376,
  26190,
  120062,
  14401,
  8700,
  265,
  31386,
  143573,
  7203,
  229889,
  61567,
  4227,
  140981,
  2466,
  72052,
  10787,
  10062,
  30958,
  6099,
  38471,
  30103,
  23202,
  208101,
  70847,
  467,
  58934,
  32271,
  32984,
  36637,
  24107,
  30771,
  17109,
  73353,
  13650,
  2098,
  157040,
  67366,
  66904,
  106018,
  265380,
  107238,
  18535,
  44025,
  32681,
  144983,
  62505,
  91295,
  56120,
  3082,
  77508,
  10322,
  63023,
  36700,
  81885,
  224127,
  16721,
  45023,
  239261,
  111272,
  13852,
  7866,
  149243,
  204199,
  32309,
  22084,
  42029,
  38316,
  126644,
  104973,
  14406,
  43454,
  67322,
  61310,
  15789,
  40285,
  24026,
  181047,
  6301,
  70927,
  23319,
  115823,
  27248,
  66693,
  115875,
  278566,
  63007,
  146844,
  56841,
  59007,
  87368,
  180001,
  22370,
  42114,
  80605,
  12022,
  10374,
  308,
  25079,
  14689,
  12618,
  63368,
  7936,
  264973,
  212291,
  136713,
  95999,
  105801,
  18965,
  32075,
  48700,
  52230,
  35119,
  96912,
  32992,
  8586,
  16606,
  101333,
  101812,
  14969,
  39930,
  759,
  193090,
  27387,
  42914,
  12937,
  5058,
  62646,
  64528,
  38624,
  25743,
  37502,
  3716,
  4435,
  30352,
  178687,
  26461,
  132611,
  42002,
  138442,
  35833,
  59582,
  16345,
  8048,
  60319,
  49349,
  309,
  47800,
  49739,
  90482,
  26405,
  34470,
  63786,
  32479,
  85028,
  39866,
  47846,
  11649,
  23934,
  29466,
  2816,
  42864,
  31828,
  7410,
  74885,
  49632,
  47629,
  111801,
  90749,
  19536,
  18767,
  105764,
  59606,
  21223,
  10746,
  76298,
  22220,
  39408,
  7190,
  79654,
  64856,
  11602,
  82156,
  272765,
  17079,
  70089,
  245473,
  51813,
  184407,
  384678,
  1576,
  122249,
  5064,
  27481,
  6188,
  25790,
  74361,
  27541,
  318284,
  45430,
  31488,
  620,
  93579,
  45723,
  192118,
  22670,
  51913,
  4162,
  70244,
  35966,
  26397,
  16199,
  50899,
  209613,
  121702,
  287507,
  2993,
  36101,
  132229,
  67345,
  33062,
  76295,
  118628,
  78705,
  52316,
  34375,
  107083,
  107454,
  44863,
  127561,
  33964,
  3073,
  154010,
  190914,
  55967,
  39074,
  6272,
  31047,
  5550,
  41123,
  26154,
  98638,
  47110,
  19998,
  148091,
  50229,
  31329,
  59900,
  195442,
  19106,
  61347,
  73497,
  70015,
  682,
  45850,
  25776,
  38022,
  148951,
  6288,
  37411,
  232526,
  109277,
  27286,
  32342,
  9262,
  5220,
  16651,
  23175,
  46740,
  129438,
  78614,
  121925,
  66914,
  88710,
  127952,
  5563,
  21500,
  34521,
  10739,
  14863,
  191006,
  62956,
  17359,
  16749,
  67027,
  56284,
  69134,
  43301,
  35039,
  58883,
  54466,
  60823,
  404451,
  75743,
  59856,
  86979,
  7923,
  34273,
  83785,
  32142,
  7693,
  268986,
  197428,
  282681,
  17049,
  22346,
  22990,
  92245,
  107180,
  3357,
  37104,
  96724,
  49153,
  7683,
  31197,
  43267,
  82231,
  164276,
  23696,
  20848,
  188364,
  22309,
  24821,
  158707,
  1018,
  22514,
  70922,
  27792,
  45589,
  59709,
  10765,
  736,
  35218,
  63479,
  51987,
  24275,
  63588,
  55361,
  92929,
  81964,
  4658,
  20122,
  12330,
  44058,
  13065,
  311456,
  72224,
  8337,
  211229,
  38979,
  22590,
  138478,
  52757,
  32595,
  133600,
  8838,
  31549,
  94412,
  43391,
  90056,
  1585,
  94802,
  127271,
  6223,
  31889,
  137038,
  132910,
  2165,
  57616,
  230152,
  6080,
  10748,
  36737,
  74579,
  134062,
  50525,
  180532,
  119270,
  34556,
  76155,
  82394,
  52595,
  29258,
  31435,
  87820,
  67996,
  26943,
  183878,
  38007,
  2410,
  13526,
  180297,
  69856,
  3503,
  187396,
  167700,
  7838,
  16701,
  9199,
  56267,
  3661,
  37407,
  65994,
  23767,
  5708,
  62508,
  221700,
  67088,
  86978,
  46776,
  84434,
  32088,
  5612,
  9149,
  88244,
  21685,
  95151,
  46750,
  189612,
  2979,
  506311,
  2594,
  3628,
  40074,
  105039,
  78243,
  28523,
  6651,
  38058,
  71999,
  30992,
  12764,
  68261,
  108991,
  6165,
  26450,
  61961,
  13400,
  22426,
  7490,
  60890,
  109623,
  2070,
  12958,
  50355,
  67979,
  257096,
  7213,
  42578,
  52121,
  35716,
  65461,
  7516,
  124758,
  39268,
  302,
  64712,
  14977,
  1467,
  219452,
  2840,
  34229,
  11121,
  21602,
  19270,
  63574,
  8024,
  1532,
  17331,
  79839,
  78885,
  52029,
  180767,
  57957,
  6069,
  91265,
  61380,
  55767,
  8927,
  32881,
  287603,
  22149,
  35029,
  68876,
  6428,
  199567,
  46926,
  13412,
  104132,
  21434,
  366616,
  45060,
  110046,
  81924,
  128910,
  45886,
  52821,
  130416,
  29416,
  77342,
  21762,
  67329,
  121432,
  79924,
  11724,
  38625,
  81006,
  102033,
  28338,
  13326,
  3250,
  82056,
  82526,
  38212,
  21112,
  12382,
  111495,
  3263,
  7414,
  86274,
  93490,
  40844,
  30224,
  45212,
  24019,
  48411,
  71367,
  24941,
  76729,
  57776,
  3769,
  38114,
  202019,
  197745,
  31953,
  237533,
  33270,
  201580,
  255648,
  100798,
  44741,
  32241,
  98468,
  106931,
  10085,
  15090,
  170358,
  33154,
  66787,
  18819,
  69760,
  25061,
  234005,
  82660,
  6295,
  131975,
  16874,
  9076,
  4094,
  25005,
  17740,
  40908,
  19533,
  220019,
  44330,
  99792,
  50040,
  19619,
  13950,
  55228,
  24423,
  31253,
  95308,
  103177,
  184795,
  28590,
  82285,
  5059,
  3210,
  75525,
  49894,
  70007,
  56178,
  10580,
  36051,
  139681,
  21617,
  98736,
  3555,
  106306,
  164189,
  37352,
  63915,
  47824,
  24883,
  145530,
  61904,
  28444,
  11483,
  19837,
  145446,
  30420,
  112972,
  85939,
  11835,
  191233,
  2262,
  20705,
  58630,
  1753,
  148334,
  1197,
  144714,
  6887,
  11223,
  107667,
  60879,
  77914,
  4151,
  57417,
  81594,
  96681,
  169430,
  1784,
  20444,
  95138,
  254041,
  27038,
  596,
  7117,
  72808,
  13759,
  3353,
  126776,
  21074,
  55322,
  27081,
  36942,
  39547,
  139830,
  179275,
  4453,
  713,
  8722,
  71399,
  19204,
  25785,
  22794,
  23923,
  104114,
  11291,
  25458,
  102309,
  88396,
  75288,
  230440,
  206396,
  104551,
  58447,
  130857,
  37247,
  94734,
  31548,
  176529,
  226077,
  65159,
  20104,
  10096,
  66881,
  94191,
  237909,
  27109,
  37404,
  1520,
  27421,
  25220,
  113003,
  23423,
  24884,
  50585,
  6286,
  231877,
  150800,
  11789,
  3226,
  90004,
  60642,
  5053,
  202400,
  61442,
  132531,
  175329,
  57138,
  30116,
  103847,
  9973,
  75367,
  16452,
  32360,
  59119,
  21246,
  10191,
  164804,
  23305,
  61051,
  37348,
  154530,
  13214,
  5468,
  50403,
  66754,
  130976,
  50559,
  80515,
  14436,
  155492,
  84017,
  5472,
  43107,
  41240,
  2890,
  90431,
  70188,
  382,
  76234,
  48040,
  50211,
  281038,
  237007,
  32115,
  142178,
  1536,
  22761,
  96429,
  1811,
  31243,
  1679,
  49143,
  55209,
  17402,
  235054,
  61494,
  7462,
  77030,
  34925,
  87609,
  78002,
  9499,
  9027,
  73289,
  201078,
  101379,
  63544,
  27666,
  5469,
  10642,
  30029,
  49816,
  132979,
  95620,
  58086,
  351930,
  116300,
  2110,
  2043,
  30845,
  6154,
  11279,
  16727,
  4122,
  2277,
  27281,
  4971,
  3650,
  39060,
  61970,
  65951,
  39674,
  75686,
  38151,
  11370,
  130809,
  177895,
  32665,
  63725,
  122267,
  7857,
  39618,
  118483,
  44792,
  157755,
  178624,
  136994,
  24260,
  41308,
  22471,
  12404,
  21707,
  12486,
  30473,
  52781,
  50246,
  20247,
  39065,
  909,
  56825,
  103158,
  128603,
  31542,
  1089,
  41935,
  32744,
  12428,
  37963,
  84420,
  33134,
  72921,
  208449,
  42622,
  168151,
  127335,
  147107,
  46699,
  38216,
  12591,
  94342,
  85814,
  31423,
  24944,
  2605,
  87542,
  67473,
  192551,
  4496,
  56321,
  91819,
  17630,
  6300,
  256183,
  114569,
  202090,
  33209,
  35289,
  34897,
  24967,
  40520,
  43470,
  5344,
  10199,
  34810,
  14283,
  10381,
  10017,
  62923,
  49924,
  23233,
  64539,
  13051,
  35686,
  19698,
  11570,
  135555,
  120868,
  44924,
  87065,
  52318,
  52335,
  47586,
  140906,
  245885,
  109834,
  78668,
  9065,
  46990,
  25258,
  72022,
  61243,
  40838,
  4545,
  146387,
  10537,
  11557,
  17470,
  36930,
  68104,
  46711,
  24264,
  79401,
  81043,
  18225,
  120488,
  24746,
  84338,
  81652,
  28266,
  13776,
  21878,
  46973,
  1047,
  230465,
  73357,
  95777,
  24973,
  210160,
  62210,
  58404,
  110633,
  169651,
  6937,
  41870,
  9909,
  26822,
  191062,
  76553,
  27519,
  96256,
  239070,
  2478,
  205678,
  67955,
  58532,
  20601,
  50120,
  19148,
  78501,
  195724,
  110740,
  8249,
  109665,
  27446,
  30568,
  57631,
  31425,
  49752,
  32820,
  65504,
  50079,
  3663,
  102256,
  219898,
  23849,
  211315,
  14645,
  4359,
  91767,
  9528,
  12449,
  49366,
  7941,
  49763,
  107848,
  8930,
  27086,
  50686,
  9744,
  10447,
  81935,
  39513,
  46514,
  1670,
  29229,
  6172,
  22312,
  137280,
  97759,
  9806,
  14445,
  22976,
  56458,
  73391,
  34983,
  93760,
  174219,
  52573,
  33149,
  59747,
  2429,
  136277,
  75123,
  165263,
  91040,
  7446,
  57632,
  48633,
  97140,
  246081,
  84766,
  151684,
  79918,
  93268,
  120346,
  54059,
  54875,
  77858,
  32996,
  103590,
  45276,
  11968,
  19600,
  25849,
  17159,
  132907,
  42828,
  16817,
  4913,
  99462,
  103303,
  27395,
  5737,
  74184,
  20749,
  21160,
  14377,
  77062,
  131403,
  158735,
  10999,
  27799,
  77785,
  9320,
  34366,
  51593,
  61070,
  33746,
  47048,
  29268,
  36675,
  30262,
  53297,
  9832,
  82e3,
  20188,
  122292,
  39917,
  7331,
  18160,
  68301,
  185935,
  134830,
  15031,
  4935,
  10004,
  165845,
  185534,
  46923,
  30109,
  44134,
  122631,
  18874,
  22903,
  112790,
  26561,
  18549,
  348902,
  82871,
  140345,
  255565,
  135390,
  63556,
  103747,
  145055,
  179600,
  145662,
  296111,
  61661,
  211987,
  23952,
  52342,
  126343,
  48450,
  32919,
  44277,
  82185,
  9591,
  62139,
  205363,
  376969,
  394874,
  108461,
  18040,
  120885,
  14798,
  39863,
  16571,
  16794,
  58271,
  81025,
  55206,
  14640,
  118656,
  6361,
  44092,
  85970,
  6262,
  153863,
  108244,
  180200,
  72264,
  79947,
  38044,
  10050,
  5735,
  61221,
  80712,
  5471,
  115689,
  11391,
  11661,
  184257,
  20010,
  60116,
  30320,
  19327,
  134598,
  45455,
  27542,
  18004,
  125092,
  452272,
  1549,
  91523,
  46567,
  180063,
  156026,
  2608,
  11174,
  58848,
  37788,
  65907,
  80194,
  30490,
  5786,
  40775,
  119519,
  106241,
  11323,
  156297,
  8425,
  61495,
  2617,
  29675,
  2425,
  59886,
  112582,
  49142,
  59618,
  4863,
  50597,
  86710,
  50650,
  168632,
  27693,
  85641,
  83643,
  18993,
  25768,
  84284,
  28090,
  93592,
  36627,
  312804,
  43381,
  9887,
  9402,
  100931,
  97165,
  3311,
  173330,
  66805,
  28935,
  4963,
  184460,
  3201,
  78102,
  19126,
  21607,
  37496,
  24938,
  22615,
  16153,
  32862,
  134792,
  153318,
  61120,
  6067,
  2812,
  12826,
  12792,
  23825,
  37559,
  64662,
  202250,
  102694,
  155488,
  85881,
  149193,
  46233,
  65383,
  15521,
  106982,
  11358,
  176786,
  25752,
  39717,
  34208,
  24510,
  32464,
  77742,
  39371,
  72028,
  138229,
  60688,
  71386,
  102834,
  132477,
  2208,
  11548,
  63670,
  271279,
  28351,
  30338,
  38620,
  32491,
  99845,
  143885,
  152266,
  13252,
  2825,
  178663,
  108097,
  1775,
  78201,
  14897,
  113573,
  163346,
  62292,
  171129,
  22183,
  96598,
  38733,
  64971,
  166776,
  117445,
  9968,
  146393,
  44677,
  74867,
  20908,
  97328,
  12761,
  25656,
  26785,
  9148,
  112344,
  26115,
  99176,
  110121,
  22437,
  49547,
  6180,
  79320,
  5835,
  31392,
  43328,
  33377,
  75870,
  119860,
  69497,
  80273,
  7325,
  155219,
  43167,
  111173,
  28347,
  20222,
  3763,
  71752,
  55041,
  47252,
  14618,
  28088,
  15012,
  97805,
  194698,
  54636,
  2036,
  41349,
  6173,
  96604,
  61530,
  51859,
  43782,
  13361,
  24334,
  22668,
  24792,
  7070,
  23441,
  16789,
  3209,
  36211,
  208475,
  26242,
  32880,
  122181,
  182407,
  21444,
  31060,
  88459,
  29929,
  77907,
  12716,
  10934,
  97005,
  20599,
  31690,
  8403,
  58445,
  30303,
  22700,
  10336,
  86731,
  103115,
  337709,
  72556,
  46788,
  112566,
  47684,
  67089,
  53548,
  36874,
  56487,
  41387,
  125985,
  26893,
  40071,
  106683,
  73712,
  18787,
  40105,
  72992,
  67246,
  137276,
  50802,
  36790,
  70328,
  138827,
  22466,
  39263,
  183295,
  29858,
  50975,
  9322,
  57397,
  10654,
  24364,
  30383,
  55799,
  41600,
  23584,
  127295,
  296610,
  129078,
  143558,
  244131,
  86397,
  36049,
  1085,
  80677,
  3820,
  108139,
  5476,
  34767,
  24683,
  7758,
  13060,
  7239,
  131671,
  250593,
  59556,
  103392,
  29810,
  4188,
  252323,
  39404,
  116877,
  7651,
  43600,
  40338,
  13554,
  157253,
  39196,
  25978,
  144387,
  61211,
  234,
  50104,
  6129,
  10449,
  93777,
  9240,
  356378,
  274148,
  4439,
  72970,
  3724,
  147770,
  78680,
  62570,
  115877,
  40027,
  40547,
  36817,
  224392,
  64609,
  34795,
  165027,
  67440,
  2477,
  37206,
  23431,
  50754,
  164797,
  46018,
  94995,
  170982,
  27051,
  7957,
  22767,
  3674,
  27900,
  56419,
  18930,
  60701,
  41302,
  2692,
  84749,
  339721,
  61996,
  111094,
  80221,
  50129,
  1045,
  8153,
  62945,
  19202,
  8250,
  37208,
  37418,
  32560,
  79477,
  41106,
  88569,
  33963,
  36693,
  5892,
  30570,
  1581,
  66471,
  49647,
  11922,
  160717,
  29442,
  5643,
  114865,
  82962,
  95982,
  132098,
  22633,
  22838,
  94726,
  54556,
  28566,
  205039,
  162340,
  33216,
  16849,
  35847,
  221339,
  94851,
  26533,
  71469,
  1805,
  3804,
  12935,
  45483,
  71020,
  36310,
  65381,
  192960,
  34240,
  35165,
  59773,
  1248,
  46954,
  155332,
  96864,
  4246,
  388800,
  16129,
  57133,
  74592,
  44807,
  442014,
  38203,
  42574,
  80818,
  91592,
  26377,
  36424,
  65760,
  977,
  77387,
  22628,
  147610,
  28018,
  30561,
  98454,
  6969,
  119628,
  63648,
  18170,
  36854,
  26601,
  64018,
  22027,
  37279,
  51395,
  152934,
  21153,
  9430,
  58760,
  194742,
  5330,
  55115,
  34158,
  28917,
  174111,
  13171,
  122326,
  1526,
  43896,
  66094,
  25325,
  4234,
  148354,
  11450,
  275,
  18999,
  112191,
  44365,
  22723,
  68409,
  8733,
  57746,
  96565,
  75007,
  14196,
  108844,
  29475,
  88599,
  177563,
  100792,
  106156,
  86323,
  93726,
  14248,
  135341,
  194131,
  40126,
  47099,
  14779,
  8272,
  39597,
  95983,
  171398,
  65882,
  28052,
  10393,
  47213,
  40689,
  22120,
  72212,
  106829,
  34964,
  109146,
  753,
  648,
  21660,
  30047,
  17527,
  181025,
  5619,
  145357,
  4085,
  216883,
  9359,
  186951,
  24779,
  53931,
  24545,
  36197,
  223296,
  62628,
  168101,
  4243,
  107313,
  30321,
  26642,
  13049,
  51059,
  31027,
  107912,
  807,
  73550,
  26551,
  84369,
  122422,
  165872,
  49754,
  74213,
  234264,
  33151,
  52014,
  33100,
  87183,
  22365,
  52500,
  40013,
  23302,
  5652,
  72723,
  21404,
  26107,
  48434,
  587,
  94049,
  168493,
  96418,
  32871,
  70860,
  31709,
  25128,
  443,
  71597,
  166253,
  15670,
  70994,
  26341,
  133675,
  28280,
  75491,
  54756,
  47955,
  56028,
  26182,
  11952,
  113272,
  472197,
  64640,
  110753,
  17919,
  337,
  50642,
  22576,
  142,
  87371,
  53391,
  93210,
  126694,
  15285,
  19642,
  85667,
  14148,
  1506,
  42092,
  52962,
  33243,
  11970,
  20734,
  135843,
  57044,
  58880,
  13002,
  219134,
  22876,
  64754,
  232519,
  4257,
  43120,
  321573,
  24799,
  64526,
  124728,
  52579,
  81472,
  70831,
  276848,
  17403,
  74359,
  23021,
  182101,
  74597,
  23744,
  148267,
  12055,
  7976,
  5349,
  11772,
  67540,
  167347,
  65318,
  18720,
  127832,
  108238,
  22828,
  90233,
  9987,
  259080,
  118185,
  73209,
  79270,
  13775,
  90100,
  137742,
  90799,
  70569,
  15699,
  19961,
  9087,
  67475,
  57872,
  39731,
  8810,
  134897,
  131868,
  146849,
  19898,
  3334,
  2281,
  167061,
  91073,
  60356,
  467742,
  74712,
  188,
  53179,
  137679,
  92769,
  29241,
  9537,
  132595,
  80119,
  1041,
  88962,
  5976,
  40171,
  44911,
  102859,
  139059,
  104558,
  98987,
  47761,
  19272,
  71472,
  113864,
  175377,
  73338,
  10857,
  23402,
  23758,
  1591,
  139864,
  5644,
  4076,
  118760,
  16427,
  134198,
  18853,
  20291,
  100849,
  37423,
  22038,
  36677,
  19071,
  195521,
  57445,
  11069,
  31869,
  55718,
  66882,
  148490,
  44,
  41296,
  75242,
  49704,
  166810,
  9906,
  20943,
  122258,
  49112,
  105667,
  15969,
  10344,
  6408,
  187694,
  21399,
  72742,
  58970,
  14867,
  14376,
  81889,
  41856,
  23225,
  15042,
  56993,
  16074,
  131389,
  74276,
  72407,
  53875,
  383108,
  53597,
  37363,
  68993,
  44854,
  122548,
  430927,
  198279,
  38430,
  80409,
  12245,
  2981,
  628,
  2818,
  17760,
  37437,
  238229,
  7968,
  46892,
  2200,
  3730,
  34190,
  65983,
  37959,
  112291,
  87850,
  70827,
  6522,
  20750,
  73913,
  111621,
  41652,
  19587,
  2780,
  58668,
  25916,
  85259,
  18200,
  168962,
  95781,
  42445,
  102050,
  7776,
  57662,
  103313,
  47742,
  96358,
  41964,
  66174,
  100396,
  29069,
  204735,
  19679,
  27978,
  7479,
  40264,
  22534,
  61183,
  36081,
  107436,
  58223,
  14680,
  23002,
  101311,
  24716,
  124108,
  12908,
  5646,
  31750,
  40380,
  14215,
  232799,
  102772,
  14122,
  96775,
  61398,
  50917,
  12096,
  149880,
  67833,
  598749,
  124194,
  155871,
  49216,
  790,
  14677,
  65319,
  56917,
  7440,
  145744,
  95701,
  12206,
  49405,
  129269,
  76199,
  45732,
  9767,
  11058,
  9047,
  210885,
  11051,
  7392,
  26307,
  2130,
  8132,
  147526,
  20802,
  232698,
  115660,
  50060,
  59789,
  57344,
  107623,
  80343,
  112676,
  23291,
  9866,
  160971,
  34032,
  118291,
  15719,
  59730,
  164911,
  28975,
  2659,
  58046,
  78480,
  21854,
  66209,
  53863,
  109085,
  116045,
  29021,
  46481,
  107552,
  22130,
  18764,
  70254,
  31272,
  11300,
  52460,
  43933,
  84738,
  20721,
  53869,
  190840,
  79673,
  105300,
  7561,
  321817,
  66924,
  13940,
  33281,
  101046,
  183181,
  32176,
  71878,
  5678,
  62924,
  79535,
  56646,
  40303,
  19559,
  27703,
  93042,
  73368,
  42187,
  3670,
  37376,
  46440,
  7023,
  36816,
  109628,
  20680,
  5940,
  276440,
  275233,
  170848,
  112093,
  136996,
  14984,
  20226,
  111441,
  77693,
  112960,
  48577,
  39370,
  55707,
  50314,
  123404,
  26570,
  54281,
  61372,
  123391,
  4857,
  35928,
  246740,
  132507,
  106646,
  44241,
  7196,
  92258,
  9825,
  37688,
  51197,
  303141,
  5590,
  15476,
  132986,
  10955,
  85782,
  34486,
  26696,
  7991,
  28813,
  18858,
  39546,
  11703,
  11365,
  38185,
  5716,
  93555,
  11925,
  40121,
  60002,
  6985,
  10976,
  171384,
  3887,
  43394,
  13337,
  56346,
  6381,
  252336,
  39573,
  75042,
  53711,
  1028,
  31781,
  44295,
  95925,
  131713,
  7214,
  68125,
  43571,
  70954,
  213234,
  1628,
  8760,
  13391,
  65485,
  17320,
  56038,
  1710,
  25248,
  60803,
  57399,
  19839,
  3870,
  326,
  281556,
  50945,
  72400,
  21460,
  316244,
  75619,
  56246,
  98775,
  481,
  13513,
  55765,
  50427,
  7388,
  123519,
  32929,
  57908,
  27124,
  61316,
  101097,
  57467,
  30228,
  48792,
  10788,
  20402,
  37318,
  50526,
  155730,
  34456,
  158065,
  145305,
  17832,
  43733,
  64052,
  4506,
  35072,
  205355,
  177028,
  184004,
  187081,
  68616,
  35938,
  83703,
  10367,
  36892,
  93186,
  260137,
  51934,
  89970,
  4985,
  23445,
  26755,
  21558,
  7948,
  78741,
  23376,
  124405,
  85594,
  68596,
  57536,
  49351,
  12619,
  56593,
  132668,
  99924,
  109728,
  71844,
  71935,
  196018,
  65464,
  17617,
  14987,
  89701,
  143773,
  33997,
  8687,
  22701,
  33258,
  2914,
  4436,
  72108,
  85610,
  9671,
  49067,
  2327,
  82988,
  1361,
  1672,
  44033,
  35777,
  30269,
  24057,
  10605,
  82236,
  616,
  15793,
  13919,
  47249,
  112086,
  116698,
  9484,
  80207,
  90574,
  33304,
  68624,
  93127,
  56101,
  42210,
  160929,
  4827,
  38995,
  38095,
  4701,
  125119,
  5027,
  33680,
  9236,
  231236,
  14135,
  87837,
  23318,
  70261,
  78893,
  30151,
  81482,
  14332,
  1084,
  74256,
  27532,
  46644,
  79185,
  3148,
  62615,
  6981,
  55672,
  31668,
  36825,
  1849,
  14536,
  37446,
  14738,
  23779,
  43058,
  162749,
  72199,
  1168,
  21346,
  5592,
  85932,
  85302,
  9668,
  18351,
  57135,
  150360,
  2080,
  228015,
  77953,
  34670,
  119302,
  151751,
  31009,
  106725,
  84265,
  45214,
  59289,
  74178,
  113071,
  263206,
  111009,
  4021,
  44449,
  188119,
  192629,
  123592,
  392506,
  292847,
  114487,
  12831,
  205858,
  9852,
  20780,
  79648,
  75767,
  357014,
  97721,
  18166,
  21005,
  67950,
  33226,
  204009,
  16536,
  2987,
  11335,
  66717,
  144910,
  47950,
  17262,
  55060,
  15063,
  2934,
  51038,
  26775,
  178497,
  66008,
  3427,
  49433,
  128592,
  20036,
  157553,
  63861,
  3089,
  23015,
  51210,
  28696,
  35933,
  49942,
  71135,
  231518,
  99620,
  17248,
  21835,
  176536,
  20676,
  16944,
  38700,
  165831,
  233253,
  295625,
  36723,
  13023,
  52745,
  10907,
  19423,
  67972,
  125868,
  95473,
  82875,
  1183,
  108455,
  52685,
  33417,
  64095,
  21433,
  52438,
  33191,
  127809,
  44505,
  211823,
  7810,
  2752,
  95548,
  162031,
  7185,
  91196,
  47563,
  61721,
  33359,
  17897,
  23682,
  42806,
  178101,
  22874,
  49707,
  199897,
  75419,
  82456,
  8618,
  11171,
  79712,
  116847,
  18783,
  44190,
  46564,
  5346,
  59046,
  95032,
  7893,
  14916,
  3214,
  26800,
  24172,
  121453,
  34362,
  10250,
  17408,
  18888,
  4840,
  68696,
  22831,
  13162,
  36005,
  32512,
  14800,
  62357,
  41723,
  45046,
  27247,
  37486,
  5372,
  2564,
  34261,
  298500,
  66509,
  133920,
  89138,
  31305,
  117697,
  19097,
  108304,
  81386,
  84106,
  23802,
  46411,
  63304,
  946,
  51417,
  41777,
  41041,
  19501,
  115864,
  60743,
  294354,
  37955,
  94165,
  18116,
  1156,
  17937,
  20645,
  57114,
  90804,
  58042,
  48643,
  92288,
  9861,
  2557,
  88546,
  61333,
  101008,
  12853,
  5148,
  87856,
  4152,
  144503,
  73841,
  18718,
  9789,
  147565,
  10846,
  42085,
  12789,
  30223,
  8993,
  56352,
  67203,
  2448,
  28215,
  6052,
  23540,
  126319,
  75933,
  36689,
  80235,
  23231,
  23561,
  21383,
  38800,
  77548,
  102798,
  21234,
  31468,
  158608,
  46188,
  63960,
  191679,
  8051,
  67014,
  11185,
  170078,
  42186,
  28827,
  34777,
  41930,
  212079,
  12421,
  34750,
  24111,
  110344,
  73918,
  45171,
  70826,
  141949,
  40063,
  23979,
  24254,
  37309,
  26724,
  27179,
  24718,
  83648,
  54938,
  14591,
  17425,
  29525,
  102675,
  48975,
  48654,
  12316,
  8929,
  60640,
  41709,
  50168,
  63264,
  89812,
  50716,
  48632,
  38755,
  138583,
  160123,
  55579,
  71829,
  24230,
  233277,
  46322,
  39650,
  166388,
  34718,
  24108,
  98252,
  7031,
  106695,
  62498,
  18258,
  35062,
  217827,
  78731,
  34824,
  33354,
  19520,
  60852,
  2432,
  60224,
  8587,
  2836,
  62955,
  702,
  20227,
  42285,
  40560,
  95592,
  62486,
  11094,
  53035,
  143291,
  18842,
  46177,
  77994,
  1770,
  9657,
  107422,
  172915,
  32655,
  128716,
  25886,
  25164,
  156740,
  119928,
  165875,
  85817,
  11007,
  89110,
  33956,
  12652,
  65156,
  180266,
  8494,
  36889,
  19958,
  20955,
  96,
  1264,
  118288,
  135769,
  44754,
  86671,
  5632,
  19026,
  168220,
  289120,
  33569,
  93821,
  66144,
  70635,
  7687,
  5642,
  2714,
  55445,
  56636,
  71545,
  184182,
  93133,
  7332,
  37389,
  12643,
  52315,
  22729,
  11014,
  158742,
  17050,
  152889,
  50178,
  34601,
  41945,
  52136,
  9948,
  26914,
  63548,
  95721,
  115951,
  40759,
  8960,
  158258,
  38938,
  49232,
  48325,
  42234,
  81523,
  253019,
  66128,
  40978,
  20048,
  238048,
  38760,
  62928,
  122560,
  118532,
  43687,
  137472,
  163689,
  26680,
  9878,
  17448,
  51035,
  16211,
  60834,
  36749,
  29178,
  14241,
  59868,
  150086,
  2305,
  26477,
  42422,
  34342,
  165341,
  83279,
  33894,
  14257,
  29928,
  12743,
  13957,
  125571,
  89134,
  66712,
  10952,
  16507,
  147839,
  30146,
  7249,
  16565,
  45399,
  39874,
  114565,
  215780,
  31990,
  230881,
  171477,
  102,
  196546,
  44538,
  10880,
  84948,
  281705,
  86651,
  10617,
  31395,
  2342,
  453658,
  43569,
  60561,
  132901,
  21845,
  17727,
  58556,
  258242,
  22262,
  58728,
  4008,
  77997,
  11806,
  37431,
  30599,
  81375,
  109137,
  185787,
  114085,
  217292,
  97453,
  169085,
  30593,
  60212,
  11544,
  102056,
  65580,
  2384,
  91655,
  4855,
  95725,
  7295,
  157994,
  16228,
  20669,
  53276,
  141590,
  105246,
  17334,
  25440,
  76067,
  17967,
  39321,
  38911,
  11362,
  28559,
  63807,
  21627,
  26468,
  85816,
  40120,
  1025,
  15234,
  58319,
  69516,
  66512,
  124548,
  75845,
  78873,
  22137,
  46681,
  51242,
  85683,
  32909,
  76747,
  35555,
  43396,
  101465,
  1765,
  73094,
  1077,
  2962,
  39028,
  66777,
  57831,
  42048,
  15828,
  13962,
  36041,
  63657,
  52412,
  5242,
  58846,
  2141,
  5506,
  219012,
  134451,
  3936,
  182230,
  17558,
  17153,
  152237,
  22621,
  49377,
  170216,
  35257,
  68233,
  65374,
  6510,
  11126,
  212151,
  7184,
  2480,
  22517,
  3437,
  33073,
  30156,
  16557,
  3768,
  55067,
  86829,
  91e3,
  12350,
  148650,
  66017,
  79424,
  70885,
  49066,
  28250,
  21369,
  51213,
  34533,
  11510,
  3258,
  18176,
  18465,
  84413,
  6315,
  36411,
  163765,
  4346,
  356,
  107618,
  598,
  13727,
  285026,
  162695,
  8749,
  14583,
  7132,
  63521,
  184253,
  32378,
  25991,
  5604,
  30961,
  53675,
  4874,
  84693,
  5086,
  34811,
  26978,
  56564,
  7904,
  33519,
  51221,
  113942,
  69253,
  6664,
  125563,
  22055,
  220680,
  102008,
  742,
  51930,
  19494,
  176108,
  44424,
  35123,
  13025,
  75685,
  11759,
  74335,
  22250,
  181453,
  131147,
  16984,
  132115,
  154311,
  11991,
  76452,
  52609,
  85351,
  196,
  30969,
  9198,
  74919,
  2529,
  56838,
  71779,
  29187,
  116304,
  3504,
  62330,
  41190,
  86153,
  28393,
  254926,
  104228,
  105189,
  13264,
  84359,
  3574,
  12415,
  8534,
  57147,
  10175,
  188174,
  59504,
  60932,
  66318,
  16407,
  107921,
  17638,
  99103,
  49278,
  28403,
  39786,
  145865,
  8462,
  3558,
  43406,
  142271,
  29139,
  21989,
  36552,
  93955,
  72365,
  7176,
  13556,
  106185,
  37957,
  321774,
  17782,
  129017,
  51154,
  27938,
  24952,
  1935,
  39366,
  2791,
  33489,
  41582,
  56078,
  24558,
  9311,
  5449,
  218786,
  27808,
  190429,
  68013,
  36020,
  86003,
  29735,
  3404,
  87348,
  119357,
  115714,
  2324,
  86796,
  81973,
  40992,
  43376,
  93621,
  28784,
  16808,
  36367,
  2517,
  2909,
  191926,
  24978,
  55303,
  53308,
  205724,
  60068,
  3098,
  21375,
  64784,
  23949,
  26579,
  63121,
  12319,
  80145,
  39967,
  97861,
  6757,
  70143,
  67642,
  37082,
  34698,
  69140,
  122883,
  46151,
  62187,
  80934,
  429,
  19437,
  135071,
  137885,
  222647,
  13331,
  154065,
  327,
  61778,
  74257,
  40116,
  37493,
  14855,
  85079,
  237641,
  42342,
  102164,
  199965,
  71204,
  4662,
  29368,
  5042,
  113914,
  122214,
  8955,
  13149,
  102503,
  43173,
  5659,
  163787,
  69003,
  307084,
  63392,
  171080,
  21390,
  81918,
  86666,
  36622,
  24126,
  28887,
  5736,
  28054,
  207170,
  163428,
  79891,
  346467,
  95363,
  38980,
  111806,
  80828,
  9200,
  19288,
  294896,
  114468,
  87405,
  111715,
  141705,
  7015,
  72754,
  68463,
  48738,
  243147,
  33397,
  101210,
  37051,
  98801,
  82847,
  20397,
  4940,
  185559,
  18716,
  54718,
  83491,
  11725,
  40803,
  1128,
  12128,
  23060,
  5174,
  7745,
  67007,
  46701,
  1571,
  27807,
  180186,
  256996,
  18975,
  16837,
  7877,
  212758,
  250379,
  15440,
  87954,
  57755,
  24719,
  124057,
  83461,
  258,
  50864,
  8874,
  29038,
  71289,
  31627,
  15429,
  9005,
  4061,
  113851,
  107716,
  82819,
  13651,
  79656,
  117851,
  17539,
  111446,
  12938,
  39724,
  190787,
  4352,
  15402,
  21070,
  62708,
  8539,
  23777,
  73853,
  13552,
  38810,
  86117,
  16285,
  56400,
  1718,
  75342,
  142863,
  29033,
  378,
  110113,
  180321,
  32586,
  23606,
  26393,
  160984,
  207987,
  23783,
  8406,
  16904,
  24596,
  47274,
  11693,
  46539,
  60524,
  78595,
  48423,
  31718,
  20170,
  9009,
  146268,
  15183,
  191060,
  172765,
  1349,
  138436,
  37365,
  10970,
  40509,
  225817,
  20021,
  70394,
  152138,
  21541,
  66559,
  66544,
  89352,
  2725,
  17258,
  91345,
  7313,
  3815,
  115868,
  8660,
  40362,
  4071,
  103524,
  39388,
  118275,
  21950,
  6549,
  38226,
  32754,
  209574,
  29201,
  43495,
  18028,
  20296,
  40597,
  18370,
  47520,
  202450,
  24134,
  2219,
  8195,
  69545,
  38041,
  136934,
  46374,
  19041,
  159811,
  84865,
  58620,
  846,
  98749,
  13569,
  30714,
  97246,
  32186,
  4479,
  27355,
  92973,
  35214,
  151491,
  75963,
  37631,
  1561,
  27200,
  238083,
  23182,
  60756,
  12291,
  25766,
  39355,
  102333,
  87362,
  65741,
  59906,
  19538,
  201575,
  48772,
  102938,
  24438,
  292580,
  39964,
  66366,
  9004,
  61379,
  50548,
  37622,
  38732,
  28379,
  68180,
  76622,
  17488,
  69849,
  5963,
  7219,
  48143,
  43413,
  55358,
  540,
  58691,
  29506,
  19245,
  52193,
  48621,
  5518,
  13048,
  118625,
  44755,
  191081,
  42061,
  89197,
  2259,
  60665,
  66994,
  71210,
  51232,
  3585,
  142096,
  55024,
  7892,
  8345,
  58653,
  463307,
  65658,
  64319,
  137941,
  136323,
  53499,
  12746,
  43492,
  6978,
  95163,
  29925,
  60175,
  5128,
  7352,
  41463,
  184756,
  121146,
  20473,
  18426,
  4598,
  5309,
  54580,
  14277,
  121151,
  10691,
  56711,
  43880,
  63409,
  76682,
  11830,
  172218,
  264898,
  32632,
  66536,
  81062,
  31649,
  25788,
  92774,
  60222,
  11100,
  63159,
  9432,
  224657,
  25240,
  53613,
  152,
  138620,
  163829,
  2397,
  85345,
  12501,
  37507,
  64932,
  38575,
  43522,
  65789,
  80198,
  78796,
  35226,
  3851,
  108891,
  73311,
  3060,
  28391,
  93671,
  39663,
  46142,
  30982,
  66041,
  37281,
  68157,
  26553,
  71872,
  81142,
  211527,
  39747,
  118119,
  22695,
  2859,
  11066,
  20232,
  168911,
  7933,
  197005,
  17066,
  111071,
  44434,
  133994,
  120798,
  12766,
  227798,
  45756,
  132852,
  29917,
  36076,
  55352,
  65281,
  129800,
  41958,
  18944,
  84678,
  18580,
  168093,
  132621,
  39997,
  54092,
  27740,
  32354,
  3770,
  114118,
  103242,
  43918,
  15899,
  18574,
  145944,
  3190,
  123469,
  219903,
  24169,
  100571,
  62403,
  16776,
  92779,
  14535,
  17168,
  16475,
  14304,
  37231,
  1712,
  28218,
  242754,
  61688,
  28980,
  1318,
  51359,
  222657,
  99200,
  67989,
  31772,
  23932,
  35351,
  201251,
  49041,
  27306,
  19128,
  40135,
  3986,
  77333,
  19649,
  120683,
  151927,
  21081,
  7076,
  78375,
  77501,
  101599,
  8011,
  89585,
  96715,
  58179,
  5378,
  102138,
  106793,
  26051,
  217276,
  4197,
  16297,
  27014,
  46721,
  13322,
  22806,
  5278,
  29629,
  70632,
  9647,
  71519,
  58818,
  40603,
  128530,
  8903,
  36770,
  56900,
  31483,
  26935,
  43845,
  34265,
  34920,
  87658,
  6114,
  84767,
  64250,
  47318,
  50720,
  19264,
  162514,
  33357,
  13117,
  6705,
  46696,
  75032,
  71054,
  87004,
  42035,
  69138,
  11903,
  99854,
  102328,
  19611,
  34525,
  69312,
  6431,
  49842,
  101600,
  133178,
  108751,
  41829,
  89939,
  225664,
  48916,
  99556,
  9195,
  130387,
  5960,
  36857,
  116724,
  53518,
  94002,
  39077,
  53996,
  6945,
  22261,
  64291,
  8314,
  152785,
  57588,
  16522,
  9091,
  5048,
  87671,
  35441,
  39509,
  1945,
  12423,
  158923,
  178413,
  37549,
  14095,
  1475,
  73188,
  62878,
  4819,
  24012,
  68534,
  42606,
  4010,
  120809,
  57497,
  59564,
  101758,
  103718,
  32701,
  80116,
  12345,
  95834,
  46918,
  21468,
  53213,
  15665,
  31200,
  3867,
  5140,
  96013,
  250744,
  21016,
  10069,
  13968,
  35449,
  180829,
  27683,
  39704,
  59956,
  22893,
  3115,
  26293,
  32785,
  75934,
  62445,
  141162,
  62720,
  2018,
  83638,
  19949,
  114012,
  95006,
  3330,
  99829,
  130935,
  309272,
  9565,
  55874,
  121727,
  37017,
  23586,
  319858,
  40970,
  27602,
  8625,
  112329,
  61060,
  100088,
  118525,
  25922,
  16232,
  1907,
  60671,
  51583,
  44553,
  80993,
  5262,
  94679,
  8676,
  940,
  20736,
  11823,
  3020,
  16476,
  12340,
  152600,
  97416,
  3703,
  25744,
  66826,
  16245,
  16876,
  46446,
  84798,
  74227,
  176020,
  45192,
  61955,
  75496,
  23946,
  23626,
  40372,
  26036,
  6149,
  11822,
  30582,
  16541,
  41914,
  82385,
  232823,
  40921,
  80773,
  14930,
  3631,
  7517,
  39619,
  4348,
  36180,
  126106,
  138939,
  62611,
  1477,
  113512,
  47321,
  25052,
  14546,
  118881,
  29060,
  23589,
  128322,
  36795,
  18401,
  137921,
  104699,
  267929,
  36194,
  172791,
  18113,
  4766,
  188215,
  30083,
  332586,
  94089,
  5805,
  77909,
  22194,
  68234,
  154976,
  43220,
  40660,
  70001,
  184893,
  138095,
  11128,
  103010,
  22663,
  5108,
  212615,
  8485,
  5565,
  49222,
  54614,
  26530,
  42639,
  16319,
  55062,
  152662,
  105595,
  21114,
  22216,
  10294,
  68158,
  10436,
  86950,
  7206,
  62115,
  3977,
  3657,
  59874,
  456,
  118617,
  18156,
  106663,
  112229,
  80992,
  17442,
  8217,
  55551,
  5133,
  34344,
  251927,
  51153,
  39364,
  201321,
  7816,
  66803,
  23057,
  156724,
  145664,
  14276,
  95705,
  979,
  2796,
  6875,
  13429,
  212525,
  50602,
  26276,
  28284,
  3424,
  19465,
  52397,
  46963,
  31420,
  51399,
  206476,
  92317,
  48851,
  637,
  100820,
  83349,
  10317,
  60227,
  21972,
  6908,
  282439,
  32857,
  224767,
  95629,
  83882,
  42106,
  87338,
  69757,
  29840,
  68709,
  37665,
  45244,
  114577,
  49188,
  175943,
  54009,
  186746,
  106158,
  70168,
  3358,
  234002,
  50555,
  9221,
  129338,
  9562,
  20118,
  32923,
  78479,
  118280,
  65752,
  4977,
  10474,
  102174,
  60947,
  129006,
  10570,
  83451,
  8598,
  8078,
  159367,
  123785,
  80438,
  16742,
  5905,
  5281,
  181513,
  42402,
  6977,
  163136,
  93179,
  42191,
  14968,
  50421,
  112401,
  105440,
  33456,
  57347,
  121611,
  4221,
  94954,
  36517,
  24046,
  27796,
  6255,
  33394,
  72990,
  135408,
  116627,
  1233,
  57874,
  25654,
  95419,
  68156,
  401399,
  313338,
  55208,
  45573,
  93124,
  119251,
  47200,
  38196,
  11909,
  130667,
  45391,
  73904,
  64964,
  167846,
  4137,
  115606,
  52036,
  62214,
  7969,
  160925,
  7187,
  1132,
  134835,
  40309,
  73195,
  64494,
  80472,
  444841,
  61111,
  26500,
  45323,
  40743,
  53625,
  52797,
  22659,
  15631,
  29739,
  36706,
  28841,
  39147,
  102836,
  26794,
  10536,
  14845,
  87305,
  45874,
  12241,
  127587,
  83833,
  57183,
  79722,
  30844,
  41304,
  84655,
  20825,
  92500,
  3722,
  25655,
  27811,
  10157,
  81634,
  31362,
  34088,
  92487,
  70123,
  22190,
  185100,
  72658,
  139035,
  192523,
  88241,
  2078,
  230490,
  44528,
  85638,
  100198,
  22088,
  29982,
  291233,
  241062,
  13865,
  4445,
  137791,
  37835,
  107218,
  31726,
  19718,
  38234,
  72528,
  23046,
  19177,
  66695,
  5109,
  17251,
  28077,
  5617,
  21554,
  47839,
  72425,
  133825,
  1486,
  73065,
  181275,
  141508,
  21768,
  62971,
  63082,
  2512,
  34200,
  9904,
  120309,
  6392,
  91243,
  68416,
  268253,
  41199,
  116757,
  138551,
  185526,
  41246,
  28986,
  4093,
  19057,
  17295,
  4148,
  245766,
  122360,
  35356,
  112075,
  20301,
  75441,
  10998,
  7977,
  19769,
  62922,
  937,
  63547,
  100196,
  26427,
  157820,
  20983,
  236696,
  22935,
  8140,
  90315,
  156004,
  47204,
  140973,
  7726,
  45097,
  52725,
  22636,
  23436,
  257282,
  105247,
  522,
  88389,
  216031,
  202204,
  46812,
  211666,
  19693,
  68828,
  81691,
  45925,
  11256,
  30292,
  372,
  5236,
  167826,
  88328,
  232776,
  151611,
  5360,
  82104,
  18841,
  80393,
  25465,
  18285,
  20320,
  72377,
  31730,
  33160,
  45803,
  38715,
  27705,
  37379,
  24163,
  18360,
  103586,
  4015,
  32305,
  269494,
  91252,
  20080,
  36567,
  54650,
  7797,
  57073,
  12650,
  31164,
  42209,
  6375,
  261663,
  105528,
  81661,
  106002,
  2800,
  5375,
  17247,
  43151,
  4442,
  15727,
  194619,
  100855,
  144898,
  62320,
  78465,
  39929,
  16454,
  1967,
  28311,
  61363,
  17219,
  9395,
  8745,
  121445,
  76939,
  80385,
  162380,
  22009,
  54191,
  44248,
  16299,
  122830,
  48151,
  74429,
  78291,
  64755,
  14238,
  44966,
  2511,
  17712,
  67954,
  93583,
  829,
  105899,
  49935,
  84750,
  11591,
  33185,
  85447,
  42717,
  27409,
  208542,
  28965,
  62052,
  52525,
  5597,
  25694,
  65594,
  16343,
  63224,
  276188,
  12475,
  9331,
  127507,
  38522,
  57287,
  24128,
  133161,
  79723,
  105548,
  133695,
  48917,
  27558,
  43278,
  46520,
  13778,
  141954,
  110785,
  83366,
  17715,
  46317,
  105763,
  66298,
  147013,
  41086,
  94180,
  16478,
  220447,
  44611,
  730,
  19722,
  78975,
  117889,
  125643,
  26254,
  16574,
  18480,
  65006,
  15806,
  38549,
  246418,
  46052,
  36056,
  8440,
  34984,
  30170,
  3163,
  59800,
  4458,
  115442,
  4283,
  41970,
  33507,
  104078,
  1653,
  22,
  121158,
  276486,
  3655,
  6338,
  24048,
  133421,
  23641,
  2161,
  24422,
  36006,
  8086,
  10675,
  181474,
  12307,
  29514,
  59143,
  14729,
  52509,
  87128,
  122470,
  19446,
  80852,
  33314,
  24573,
  119864,
  14237,
  9652,
  57779,
  6612,
  51851,
  15284,
  98871,
  90581,
  124466,
  156831,
  21190,
  22015,
  71380,
  161906,
  87247,
  69201,
  18392,
  17908,
  108470,
  72962,
  40719,
  14338,
  17911,
  95260,
  43339,
  20610,
  78916,
  20710,
  72451,
  11315,
  31448,
  17263,
  58853,
  178878,
  48111,
  116002,
  45497,
  80506,
  82605,
  85880,
  36300,
  121755,
  25215,
  36118,
  301929,
  88728,
  405223,
  276136,
  553,
  34704,
  212438,
  49970,
  78329,
  922,
  20711,
  25036,
  257130,
  38295,
  145369,
  18128,
  15385,
  30829,
  55656,
  48345,
  8012,
  3561,
  28004,
  122041,
  192900,
  58338,
  112508,
  41085,
  29976,
  87040,
  47117,
  23905,
  4336,
  92061,
  138880,
  97407,
  42083,
  172121,
  6256,
  25192,
  172671,
  5,
  93568,
  1420,
  12677,
  31605,
  56743,
  40620,
  6015,
  78415,
  231077,
  31298,
  80026,
  13902,
  19048,
  24924,
  170586,
  32955,
  176119,
  87859,
  36731,
  6773,
  27711,
  24658,
  26475,
  115216,
  133207,
  93250,
  95820,
  88522,
  8317,
  5714,
  124047,
  55219,
  86860,
  19677,
  23961,
  22928,
  162209,
  8904,
  225992,
  359835,
  56084,
  96201,
  29392,
  96558,
  86071,
  93643,
  55114,
  13347,
  8183,
  95129,
  82012,
  2017,
  123336,
  34219,
  115554,
  157159,
  47747,
  101684,
  41008,
  18735,
  193781,
  104151,
  226906,
  7552,
  179874,
  124113,
  31159,
  21162,
  44010,
  14771,
  51268,
  166128,
  31382,
  73124,
  77438,
  92830,
  205709,
  12113,
  1292,
  38937,
  13114,
  1334,
  2118,
  15597,
  69581,
  14449,
  21934,
  76618,
  48728,
  67038,
  14967,
  51495,
  24243,
  87736,
  147249,
  26720,
  11119,
  46063,
  43749,
  5843,
  44147,
  152629,
  133428,
  65703,
  14269,
  45604,
  57982,
  28672,
  55616,
  45957,
  8438,
  95433,
  37698,
  220862,
  132034,
  39456,
  61870,
  4161,
  26501,
  73560,
  56418,
  9845,
  4654,
  20916,
  10456,
  88920,
  119358,
  9015,
  65931,
  96507,
  48029,
  38534,
  21676,
  109081,
  43078,
  34943,
  25089,
  6131,
  28766,
  23665,
  5477,
  10255,
  16695,
  67,
  45778,
  42443,
  42770,
  29534,
  23733,
  100513,
  62617,
  42630,
  48746,
  14191,
  43753,
  50295,
  26007,
  8792,
  57243,
  43119,
  54725,
  164253,
  58250,
  112304,
  131796,
  25165,
  4651,
  3188,
  24831,
  47748,
  3705,
  19540,
  13211,
  102095,
  5593,
  18699,
  23666,
  32005,
  117571,
  33541,
  60584,
  74573,
  86311,
  99443,
  25172,
  27222,
  168938,
  7143,
  11853,
  53560,
  18834,
  19960,
  86522,
  28217,
  53266,
  117700,
  72989,
  34323,
  18721,
  66450,
  34346,
  74056,
  47217,
  202002,
  46269,
  9429,
  68582,
  75458,
  37823,
  82843,
  96652,
  32549,
  145144,
  27958,
  19820,
  158086,
  31955,
  201406,
  135379,
  31207,
  192545,
  12950,
  51704,
  9094,
  248263,
  76147,
  64028,
  110009,
  79407,
  89345,
  99284,
  223492,
  47966,
  26848,
  15359,
  201137,
  2861,
  110507,
  71231,
  72297,
  31851,
  118777,
  71039,
  151051,
  240855,
  16333,
  50766,
  14727,
  7939,
  4149,
  80908,
  418780,
  88378,
  59276,
  1327,
  7284,
  38576,
  79814,
  65820,
  42199,
  84860,
  49574,
  62596,
  12396,
  70598,
  40117,
  8648,
  7994,
  16836,
  7630,
  14047,
  359699,
  106878,
  525,
  29037,
  28064,
  13380,
  11675,
  50669,
  74216,
  103539,
  180314,
  27449,
  56299,
  172344,
  19274,
  7301,
  246099,
  32043,
  19422,
  36506,
  129317,
  6806,
  30140,
  4614,
  46639,
  66926,
  932,
  86600,
  6322,
  27847,
  233103,
  10541,
  39025,
  34887,
  3517,
  12972,
  26220,
  2031,
  66561,
  115015,
  48658,
  47596,
  12714,
  33845,
  3893,
  16165,
  35237,
  89983,
  14769,
  11962,
  147224,
  47018,
  29977,
  27979,
  5552,
  82338,
  86023,
  131368,
  1218,
  24853,
  237840,
  132193,
  15455,
  40873,
  3668,
  65351,
  53388,
  15229,
  59889,
  272245,
  47934,
  11858,
  34347,
  18038,
  90853,
  86981,
  300602,
  19343,
  114181,
  29362,
  84921,
  6095,
  106059,
  79472,
  38015,
  1206,
  48741,
  6208,
  8e4,
  21916,
  17423,
  6002,
  108083,
  24479,
  34931,
  56661,
  9511,
  26995,
  100694,
  163853,
  35997,
  81254,
  58321,
  18919,
  171890,
  86877,
  91341,
  74503,
  70477,
  53412,
  7027,
  59281,
  39892,
  131302,
  5864,
  15947,
  61301,
  67466,
  162369,
  47956,
  27874,
  35624,
  282324,
  21270,
  111847,
  102548,
  41482,
  30955,
  116737,
  28264,
  8592,
  55458,
  22301,
  75090,
  29821,
  30697,
  51709,
  3041,
  19208,
  8038,
  24634,
  30467,
  87509,
  126428,
  19389,
  18814,
  152686,
  20701,
  83474,
  45832,
  80891,
  105808,
  11378,
  153223,
  120770,
  98186,
  150633,
  49838,
  9141,
  12755,
  30962,
  5260,
  74490,
  21256,
  31678,
  65062,
  33326,
  289838,
  187831,
  20595,
  89768,
  2805,
  58535,
  10844,
  70085,
  12090,
  2451,
  138068,
  98544,
  24461,
  4511,
  6754,
  41684,
  28203,
  3383,
  65355,
  82833,
  30161,
  83924,
  234361,
  128424,
  28921,
  222594,
  33975,
  125491,
  34069,
  11508,
  67464,
  144226,
  41850,
  98703,
  34371,
  7901,
  21254,
  38398,
  65651,
  23549,
  53883,
  213340,
  123269,
  12028,
  71764,
  177701,
  28758,
  2623,
  68395,
  11549,
  15232,
  68603,
  9660,
  63116,
  36079,
  57093,
  31198,
  20475,
  48467,
  89984,
  35619,
  186847,
  107469,
  31389,
  43631,
  73867,
  41949,
  68841,
  114250,
  1605,
  30564,
  63403,
  17588,
  27680,
  99533,
  12641,
  70325,
  50428,
  73426,
  78379,
  11855,
  91651,
  72081,
  91720,
  60198,
  15743,
  12065,
  83398,
  140046,
  6761,
  46598,
  45900,
  5068,
  886,
  62448,
  148968,
  37347,
  19405,
  9680,
  15819,
  43496,
  63370,
  75667,
  163700,
  37639,
  3633,
  22774,
  34341,
  183131,
  134335,
  37200,
  23915,
  7054,
  14194,
  12970,
  26438,
  13350,
  285521,
  25594,
  8219,
  104410,
  91039,
  168804,
  138480,
  149734,
  15907,
  33818,
  61132,
  60082,
  4622,
  110187,
  56736,
  13551,
  73571,
  3945,
  73463,
  65498,
  17758,
  263266,
  17593,
  2710,
  27585,
  54469,
  38200,
  45367,
  63754,
  28881,
  3473,
  12791,
  98287,
  31895,
  65787,
  4463,
  94536,
  24951,
  36332,
  59901,
  28803,
  52130,
  86403,
  7668,
  181822,
  74831,
  18977,
  9850,
  177206,
  145485,
  109798,
  7292,
  31421,
  26280,
  77211,
  58511,
  12507,
  127004,
  11113,
  147,
  8729,
  56208,
  43066,
  79926,
  129937,
  31345,
  83947,
  39915,
  46146,
  98763,
  42566,
  1337,
  13192,
  18323,
  105163,
  80570,
  117753,
  16555,
  72883,
  11077,
  159438,
  40764,
  70933,
  83329,
  26066,
  12276,
  72059,
  21655,
  173836,
  126713,
  69454,
  153482,
  91585,
  70644,
  102558,
  110483,
  6764,
  127864,
  190133,
  3961,
  101798,
  20945,
  71138,
  82402,
  90884,
  69669,
  44753,
  923,
  16939,
  59700,
  164258,
  25969,
  27082,
  31399,
  43846,
  6306,
  246093,
  51342,
  6153,
  151581,
  202801,
  182731,
  56475,
  162188,
  89426,
  141356,
  14355,
  121815,
  27536,
  28023,
  65257,
  77523,
  106668,
  127314,
  24947,
  12790,
  38796,
  169698,
  23555,
  10725,
  44573,
  183083,
  42088,
  62716,
  43265,
  105958,
  32050,
  44067,
  50118,
  1668,
  3874,
  6243,
  318411,
  16599,
  1691,
  94999,
  52378,
  28671,
  216728,
  123258,
  2059,
  34969,
  69225,
  5913,
  136280,
  171443,
  141515,
  91662,
  22175,
  135282,
  80020,
  92270,
  1663,
  4808,
  4482,
  3495,
  34691,
  5226,
  109830,
  108512,
  17342,
  107488,
  11606,
  123190,
  100247,
  29666,
  146527,
  113014,
  15794,
  30894,
  13224,
  39585,
  243192,
  22351,
  9903,
  7836,
  47699,
  11078,
  25468,
  122291,
  48821,
  26780,
  122679,
  75521,
  81450,
  630,
  4895,
  92900,
  55074,
  74293,
  17441,
  3563,
  111657,
  103102,
  51613,
  12318,
  52370,
  36191,
  68245,
  34269,
  40445,
  41354,
  122901,
  168604,
  182500,
  62012,
  42557,
  11259,
  24428,
  115113,
  86345,
  12362,
  3909,
  78430,
  86852,
  134602,
  20459,
  47853,
  93879,
  22577,
  7659,
  3688,
  38555,
  13349,
  17381,
  56715,
  91639,
  12493,
  10895,
  92438,
  3142,
  37057,
  28928,
  2004,
  36427,
  32268,
  34222,
  209974,
  10432,
  67436,
  41989,
  173518,
  107930,
  27079,
  62729,
  30908,
  55558,
  5828,
  45031,
  14902,
  53546,
  8204,
  144263,
  60255,
  14520,
  88212,
  86582,
  109589,
  69356,
  8064,
  47449,
  8505,
  66558,
  16886,
  4844,
  52817,
  111260,
  215129,
  12941,
  91118,
  650,
  20770,
  6273,
  73089,
  40618,
  62790,
  2873,
  35002,
  14023,
  97208,
  19386,
  102646,
  36993,
  143736,
  135457,
  35385,
  113601,
  17893,
  32627,
  84439,
  100619,
  56016,
  6581,
  57264,
  172160,
  45452,
  111710,
  203627,
  70131,
  24100,
  322787,
  1996,
  35665,
  70078,
  22358,
  90922,
  83658,
  4097,
  63200,
  58499,
  14542,
  99153,
  52159,
  6615,
  12414,
  63415,
  31986,
  16823,
  1579,
  65405,
  137809,
  8841,
  16898,
  48082,
  259,
  33014,
  42375,
  12260,
  179850,
  73667,
  91389,
  98882,
  29532,
  17311,
  326251,
  41092,
  5928,
  20742,
  44964,
  48019,
  43505,
  9317,
  49265,
  6643,
  192712,
  48424,
  163487,
  19861,
  20113,
  70848,
  31928,
  105333,
  23685,
  78563,
  14638,
  54755,
  7158,
  24142,
  44018,
  20774,
  125255,
  20331,
  24280,
  10163,
  1285,
  2336,
  39851,
  4299,
  117269,
  46714,
  63816,
  87779,
  159624,
  11731,
  9971,
  990,
  137317,
  108831,
  50994,
  74554,
  162680,
  23640,
  131597,
  146962,
  170620,
  34829,
  91205,
  21184,
  1913,
  63616,
  18427,
  93136,
  156592,
  17519,
  67565,
  115882,
  138220,
  78622,
  88535,
  18115,
  2711,
  33554,
  109492,
  54298,
  971,
  24914,
  25863,
  36363,
  45715,
  27099,
  194995,
  14299,
  178181,
  111488,
  72395,
  322385,
  157719,
  130787,
  11897,
  81843,
  83999,
  11369,
  49280,
  118604,
  40922,
  61332,
  110343,
  53407,
  75639,
  40582,
  300440,
  54722,
  25637,
  13694,
  48248,
  48278,
  194521,
  56203,
  52779,
  48783,
  72627,
  10953,
  376,
  16733,
  280238,
  26351,
  230789,
  15132,
  25168,
  137270,
  3588,
  63704,
  73376,
  94031,
  74284,
  19443,
  159557,
  9697,
  39901,
  13351,
  119050,
  15406,
  146455,
  3460,
  29556,
  75195,
  37673,
  102524,
  92329,
  47289,
  98413,
  15311,
  100684,
  56345,
  7116,
  95480,
  11590,
  7200,
  167,
  23610,
  58426,
  17730,
  136656,
  27944,
  53151,
  2701,
  8824,
  103124,
  3017,
  90744,
  113588,
  53216,
  79736,
  65940,
  26931,
  498,
  29568,
  80540,
  143543,
  21292,
  1740,
  59268,
  16561,
  180816,
  42323,
  50174,
  40890,
  52866,
  10703,
  57169,
  4700,
  17191,
  4424,
  93511,
  49698,
  166650,
  26972,
  48631,
  165169,
  82879,
  69326,
  202970,
  4007,
  2376,
  231325,
  139592,
  22119,
  62851,
  37504,
  68816,
  58345,
  67398,
  186643,
  43331,
  277416,
  53749,
  15746,
  23102,
  17432,
  4793,
  151138,
  48822,
  54265,
  48203,
  198688,
  14305,
  54287,
  2291,
  18018,
  113378,
  123260,
  7180,
  97549,
  87027,
  120085,
  2920,
  76080,
  8190,
  102005,
  5641,
  64580,
  14955,
  59802,
  54028,
  58884,
  19367,
  81779,
  412567,
  85957,
  97053,
  103637,
  78871,
  29364,
  27637,
  141728,
  4767,
  30686,
  112738,
  130146,
  42745,
  12730,
  105040,
  14844,
  232,
  210944,
  36581,
  152317,
  135543,
  29744,
  3129,
  55647,
  58149,
  46319,
  27265,
  17499,
  28005,
  59948,
  7170,
  34138,
  5702,
  293047,
  110892,
  408,
  91760,
  218674,
  18469,
  46095,
  81403,
  14389,
  4610,
  35672,
  73060,
  11006,
  74848,
  104820,
  118143,
  190357,
  20043,
  105358,
  141735,
  5115,
  27093,
  45924,
  123073,
  52599,
  29433,
  9616,
  238350,
  78610,
  24851,
  58858,
  26769,
  31969,
  24613,
  18294,
  4982,
  32735,
  39639,
  143563,
  112073,
  202205,
  12567,
  4873,
  88601,
  44897,
  81503,
  101648,
  81362,
  34662,
  85277,
  17574,
  48173,
  21435,
  221188,
  40215,
  39576,
  80786,
  26544,
  64668,
  81841,
  10731,
  37733,
  247986,
  149188,
  127703,
  495,
  18382,
  54388,
  72446,
  43071,
  30974,
  198723,
  89608,
  41360,
  190,
  33045,
  8386,
  31658,
  19992,
  237838,
  119015,
  137622,
  50890,
  100913,
  6460,
  116233,
  267230,
  26621,
  104129,
  65114,
  14190,
  41542,
  14888,
  85962,
  23342,
  23041,
  26453,
  43725,
  71809,
  45186,
  4770,
  46452,
  53894,
  56616,
  221286,
  18973,
  9038,
  109299,
  55365,
  19366,
  26863,
  18808,
  60909,
  69353,
  41738,
  83463,
  12100,
  68561,
  72860,
  3980,
  13796,
  49340,
  12332,
  31311,
  27418,
  4255,
  53430,
  18976,
  45523,
  510,
  14224,
  30477,
  26581,
  4530,
  3651,
  101663,
  139840,
  22709,
  150861,
  31996,
  63923,
  120623,
  262522,
  3076,
  10528,
  2929,
  14672,
  130238,
  18087,
  9816,
  121894,
  100308,
  25085,
  55111,
  14565,
  18952,
  53293,
  2042,
  369988,
  23674,
  61789,
  133529,
  28783,
  108293,
  35477,
  47119,
  36448,
  71049,
  40015,
  33055,
  78598,
  198442,
  1833,
  159937,
  40654,
  77444,
  189245,
  113153,
  8621,
  18599,
  38553,
  35223,
  166072,
  2375,
  11659,
  21786,
  89523,
  6032,
  12116,
  63046,
  159398,
  18454,
  3678,
  32521,
  47626,
  11411,
  103527,
  38896,
  42946,
  15696,
  26370,
  10185,
  8413,
  37080,
  165583,
  4331,
  63555,
  14907,
  72220,
  50056,
  6623,
  62236,
  36565,
  49783,
  10049,
  17503,
  100581,
  55951,
  146244,
  24724,
  9626,
  17969,
  25524,
  109300,
  173965,
  99994,
  101056,
  46459,
  43647,
  53737,
  277968,
  8347,
  123521,
  74858,
  33829,
  44762,
  77574,
  877,
  81377,
  222525,
  123532,
  30602,
  43881,
  53145,
  2973,
  16284,
  81940,
  61281,
  127044,
  63620,
  9875,
  14756,
  114829,
  19032,
  9202,
  52759,
  119141,
  23928,
  120551,
  19607,
  3599,
  33401,
  76821,
  73233,
  117430,
  39968,
  36539,
  7071,
  5446,
  121735,
  194059,
  15206,
  45283,
  6706,
  15603,
  65615,
  1207,
  165723,
  92275,
  34773,
  104447,
  8396,
  32353,
  205240,
  164323,
  13600,
  60555,
  79205,
  25532,
  22907,
  33410,
  57480,
  107111,
  69630,
  32137,
  47832,
  70913,
  33161,
  20321,
  2371,
  117348,
  10714,
  86246,
  1625,
  11763,
  17900,
  268,
  78457,
  99175,
  97940,
  101092,
  86660,
  32221,
  14041,
  128504,
  125080,
  53744,
  124263,
  31017,
  13897,
  403,
  31859,
  21964,
  5633,
  111630,
  5547,
  77329,
  17961,
  18241,
  84995,
  25984,
  12983,
  67491,
  62168,
  47262,
  5241,
  297,
  51191,
  7351,
  8967,
  147212,
  82060,
  16821,
  782,
  11033,
  82431,
  62957,
  5026,
  43459,
  77963,
  203477,
  53528,
  6247,
  191852,
  87774,
  74164,
  215654,
  13467,
  1522,
  219964,
  28589,
  244104,
  16242,
  117821,
  67725,
  72570,
  156792,
  17186,
  15979,
  26990,
  44128,
  193014,
  35276,
  57125,
  16212,
  166451,
  68017,
  6905,
  77608,
  16364,
  53777,
  75921,
  76426,
  37975,
  26203,
  269296,
  64099,
  84122,
  12077,
  38533,
  830,
  4407,
  20139,
  963,
  43028,
  38902,
  42911,
  37503,
  83343,
  85045,
  16979,
  1165,
  60835,
  137387,
  58380,
  86990,
  110066,
  134540,
  56331,
  193845,
  81238,
  17922,
  163093,
  38744,
  110641,
  12502,
  56404,
  34862,
  26865,
  125964,
  12965,
  111648,
  25547,
  7771,
  27196,
  136980,
  9555,
  29551,
  107158,
  57885,
  18831,
  37705,
  35505,
  101742,
  13970,
  102109,
  62548,
  124657,
  23328,
  11124,
  89592,
  146376,
  248050,
  6241,
  22033,
  18337,
  80685,
  29898,
  11908,
  216623,
  67721,
  106162,
  146610,
  21377,
  15085,
  91552,
  42041,
  62560,
  122532,
  125336,
  102365,
  121537,
  142559,
  29693,
  223919,
  11515,
  110495,
  18776,
  22494,
  5895,
  185059,
  103592,
  229351,
  51220,
  100102,
  37027,
  257855,
  29359,
  54123,
  36066,
  106493,
  12244,
  79258,
  32002,
  432,
  56205,
  94836,
  90182,
  6726,
  14762,
  29391,
  48938,
  26864,
  38083,
  60364,
  3310,
  60192,
  14766,
  205567,
  57504,
  110760,
  22649,
  24666,
  46333,
  21517,
  3430,
  13135,
  28873,
  27052,
  158809,
  11597,
  20529,
  6695,
  23138,
  22960,
  37137,
  45574,
  6545,
  305877,
  43423,
  26153,
  24769,
  59844,
  14501,
  10430,
  134352,
  56169,
  13213,
  103432,
  49523,
  35181,
  13435,
  12408,
  129475,
  64620,
  230854,
  77390,
  51990,
  15653,
  83248,
  33466,
  44571,
  117828,
  51481,
  2187,
  10559,
  68019,
  18021,
  54895,
  48247,
  18354,
  33737,
  4554,
  108595,
  37288,
  39767,
  116707,
  9175,
  3726,
  108877,
  21616,
  83684,
  49862,
  1938,
  8543,
  276466,
  20134,
  108498,
  48770,
  102254,
  31914,
  131520,
  185291,
  100559,
  51890,
  209,
  19526,
  76471,
  50544,
  71814,
  99351,
  8172,
  198526,
  28816,
  20419,
  9109,
  98389,
  136777,
  76479,
  75596,
  30635,
  165417,
  48216,
  120220,
  25955,
  211071,
  39314,
  24308,
  32164,
  2559,
  146280,
  43403,
  9233,
  17947,
  90585,
  1786,
  86920,
  125662,
  2457,
  64741,
  32152,
  32918,
  122882,
  78538,
  44001,
  31723,
  56426,
  23375,
  103172,
  88177,
  145697,
  52506,
  49319,
  68016,
  31664,
  41488,
  18486,
  110400,
  7030,
  28241,
  986,
  109199,
  19900,
  42147,
  56864,
  65287,
  49183,
  7858,
  24e3,
  30453,
  840,
  16673,
  25907,
  68916,
  89927,
  6309,
  158335,
  36407,
  199737,
  130464,
  13137,
  59603,
  201778,
  195292,
  21015,
  42466,
  179062,
  172561,
  89492,
  11075,
  180407,
  31868,
  72493,
  20998,
  60217,
  9865,
  19530,
  39274,
  130266,
  54539,
  21623,
  12535,
  13505,
  40641,
  73375,
  4087,
  85633,
  2153,
  3117,
  70680,
  55788,
  92096,
  47509,
  98493,
  37490,
  271936,
  151475,
  3032,
  16171,
  96642,
  34106,
  78425,
  125761,
  19591,
  3366,
  19316,
  54508,
  24183,
  50786,
  194248,
  91528,
  33253,
  34622,
  108355,
  41741,
  705,
  3814,
  3883,
  108929,
  13203,
  67831,
  10142,
  59754,
  68208,
  29128,
  84820,
  56880,
  38794,
  24972,
  48571,
  40821,
  40476,
  18137,
  164254,
  24064,
  236309,
  79181,
  11282,
  395,
  39169,
  2013,
  51587,
  28551,
  9645,
  701,
  109513,
  115899,
  113566,
  12762,
  62045,
  58322,
  103726,
  41343,
  40866,
  244102,
  143816,
  2490,
  70346,
  40973,
  52618,
  15412,
  30720,
  104315,
  38917,
  42027,
  93676,
  17513,
  107418,
  20706,
  123890,
  13399,
  97727,
  24044,
  87962,
  65606,
  44250,
  98044,
  65276,
  74790,
  101473,
  19350,
  91570,
  1326,
  87790,
  172042,
  7577,
  100813,
  86896,
  85891,
  41512,
  108130,
  27794,
  14875,
  71431,
  12835,
  156250,
  58135,
  3759,
  22476,
  42176,
  115873,
  34686,
  56523,
  73643,
  108505,
  51491,
  20838,
  12721,
  32863,
  45700,
  29496,
  13700,
  34294,
  55360,
  29206,
  155942,
  123812,
  7706,
  163234,
  203,
  132720,
  49358,
  144431,
  8130,
  175788,
  35818,
  3270,
  76832,
  25710,
  54095,
  97274,
  28779,
  94621,
  74396,
  19092,
  128242,
  58067,
  20885,
  14670,
  93255,
  15107,
  63291,
  23654,
  126900,
  129421,
  59294,
  262659,
  9798,
  3251,
  67344,
  28600,
  44629,
  50672,
  29072,
  26999,
  31526,
  23183,
  49175,
  165843,
  175455,
  17282,
  175411,
  32022,
  45989,
  30298,
  90690,
  78118,
  83156,
  23749,
  35636,
  31317,
  7069,
  80381,
  94561,
  133756,
  14960,
  97404,
  6138,
  41065,
  78041,
  32843,
  16601,
  34123,
  9559,
  146529,
  123377,
  96395,
  54441,
  42012,
  84257,
  123541,
  10745,
  22139,
  106459,
  11720,
  150883,
  172651,
  154996,
  110538,
  4728,
  53447,
  25704,
  2009,
  71152,
  119354,
  21166,
  66604,
  1429,
  216162,
  8637,
  122250,
  63520,
  27180,
  29172,
  36124,
  276428,
  107787,
  77184,
  4680,
  14952,
  104903,
  24418,
  14793,
  51561,
  52931,
  8371,
  26342,
  48526,
  7118,
  92066,
  67280,
  40653,
  8847,
  34597,
  105438,
  14198,
  50163,
  61188,
  146286,
  50315,
  41205,
  170829,
  161496,
  585,
  197359,
  95056,
  1687,
  365794,
  91349,
  48507,
  5804,
  49263,
  5146,
  104902,
  96365,
  117343,
  132222,
  46084,
  96919,
  16875,
  8073,
  262381,
  79982,
  52663,
  13928,
  16056,
  153908,
  15145,
  109256,
  132308,
  18763,
  24904,
  167644,
  13618,
  40750,
  18686,
  147124,
  114709,
  150038,
  52849,
  2938,
  12568,
  48617,
  8778,
  5459,
  44202,
  44591,
  74914,
  17183,
  248689,
  13878,
  7822,
  80060,
  23116,
  194037,
  18487,
  2067,
  7798,
  43077,
  33678,
  244028,
  31320,
  74273,
  2794,
  19466,
  8218,
  36280,
  183997,
  48124,
  19416,
  29656,
  19280,
  98734,
  7715,
  18311,
  30701,
  133602,
  150307,
  126956,
  7378,
  2933,
  79903,
  13178,
  12593,
  86571,
  26604,
  92446,
  13574,
  44205,
  65699,
  427599,
  21118,
  8245,
  14407,
  27877,
  47936,
  33542,
  7916,
  26460,
  117762,
  21596,
  37818,
  2249,
  127359,
  209394,
  60044,
  47677,
  308089,
  36791,
  154971,
  31417,
  6998,
  150042,
  174360,
  12255,
  43009,
  29335,
  48739,
  3912,
  101398,
  53340,
  2580,
  146939,
  151295,
  45360,
  125275,
  15273,
  45383,
  27456,
  48761,
  23314,
  8750,
  60801,
  85823,
  104759,
  27894,
  123685,
  66968,
  39480,
  26917,
  55290,
  83305,
  2696,
  98390,
  57569,
  145853,
  340733,
  4919,
  20024,
  52268,
  30884,
  7413,
  203685,
  70989,
  112855,
  4129,
  50536,
  349518,
  68205,
  332641,
  159581,
  135361,
  236026,
  37563,
  176404,
  64899,
  6578,
  122033,
  63871,
  1850,
  85234,
  82089,
  66124,
  74145,
  121098,
  107351,
  12687,
  36881,
  117334,
  13136,
  14698,
  85933,
  93866,
  18047,
  32620,
  310,
  15094,
  46e3,
  88451,
  23632,
  36645,
  27940,
  87618,
  80520,
  58892,
  20976,
  27702,
  140090,
  96075,
  67841,
  103292,
  238964,
  87778,
  107338,
  17019,
  83427,
  67522,
  7302,
  8261,
  47570,
  116787,
  8730,
  80484,
  61772,
  174422,
  56005,
  131193,
  52875,
  14588,
  28471,
  59817,
  9586,
  15720,
  158155,
  51307,
  109734,
  15196,
  11025,
  59331,
  3884,
  52626,
  102602,
  84797,
  25158,
  27314,
  4437,
  20488,
  76214,
  189248,
  35023,
  114952,
  157376,
  2827,
  62439,
  102878,
  129749,
  36405,
  10329,
  109339,
  108633,
  36662,
  1254,
  13267,
  5470,
  87105,
  58004,
  15397,
  10434,
  159667,
  21864,
  52022,
  179464,
  3013,
  32147,
  31496,
  116832,
  18494,
  105502,
  129227,
  107267,
  50033,
  13481,
  9954,
  24267,
  22141,
  16257,
  116154,
  36185,
  950,
  115685,
  11305,
  176708,
  2048,
  178671,
  112573,
  287867,
  162328,
  497663,
  95170,
  50979,
  193861,
  50987,
  30368,
  136257,
  31830,
  46549,
  15119,
  169876,
  23788,
  17462,
  249887,
  57377,
  1949,
  35448,
  14791,
  43769,
  210091,
  3783,
  34612,
  282103,
  88380,
  245190,
  5457,
  20491,
  98908,
  11402,
  86899,
  117916,
  16028,
  162584,
  60644,
  320177,
  156096,
  31065,
  55876,
  22e3,
  77655,
  9992,
  23397,
  13757,
  317623,
  63978,
  215255,
  2443,
  17648,
  93231,
  27388,
  104529,
  93807,
  55505,
  140477,
  12046,
  112040,
  70887,
  40152,
  94365,
  112353,
  25063,
  114679,
  266061,
  71248,
  119555,
  15589,
  2244,
  617,
  14129,
  211431,
  70110,
  100652,
  7777,
  4383,
  85911,
  89221,
  21010,
  120615,
  58357,
  86405,
  37554,
  41647,
  18,
  15143,
  69662,
  60491,
  14714,
  186134,
  148344,
  42347,
  5410,
  168175,
  44535,
  42449,
  343894,
  129417,
  99682,
  20659,
  27272,
  140483,
  63455,
  222159,
  17536,
  13722,
  42637,
  62324,
  11976,
  114691,
  148109,
  2283,
  32057,
  182393,
  4295,
  147364,
  33705,
  2075,
  44303,
  30274,
  28331,
  63740,
  69740,
  29148,
  10346,
  44862,
  33716,
  73937,
  153333,
  12930,
  38784,
  247159,
  2515,
  41053,
  20256,
  83368,
  256189,
  54639,
  115240,
  5096,
  24661,
  175419,
  153552,
  26516,
  141,
  138176,
  63885,
  34115,
  47222,
  55709,
  2765,
  28479,
  38875,
  236608,
  12229,
  22921,
  77291,
  54426,
  45388,
  2860,
  57787,
  114579,
  295139,
  105782,
  17826,
  71066,
  19119,
  54364,
  69385,
  16568,
  12323,
  28057,
  33346,
  34919,
  124763,
  155533,
  101386,
  31644,
  8627,
  49001,
  303600,
  29868,
  63213,
  9103,
  77280,
  71333,
  9696,
  138789,
  37059,
  24823,
  5057,
  21352,
  32368,
  114208,
  56803,
  19424,
  10445,
  58514,
  8661,
  209508,
  26187,
  171838,
  10460,
  63454,
  14016,
  122504,
  41328,
  21329,
  46618,
  32493,
  38225,
  7855,
  31763,
  7945,
  29876,
  8734,
  6438,
  24205,
  97490,
  139977,
  130740,
  47323,
  33195,
  85390,
  57194,
  13813,
  60600,
  21313,
  96251,
  7699,
  27584,
  170521,
  139271,
  1363,
  4402,
  336738,
  129223,
  84983,
  69150,
  13147,
  3590,
  163929,
  207225,
  155260,
  55916,
  20288,
  4503,
  8398,
  98490,
  11773,
  27512,
  37113,
  84976,
  86558,
  28365,
  11756,
  116005,
  182148,
  13733,
  115313,
  47644,
  67208,
  85069,
  9347,
  14995,
  226141,
  14704,
  101835,
  41159,
  35314,
  13113,
  63526,
  214039,
  29978,
  50446,
  83339,
  17440,
  129441,
  72522,
  118641,
  97816,
  24907,
  73844,
  15717,
  118884,
  167255,
  96509,
  162793,
  30847,
  36849,
  51297,
  78974,
  77793,
  10427,
  1873,
  2972,
  9999,
  35074,
  28190,
  64297,
  146836,
  46298,
  60038,
  163007,
  108919,
  61219,
  2403,
  75022,
  127339,
  4233,
  110389,
  69022,
  9833,
  128097,
  88016,
  79390,
  222936,
  22570,
  94657,
  28462,
  56956,
  38803,
  81536,
  30474,
  152794,
  19566,
  16481,
  147408,
  74574,
  81895,
  20731,
  1918,
  1366,
  76367,
  187321,
  54494,
  24366,
  21690,
  61696,
  33283,
  107477,
  77499,
  31112,
  414383,
  74362,
  18463,
  218441,
  120929,
  59848,
  258629,
  201924,
  69269,
  454,
  19989,
  13054,
  59894,
  3623,
  58908,
  20681,
  35723,
  78523,
  102680,
  38988,
  184112,
  108087,
  50944,
  132704,
  52966,
  21699,
  18860,
  96349,
  201411,
  82697,
  85395,
  95658,
  5093,
  6427,
  177894,
  44191,
  32755,
  26961,
  155739,
  6249,
  31310,
  81030,
  26574,
  84311,
  120155,
  86730,
  113535,
  7424,
  48888,
  13516,
  45747,
  98098,
  20077,
  183995,
  81945,
  43210,
  26704,
  40420,
  75831,
  45648,
  11180,
  6855,
  57927,
  65528,
  124096,
  34851,
  2598,
  156633,
  107572,
  127352,
  38169,
  123845,
  60142,
  62722,
  105584,
  232364,
  23211,
  68120,
  1601,
  22169,
  89299,
  747,
  258039,
  80572,
  7258,
  152249,
  11862,
  101204,
  8834,
  121434,
  33761,
  19175,
  133142,
  46343,
  40178,
  48723,
  3589,
  41977,
  30210,
  38868,
  62257,
  10087,
  82658,
  87827,
  90646,
  16415,
  47552,
  351723,
  28298,
  72225,
  91146,
  272760,
  1701,
  11295,
  1652,
  109651,
  300747,
  51863,
  198800,
  29446,
  11794,
  32345,
  37538,
  22356,
  33102,
  37590,
  113544,
  37970,
  11478,
  179743,
  25454,
  103417,
  59905,
  221970,
  105196,
  145604,
  7817,
  164809,
  102360,
  16974,
  75840,
  255333,
  56902,
  6659,
  1954,
  645,
  59400,
  67769,
  7689,
  18675,
  5215,
  13793,
  20536,
  27852,
  3387,
  29523,
  259718,
  16860,
  94625,
  43143,
  29245,
  15848,
  233581,
  22685,
  63631,
  78557,
  22836,
  133302,
  84513,
  1348,
  51826,
  47129,
  98836,
  58284,
  1830,
  1749,
  94642,
  10933,
  6145,
  12506,
  10975,
  13879,
  103781,
  144434,
  10268,
  28409,
  32346,
  52968,
  121567,
  107374,
  77268,
  23686,
  35097,
  10501,
  155275,
  15303,
  47136,
  21102,
  168741,
  55332,
  90385,
  15996,
  84817,
  681,
  137803,
  25054,
  142275,
  6163,
  38175,
  8056,
  124296,
  240642,
  65621,
  4934,
  178205,
  16101,
  62803,
  60964,
  18230,
  100622,
  76465,
  44689,
  14545,
  9543,
  47514,
  16852,
  93380,
  28048,
  12047,
  107106,
  37575,
  101485,
  77047,
  57326,
  34819,
  96137,
  76916,
  6469,
  46264,
  115983,
  75768,
  87668,
  69942,
  13027,
  165,
  8373,
  114231,
  26434,
  52844,
  42799,
  182044,
  23580,
  146254,
  38081,
  43236,
  33883,
  146220,
  382894,
  14606,
  46035,
  36481,
  166621,
  35417,
  95382,
  2957,
  59384,
  60428,
  36358,
  66343,
  75378,
  22267,
  22950,
  83528,
  17577,
  56474,
  25285,
  4619,
  179691,
  75355,
  95836,
  53295,
  34588,
  171410,
  4487,
  14679,
  84208,
  44015,
  18562,
  109133,
  54101,
  11531,
  86052,
  174479,
  303157,
  28095,
  9953,
  35642,
  14564,
  39802,
  16145,
  77606,
  117406,
  53038,
  121117,
  53624,
  22062,
  1212,
  7632,
  127157,
  237292,
  189087,
  10478,
  127345,
  102515,
  181997,
  86752,
  87623,
  10966,
  121602,
  68783,
  68681,
  83042,
  114380,
  138349,
  191305,
  67176,
  50085,
  39016,
  1427,
  42384,
  1412,
  67118,
  122616,
  72389,
  25260,
  2237,
  13576,
  137346,
  19938,
  20304,
  2191,
  68759,
  5373,
  61364,
  238507,
  75814,
  23931,
  69565,
  38993,
  131741,
  38364,
  12528,
  87762,
  5679,
  129853,
  5310,
  186831,
  32653,
  90338,
  260176,
  389531,
  108118,
  26843,
  43985,
  50175,
  30563,
  25106,
  56965,
  18130,
  140428,
  4542,
  165503,
  117991,
  24219,
  229605,
  1819,
  129663,
  1240,
  3797,
  76093,
  18398,
  71339,
  51919,
  93043,
  27175,
  47060,
  216257,
  6483,
  35051,
  1217,
  16512,
  80798,
  129064,
  13225,
  69339,
  8548,
  237079,
  72298,
  2575,
  34280,
  51379,
  117910,
  55671,
  53345,
  247552,
  29486,
  39328,
  140821,
  34681,
  57045,
  60177,
  5004,
  90269,
  78522,
  2479,
  322607,
  48474,
  61296,
  13057,
  31558,
  4678,
  59271,
  6699,
  27044,
  31988,
  35944,
  12503,
  83480,
  4389,
  136508,
  3781,
  114121,
  70279,
  4488,
  155829,
  42214,
  2898,
  68191,
  75695,
  305850,
  45041,
  74344,
  106509,
  30087,
  17429,
  93292,
  12477,
  290,
  23080,
  114802,
  35714,
  18751,
  26554,
  105424,
  17775,
  2144,
  2412,
  100610,
  65192,
  113975,
  52975,
  180272,
  135050,
  129815,
  76238,
  106483,
  21440,
  63186,
  4260,
  46189,
  9711,
  28249,
  4169,
  23429,
  23390,
  8324,
  141585,
  63809,
  67668,
  38457,
  38063,
  39226,
  59972,
  1189,
  203916,
  62368,
  14403,
  16949,
  61767,
  85801,
  1739,
  40147,
  35049,
  76757,
  33124,
  62102,
  15780,
  103593,
  103009,
  53484,
  22952,
  67973,
  114645,
  6566,
  5245,
  50462,
  7601,
  8288,
  3513,
  194571,
  80276,
  1908,
  54592,
  5124,
  58571,
  2513,
  6800,
  273997,
  193904,
  1119,
  17991,
  117245,
  2508,
  129156,
  82366,
  26278,
  71465,
  63341,
  56943,
  39662,
  106116,
  94966,
  156875,
  9736,
  2204,
  122308,
  94418,
  27134,
  1280,
  24539,
  49022,
  45314,
  3764,
  50904,
  46424,
  30699,
  28087,
  293839,
  9400,
  33646,
  40165,
  822,
  147499,
  50263,
  116179,
  29085,
  11863,
  31314,
  5578,
  17797,
  5104,
  12454,
  1604,
  15342,
  219206,
  10232,
  67800,
  94261,
  25872,
  13565,
  90339,
  78971,
  75377,
  26649,
  41184,
  47695,
  11514,
  35369,
  20767,
  14227,
  41953,
  309396,
  148270,
  147938,
  33074,
  14453,
  27499,
  109019,
  39018,
  25738,
  240196,
  158931,
  52820,
  8612,
  95853,
  21524,
  137010,
  84901,
  70869,
  70021,
  116794,
  48404,
  38771,
  6732,
  1070,
  70990,
  187297,
  49140,
  5238,
  576,
  3564,
  253975,
  16027,
  16483,
  2811,
  37775,
  19034,
  25259,
  4053,
  2e3,
  70083,
  95774,
  19713,
  33431,
  92703,
  91314,
  42381,
  288770,
  48194,
  95985,
  3991,
  77418,
  13406,
  241328,
  245086,
  56533,
  35275,
  62725,
  9246,
  51924,
  70181,
  95331,
  16163,
  31410,
  79016,
  39312,
  120878,
  119371,
  275987,
  80124,
  27712,
  9186,
  220,
  23598,
  146167,
  85209,
  68238,
  282190,
  57048,
  31273,
  30555,
  80913,
  17594,
  75779,
  59160,
  135002,
  101219,
  189377,
  29225,
  96735,
  60126,
  62522,
  104e3,
  27620,
  86814,
  17240,
  147533,
  11001,
  5425,
  43682,
  410,
  49460,
  87270,
  69480,
  46315,
  59448,
  1816,
  76201,
  9431,
  11788,
  87960,
  29063,
  65539,
  47347,
  11678,
  33846,
  7008,
  196704,
  9895,
  6753,
  8633,
  120892,
  59970,
  572824,
  115934,
  6646,
  202559,
  892,
  48351,
  37611,
  251282,
  57823,
  67263,
  57750,
  26527,
  34485,
  90747,
  7685,
  88370,
  6144,
  64182,
  1709,
  41969,
  21458,
  62327,
  181657,
  49247,
  225330,
  122600,
  114574,
  107124,
  85361,
  111833,
  63243,
  71420,
  15655,
  191178,
  72430,
  18063,
  51425,
  54002,
  12364,
  53225,
  86557,
  18193,
  97580,
  41232,
  138398,
  67821,
  128724,
  8944,
  233212,
  101353,
  52099,
  42127,
  14006,
  120107,
  32789,
  32132,
  3498,
  18123,
  33758,
  56058,
  5779,
  128760,
  59888,
  98869,
  18445,
  84702,
  51911,
  13234,
  218379,
  20093,
  39031,
  8074,
  70195,
  20708,
  23462,
  24355,
  131384,
  60189,
  26390,
  10403,
  41060,
  7140,
  10781,
  49410,
  42261,
  87202,
  82566,
  41663,
  43105,
  60276,
  2768,
  5733,
  74176,
  28329,
  2297,
  145430,
  131632,
  83615,
  122915,
  105441,
  655,
  224102,
  5284,
  136426,
  67763,
  16294,
  188511,
  32538,
  61049,
  27893,
  3394,
  13951,
  159099,
  28542,
  17930,
  145360,
  9492,
  190122,
  32285,
  78855,
  26440,
  13570,
  58648,
  73908,
  4239,
  124561,
  2444,
  74172,
  53131,
  11468,
  10794,
  73566,
  11623,
  35343,
  64710,
  30481,
  4163,
  10328,
  38309,
  29901,
  10538,
  154377,
  76132,
  92405,
  24839,
  11679,
  3465,
  13449,
  11637,
  7824,
  2337,
  57754,
  1260,
  14458,
  41118,
  19878,
  38661,
  13416,
  159180,
  37074,
  163164,
  54137,
  28627,
  52134,
  184900,
  8520,
  40385,
  29546,
  30502,
  22386,
  66527,
  107458,
  6850,
  24022,
  47983,
  30603,
  35083,
  8934,
  304066,
  39500,
  9,
  28261,
  33026,
  77251,
  9374,
  44833,
  116312,
  34990,
  29236,
  63563,
  125639,
  135405,
  165398,
  159055,
  55690,
  88141,
  69643,
  236964,
  31983,
  25572,
  20436,
  36746,
  60896,
  31850,
  16179,
  11828,
  5888,
  3043,
  66368,
  9750,
  31167,
  7915,
  53111,
  36430,
  1333,
  64344,
  93659,
  20061,
  60596,
  180191,
  51630,
  6792,
  30244,
  43509,
  101058,
  22409,
  420,
  44210,
  109783,
  43223,
  27030,
  72477,
  72831,
  32679,
  29235,
  7675,
  47556,
  12258,
  39907,
  149412,
  84926,
  118247,
  24692,
  71717,
  105038,
  86009,
  45941,
  41189,
  89453,
  29856,
  52543,
  30627,
  226798,
  67303,
  59230,
  67415,
  34408,
  1367,
  99685,
  16867,
  128419,
  52147,
  4111,
  125381,
  117881,
  16173,
  44093,
  102224,
  31575,
  23234,
  24870,
  83790,
  127407,
  239098,
  3200,
  994,
  1255,
  100903,
  242275,
  117266,
  55116,
  38205,
  16140,
  29662,
  11307,
  40414,
  208793,
  123355,
  56470,
  4862,
  75600,
  30119,
  58218,
  70828,
  24075,
  26974,
  7802,
  192353,
  4851,
  5475,
  78720,
  66596,
  3409,
  28573,
  64396,
  30381,
  30690,
  59859,
  88256,
  5406,
  99945,
  103064,
  34463,
  37727,
  24238,
  86643,
  60088,
  4057,
  23741,
  5967,
  162904,
  38240,
  28356,
  93858,
  25510,
  122879,
  6897,
  3278,
  7057,
  11971,
  4400,
  35461,
  211413,
  21395,
  59615,
  39471,
  87233,
  55795,
  128426,
  3051,
  22470,
  41950,
  14705,
  3974,
  180108,
  80476,
  78442,
  204996,
  91987,
  15634,
  67610,
  139015,
  142373,
  35611,
  51134,
  10387,
  4353,
  153456,
  57749,
  181039,
  14183,
  68447,
  151532,
  21107,
  36452,
  20551,
  3186,
  46247,
  46383,
  129666,
  88736,
  140662,
  146243,
  2066,
  8360,
  7978,
  64818,
  106963,
  17896,
  47801,
  10723,
  114821,
  223295,
  74192,
  3293,
  3393,
  16987,
  74064,
  11277,
  91622,
  4270,
  29828,
  27951,
  387869,
  103235,
  1374,
  61988,
  120083,
  477,
  145892,
  128378,
  11779,
  211263,
  61354,
  18221,
  17869,
  46530,
  83061,
  108538,
  157981,
  90608,
  67199,
  95080,
  49064,
  195814,
  12302,
  66307,
  10348,
  231346,
  160732,
  112859,
  63633,
  146558,
  21271,
  31037,
  198802,
  47622,
  12862,
  95710,
  3910,
  77850,
  73961,
  85585,
  34752,
  61e3,
  4082,
  24595,
  103679,
  71107,
  8208,
  79568,
  150019,
  16615,
  24961,
  139857,
  32664,
  197366,
  4559,
  54735,
  32696,
  4126,
  162019,
  75698,
  13916,
  70108,
  159638,
  19834,
  9349,
  24675,
  175560,
  49643,
  18206,
  52459,
  27992,
  10809,
  88865,
  401975,
  133172,
  29e3,
  34558,
  30915,
  3658,
  25834,
  42430,
  36562,
  125265,
  18182,
  10155,
  40149,
  97082,
  208980,
  19575,
  60853,
  90529,
  66545,
  9600,
  789,
  46420,
  2317,
  88593,
  55595,
  98980,
  115302,
  5742,
  169155,
  1073,
  177901,
  3472,
  11189,
  63711,
  78643,
  65472,
  50459,
  127979,
  93,
  42202,
  67053,
  21720,
  157650,
  11145,
  141378,
  42033,
  22824,
  85705,
  79114,
  35584,
  15974,
  1510,
  54172,
  28562,
  12451,
  104226,
  19190,
  97151,
  73024,
  20948,
  5151,
  81741,
  21499,
  29006,
  84183,
  198074,
  54003,
  45120,
  170125,
  26240,
  35177,
  28389,
  64863,
  79974,
  60778,
  176915,
  232183,
  45342,
  2038,
  80253,
  41564,
  40703,
  32689,
  5430,
  100689,
  5366,
  23007,
  134279,
  14266,
  26712,
  73993,
  24934,
  64242,
  52113,
  102887,
  61801,
  46415,
  201049,
  54251,
  62133,
  122757,
  164883,
  30815,
  139966,
  2319,
  30842,
  766,
  13362,
  10287,
  134518,
  86111,
  81665,
  82440,
  28333,
  43019,
  18963,
  8804,
  161944,
  23439,
  102144,
  101145,
  80029,
  39052,
  248708,
  30350,
  117340,
  11878,
  128467,
  974,
  138625,
  63961,
  5237,
  74778,
  61834,
  67040,
  43814,
  13690,
  65947,
  33809,
  232476,
  115258,
  181745,
  28824,
  94013,
  9510,
  10246,
  93722,
  81976,
  7217,
  114383,
  3493,
  16014,
  69045,
  72692,
  12145,
  80981,
  9507,
  6692,
  1620,
  60820,
  330444,
  35474,
  33962,
  4797,
  7053,
  295463,
  46445,
  27026,
  12491,
  77988,
  49524,
  35675,
  90947,
  29114,
  166705,
  101385,
  133782,
  32704,
  6186,
  84595,
  176031,
  185623,
  45966,
  151302,
  63069,
  1699,
  107491,
  947,
  15458,
  74452,
  196212,
  6046,
  10498,
  12163,
  10239,
  35191,
  243951,
  9277,
  9090,
  29539,
  54460,
  22820,
  26514,
  112549,
  60372,
  51753,
  48756,
  21812,
  70861,
  260326,
  41,
  44222,
  10441,
  16961,
  48148,
  138771,
  216194,
  5914,
  52153,
  53400,
  212036,
  56519,
  26245,
  10117,
  45888,
  15294,
  138019,
  90913,
  26368,
  43842,
  42111,
  23348,
  6082,
  194845,
  161089,
  156206,
  51546,
  11647,
  30759,
  302912,
  262094,
  8635,
  78876,
  26535,
  35283,
  54183,
  31183,
  85484,
  147873,
  12989,
  5197,
  6356,
  72894,
  65347,
  20150,
  27370,
  73787,
  1493,
  45918,
  12366,
  190217,
  20724,
  13858,
  10981,
  67449,
  81213,
  7553,
  14115,
  72242,
  271517,
  11842,
  48310,
  88743,
  143726,
  22177,
  3290,
  243231,
  58452,
  62937,
  12592,
  1654,
  40066,
  33477,
  13751,
  9921,
  128442,
  15868,
  7106,
  75236,
  83773,
  10775,
  36938,
  10482,
  170465,
  17368,
  17469,
  161508,
  32752,
  98340,
  800,
  19824,
  264456,
  3901,
  87319,
  2867,
  26782,
  9630,
  113102,
  185815,
  24197,
  44584,
  86366,
  40224,
  3636,
  140916,
  31731,
  267731,
  9567,
  53678,
  72984,
  29389,
  27963,
  17106,
  50282,
  284911,
  60170,
  8322,
  12608,
  23374,
  89652,
  5268,
  39044,
  229766,
  8869,
  151350,
  31436,
  177342,
  12269,
  183212,
  120418,
  116270,
  2843,
  78888,
  69192,
  7865,
  184099,
  1086,
  129897,
  18383,
  70508,
  20242,
  18508,
  229924,
  124569,
  35749,
  50589,
  55626,
  9884,
  83115,
  40971,
  30671,
  18135,
  14452,
  38861,
  17844,
  201826,
  5549,
  26413,
  17189,
  13561,
  38539,
  10679,
  143331,
  3314,
  36785,
  171194,
  49685,
  187713,
  67506,
  4618,
  104039,
  17060,
  195080,
  50648,
  33159,
  19238,
  67559,
  134840,
  28599,
  157523,
  17130,
  38064,
  117398,
  94355,
  31918,
  13575,
  34538,
  40326,
  13997,
  3494,
  348283,
  62481,
  26862,
  3603,
  104426,
  244363,
  153709,
  112487,
  304612,
  199674,
  41239,
  35545,
  54869,
  293005,
  28223,
  26277,
  26899,
  4533,
  18518,
  15492,
  38587,
  80488,
  70485,
  160395,
  263,
  60162,
  11382,
  222152,
  4696,
  250751,
  51921,
  182609,
  10707,
  48463,
  46243,
  1227,
  49111,
  111564,
  46502,
  33342,
  56846,
  68541,
  63559,
  858,
  139927,
  16654,
  229375,
  76759,
  26478,
  33205,
  95828,
  23399,
  92945,
  2637,
  35630,
  28470,
  143992,
  50214,
  14174,
  21456,
  166191,
  65665,
  1711,
  21594,
  78019,
  97599,
  111701,
  36,
  147151,
  110246,
  189022,
  43021,
  30397,
  40757,
  131935,
  42065,
  73335,
  48039,
  26596,
  28984,
  15102,
  2361,
  7421,
  202167,
  69744,
  43766,
  52826,
  3642,
  83304,
  33873,
  75140,
  63169,
  192389,
  36551,
  92748,
  13039,
  123959,
  233220,
  21738,
  84447,
  77230,
  20228,
  187852,
  19095,
  25799,
  92136,
  108774,
  29237,
  53947,
  2299,
  118106,
  2687,
  8830,
  42331,
  202924,
  33667,
  2023,
  73763,
  30704,
  19363,
  19779,
  16737,
  35629,
  48081,
  24068,
  101013,
  162338,
  291912,
  13749,
  24745,
  328289,
  167679,
  70086,
  48299,
  23306,
  16732,
  17801,
  43322,
  54589,
  3586,
  63653,
  43624,
  53474,
  925,
  109177,
  251316,
  43805,
  13082,
  19511,
  86565,
  142182,
  92461,
  17117,
  101033,
  103319,
  64589,
  4022,
  4351,
  235897,
  5352,
  82705,
  107142,
  46391,
  156084,
  5860,
  61365,
  10558,
  13045,
  7717,
  18357,
  33922,
  12590,
  33065,
  6928,
  46993,
  783,
  46937,
  67846,
  8952,
  26295,
  6107,
  119656,
  18799,
  17458,
  50747,
  4229,
  179559,
  112727,
  118080,
  20683,
  41464,
  125468,
  51560,
  49749,
  44231,
  7359,
  35339,
  62988,
  136487,
  67015,
  5208,
  29150,
  24956,
  105186,
  48858,
  6143,
  18097,
  6972,
  16404,
  73489,
  58742,
  97196,
  36357,
  164616,
  5834,
  32267,
  13746,
  147733,
  15113,
  132091,
  34127,
  106298,
  39729,
  106426,
  22294,
  9780,
  15602,
  36213,
  71502,
  42808,
  66802,
  599,
  60755,
  5851,
  39120,
  67363,
  108623,
  126368,
  72770,
  91263,
  32486,
  30596,
  151717,
  7951,
  52002,
  43103,
  11768,
  68942,
  40901,
  39344,
  24037,
  127500,
  116890,
  48403,
  16926,
  86750,
  17745,
  48648,
  159545,
  34460,
  58419,
  5634,
  114317,
  67865,
  31462,
  23352,
  24010,
  98185,
  125708,
  69686,
  68337,
  13610,
  26271,
  70691,
  2980,
  4768,
  27225,
  102402,
  75453,
  28106,
  8104,
  6931,
  1176,
  6274,
  6475,
  112635,
  22498,
  6176,
  238686,
  26832,
  28893,
  90319,
  14441,
  15682,
  15087,
  39517,
  45270,
  109134,
  104440,
  45965,
  47645,
  81772,
  7876,
  52683,
  87720,
  12898,
  4505,
  185665,
  2769,
  113401,
  15664,
  57592,
  105229,
  137381,
  97059,
  119268,
  6876,
  43309,
  33886,
  128363,
  35476,
  144249,
  67013,
  143587,
  83367,
  25703,
  91436,
  59347,
  53236,
  2289,
  16519,
  19844,
  46309,
  58558,
  99834,
  23313,
  218816,
  231303,
  36388,
  51333,
  183535,
  109792,
  139277,
  54306,
  90139,
  18235,
  8275,
  32710,
  37677,
  82464,
  86025,
  92204,
  88842,
  117723,
  37570,
  128723,
  234242,
  76350,
  73795,
  34896,
  148247,
  58424,
  11105,
  11744,
  45746,
  63372,
  17118,
  49772,
  199520,
  81902,
  38004,
  22911,
  33752,
  3125,
  1995,
  53792,
  4689,
  26909,
  108150,
  146062,
  69674,
  41811,
  161444,
  84855,
  8999,
  28561,
  16731,
  93937,
  3189,
  21967,
  24890,
  22943,
  1356,
  145300,
  51569,
  28802,
  517,
  118679,
  31703,
  40607,
  48098,
  108854,
  25003,
  10233,
  73969,
  177495,
  5248,
  24516,
  215347,
  146192,
  48712,
  60626,
  69188,
  40735,
  5866,
  586,
  101541,
  6509,
  47590,
  52129,
  5969,
  222045,
  110933,
  25733,
  24223,
  65339,
  62812,
  2414,
  155418,
  35819,
  16022,
  78423,
  43138,
  20995,
  128255,
  240673,
  46745,
  236093,
  72176,
  57085,
  97841,
  61248,
  107,
  36068,
  193177,
  105427,
  55726,
  215229,
  20446,
  47228,
  100420,
  87091,
  14429,
  121708,
  23605,
  21157,
  187721,
  21880,
  2997,
  203976,
  99166,
  95068,
  25877,
  7724,
  98925,
  83401,
  4829,
  13182,
  18229,
  13718,
  239662,
  38653,
  116505,
  153497,
  30589,
  89029,
  38962,
  181302,
  43853,
  78872,
  180301,
  4786,
  248240,
  7401,
  106136,
  112590,
  77745,
  19731,
  60880,
  77789,
  125748,
  135487,
  5975,
  48627,
  34084,
  12419,
  215770,
  47557,
  254582,
  10364,
  106495,
  21856,
  67539,
  88981,
  38805,
  21428,
  48732,
  42316,
  12149,
  16078,
  52808,
  25327,
  51322,
  33850,
  51147,
  12253,
  122354,
  46077,
  56483,
  254553,
  115417,
  81834,
  150991,
  94662,
  86668,
  7381,
  12841,
  100650,
  18218,
  15741,
  22372,
  68294,
  50705,
  15535,
  84660,
  61887,
  22553,
  72299,
  31361,
  24824,
  17743,
  46820,
  64288,
  31582,
  77006,
  111674,
  116384,
  30760,
  80920,
  86149,
  77192,
  51979,
  79691,
  60342,
  122805,
  103800,
  240873,
  160744,
  233114,
  78962,
  54920,
  8608,
  3484,
  316104,
  72548,
  24337,
  5088,
  230040,
  21926,
  10172,
  36838,
  26,
  86221,
  83458,
  102176,
  12062,
  17571,
  41929,
  41170,
  28428,
  68239,
  41750,
  103930,
  2634,
  18313,
  53019,
  34825,
  97837,
  63115,
  24606,
  73157,
  152474,
  14715,
  91439,
  37033,
  109806,
  140259,
  30668,
  174760,
  380,
  135597,
  95673,
  136073,
  65073,
  134249,
  13829,
  17279,
  122305,
  4420,
  46444,
  10237,
  64848,
  203623,
  70728,
  10349,
  182885,
  65075,
  24519,
  25783,
  40318,
  34139,
  22222,
  63394,
  55266,
  102764,
  41422,
  20126,
  65100,
  90408,
  53640,
  35128,
  48932,
  11192,
  38935,
  96839,
  34782,
  39492,
  19396,
  41332,
  6250,
  5511,
  19492,
  51304,
  25936,
  104466,
  54099,
  73771,
  86115,
  5080,
  7669,
  30891,
  111700,
  13931,
  25276,
  72289,
  135447,
  14820,
  258641,
  25265,
  31005,
  281179,
  75286,
  393,
  95359,
  14623,
  13584,
  6680,
  101227,
  80173,
  44933,
  76666,
  54542,
  13244,
  39348,
  458,
  25379,
  109451,
  134348,
  81143,
  6959,
  65554,
  12027,
  51311,
  8716,
  57589,
  140731,
  28467,
  23316,
  17272,
  30458,
  25980,
  55229,
  77197,
  83798,
  28302,
  114784,
  7428,
  34548,
  26241,
  14712,
  39336,
  103304,
  18928,
  54080,
  12870,
  334,
  87722,
  15208,
  16895,
  142098,
  114262,
  39820,
  83913,
  57817,
  28682,
  7721,
  14900,
  108672,
  11250,
  62246,
  42849,
  415188,
  1724,
  26555,
  24549,
  25505,
  26443,
  107450,
  145899,
  61035,
  43528,
  6901,
  60726,
  65906,
  267741,
  21338,
  147590,
  42079,
  18924,
  73017,
  135236,
  15393,
  5206,
  4026,
  84185,
  1531,
  5988,
  113890,
  82647,
  303391,
  7386,
  69844,
  71611,
  189865,
  76523,
  31877,
  13315,
  19314,
  198575,
  32821,
  1928,
  67641,
  25913,
  104475,
  103489,
  3297,
  70391,
  18406,
  15446,
  113347,
  19295,
  93790,
  27856,
  1792,
  167471,
  116449,
  8541,
  4408,
  41757,
  63233,
  25765,
  86680,
  64501,
  27034,
  24816,
  34975,
  6079,
  4486,
  49693,
  36229,
  16917,
  21581,
  62426,
  27862,
  11612,
  54284,
  35702,
  194034,
  355,
  24277,
  48262,
  87411,
  70504,
  310164,
  118018,
  12516,
  47559,
  43502,
  57433,
  107139,
  9290,
  66533,
  80863,
  14634,
  34312,
  91725,
  28606,
  21342,
  67241,
  72355,
  43244,
  375789,
  37402,
  174015,
  105070,
  8342,
  44167,
  67494,
  1890,
  16365,
  11723,
  271002,
  1865,
  47918,
  8350,
  45564,
  27742,
  25110,
  125803,
  8553,
  49504,
  81925,
  62211,
  4534,
  15491,
  19011,
  80373,
  206920,
  667,
  102405,
  128623,
  245524,
  5553,
  113309,
  192739,
  65766,
  19567,
  22832,
  261958,
  29679,
  21293,
  71134,
  20962,
  105123,
  24721,
  860,
  21752,
  33448,
  18372,
  157167,
  94822,
  35770,
  173224,
  232737,
  75729,
  28937,
  46828,
  28062,
  25453,
  5207,
  140366,
  36665,
  30652,
  6169,
  67920,
  150458,
  92040,
  23186,
  184604,
  92330,
  20891,
  176492,
  49427,
  27828,
  38305,
  42495,
  143982,
  49560,
  25503,
  90043,
  29747,
  65328,
  47830,
  12932,
  11068,
  77721,
  9003,
  25213,
  94205,
  140426,
  46090,
  89945,
  138173,
  192691,
  33329,
  112232,
  129905,
  35709,
  27514,
  1841,
  19957,
  31411,
  127476,
  53572,
  17497,
  173549,
  55063,
  175135,
  19841,
  69314,
  5192,
  237921,
  117660,
  150697,
  4060,
  273045,
  50414,
  98940,
  65348,
  153665,
  164423,
  58804,
  156695,
  48994,
  213928,
  86036,
  28608,
  8355,
  39574,
  34540,
  16927,
  135680,
  18374,
  151587,
  10830,
  53805,
  16878,
  16623,
  4282,
  48030,
  8537,
  14986,
  46102,
  13062,
  72897,
  72,
  33050,
  108227,
  39451,
  45935,
  651,
  113320,
  40535,
  95176,
  57450,
  48843,
  5003,
  19019,
  10407,
  211163,
  3848,
  1068,
  4988,
  32091,
  30095,
  41692,
  15099,
  43602,
  107434,
  50744,
  7627,
  171349,
  16313,
  150832,
  352665,
  207750,
  33937,
  38256,
  51091,
  156e3,
  87889,
  90663,
  84175,
  24908,
  114900,
  50365,
  31494,
  83829,
  5398,
  169342,
  47521,
  54818,
  18935,
  8356,
  43094,
  41212,
  174536,
  10082,
  92550,
  6678,
  60614,
  23355,
  69721,
  14796,
  34149,
  128830,
  58187,
  3179,
  208,
  40325,
  28399,
  225029,
  401412,
  51150,
  31580,
  207268,
  6657,
  10993,
  69818,
  64282,
  289845,
  23308,
  12961,
  38447,
  6681,
  52944,
  31855,
  2572,
  47646,
  120728,
  179148,
  37240,
  45196,
  218274,
  4816,
  3695,
  21961,
  50084,
  35209,
  18073,
  51452,
  27004,
  6100,
  33941,
  1377,
  84831,
  171214,
  85,
  141510,
  9078,
  99227,
  32610,
  6417,
  11718,
  49868,
  65579,
  87902,
  73018,
  49062,
  46280,
  61742,
  21512,
  40862,
  107733,
  15941,
  29168,
  157765,
  144919,
  14487,
  5767,
  158014,
  140070,
  7241,
  573,
  71584,
  16921,
  223566,
  40331,
  179473,
  35081,
  47926,
  140885,
  41508,
  52104,
  59180,
  42310,
  32811,
  29048,
  123517,
  102413,
  80208,
  10104,
  14746,
  12649,
  153641,
  126022,
  37965,
  113017,
  4171,
  83,
  142592,
  2809,
  6362,
  50416,
  71323,
  116894,
  260776,
  16204,
  1524,
  5760,
  30351,
  12658,
  20703,
  54403,
  36083,
  45408,
  74772,
  4946,
  14485,
  50759,
  111222,
  10890,
  2195,
  167147,
  92962,
  130534,
  16283,
  177256,
  35016,
  15472,
  210156,
  151187,
  73922,
  117691,
  43250,
  52051,
  37392,
  24811,
  24358,
  30830,
  5775,
  818,
  21969,
  1476,
  127322,
  151783,
  58392,
  31021,
  106913,
  65215,
  89407,
  90802,
  28531,
  11690,
  20234,
  95249,
  44602,
  37256,
  18707,
  11928,
  5161,
  4410,
  26571,
  51903,
  49768,
  22008,
  25252,
  65780,
  209499,
  68769,
  203726,
  13249,
  137363,
  48845,
  86823,
  6658,
  5674,
  31881,
  1083,
  1823,
  108676,
  34518,
  166752,
  13791,
  14287,
  91576,
  91429,
  8665,
  11529,
  26401,
  16191,
  91972,
  30964,
  5254,
  28486,
  54697,
  79613,
  66520,
  18447,
  22870,
  45203,
  194466,
  22822,
  51703,
  12278,
  76716,
  44595,
  73455,
  33546,
  12235,
  144843,
  36154,
  51247,
  11116,
  33040,
  3180,
  225753,
  60864,
  1972,
  28469,
  12891,
  28879,
  10338,
  144157,
  56294,
  353058,
  38302,
  41447,
  87532,
  110616,
  27065,
  168438,
  6557,
  1213,
  50804,
  144643,
  24817,
  2390,
  136531,
  38174,
  247513,
  16190,
  4059,
  122791,
  131994,
  137430,
  39506,
  57650,
  16305,
  5188,
  54309,
  106128,
  20628,
  88071,
  67394,
  395446,
  250285,
  66176,
  91254,
  1399,
  114196,
  43915,
  60230,
  44853,
  27206,
  106353,
  43013,
  18733,
  345105,
  226453,
  51202,
  16607,
  57106,
  117175,
  35492,
  10476,
  89598,
  127439,
  15187,
  39624,
  13688,
  61570,
  10615,
  31111,
  59370,
  6238,
  175252,
  32143,
  224492,
  41388,
  95408,
  34384,
  148238,
  78307,
  38959,
  9340,
  160091,
  61443,
  15737,
  11216,
  41244,
  170,
  38299,
  102443,
  113097,
  26382,
  14027,
  33707,
  3957,
  76300,
  66160,
  19431,
  18900,
  6952,
  1717,
  108656,
  82206,
  188021,
  257335,
  27295,
  43999,
  41210,
  31777,
  46956,
  57457,
  12657,
  11489,
  15697,
  48060,
  204748,
  53583,
  82422,
  284790,
  30503,
  137341,
  8120,
  19615,
  220311,
  15991,
  10217,
  63424,
  9808,
  67431,
  70976,
  98221,
  4491,
  15177,
  28535,
  144789,
  751,
  13230,
  2394,
  1504,
  33977,
  132104,
  30316,
  22230,
  931,
  97193,
  185240,
  24826,
  22687,
  174322,
  15307,
  22988,
  1390,
  188745,
  180325,
  29580,
  59068,
  74903,
  18994,
  29195,
  79,
  15436,
  7622,
  38462,
  11566,
  138710,
  44828,
  45774,
  37768,
  99236,
  68137,
  84083,
  19282,
  22698,
  17134,
  74807,
  126662,
  173497,
  46248,
  16938,
  119735,
  3212,
  28292,
  213652,
  49013,
  9975,
  32180,
  45660,
  86250,
  4801,
  68788,
  95490,
  77482,
  113751,
  11994,
  44624,
  94452,
  46839,
  128497,
  100316,
  5798,
  58588,
  73184,
  202987,
  65417,
  37790,
  88524,
  1606,
  43156,
  97964,
  105717,
  34947,
  11203,
  100060,
  37742,
  130074,
  93653,
  107799,
  94311,
  196106,
  41347,
  8035,
  10780,
  16390,
  27883,
  118236,
  167395,
  1979,
  25006,
  19375,
  31628,
  18916,
  144723,
  78502,
  114047,
  103107,
  86492,
  107686,
  5844,
  20934,
  206963,
  23556,
  22591,
  16562,
  146333,
  20167,
  10471,
  117434,
  33085,
  2863,
  9740,
  36669,
  41849,
  37271,
  22790,
  18209,
  28979,
  8231,
  12952,
  54408,
  21731,
  25130,
  45208,
  55748,
  138120,
  75826,
  414,
  29593,
  9925,
  292865,
  25999,
  683,
  123149,
  7036,
  92159,
  86055,
  61827,
  103680,
  23176,
  54918,
  58466,
  57578,
  13305,
  5709,
  86479,
  16697,
  31064,
  17660,
  200919,
  10770,
  49793,
  33423,
  32370,
  52047,
  16488,
  62555,
  6459,
  8426,
  83493,
  7763,
  59725,
  82812,
  18628,
  67760,
  79405,
  68557,
  9612,
  7673,
  28102,
  56517,
  69620,
  171797,
  32458,
  29541,
  15870,
  81109,
  32080,
  207644,
  71495,
  21202,
  11039,
  91036,
  61230,
  2810,
  130800,
  32260,
  4613,
  60590,
  37112,
  75214,
  33979,
  126402,
  155062,
  30642,
  63875,
  12810,
  194463,
  82799,
  47664,
  16725,
  36685,
  43367,
  61099,
  449,
  172150,
  102867,
  21691,
  301838,
  36745,
  7130,
  18671,
  57316,
  34852,
  38034,
  54182,
  35578,
  65900,
  99486,
  19771,
  3456,
  2658,
  16914,
  99866,
  28390,
  28109,
  8262,
  21147,
  34353,
  20006,
  4228,
  137085,
  1675,
  203023,
  283196,
  198286,
  214375,
  163329,
  290603,
  152574,
  40471,
  83506,
  30068,
  14730,
  23177,
  131539,
  34759,
  27668,
  32178,
  71896,
  104799,
  116305,
  85430,
  119262,
  42860,
  25160,
  8911,
  23428,
  49437,
  105322,
  6519,
  16203,
  6349,
  74711,
  1230,
  38045,
  8540,
  75165,
  44736,
  25909,
  51026,
  317034,
  4984,
  32281,
  91312,
  27060,
  44431,
  17817,
  45363,
  155937,
  239085,
  35697,
  59784,
  91993,
  29531,
  126740,
  213757,
  76560,
  167776,
  285273,
  24262,
  8237,
  65030,
  41160,
  74437,
  48804,
  118916,
  13159,
  37842,
  1031,
  75349,
  1478,
  11655,
  108777,
  23435,
  277425,
  101734,
  67469,
  70231,
  124711,
  43532,
  28514,
  65526,
  54956,
  1e3,
  21882,
  17728,
  25302,
  40952,
  52214,
  149632,
  1999,
  2111,
  3259,
  63362,
  89961,
  220561,
  39777,
  26335,
  9063,
  10572,
  12416,
  34551,
  34623,
  38604,
  24723,
  5947,
  15588,
  69927,
  66252,
  119177,
  69173,
  46629,
  28714,
  70715,
  212408,
  20521,
  406913,
  74380,
  11716,
  50659,
  50862,
  37009,
  88460,
  130101,
  7210,
  53853,
  538,
  65120,
  151950,
  55806,
  163748,
  52837,
  13153,
  21100,
  16674,
  64536,
  6091,
  138201,
  44837,
  58547,
  3723,
  163,
  2177,
  32288,
  85454,
  34033,
  8497,
  14282,
  25742,
  10535,
  10741,
  79559,
  117493,
  243787,
  49337,
  100718,
  79495,
  40139,
  42956,
  7551,
  55433,
  15421,
  31509,
  23034,
  45081,
  547,
  61176,
  53434,
  328001,
  8470,
  36263,
  30145,
  4519,
  74173,
  53935,
  11845,
  73774,
  60211,
  78025,
  3,
  4102,
  73782,
  109293,
  315332,
  48412,
  26683,
  13714,
  6865,
  20128,
  18490,
  104141,
  325,
  39470,
  171970,
  115860,
  15707,
  7268,
  73301,
  74336,
  31370,
  2368,
  111827,
  107757,
  136231,
  142844,
  97138,
  96638,
  84053,
  38691,
  23801,
  1588,
  10573,
  122098,
  77039,
  240,
  186135,
  146101,
  11996,
  18143,
  112963,
  46171,
  155836,
  348769,
  47795,
  121213,
  116266,
  132515,
  3344,
  144804,
  31286,
  99187,
  255838,
  129694,
  35894,
  48779,
  55235,
  148582,
  71967,
  65282,
  15174,
  13920,
  47080,
  6147,
  108242,
  157593,
  125025,
  7136,
  1286,
  28957,
  127956,
  28402,
  98813,
  20805,
  7532,
  109417,
  40610,
  5041,
  32958,
  15142,
  18408,
  108596,
  33543,
  50517,
  27748,
  80114,
  233434,
  91447,
  487,
  37094,
  100048,
  30541,
  43477,
  10639,
  89862,
  155868,
  37667,
  8726,
  60684,
  237903,
  73408,
  99589,
  12190,
  38739,
  97348,
  3914,
  13594,
  2680,
  149016,
  13907,
  30171,
  28343,
  23530,
  115225,
  61104,
  35821,
  147679,
  14337,
  4297,
  244282,
  24085,
  326976,
  56428,
  7851,
  21303,
  131620,
  71446,
  83253,
  68692,
  111870,
  5224,
  15813,
  38197,
  49026,
  45057,
  13660,
  3306,
  76345,
  40671,
  27905,
  91072,
  996,
  68527,
  62085,
  91351,
  122634,
  55109,
  168209,
  2024,
  27560,
  112707,
  17352,
  8306,
  167115,
  169921,
  166958,
  5031,
  46020,
  11844,
  67284,
  19130,
  76185,
  6920,
  32849,
  5450,
  14610,
  22451,
  21002,
  17392,
  31872,
  66682,
  84796,
  13709,
  40210,
  59898,
  12029,
  8719,
  53564,
  21462,
  91884,
  21647,
  88379,
  194428,
  12754,
  37797,
  132826,
  160016,
  22567,
  54383,
  53186,
  77611,
  31107,
  8339,
  4694,
  19185,
  90355,
  23597,
  17222,
  140675,
  28442,
  23668,
  55977,
  9128,
  61555,
  28774,
  155229,
  17658,
  9390,
  24379,
  69357,
  15752,
  127381,
  239631,
  62460,
  93181,
  55913,
  45133,
  140155,
  18676,
  25249,
  33164,
  29581,
  82837,
  67223,
  22362,
  29975,
  7317,
  52813,
  1943,
  29613,
  20012,
  207130,
  49617,
  49651,
  5636,
  15334,
  36313,
  29226,
  28084,
  95247,
  72072,
  19e3,
  224932,
  15811,
  114,
  32127,
  38097,
  37508,
  88507,
  37225,
  27359,
  91626,
  12193,
  69279,
  20608,
  11055,
  88156,
  92808,
  2152,
  57259,
  55275,
  72789,
  24475,
  104414,
  1708,
  9882,
  3818,
  48661,
  66897,
  1631,
  34806,
  227930,
  85815,
  87753,
  18321,
  250664,
  72733,
  25107,
  206797,
  50891,
  8082,
  196411,
  92596,
  96764,
  152823,
  65514,
  22819,
  387277,
  62176,
  51225,
  40329,
  15563,
  189,
  3659,
  73670,
  64357,
  51793,
  275136,
  33482,
  86653,
  74615,
  67058,
  11318,
  125720,
  15388,
  22388,
  8267,
  1730,
  102663,
  170910,
  40784,
  7144,
  85373,
  13040,
  7088,
  94309,
  583,
  44224,
  140424,
  77439,
  18496,
  164026,
  36578,
  4722,
  9151,
  5824,
  63365,
  26510,
  35199,
  40500,
  79277,
  32495,
  44614,
  35233,
  9566,
  203293,
  152144,
  7097,
  2330,
  183480,
  98629,
  13423,
  330887,
  44130,
  68600,
  30939,
  97829,
  31012,
  345465,
  56747,
  94879,
  4939,
  160027,
  149761,
  99423,
  46099,
  32251,
  15332,
  8761,
  96094,
  128555,
  5763,
  235318,
  222223,
  55729,
  30241,
  55420,
  201746,
  3987,
  81382,
  8259,
  49325,
  23287,
  7719,
  24633,
  251100,
  92311,
  18591,
  110533,
  64759,
  170260,
  393860,
  7175,
  21144,
  132887,
  3593,
  75346,
  101277,
  91109,
  16387,
  259187,
  11627,
  57459,
  173829,
  44694,
  55780,
  49797,
  89192,
  120443,
  62622,
  3904,
  14814,
  23887,
  1027,
  112258,
  64955,
  99800,
  11132,
  66353,
  36202,
  48624,
  18158,
  88481,
  96882,
  43059,
  11040,
  2455,
  7077,
  21651,
  181159,
  99126,
  100434,
  61388,
  68186,
  19161,
  110468,
  120052,
  8819,
  55324,
  41494,
  7014,
  37689,
  3618,
  87729,
  92615,
  207943,
  9823,
  128657,
  12587,
  15857,
  6379,
  67628,
  51216,
  71775,
  157617,
  63244,
  1503,
  3864,
  218754,
  110864,
  5769,
  21492,
  7243,
  1192,
  87921,
  85529,
  31512,
  18537,
  42698,
  35350,
  73510,
  84474,
  34301,
  8991,
  21013,
  35034,
  566,
  38832,
  19838,
  35586,
  37216,
  39413,
  55006,
  12178,
  59742,
  856,
  84563,
  6900,
  25632,
  17437,
  49786,
  30723,
  13847,
  70845,
  4044,
  7843,
  23944,
  235976,
  55530,
  48942,
  6518,
  20939,
  73769,
  192653,
  52936,
  95207,
  23895,
  132542,
  142982,
  22632,
  87452,
  48042,
  54018,
  178468,
  10728,
  26230,
  23559,
  363,
  81269,
  142012,
  5718,
  346258,
  31456,
  84333,
  246476,
  51018,
  66692,
  101804,
  120570,
  39962,
  30373,
  70593,
  2864,
  60541,
  19425,
  54209,
  104092,
  7201,
  31545,
  48018,
  25865,
  15442,
  46257,
  40443,
  8328,
  6451,
  111782,
  47527,
  97754,
  33046,
  470,
  245116,
  31095,
  39,
  91934,
  87208,
  73470,
  36708,
  36521,
  12801,
  70624,
  36272,
  8892,
  79768,
  12427,
  55454,
  103756,
  5908,
  52390,
  62962,
  22720,
  141138,
  94634,
  41689,
  128402,
  126390,
  6628,
  106394,
  35527,
  134394,
  82727,
  254651,
  194502,
  148064,
  89549,
  3202,
  28359,
  957,
  21954,
  27906,
  49840,
  142747,
  8307,
  24206,
  48978,
  1186,
  71728,
  133038,
  71474,
  91306,
  6333,
  110959,
  74600,
  70387,
  18983,
  62609,
  56057,
  22970,
  1147,
  135850,
  1321,
  28834,
  3578,
  59715,
  102227,
  32827,
  81415,
  99952,
  55636,
  257598,
  390,
  22702,
  35701,
  85872,
  402916,
  39216,
  189795,
  14929,
  19467,
  10112,
  144422,
  61514,
  5279,
  63421,
  134686,
  41436,
  8424,
  51925,
  10598,
  132295,
  124416,
  4604,
  194739,
  210929,
  57866,
  31829,
  51626,
  50007,
  9976,
  91878,
  61906,
  56168,
  81906,
  60918,
  61859,
  40017,
  23059,
  16887,
  40927,
  62064,
  12785,
  32893,
  32913,
  21782,
  93965,
  20169,
  44387,
  79084,
  38463,
  11457,
  93950,
  27127,
  157050,
  2697,
  337088,
  5116,
  54128,
  48255,
  33279,
  8821,
  27352,
  25515,
  124022,
  65710,
  28906,
  38557,
  33390,
  1722,
  104435,
  72215,
  38551,
  12094,
  30978,
  25113,
  6671,
  37355,
  175109,
  42862,
  98024,
  65406,
  221276,
  59624,
  118012,
  64637,
  78760,
  86697,
  21426,
  1639,
  40350,
  12584,
  67193,
  84144,
  31396,
  7863,
  143011,
  69629,
  63112,
  9454,
  28666,
  65798,
  46372,
  134721,
  6314,
  51402,
  30837,
  151922,
  2847,
  38676,
  38008,
  92823,
  136245,
  17540,
  5504,
  109295,
  205242,
  37606,
  5211,
  214892,
  1586,
  20670,
  208711,
  137743,
  19328,
  40652,
  16995,
  20023,
  14657,
  154919,
  34422,
  12996,
  13918,
  38221,
  47690,
  16398,
  2959,
  37680,
  89122,
  6721,
  198469,
  91876,
  172043,
  83898,
  101992,
  26084,
  94570,
  3635,
  76958,
  22853,
  76497,
  38266,
  176590,
  168403,
  44464,
  142840,
  79180,
  184594,
  1984,
  41806,
  83147,
  11985,
  6546,
  366068,
  59732,
  24533,
  271505,
  8736,
  39084,
  222992,
  93429,
  28962,
  58985,
  86665,
  8432,
  30028,
  14548,
  32439,
  54424,
  165029,
  55175,
  27458,
  69046,
  121277,
  46168,
  33732,
  20661,
  24581,
  135574,
  123110,
  37556,
  79260,
  72611,
  16957,
  12939,
  46162,
  58238,
  44907,
  72936,
  253758,
  41324,
  32518,
  96480,
  11949,
  124438,
  65280,
  43256,
  34107,
  53533,
  43531,
  37037,
  28366,
  45970,
  32741,
  173438,
  6121,
  194202,
  62969,
  26355,
  30314,
  58370,
  28455,
  1848,
  50519,
  82830,
  90393,
  21761,
  295490,
  10936,
  256940,
  133568,
  44050,
  20269,
  4089,
  27457,
  21610,
  219460,
  36743,
  14821,
  101388,
  52005,
  13124,
  30979,
  140816,
  167362,
  26054,
  18458,
  60789,
  34917,
  40447,
  26606,
  33422,
  9066,
  3452,
  83614,
  5761,
  20263,
  137238,
  25038,
  91310,
  101,
  52322,
  74548,
  42572,
  38084,
  214054,
  186568,
  31802,
  17665,
  30620,
  141936,
  37730,
  14420,
  4265,
  187218,
  49640,
  188208,
  51441,
  55388,
  96452,
  66659,
  40869,
  42039,
  60967,
  221027,
  19234,
  178581,
  29105,
  96050,
  9165,
  196118,
  157335,
  3738,
  40354,
  117436,
  2965,
  34136,
  59659,
  15570,
  50843,
  230035,
  31444,
  71260,
  43886,
  18316,
  5387,
  38500,
  168508,
  17406,
  32174,
  8828,
  103373,
  143806,
  90367,
  3560,
  18719,
  122310,
  16508,
  26719,
  2541,
  105429,
  6645,
  37998,
  73190,
  10591,
  235916,
  49737,
  87112,
  233941,
  53188,
  32193,
  79154,
  4544,
  52905,
  126477,
  7580,
  63501,
  57314,
  3216,
  31337,
  6541,
  103083,
  60846,
  49,
  9756,
  15481,
  1355,
  43840,
  14319,
  13743,
  27486,
  10222,
  73114,
  230718,
  418644,
  16706,
  6674,
  279748,
  23058,
  45273,
  295831,
  86306,
  2743,
  5535,
  88773,
  21829,
  35253,
  120938,
  31153,
  3169,
  16839,
  42847,
  8751,
  80974,
  33942,
  36867,
  35514,
  16485,
  26474,
  77775,
  56877,
  5391,
  48346,
  3882,
  108713,
  31403,
  27804,
  55248,
  26235,
  43821,
  136104,
  40118,
  175507,
  28034,
  203908,
  18732,
  1788,
  34030,
  106427,
  36958,
  54359,
  7251,
  44936,
  15356,
  69139,
  455,
  157915,
  22173,
  140291,
  50348,
  43275,
  82066,
  49621,
  54952,
  15216,
  36226,
  96695,
  66855,
  6936,
  1987,
  8227,
  196087,
  4631,
  68827,
  99004,
  47541,
  110265,
  17953,
  147605,
  110242,
  58520,
  31312,
  38724,
  329975,
  642,
  3155,
  34497,
  75937,
  6207,
  73843,
  6120,
  17249,
  51429,
  117746,
  3218,
  910,
  68961,
  319671,
  14938,
  29555,
  34700,
  1649,
  66673,
  72268,
  9655,
  76800,
  153087,
  6941,
  210168,
  27130,
  35398,
  1780,
  73242,
  3135,
  56689,
  19556,
  165307,
  8765,
  35967,
  121458,
  13333,
  70453,
  17350,
  117253,
  22265,
  13340,
  44265,
  39869,
  441,
  3742,
  135025,
  23581,
  33309,
  16543,
  17731,
  13291,
  157637,
  283005,
  21408,
  101360,
  63887,
  52312,
  83873,
  5338,
  233779,
  23759,
  186949,
  34531,
  177320,
  38069,
  156465,
  91004,
  19353,
  59852,
  68160,
  14891,
  1338,
  1072,
  29823,
  1950,
  28901,
  81407,
  313445,
  73038,
  84807,
  162348,
  240257,
  37162,
  138934,
  16111,
  58013,
  41253,
  102951,
  16457,
  96056,
  19541,
  56402,
  67217,
  41638,
  94381,
  89674,
  29481,
  37456,
  80815,
  151579,
  13937,
  13683,
  132537,
  19699,
  134545,
  67020,
  29816,
  222341,
  141235,
  427578,
  48868,
  129557,
  233342,
  23077,
  87871,
  16213,
  18728,
  16184,
  9469,
  37913,
  19680,
  2798,
  171356,
  178328,
  13216,
  50049,
  72690,
  71904,
  124644,
  55455,
  7504,
  29052,
  41036,
  266546,
  19899,
  30391,
  188755,
  8659,
  59469,
  16,
  104298,
  112943,
  53865,
  76203,
  138226,
  68857,
  139953,
  14125,
  107625,
  119795,
  173133,
  4398,
  50273,
  48808,
  54390,
  16466,
  122086,
  31835,
  67035,
  50971,
  48859,
  7508,
  46427,
  66477,
  73021,
  84615,
  39985,
  83076,
  46779,
  201569,
  53336,
  36443,
  60865,
  168164,
  143810,
  51393,
  25548,
  169307,
  32896,
  24485,
  38424,
  21837,
  29087,
  275813,
  51674,
  6714,
  64883,
  46169,
  187369,
  55186,
  76192,
  12852,
  12018,
  62134,
  31067,
  118303,
  16542,
  12125,
  10579,
  4928,
  26291,
  43854,
  7091,
  10946,
  253716,
  109062,
  39283,
  17261,
  113012,
  258512,
  47764,
  125126,
  32646,
  55892,
  80279,
  201623,
  149872,
  3192,
  385,
  1208,
  48750,
  5376,
  58738,
  22335,
  5427,
  82416,
  47811,
  32435,
  143086,
  38930,
  94128,
  59975,
  156037,
  37977,
  38224,
  62485,
  7698,
  50405,
  71027,
  16462,
  21559,
  136153,
  34131,
  107506,
  162069,
  63703,
  3101,
  215029,
  40407,
  4178,
  3774,
  9187,
  80019,
  17880,
  97926,
  67579,
  2600,
  18405,
  8351,
  47924,
  86638,
  70820,
  92206,
  86453,
  29610,
  42241,
  119200,
  3198,
  15466,
  67813,
  57863,
  35454,
  4779,
  99518,
  4649,
  104641,
  144269,
  33730,
  38073,
  65864,
  6838,
  109456,
  193298,
  154007,
  5623,
  45741,
  30846,
  182578,
  25573,
  157224,
  1543,
  58575,
  138703,
  146140,
  44971,
  49356,
  18275,
  59064,
  20300,
  13122,
  11848,
  24453,
  11973,
  9797,
  86843,
  2919,
  25530,
  49210,
  1130,
  161220,
  76788,
  75373,
  85604,
  34926,
  36014,
  17777,
  17255,
  51533,
  11676,
  92226,
  51845,
  119859,
  21525,
  5936,
  18507,
  28050,
  1140,
  31418,
  14857,
  34207,
  47859,
  10750,
  36382,
  32079,
  106909,
  59426,
  87757,
  38393,
  110042,
  15965,
  97104,
  33757,
  35344,
  97993,
  53979,
  33651,
  45407,
  41884,
  82515,
  173089,
  7177,
  58371,
  35365,
  47543,
  51927,
  35587,
  10670,
  23544,
  29306,
  84233,
  39976,
  76076,
  62097,
  9007,
  8668,
  28119,
  78281,
  120790,
  19835,
  143020,
  54968,
  18670,
  64959,
  20649,
  34469,
  42570,
  33001,
  136570,
  87796,
  120044,
  1106,
  58700,
  63951,
  127623,
  12805,
  83057,
  40212,
  31773,
  49850,
  7361,
  54336,
  347524,
  101314,
  23751,
  19569,
  48791,
  29174,
  49369,
  20467,
  7465,
  75842,
  38281,
  623,
  112457,
  60210,
  28849,
  51003,
  94720,
  6426,
  90047,
  85560,
  43761,
  3579,
  85105,
  34607,
  90410,
  118528,
  7224,
  42907,
  111163,
  18168,
  6960,
  161135,
  191298,
  5247,
  100584,
  127552,
  171568,
  20121,
  91173,
  12636,
  54615,
  20199,
  63730,
  98105,
  2396,
  40387,
  14438,
  125012,
  4765,
  33235,
  12865,
  45299,
  37728,
  82098,
  77872,
  114037,
  59253,
  19675,
  24838,
  398016,
  102561,
  11446,
  17069,
  57508,
  178277,
  65836,
  99941,
  26114,
  2585,
  271882,
  136866,
  50126,
  11027,
  155648,
  118367,
  14585,
  8910,
  123015,
  335383,
  40434,
  41016,
  53021,
  14439,
  87098,
  176860,
  201543,
  121888,
  2358,
  9286,
  5739,
  22666,
  54270,
  37884,
  169381,
  33984,
  93859,
  16124,
  89364,
  72207,
  51639,
  76366,
  99029,
  65812,
  2198,
  12147,
  174891,
  194289,
  6986,
  30252,
  88822,
  21284,
  11445,
  288337,
  160821,
  33034,
  100869,
  43852,
  25761,
  52882,
  1144,
  103809,
  1924,
  84458,
  86079,
  43411,
  13542,
  139276,
  18141,
  34978,
  41298,
  7276,
  26481,
  173800,
  33210,
  17951,
  142652,
  33616,
  33677,
  2210,
  19941,
  98568,
  2486,
  192414,
  80136,
  12058,
  235883,
  50963,
  249638,
  29572,
  27221,
  47034,
  6124,
  72107,
  63346,
  97620,
  158513,
  299699,
  40388,
  23235,
  37176,
  224244,
  198386,
  121323,
  67992,
  23827,
  63170,
  17838,
  106622,
  158590,
  26807,
  5345,
  23489,
  91891,
  55474,
  74834,
  37981,
  13058,
  5977,
  72552,
  34706,
  26828,
  145172,
  19904,
  21367,
  34043,
  960,
  77092,
  91381,
  4733,
  47446,
  7680,
  41697,
  5170,
  16960,
  14741,
  46101,
  13656,
  473,
  51842,
  37433,
  11103,
  11551,
  121951,
  13191,
  97536,
  165932,
  50397,
  51628,
  129028,
  9069,
  44885,
  6590,
  59195,
  47045,
  32940,
  225472,
  90345,
  21833,
  13303,
  29407,
  96615,
  141951,
  5198,
  6028,
  18395,
  7181,
  3861,
  14966,
  156358,
  167182,
  36529,
  55253,
  25942,
  173153,
  30959,
  27261,
  50691,
  150176,
  162201,
  38467,
  48462,
  80602,
  42163,
  118482,
  168,
  108756,
  26011,
  17166,
  54149,
  456538,
  22512,
  91374,
  13816,
  90358,
  131615,
  18132,
  226707,
  1824,
  28139,
  26860,
  42253,
  93877,
  77351,
  65575,
  8980,
  80574,
  22020,
  27948,
  40422,
  91324,
  76376,
  13528,
  39281,
  91685,
  82215,
  122541,
  144066,
  1983,
  193851,
  17283,
  26320,
  2739,
  194978,
  4790,
  26845,
  42627,
  61300,
  65815,
  174612,
  55133,
  4200,
  191130,
  79771,
  158321,
  52280,
  166796,
  221620,
  62461,
  11278,
  4067,
  88152,
  83409,
  31717,
  121367,
  13522,
  47325,
  37945,
  10406,
  174348,
  249321,
  154101,
  64912,
  29938,
  51775,
  17220,
  15776,
  166138,
  78890,
  84425,
  54121,
  42861,
  16368,
  24572,
  291647,
  10197,
  32073,
  22651,
  11677,
  97509,
  26952,
  35787,
  18424,
  41910,
  71614,
  94977,
  72318,
  41594,
  70024,
  275419,
  37702,
  60199,
  7335,
  39107,
  61315,
  18271,
  18394,
  33768,
  87884,
  104277,
  123724,
  7277,
  56288,
  71981,
  189803,
  49320,
  3352,
  6798,
  14240,
  8954,
  69220,
  94433,
  57372,
  28620,
  68863,
  193727,
  85575,
  42309,
  41667,
  67689,
  42081,
  22543,
  44824,
  12719,
  28540,
  114236,
  101553,
  27638,
  27296,
  4300,
  5353,
  4663,
  19379,
  94098,
  3758,
  95888,
  95144,
  80344,
  87320,
  28447,
  259518,
  12718,
  71391,
  152731,
  37063,
  24132,
  31911,
  104896,
  15672,
  103782,
  1521,
  4945,
  72541,
  23717,
  122632,
  15619,
  87175,
  206120,
  29428,
  189780,
  61416,
  28350,
  44457,
  972,
  1175,
  47233,
  198738,
  95789,
  41907,
  21953,
  97034,
  59341,
  22864,
  53713,
  16873,
  32971,
  20693,
  20954,
  31336,
  21477,
  16169,
  38370,
  16412,
  9019,
  3841,
  24599,
  21938,
  17085,
  6484,
  81198,
  76413,
  5849,
  72514,
  12320,
  65247,
  276175,
  37234,
  59796,
  52642,
  16312,
  57349,
  198507,
  94148,
  46134,
  18958,
  125552,
  1747,
  18725,
  151873,
  14901,
  5490,
  68287,
  29470,
  3689,
  64794,
  40814,
  26018,
  25692,
  54450,
  2703,
  88278,
  124886,
  173087,
  174e3,
  24159,
  179477,
  24276,
  46004,
  201876,
  209202,
  445,
  52876,
  31948,
  30206,
  157610,
  39180,
  18439,
  44124,
  50469,
  5774,
  96278,
  222758,
  200216,
  50290,
  45486,
  20435,
  46986,
  46276,
  140133,
  142326,
  15569,
  13363,
  47522,
  92583,
  2182,
  7135,
  16853,
  22998,
  30272,
  4952,
  63263,
  35623,
  39096,
  53789,
  44864,
  20053,
  110392,
  124213,
  4630,
  16087,
  28221,
  127787,
  25839,
  77481,
  44693,
  13464,
  113146,
  6983,
  27069,
  55717,
  50102,
  4760,
  7107,
  26186,
  66507,
  59145,
  36032,
  104182,
  71328,
  29425,
  64317,
  50781,
  47465,
  94298,
  69706,
  74899,
  22754,
  120756,
  25108,
  93077,
  56834,
  73286,
  39928,
  16218,
  41699,
  176763,
  7555,
  70819,
  50083,
  26895,
  23315,
  26014,
  16773,
  123079,
  41712,
  5719,
  31516,
  90427,
  158540,
  85051,
  183128,
  40864,
  27505,
  55392,
  9058,
  45224,
  96857,
  30901,
  136622,
  96557,
  56304,
  120061,
  11501,
  151448,
  5773,
  89743,
  7769,
  86069,
  2935,
  18471,
  41628,
  10114,
  33660,
  110170,
  49479,
  26745,
  92846,
  33221,
  26731,
  18795,
  87076,
  8550,
  2100,
  29972,
  120289,
  3077,
  72490,
  33784,
  2630,
  208722,
  50861,
  63483,
  79029,
  6419,
  39467,
  14302,
  45286,
  64207,
  9686,
  67513,
  44170,
  1050,
  77246,
  59266,
  17055,
  53801,
  7150,
  11111,
  42432,
  4278,
  94579,
  362117,
  36175,
  42902,
  41933,
  39002,
  98489,
  22913,
  74161,
  84773,
  57036,
  17556,
  162288,
  74485,
  178760,
  93867,
  73635,
  128860,
  50362,
  261,
  67455,
  80001,
  46080,
  35662,
  4368,
  25247,
  19230,
  74393,
  22588,
  1822,
  27682,
  235324,
  13798,
  85998,
  13194,
  235067,
  23514,
  71669,
  147632,
  23191,
  134748,
  214683,
  105101,
  1518,
  25489,
  247114,
  7380,
  54842,
  26922,
  3971,
  26361,
  20844,
  68642,
  170517,
  77339,
  123255,
  8963,
  77818,
  150998,
  48466,
  36806,
  2732,
  23261,
  11741,
  236162,
  18243,
  126216,
  28690,
  50546,
  16385,
  92760,
  197383,
  246558,
  201295,
  88255,
  67588,
  71687,
  176076,
  172653,
  169058,
  33906,
  63747,
  24835,
  157621,
  43338,
  30050,
  46152,
  132741,
  2770,
  51371,
  94835,
  6614,
  15112,
  11749,
  56936,
  1250,
  19027,
  399017,
  58036,
  100215,
  23388,
  55815,
  308768,
  124152,
  94803,
  9521,
  64186,
  8971,
  28,
  30427,
  62163,
  7616,
  103838,
  35079,
  29203,
  131235,
  7743,
  17389,
  10882,
  37420,
  61460,
  228512,
  85363,
  41581,
  131077,
  62822,
  119647,
  10130,
  54445,
  26925,
  19968,
  29016,
  24446,
  74028,
  24176,
  61448,
  67185,
  9254,
  8563,
  119129,
  9771,
  99184,
  37716,
  39514,
  10532,
  221512,
  258753,
  218630,
  55980,
  23394,
  32141,
  61924,
  66749,
  32411,
  3741,
  36475,
  26678,
  77010,
  44946,
  91203,
  128749,
  116953,
  20476,
  49625,
  53116,
  13735,
  102335,
  29376,
  51946,
  83407,
  67892,
  59212,
  34685,
  21083,
  1546,
  112982,
  32972,
  74397,
  1078,
  190545,
  16082,
  86140,
  58591,
  89611,
  101531,
  10061,
  105104,
  76319,
  20035,
  17551,
  52611,
  169061,
  190842,
  100780,
  23907,
  90413,
  115619,
  9675,
  34710,
  193435,
  49443,
  129734,
  11183,
  258877,
  16318,
  136182,
  126808,
  44635,
  27304,
  192375,
  2599,
  125648,
  47051,
  12091,
  23814,
  721,
  58800,
  40137,
  66726,
  97930,
  60877,
  74487,
  7942,
  54326,
  9841,
  41428,
  13762,
  8211,
  85383,
  6950,
  99177,
  79806,
  201786,
  296464,
  124087,
  13144,
  29741,
  41721,
  47634,
  55088,
  254286,
  106408,
  17041,
  99064,
  12942,
  64086,
  45233,
  14005,
  2612,
  55827,
  255,
  7984,
  13980,
  38574,
  12776,
  46654,
  73499,
  249951,
  2101,
  26676,
  25996,
  132326,
  116415,
  119062,
  50449,
  31033,
  23038,
  11589,
  179252,
  20007,
  14860,
  129270,
  21143,
  17796,
  144715,
  60106,
  70758,
  69842,
  34674,
  282133,
  44014,
  16774,
  57268,
  38528,
  24053,
  46373,
  201667,
  28327,
  471023,
  51889,
  102667,
  21193,
  114909,
  84132,
  69317,
  96723,
  67969,
  16134,
  68145,
  15058,
  28765,
  32035,
  2524,
  101089,
  98664,
  25045,
  76571,
  14957,
  86040,
  118506,
  262428,
  154764,
  81573,
  39681,
  283900,
  73287,
  127825,
  544,
  80448,
  52347,
  38512,
  175971,
  15180,
  45467,
  33086,
  46552,
  48894,
  81107,
  43213,
  36672,
  54025,
  76703,
  8053,
  7608,
  13299,
  56619,
  20752,
  238099,
  54164,
  105133,
  1444,
  32942,
  953,
  37564,
  8e3,
  66316,
  119463,
  106817,
  404,
  13667,
  149108,
  128597,
  31267,
  10269,
  49836,
  106150,
  1484,
  52330,
  76965,
  160486,
  171648,
  38456,
  31263,
  22424,
  37738,
  66245,
  67467,
  143369,
  60471,
  75610,
  20895,
  115528,
  86070,
  60854,
  40796,
  49347,
  18989,
  15030,
  11371,
  37578,
  15779,
  79867,
  10187,
  86462,
  46402,
  155626,
  93200,
  40229,
  7090,
  57547,
  108053,
  99598,
  11088,
  47505,
  41218,
  206017,
  2173,
  20988,
  30219,
  22919,
  80563,
  57566,
  42369,
  93141,
  41675,
  2407,
  182519,
  120495,
  27154,
  16702,
  29456,
  14349,
  7958,
  16688,
  117177,
  140375,
  42467,
  261919,
  74916,
  153569,
  10836,
  34742,
  49526,
  7621,
  105997,
  12212,
  2270,
  392377,
  7755,
  17959,
  25086,
  232152,
  138791,
  33847,
  13860,
  35316,
  5811,
  1344,
  71259,
  50452,
  207539,
  92635,
  50359,
  5821,
  33674,
  30255,
  2086,
  2587,
  96264,
  17543,
  42,
  6029,
  9580,
  43007,
  139248,
  82831,
  12917,
  29607,
  25786,
  51467,
  42137,
  85161,
  100698,
  31561,
  88989,
  121990,
  278500,
  3602,
  109344,
  37982,
  15279,
  116442,
  28936,
  30880,
  87894,
  58079,
  128661,
  126731,
  67392,
  28051,
  146885,
  4861,
  16216,
  97344,
  42827,
  147561,
  153948,
  22684,
  21335,
  47685,
  1853,
  43349,
  15185,
  59642,
  10229,
  25520,
  187921,
  108972,
  5579,
  98037,
  24945,
  6697,
  19193,
  63734,
  137934,
  75056,
  89740,
  19767,
  224268,
  56138,
  63643,
  151661,
  39313,
  70618,
  84031,
  89723,
  84074,
  13703,
  85626,
  35460,
  8867,
  64845,
  3439,
  57906,
  99776,
  63968,
  49270,
  81130,
  34356,
  16210,
  23547,
  36446,
  34090,
  140028,
  72439,
  2221,
  22163,
  57058,
  363492,
  113754,
  18913,
  95451,
  48663,
  54464,
  54037,
  176097,
  68425,
  3023,
  34906,
  29482,
  117389,
  341780,
  80431,
  58330,
  16753,
  92616,
  60907,
  94846,
  147486,
  4498,
  48646,
  7773,
  46801,
  7778,
  18946,
  464978,
  47558,
  33223,
  177444,
  7328,
  15626,
  63337,
  94700,
  11743,
  9351,
  255024,
  39098,
  16447,
  42647,
  96230,
  39769,
  58840,
  10068,
  63439,
  35800,
  65843,
  58823,
  413844,
  9156,
  51258,
  7434,
  61791,
  85018,
  6872,
  3692,
  28096,
  7121,
  33024,
  6009,
  75532,
  31997,
  192535,
  9661,
  3304,
  9547,
  14753,
  31987,
  25314,
  55689,
  15896,
  20430,
  39472,
  31340,
  99744,
  25398,
  115569,
  54883,
  28719,
  205423,
  23071,
  57855,
  64638,
  149867,
  25671,
  82403,
  37616,
  20668,
  39989,
  77996,
  74948,
  140555,
  175248,
  64810,
  36515,
  46595,
  4958,
  248773,
  24045,
  28728,
  136673,
  168704,
  20804,
  114833,
  100325,
  27135,
  21205,
  96151,
  153134,
  45992,
  7093,
  13992,
  76047,
  1980,
  19432,
  145001,
  75159,
  87462,
  17710,
  1013,
  45556,
  34297,
  144882,
  20648,
  26061,
  11319,
  129567,
  108555,
  18872,
  464580,
  33386,
  22717,
  65948,
  167189,
  5603,
  135042,
  79542,
  8801,
  202632,
  18114,
  91882,
  5973,
  5239,
  67315,
  4431,
  60916,
  47819,
  71693,
  32597,
  32606,
  18183,
  45072,
  80329,
  76385,
  24749,
  51305,
  40314,
  156514,
  14693,
  130345,
  13168,
  66214,
  18029,
  12858,
  34801,
  27628,
  14544,
  10823,
  40522,
  40185,
  33739,
  148694,
  23548,
  9923,
  61012,
  28859,
  17933,
  19442,
  34364,
  99849,
  164107,
  141167,
  30629,
  21054,
  6744,
  36491,
  8096,
  42474,
  41706,
  155060,
  30650,
  10600,
  163442,
  1143,
  96655,
  61390,
  52359,
  7559,
  51568,
  64256,
  203854,
  4467,
  22453,
  14504,
  436398,
  7878,
  6980,
  8293,
  63610,
  293747,
  16167,
  35763,
  19627,
  147603,
  15419,
  18032,
  110744,
  51346,
  33681,
  54571,
  40472,
  48615,
  39073,
  21604,
  13754,
  173027,
  92560,
  11083,
  47299,
  63062,
  11813,
  52007,
  29883,
  9734,
  139722,
  15953,
  1550,
  20651,
  13616,
  49306,
  16113,
  90089,
  92326,
  7584,
  30712,
  72424,
  164858,
  6831,
  152871,
  55746,
  197721,
  34167,
  196442,
  6022,
  112107,
  55215,
  7538,
  123381,
  4920,
  43539,
  77165,
  8939,
  50392,
  34192,
  20225,
  79762,
  22505,
  58667,
  40770,
  29788,
  97180,
  82835,
  4568,
  8579,
  13273,
  363569,
  35898,
  49983,
  436,
  36598,
  3237,
  131691,
  62418,
  35591,
  8101,
  4073,
  379438,
  65218,
  76072,
  33887,
  2968,
  27573,
  212619,
  288680,
  68278,
  72851,
  150504,
  217896,
  6913,
  121339,
  22017,
  35340,
  51072,
  43616,
  75043,
  31437,
  10833,
  81487,
  4364,
  22968,
  41454,
  106687,
  85446,
  19863,
  109625,
  149241,
  524,
  141850,
  214404,
  54376,
  657,
  237023,
  9401,
  108137,
  53800,
  32474,
  49712,
  53334,
  126876,
  27337,
  45552,
  177696,
  8269,
  15036,
  12097,
  42240,
  2328,
  125374,
  119295,
  99715,
  2500,
  19624,
  39441,
  27220,
  102691,
  60957,
  94543,
  39101,
  18566,
  67362,
  13975,
  78230,
  25017,
  34017,
  239007,
  90027,
  39351,
  41681,
  35354,
  43822,
  1043,
  916,
  58587,
  141983,
  94818,
  38799,
  75459,
  41114,
  67432,
  16195,
  36606,
  59568,
  22272,
  126769,
  31424,
  68659,
  12287,
  134302,
  257977,
  5756,
  207285,
  95637,
  47248,
  117689,
  19583,
  77451,
  22373,
  12200,
  54993,
  117118,
  34244,
  29386,
  34562,
  53819,
  71267,
  64172,
  77665,
  49368,
  7716,
  59301,
  25749,
  45426,
  194789,
  17297,
  2650,
  1766,
  32501,
  45198,
  20403,
  20984,
  6600,
  14171,
  94604,
  19037,
  5402,
  29896,
  9938,
  59935,
  109708,
  88081,
  145182,
  44844,
  39167,
  352626,
  164173,
  35374,
  45982,
  6122,
  154,
  73419,
  220487,
  53834,
  53601,
  17992,
  8609,
  229321,
  5610,
  68098,
  66815,
  71012,
  95069,
  140968,
  27396,
  8957,
  134489,
  24656,
  86659,
  56598,
  134852,
  17316,
  123838,
  255436,
  6613,
  41610,
  138033,
  81452,
  32023,
  32396,
  123687,
  63398,
  8693,
  29712,
  30407,
  19296,
  121188,
  3551,
  36099,
  20032,
  111948,
  56624,
  16547,
  27453,
  35916,
  15378,
  52039,
  56849,
  13489,
  22214,
  73177,
  53097,
  277349,
  2157,
  14029,
  187886,
  10260,
  141743,
  246460,
  91880,
  50869,
  3788,
  49486,
  133566,
  54950,
  33120,
  129337,
  53768,
  18333,
  9525,
  26902,
  312251,
  10297,
  9020,
  70759,
  16647,
  112432,
  59260,
  84609,
  9818,
  82766,
  73569,
  468,
  46001,
  75780,
  55028,
  52106,
  11498,
  43645,
  108069,
  17150,
  17753,
  29417,
  16705,
  31799,
  9606,
  289,
  122254,
  115975,
  8620,
  6133,
  255357,
  56908,
  14456,
  133464,
  43554,
  79224,
  11247,
  29630,
  160,
  12756,
  25464,
  65960,
  350428,
  62521,
  321796,
  100359,
  67358,
  35169,
  46172,
  113128,
  48988,
  88868,
  31094,
  33266,
  6847,
  60887,
  98188,
  49659,
  69117,
  92977,
  220228,
  13947,
  80181,
  35103,
  62170,
  97351,
  13475,
  2440,
  199768,
  19498,
  36597,
  46971,
  25234,
  67806,
  62881,
  84717,
  73648,
  181966,
  10488,
  94149,
  21550,
  26655,
  63436,
  48375,
  14405,
  165650,
  9621,
  24439,
  28043,
  42735,
  4490,
  29963,
  56674,
  45373,
  1934,
  262446,
  50855,
  67098,
  26898,
  5261,
  52696,
  40644,
  33900,
  9440,
  180286,
  87162,
  22940,
  19704,
  26936,
  69769,
  10254,
  101759,
  27406,
  12243,
  48e3,
  73926,
  113215,
  54935,
  5726,
  192787,
  4312,
  106216,
  9366,
  11550,
  52949,
  23457,
  212271,
  277152,
  133895,
  108374,
  6191,
  96477,
  29980,
  218916,
  58024,
  54696,
  40853,
  91124,
  65894,
  91170,
  65908,
  252552,
  6793,
  29212,
  15389,
  44516,
  122515,
  52617,
  35058,
  9017,
  103536,
  39510,
  49136,
  19242,
  130652,
  662077,
  74699,
  47024,
  31422,
  8517,
  73351,
  24399,
  13867,
  128360,
  4810,
  4434,
  61779,
  111983,
  61036,
  17798,
  110240,
  59722,
  102960,
  39688,
  10001,
  23803,
  23039,
  176498,
  56659,
  44814,
  134295,
  17188,
  77577,
  74466,
  226175,
  102472,
  154333,
  63900,
  111747,
  18062,
  41171,
  79669,
  32773,
  408933,
  42562,
  28931,
  30907,
  107388,
  43487,
  2946,
  240310,
  23938,
  24354,
  319,
  184983,
  7927,
  6488,
  1422,
  10790,
  68809,
  68209,
  64775,
  4361,
  202,
  17123,
  59634,
  51200,
  44391,
  18188,
  17843,
  2619,
  74278,
  3230,
  9540,
  47187,
  21702,
  36274,
  56894,
  43907,
  16310,
  34790,
  16866,
  6150,
  5561,
  13587,
  107545,
  108873,
  126867,
  86986,
  28640,
  33427,
  19017,
  5762,
  80637,
  17430,
  46903,
  2047,
  131055,
  25958,
  13558,
  5444,
  47152,
  13900,
  44563,
  122857,
  45348,
  70863,
  39593,
  54332,
  38068,
  33637,
  318,
  40310,
  143467,
  18502,
  24520,
  11377,
  62013,
  28942,
  27246,
  28269,
  83545,
  17999,
  59015,
  90707,
  30065,
  15161,
  34720,
  1263,
  37008,
  2012,
  6060,
  98575,
  92933,
  5721,
  299,
  199555,
  24578,
  29223,
  2985,
  743,
  115825,
  109523,
  136657,
  47454,
  26378,
  53586,
  3733,
  174945,
  93340,
  244456,
  5693,
  37386,
  28782,
  89767,
  27545,
  23573,
  18798,
  136425,
  34320,
  84778,
  20041,
  48453,
  38215,
  7477,
  71958,
  40621,
  8773,
  5874,
  187927,
  105965,
  51100,
  43533,
  18083,
  8443,
  10180,
  43597,
  2003,
  183999,
  69689,
  12216,
  129696,
  146188,
  62389,
  34044,
  68410,
  12765,
  43273,
  26949,
  266807,
  3345,
  34477,
  79197,
  5688,
  47539,
  213110,
  21634,
  22257,
  50092,
  32222,
  42346,
  39530,
  63668,
  98,
  134978,
  74022,
  5152,
  59088,
  174145,
  37220,
  9934,
  9545,
  118937,
  5724,
  87240,
  19875,
  15784,
  40143,
  23263,
  87513,
  181654,
  285152,
  37881,
  263241,
  4966,
  43934,
  10433,
  186657,
  6470,
  74416,
  225854,
  25908,
  142677,
  246262,
  32280,
  6192,
  75890,
  45546,
  143264,
  135305,
  29742,
  47013,
  77787,
  11732,
  126658,
  8763,
  37950,
  21806,
  57557,
  113464,
  89465,
  108995,
  164574,
  23894,
  22996,
  23169,
  15369,
  23117,
  17642,
  130607,
  40503,
  36239,
  280990,
  44666,
  9981,
  40427,
  147487,
  26869,
  168452,
  32886,
  32991,
  46798,
  240839,
  15111,
  70502,
  65697,
  88548,
  44145,
  28701,
  48767,
  31139,
  206777,
  35659,
  181164,
  166262,
  14554,
  171445,
  31786,
  66523,
  76607,
  17956,
  6507,
  31279,
  90476,
  116611,
  167918,
  6560,
  1243,
  115324,
  80128,
  41867,
  55897,
  187323,
  37069,
  32596,
  189444,
  145931,
  13390,
  105530,
  65709,
  26805,
  6999,
  55714,
  41300,
  22915,
  68951,
  22138,
  21120,
  22264,
  10058,
  19945,
  33635,
  56123,
  99085,
  10032,
  5818,
  6016,
  46649,
  57476,
  35264,
  94413,
  112522,
  262288,
  93686,
  83038,
  14341,
  23204,
  28807,
  66084,
  77987,
  6101,
  126673,
  7133,
  38126,
  5923,
  122091,
  170240,
  97772,
  46874,
  215746,
  43948,
  41622,
  3272,
  55596,
  8332,
  146411,
  251315,
  13533,
  8561,
  81521,
  115449,
  48616,
  175175,
  2063,
  186556,
  3036,
  134537,
  75772,
  29728,
  82360,
  22973,
  186559,
  86348,
  89100,
  38388,
  82297,
  45610,
  2613,
  87082,
  9986,
  177812,
  57884,
  23591,
  47485,
  42543,
  33582,
  44713,
  74439,
  257444,
  252451,
  31825,
  35631,
  38540,
  33066,
  5147,
  13973,
  4343,
  51830,
  70378,
  22827,
  26448,
  95560,
  36896,
  241741,
  48067,
  203953,
  298860,
  61620,
  20450,
  3220,
  67272,
  6586,
  107662,
  100160,
  108684,
  6929,
  57226,
  4762,
  7457,
  1320,
  40404,
  77204,
  99309,
  62750,
  208653,
  59977,
  44e3,
  74315,
  34332,
  5819,
  172217,
  64904,
  114077,
  18147,
  84012,
  1791,
  98456,
  90930,
  21446,
  116669,
  103938,
  7422,
  85140,
  59713,
  5768,
  326211,
  16239,
  75411,
  13229,
  29398,
  10758,
  236107,
  1539,
  112472,
  95979,
  152154,
  151294,
  306,
  21196,
  38146,
  10700,
  6891,
  84282,
  109646,
  56492,
  40539,
  6589,
  119491,
  51354,
  30685,
  140209,
  136906,
  29622,
  73617,
  49553,
  70525,
  51671,
  166869,
  139616,
  74395,
  37439,
  49595,
  45678,
  11959,
  33211,
  86560,
  52434,
  9282,
  62690,
  112155,
  130810,
  5243,
  108261,
  99970,
  265613,
  72551,
  80049,
  6391,
  33365,
  90721,
  66737,
  69872,
  87011,
  1860,
  9032,
  112544,
  60905,
  37371,
  89015,
  140351,
  19076,
  850,
  373531,
  2802,
  36725,
  218795,
  72062,
  28990,
  16550,
  24614,
  7815,
  6187,
  26336,
  33373,
  32162,
  42791,
  73555,
  32062,
  23386,
  10244,
  56392,
  49442,
  27076,
  136262,
  12412,
  14883,
  1134,
  33675,
  97153,
  199281,
  15608,
  100152,
  74072,
  47942,
  254301,
  36451,
  16026,
  10687,
  65067,
  56708,
  254030,
  30290,
  50490,
  13864,
  57941,
  259331,
  35588,
  23485,
  43486,
  24869,
  21620,
  92971,
  22072,
  88645,
  1048,
  182050,
  13343,
  32452,
  14825,
  19509,
  3325,
  216938,
  45740,
  99716,
  189082,
  53740,
  78245,
  25609,
  24311,
  176777,
  47340,
  308354,
  40669,
  66085,
  14102,
  125339,
  9225,
  128709,
  97207,
  1271,
  200933,
  78439,
  113451,
  88975,
  18324,
  46521,
  11819,
  18570,
  141756,
  72512,
  170020,
  52754,
  63550,
  118515,
  103073,
  93330,
  32736,
  50499,
  14722,
  31600,
  68452,
  398867,
  29316,
  172786,
  18417,
  104924,
  2606,
  5670,
  84818,
  16288,
  67106,
  59580,
  82929,
  607401,
  291,
  85829,
  359,
  15897,
  35830,
  50696,
  65630,
  52672,
  22115,
  356968,
  29895,
  40837,
  231192,
  34024,
  38957,
  26722,
  406,
  23335,
  124952,
  72068,
  68804,
  13268,
  147101,
  164740,
  276569,
  162596,
  66943,
  11569,
  26654,
  66358,
  4777,
  23229,
  102127,
  5848,
  978,
  2921,
  59666,
  5371,
  28212,
  90108,
  42938,
  39320,
  2499,
  4271,
  108792,
  33510,
  125072,
  71653,
  65239,
  38250,
  66357,
  38577,
  13964,
  86251,
  35708,
  50755,
  36010,
  29448,
  12209,
  3844,
  38222,
  206337,
  100876,
  67827,
  137088,
  14167,
  252225,
  84163,
  195270,
  1306,
  5703,
  54198,
  779,
  46802,
  22028,
  51124,
  86759,
  70560,
  113164,
  35685,
  162145,
  45471,
  34561,
  422,
  2611,
  6464,
  47486,
  19223,
  38246,
  9191,
  18331,
  89942,
  243642,
  212364,
  15893,
  17518,
  22617,
  6409,
  30046,
  126182,
  59716,
  36560,
  104428,
  18846,
  26592,
  19458,
  50793,
  147333,
  30826,
  1388,
  27647,
  10922,
  14495,
  33545,
  19269,
  135828,
  39727,
  41601,
  46931,
  233379,
  49169,
  131130,
  182112,
  16276,
  82381,
  118209,
  142445,
  128310,
  19672,
  28740,
  82907,
  33436,
  3118,
  102206,
  28723,
  24819,
  41937,
  38854,
  5157,
  3881,
  111491,
  1142,
  9776,
  421673,
  152241,
  29309,
  14961,
  87854,
  6054,
  15424,
  3796,
  82656,
  54996,
  2108,
  55367,
  239450,
  154525,
  9643,
  118103,
  106041,
  64601,
  68549,
  48707,
  30266,
  25772,
  18740,
  9462,
  229669,
  91798,
  112152,
  191327,
  14493,
  72828,
  8175,
  66636,
  236474,
  25817,
  87351,
  129027,
  76653,
  20422,
  22983,
  71240,
  27846,
  44661,
  12399,
  46158,
  77704,
  53101,
  35032,
  11072,
  17300,
  109294,
  33638,
  24408,
  1895,
  11241,
  760,
  17584,
  82479,
  125877,
  63150,
  141075,
  34259,
  23274,
  81698,
  15732,
  43577,
  48340,
  91584,
  14688,
  16379,
  24481,
  150280,
  96420,
  262050,
  48635,
  43727,
  61819,
  56268,
  72003,
  88178,
  17281,
  79912,
  13218,
  122519,
  125295,
  166396,
  11811,
  2171,
  118930,
  67746,
  17636,
  178278,
  174656,
  95661,
  173039,
  83845,
  79689,
  17473,
  98555,
  127696,
  203415,
  54730,
  22925,
  232239,
  9309,
  12136,
  175026,
  20740,
  180188,
  10747,
  39816,
  314017,
  266131,
  10040,
  175732,
  112550,
  220651,
  31974,
  37393,
  888,
  23008,
  86799,
  4303,
  64905,
  148467,
  75337,
  251,
  3284,
  370102,
  50264,
  9835,
  5438,
  23655,
  4481,
  29851,
  329,
  12855,
  7162,
  64931,
  78141,
  12804,
  42372,
  296771,
  83547,
  18624,
  34874,
  86271,
  3360,
  48665,
  77735,
  88767,
  11463,
  63527,
  28889,
  22258,
  29140,
  194315,
  113924,
  25499,
  6406,
  31334,
  1845,
  4802,
  49184,
  43455,
  35469,
  127594,
  92970,
  61038,
  115005,
  38840,
  87761,
  106838,
  8811,
  20572,
  55637,
  11162,
  96721,
  132425,
  108925,
  2948,
  125457,
  36356,
  3502,
  75270,
  27622,
  127192,
  2561,
  123095,
  49394,
  61155,
  16897,
  110064,
  9699,
  89448,
  53356,
  19628,
  220310,
  21622,
  83036,
  9885,
  112214,
  6087,
  26713,
  17901,
  161912,
  91492,
  3440,
  68594,
  9266,
  92238,
  8087,
  6866,
  150194,
  72175,
  80701,
  13459,
  31836,
  43243,
  239700,
  95846,
  44749,
  50647,
  21945,
  230538,
  120612,
  132371,
  244604,
  5193,
  105637,
  34661,
  41341,
  68775,
  85393,
  1874,
  8771,
  33718,
  49672,
  77403,
  595452,
  99507,
  6490,
  58895,
  128742,
  7704,
  39239,
  73217,
  43816,
  62824,
  37804,
  199976,
  22361,
  80005,
  87514,
  94832,
  14089,
  4574,
  139975,
  59142,
  75523,
  100268,
  43906,
  53442,
  15152,
  2547,
  186002,
  17011,
  19513,
  204282,
  3343,
  60568,
  128318,
  119250,
  4298,
  51871,
  41336,
  71759,
  21921,
  45074,
  98169,
  145889,
  99427,
  11350,
  1237,
  5520,
  28799,
  7803,
  53702,
  21026,
  136352,
  38293,
  128690,
  12158,
  90132,
  44600,
  10184,
  26957,
  39459,
  126025,
  78904,
  82999,
  59373,
  39301,
  150198,
  120529,
  153042,
  20177,
  50089,
  14764,
  271571,
  30530,
  123161,
  38975,
  101562,
  22941,
  5648,
  124654,
  109243,
  69817,
  71675,
  49162,
  106884,
  21241,
  107795,
  30258,
  16572,
  188262,
  141456,
  7688,
  60718,
  8271,
  11044,
  32440,
  104608,
  103419,
  236109,
  93156,
  43293,
  128929,
  42107,
  67180,
  25201,
  115254,
  185488,
  130954,
  72813,
  167547,
  20537,
  39969,
  38432,
  22582,
  184022,
  1139,
  27199,
  5655,
  17767,
  97412,
  122606,
  209377,
  27070,
  35871,
  326617,
  188954,
  42680,
  73512,
  80911,
  22629,
  3011,
  95021,
  315242,
  157737,
  383,
  41821,
  41808,
  19335,
  27950,
  15674,
  25677,
  110950,
  35375,
  76835,
  59108,
  57370,
  35262,
  16569,
  160415,
  37706,
  78086,
  32041,
  49691,
  137143,
  9782,
  172080,
  50148,
  77917,
  6323,
  10110,
  69172,
  17711,
  21795,
  59511,
  76184,
  135114,
  31046,
  132319,
  59105,
  157578,
  20549,
  80778,
  57649,
  158421,
  65143,
  4575,
  72235,
  21899,
  10797,
  92745,
  34035,
  106079,
  80159,
  4508,
  78304,
  25350,
  75457,
  46458,
  32937,
  25623,
  47,
  8531,
  104751,
  84953,
  8138,
  36508,
  187199,
  66310,
  115274,
  13253,
  32461,
  38536,
  1916,
  42007,
  187160,
  35055,
  26325,
  84394,
  35963,
  94216,
  45590,
  97782
];

// ../../node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js
var MAX_COMMON_PREFIX_LENGTH = 15;
var RoutingTableRefresh = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "peerRouting");
    __publicField(this, "routingTable");
    __publicField(this, "refreshInterval");
    __publicField(this, "refreshQueryTimeout");
    __publicField(this, "commonPrefixLengthRefreshedAt");
    __publicField(this, "refreshTimeoutId");
    const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:routing-table:refresh`);
    this.peerRouting = peerRouting;
    this.routingTable = routingTable;
    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;
    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;
    this.commonPrefixLengthRefreshedAt = [];
    this.refreshTable = this.refreshTable.bind(this);
  }
  async afterStart() {
    this.log(`refreshing routing table every ${this.refreshInterval}ms`);
    this.refreshTable(true);
  }
  async stop() {
    if (this.refreshTimeoutId != null) {
      clearTimeout(this.refreshTimeoutId);
    }
  }
  /**
   * To speed lookups, we seed the table with random PeerIds. This means
   * when we are asked to locate a peer on the network, we can find a KadId
   * that is close to the requested peer ID and query that, then network
   * peers will tell us who they know who is close to the fake ID
   */
  refreshTable(force = false, options2) {
    this.log("refreshing routing table");
    const prefixLength = this._maxCommonPrefix();
    const refreshCommonPrefixLengths = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
    this.log(`max common prefix length ${prefixLength}`);
    this.log(`tracked CPLs [ ${refreshCommonPrefixLengths.map((date) => date.toISOString()).join(", ")} ]`);
    Promise.all(refreshCommonPrefixLengths.map(async (lastRefresh, index) => {
      try {
        await this._refreshCommonPrefixLength(index, lastRefresh, force, options2);
        if (this._numPeersForCpl(prefixLength) === 0) {
          const lastCpl = Math.min(2 * (index + 1), refreshCommonPrefixLengths.length - 1);
          for (let n2 = index + 1; n2 < lastCpl + 1; n2++) {
            try {
              await this._refreshCommonPrefixLength(n2, lastRefresh, force, options2);
            } catch (err) {
              this.log.error("failed to refresh entries with common prefix length %d - %e", n2, err);
            }
          }
        }
      } catch (err) {
        this.log.error("failed to refresh entries with common prefix length - %e", err);
      }
    })).catch((err) => {
      this.log.error("failed to refresh table - %e", err);
    }).then(() => {
      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);
      if (this.refreshTimeoutId.unref != null) {
        this.refreshTimeoutId.unref();
      }
    }).catch((err) => {
      this.log.error("failed to set refresh timeout - %e", err);
    });
  }
  async _refreshCommonPrefixLength(cpl, lastRefresh, force, options2) {
    if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {
      this.log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
      return;
    }
    const peerId = this._generateRandomPeerId(cpl);
    this.log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId, this.routingTable.size);
    const signal = anySignal([options2?.signal, AbortSignal.timeout(this.refreshQueryTimeout)]);
    setMaxListeners(Infinity, signal);
    try {
      const peers = await src_default6(this.peerRouting.getClosestPeers(peerId.toMultihash().bytes, {
        signal
      }));
      this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId);
      this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId, this.routingTable.size);
    } finally {
      signal.clear();
    }
  }
  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
    }
    const dates = [];
    for (let i2 = 0; i2 <= maxCommonPrefix; i2++) {
      dates[i2] = this.commonPrefixLengthRefreshedAt[i2] ?? /* @__PURE__ */ new Date();
    }
    return dates;
  }
  _generateRandomPeerId(targetCommonPrefixLength) {
    if (this.routingTable.kb == null) {
      throw new Error("Routing table not started");
    }
    if (this.routingTable.kb.localPeer == null) {
      throw new Error("Local peer not set");
    }
    const randomData = randomBytes2(2);
    const randomUint16 = (randomData[1] << 8) + randomData[0];
    const key = this._makePeerId(this.routingTable.kb.localPeer.kadId, randomUint16, targetCommonPrefixLength);
    const multihash = decode4(key);
    return peerIdFromMultihash3(multihash);
  }
  _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
    }
    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
    const localPrefix = view.getUint16(0, false);
    const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
    const keyPrefix = generated_prefix_list_browser_default[targetPrefix];
    const keyBuffer = new ArrayBuffer(34);
    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
    keyView.setUint8(0, sha256.code);
    keyView.setUint8(1, 32);
    keyView.setUint32(2, keyPrefix, false);
    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
  }
  /**
   * returns the maximum common prefix length between any peer in the table
   * and the current peer
   */
  _maxCommonPrefix() {
    let prefixLength = 0;
    for (const length4 of this._prefixLengths()) {
      if (length4 > prefixLength) {
        prefixLength = length4;
      }
    }
    return prefixLength;
  }
  /**
   * Returns the number of peers in the table with a given prefix length
   */
  _numPeersForCpl(prefixLength) {
    let count = 0;
    for (const length4 of this._prefixLengths()) {
      if (length4 === prefixLength) {
        count++;
      }
    }
    return count;
  }
  /**
   * Yields the common prefix length of every peer in the table
   */
  *_prefixLengths() {
    if (this.routingTable.kb?.localPeer == null) {
      return;
    }
    for (const { kadId } of this.routingTable.kb.toIterable()) {
      const distance = xor(this.routingTable.kb.localPeer.kadId, kadId);
      let leadingZeros = 0;
      for (const byte of distance) {
        if (byte === 0) {
          leadingZeros++;
        } else {
          break;
        }
      }
      yield leadingZeros;
    }
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/add-provider.js
var AddProviderHandler = class {
  constructor(components, init) {
    __publicField(this, "peerId");
    __publicField(this, "providers");
    __publicField(this, "peerStore");
    __publicField(this, "log");
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:add-provider`);
    this.peerId = components.peerId;
    this.providers = init.providers;
    this.peerStore = components.peerStore;
  }
  async handle(peerId, msg) {
    if (msg.key == null || msg.key.length === 0) {
      throw new InvalidMessageError2("Missing key");
    }
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err) {
      throw new InvalidMessageError2("Invalid CID");
    }
    if (msg.providers == null || msg.providers.length === 0) {
      this.log.error("no providers found in message");
    }
    this.log("%p asked us, %p to store provider record for for %c", peerId, this.peerId, cid);
    await Promise.all(msg.providers.map(async (pi) => {
      const digest2 = decode4(pi.id);
      const providerId = peerIdFromMultihash3(digest2);
      const providerMultiaddrs = pi.multiaddrs.map((buf2) => multiaddr(buf2));
      if (!peerId.equals(providerId)) {
        this.log("invalid provider peer %p from %p", pi.id, peerId);
        return;
      }
      if (pi.multiaddrs.length < 1) {
        this.log("no valid addresses for provider %p. Ignore", peerId);
        return;
      }
      this.log.trace("received provider %p for %s (addrs %s)", peerId, cid, providerMultiaddrs);
      await this.providers.addProvider(cid, providerId);
      await this.peerStore.merge(providerId, {
        multiaddrs: providerMultiaddrs
      });
    }));
    return void 0;
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/find-node.js
var FindNodeHandler = class {
  constructor(components, init) {
    __publicField(this, "peerRouting");
    __publicField(this, "peerInfoMapper");
    __publicField(this, "peerId");
    __publicField(this, "addressManager");
    __publicField(this, "log");
    const { peerRouting, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:find-node`);
    this.peerId = components.peerId;
    this.addressManager = components.addressManager;
    this.peerRouting = peerRouting;
    this.peerInfoMapper = init.peerInfoMapper;
  }
  /**
   * Process `FindNode` DHT messages
   */
  async handle(peerId, msg) {
    this.log("incoming request from %p for peers close to %b", peerId, msg.key);
    try {
      if (msg.key == null) {
        throw new InvalidMessageError2("Invalid FIND_NODE message received - key was missing");
      }
      const closer = await this.peerRouting.getClosestPeersOffline(msg.key, {
        exclude: [
          // never tell a peer about itself
          peerId,
          // do not include the server in the results
          this.peerId
        ]
      });
      if (equals3(this.peerId.toMultihash().bytes, msg.key)) {
        closer.push({
          id: this.peerId,
          multiaddrs: this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(CODE_P2P2))
        });
      }
      const response = {
        type: MessageType.FIND_NODE,
        clusterLevel: msg.clusterLevel,
        closer: closer.map(this.peerInfoMapper).filter(({ multiaddrs }) => multiaddrs.length).map((peerInfo) => ({
          id: peerInfo.id.toMultihash().bytes,
          multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
        })),
        providers: []
      };
      if (response.closer.length === 0) {
        this.log("could not find any peers closer to %b for %p", msg.key, peerId);
      } else {
        this.log("found %d peers close to %b for %p", response.closer.length, msg.key, peerId);
      }
      return response;
    } catch (err) {
      this.log("error during finding peers closer to %b for %p - %e", msg.key, peerId, err);
      throw err;
    }
  }
};

// ../../node_modules/it-all/dist/src/index.js
function isAsyncIterable9(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function all(source) {
  if (isAsyncIterable9(source)) {
    return (async () => {
      const arr2 = [];
      for await (const entry of source) {
        arr2.push(entry);
      }
      return arr2;
    })();
  }
  const arr = [];
  for (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
var src_default8 = all;

// ../../node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-providers.js
var GetProvidersHandler = class {
  constructor(components, init) {
    __publicField(this, "peerId");
    __publicField(this, "peerRouting");
    __publicField(this, "providers");
    __publicField(this, "peerStore");
    __publicField(this, "peerInfoMapper");
    __publicField(this, "log");
    const { peerRouting, providers, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:get-providers`);
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.peerRouting = peerRouting;
    this.providers = providers;
    this.peerInfoMapper = init.peerInfoMapper;
  }
  async handle(peerId, msg) {
    if (msg.key == null) {
      throw new InvalidMessageError2("Invalid GET_PROVIDERS message received - key was missing");
    }
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err) {
      throw new InvalidMessageError2("Invalid CID");
    }
    this.log("%p asking for providers for %s", peerId, cid);
    const [providerPeers, closerPeers] = await Promise.all([
      src_default8(src_default5(await this.providers.getProviders(cid), async (peerId2) => {
        const peer = await this.peerStore.get(peerId2);
        const info = {
          id: peer.id,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        };
        return info;
      })),
      this.peerRouting.getClosestPeersOffline(msg.key)
    ]);
    const response = {
      type: MessageType.GET_PROVIDERS,
      key: msg.key,
      clusterLevel: msg.clusterLevel,
      closer: closerPeers.map(this.peerInfoMapper).filter(({ id, multiaddrs }) => multiaddrs.length > 0).map((peerInfo) => ({
        id: peerInfo.id.toMultihash().bytes,
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      })),
      providers: providerPeers.map(this.peerInfoMapper).filter(({ id, multiaddrs }) => multiaddrs.length > 0).map((peerInfo) => ({
        id: peerInfo.id.toMultihash().bytes,
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      }))
    };
    this.log("got %s providers %s closerPeers", response.providers.length, response.closer.length);
    return response;
  }
  async _getAddresses(peerId) {
    return [];
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-value.js
var GetValueHandler = class {
  constructor(components, init) {
    __publicField(this, "peerStore");
    __publicField(this, "datastore");
    __publicField(this, "peerRouting");
    __publicField(this, "log");
    __publicField(this, "datastorePrefix");
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:get-value`);
    this.datastorePrefix = `${init.datastorePrefix}/record`;
    this.peerStore = components.peerStore;
    this.datastore = components.datastore;
    this.peerRouting = init.peerRouting;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    this.log("%p asked for key %b", peerId, key);
    if (key == null || key.length === 0) {
      throw new InvalidMessageError2("Invalid key");
    }
    const response = {
      type: MessageType.GET_VALUE,
      key,
      clusterLevel: msg.clusterLevel,
      closer: [],
      providers: []
    };
    if (isPublicKeyKey(key)) {
      this.log("is public key");
      const idFromKey = fromPublicKeyKey(key);
      let pubKey;
      try {
        const peer = await this.peerStore.get(idFromKey);
        if (peer.id.publicKey == null) {
          throw new NotFoundError2("No public key found in key book");
        }
        pubKey = publicKeyToProtobuf(peer.id.publicKey);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      if (pubKey != null) {
        this.log("returning found public key");
        response.record = new Libp2pRecord(key, pubKey, /* @__PURE__ */ new Date()).serialize();
        return response;
      }
    }
    const [record, closer] = await Promise.all([
      this._checkLocalDatastore(key),
      this.peerRouting.getClosestPeersOffline(key)
    ]);
    if (record != null) {
      this.log("had record for %b in local datastore", key);
      response.record = record.serialize();
    }
    if (closer.length > 0) {
      this.log("had %s closer peers in routing table", closer.length);
      response.closer = closer.map((peerInfo) => ({
        id: peerInfo.id.toMultihash().bytes,
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      }));
    }
    return response;
  }
  /**
   * Try to fetch a given record by from the local datastore.
   * Returns the record if it is still valid, meaning
   * - it was either authored by this node, or
   * - it was received less than `PROVIDERS_VALIDITY` ago.
   */
  async _checkLocalDatastore(key) {
    this.log("checkLocalDatastore looking for %b", key);
    const dsKey = bufferToRecordKey(this.datastorePrefix, key);
    let rawRecord;
    try {
      rawRecord = await this.datastore.get(dsKey);
    } catch (err) {
      if (err.name === "NotFoundError") {
        return void 0;
      }
      throw err;
    }
    const record = Libp2pRecord.deserialize(rawRecord);
    if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > PROVIDERS_VALIDITY) {
      await this.datastore.delete(dsKey);
      return void 0;
    }
    return record;
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/ping.js
var PingHandler = class {
  constructor(components, init) {
    __publicField(this, "log");
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:ping`);
  }
  async handle(peerId, msg) {
    this.log("ping from %p", peerId);
    return msg;
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/put-value.js
var PutValueHandler = class {
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "validators");
    __publicField(this, "log");
    __publicField(this, "datastorePrefix");
    const { validators: validators2 } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:put-value`);
    this.datastorePrefix = `${init.datastorePrefix}/record`;
    this.validators = validators2;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    this.log("%p asked us to store value for key %b", peerId, key);
    if (msg.record == null) {
      this.log.error("empty record from %p", peerId);
      throw new InvalidMessageError2(`Empty record from: ${peerId}`);
    }
    try {
      const deserializedRecord = Libp2pRecord.deserialize(msg.record);
      await verifyRecord(this.validators, deserializedRecord);
      deserializedRecord.timeReceived = /* @__PURE__ */ new Date();
      const recordKey = bufferToRecordKey(this.datastorePrefix, deserializedRecord.key);
      await this.components.datastore.put(recordKey, deserializedRecord.serialize().subarray());
      this.log("put record for %b into datastore under key %k", key, recordKey);
    } catch (err) {
      this.log("did not put record for key %b into datastore %o", key, err);
    }
    return msg;
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/rpc/index.js
var RPC3 = class {
  constructor(components, init) {
    __publicField(this, "handlers");
    __publicField(this, "log");
    __publicField(this, "metrics");
    __publicField(this, "incomingMessageTimeout");
    this.metrics = {
      operations: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_inbound_rpc_requests_total`),
      errors: components.metrics?.registerCounterGroup(`${init.metricsPrefix}_inbound_rpc_errors_total`),
      rpcTime: components.metrics?.registerMetricGroup(`${init.metricsPrefix}_inbound_rpc_time_seconds`, { label: "operation" })
    };
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc`);
    this.incomingMessageTimeout = init.incomingMessageTimeout ?? 1e4;
    this.handlers = {
      [MessageType.GET_VALUE.toString()]: new GetValueHandler(components, init),
      [MessageType.PUT_VALUE.toString()]: new PutValueHandler(components, init),
      [MessageType.FIND_NODE.toString()]: new FindNodeHandler(components, init),
      [MessageType.ADD_PROVIDER.toString()]: new AddProviderHandler(components, init),
      [MessageType.GET_PROVIDERS.toString()]: new GetProvidersHandler(components, init),
      [MessageType.PING.toString()]: new PingHandler(components, init)
    };
  }
  /**
   * Process incoming DHT messages
   */
  async handleMessage(peerId, msg) {
    const handler = this.handlers[msg.type];
    if (handler == null) {
      this.log.error(`no handler found for message type: ${msg.type}`);
      return;
    }
    try {
      this.metrics.operations?.increment({
        [msg.type]: true
      });
      return await handler.handle(peerId, msg);
    } catch {
      this.metrics.errors?.increment({
        [msg.type]: true
      });
    }
  }
  /**
   * Handle incoming streams on the dht protocol
   */
  async onIncomingStream(stream, connection) {
    const abortListener = () => {
      stream.abort(new TimeoutError2());
    };
    let signal = AbortSignal.timeout(this.incomingMessageTimeout);
    signal.addEventListener("abort", abortListener);
    const messages2 = pbStream(stream).pb(Message);
    while (true) {
      if (stream.readStatus !== "readable") {
        await stream.close({
          signal
        });
        break;
      }
      const message2 = await messages2.read({
        signal
      });
      const stopSuccessTimer = this.metrics?.rpcTime?.timer(message2.type.toString());
      const stopErrorTimer = this.metrics?.rpcTime?.timer(message2.type.toString());
      let errored = false;
      try {
        this.log("incoming %s from %p", message2.type, connection.remotePeer);
        const res = await this.handleMessage(connection.remotePeer, message2);
        if (res != null) {
          await messages2.write(res, {
            signal
          });
        }
      } catch (err) {
        errored = true;
        stopErrorTimer?.();
        throw err;
      } finally {
        if (!errored) {
          stopSuccessTimer?.();
        }
      }
      signal.removeEventListener("abort", abortListener);
      signal = AbortSignal.timeout(this.incomingMessageTimeout);
      signal.addEventListener("abort", abortListener);
    }
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/topology-listener.js
var TopologyListener = class extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "protocol");
    __publicField(this, "running");
    __publicField(this, "registrarId");
    const { protocol: protocol2, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:topology-listener`);
    this.running = false;
    this.protocol = protocol2;
  }
  isStarted() {
    return this.running;
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.registrarId = await this.components.registrar.register(this.protocol, {
      onConnect: (peerId) => {
        this.log("observed peer %p with protocol %s", peerId, this.protocol);
        this.dispatchEvent(new CustomEvent("peer", {
          detail: peerId
        }));
      }
    });
  }
  /**
   * Stop all network activity
   */
  async stop() {
    this.running = false;
    if (this.registrarId != null) {
      this.components.registrar.unregister(this.registrarId);
      this.registrarId = void 0;
    }
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/kad-dht.js
var _a19, _b16, _c8;
var DHTContentRouting = class {
  constructor(dht) {
    __publicField(this, "dht");
    this.dht = dht;
  }
  async provide(cid, options2 = {}) {
    await src_default3(this.dht.provide(cid, options2));
  }
  async cancelReprovide(key) {
    await this.dht.cancelReprovide(key);
  }
  async *findProviders(cid, options2 = {}) {
    for await (const event of this.dht.findProviders(cid, options2)) {
      if (event.name === "PROVIDER") {
        yield* event.providers.map((peer) => ({
          ...peer,
          routing: "kad-dht"
        }));
      }
    }
  }
  async put(key, value2, options2) {
    await src_default3(this.dht.put(key, value2, options2));
  }
  async get(key, options2) {
    for await (const event of this.dht.get(key, options2)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw new NotFoundError2("Could not find value for key");
  }
};
var DHTPeerRouting = class {
  constructor(dht) {
    __publicField(this, "dht");
    this.dht = dht;
  }
  async findPeer(peerId, options2 = {}) {
    for await (const event of this.dht.findPeer(peerId, options2)) {
      if (event.name === "FINAL_PEER") {
        return event.peer;
      }
    }
    throw new NotFoundError2("Peer not found");
  }
  async *getClosestPeers(key, options2 = {}) {
    for await (const event of this.dht.getClosestPeers(key, options2)) {
      if (event.name === "FINAL_PEER") {
        yield event.peer;
      }
    }
  }
};
var DEFAULT_MAX_INBOUND_STREAMS = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
var KadDHT = class extends TypedEventEmitter {
  /**
   * Create a new KadDHT
   */
  constructor(components, init = {}) {
    super();
    __publicField(this, "k");
    __publicField(this, "a");
    __publicField(this, "d");
    __publicField(this, "protocol");
    __publicField(this, "routingTable");
    __publicField(this, "providers");
    __publicField(this, "network");
    __publicField(this, "peerRouting");
    __publicField(this, "components");
    __publicField(this, "log");
    __publicField(this, "running");
    __publicField(this, "clientMode");
    __publicField(this, "validators");
    __publicField(this, "selectors");
    __publicField(this, "queryManager");
    __publicField(this, "contentFetching");
    __publicField(this, "contentRouting");
    __publicField(this, "routingTableRefresh");
    __publicField(this, "rpc");
    __publicField(this, "topologyListener");
    __publicField(this, "querySelf");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "dhtContentRouting");
    __publicField(this, "dhtPeerRouting");
    __publicField(this, "peerInfoMapper");
    __publicField(this, "reprovider");
    __publicField(this, "onPeerConnectTimeout");
    __publicField(this, _c8, "@libp2p/kad-dht");
    __publicField(this, _b16, [
      "@libp2p/content-routing",
      "@libp2p/peer-routing",
      "@libp2p/peer-discovery",
      "@libp2p/kad-dht"
    ]);
    __publicField(this, _a19, [
      "@libp2p/identify",
      "@libp2p/ping"
    ]);
    const logPrefix = init.logPrefix ?? "libp2p:kad-dht";
    const datastorePrefix = init.datastorePrefix ?? "/dht";
    const metricsPrefix = init.metricsPrefix ?? "libp2p_kad_dht";
    const operationMetrics = {
      queries: components.metrics?.registerMetricGroup(`${metricsPrefix}_operations_total`, { label: "operation" }),
      errors: components.metrics?.registerCounterGroup(`${metricsPrefix}_operation_errors_total`, { label: "operation" }),
      queryTime: components.metrics?.registerMetricGroup(`${metricsPrefix}_operation_time_seconds`, { label: "operation" }),
      errorTime: components.metrics?.registerMetricGroup(`${metricsPrefix}_operation_error_time_seconds`, { label: "operation" })
    };
    this.running = false;
    this.components = components;
    this.log = components.logger.forComponent(logPrefix);
    this.k = init.kBucketSize ?? KBUCKET_SIZE;
    this.a = init.alpha ?? ALPHA;
    this.d = init.disjointPaths ?? this.a;
    this.protocol = init.protocol ?? PROTOCOL;
    this.clientMode = init.clientMode ?? true;
    this.maxInboundStreams = init.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
    this.peerInfoMapper = init.peerInfoMapper ?? removePrivateAddressesMapper;
    this.onPeerConnectTimeout = init.onPeerConnectTimeout ?? ON_PEER_CONNECT_TIMEOUT;
    this.providers = new Providers(components, {
      ...init.providers,
      logPrefix,
      datastorePrefix
    });
    this.validators = {
      ...validators,
      ...init.validators
    };
    this.selectors = {
      ...selectors,
      ...init.selectors
    };
    this.network = new Network(components, {
      protocol: this.protocol,
      logPrefix,
      metricsPrefix
    });
    this.routingTable = new RoutingTable(components, {
      kBucketSize: this.k,
      pingOldContactTimeout: init.pingOldContactTimeout,
      pingOldContactConcurrency: init.pingOldContactConcurrency,
      pingOldContactMaxQueueSize: init.pingOldContactMaxQueueSize,
      pingNewContactTimeout: init.pingNewContactTimeout,
      pingNewContactConcurrency: init.pingNewContactConcurrency,
      pingNewContactMaxQueueSize: init.pingNewContactMaxQueueSize,
      protocol: this.protocol,
      logPrefix,
      metricsPrefix,
      prefixLength: init.prefixLength,
      splitThreshold: init.kBucketSplitThreshold,
      network: this.network
    });
    const initialQuerySelfHasRun = pDefer();
    if (init.allowQueryWithZeroPeers === true) {
      initialQuerySelfHasRun.resolve();
    }
    this.queryManager = new QueryManager(components, {
      disjointPaths: this.d,
      alpha: this.a,
      logPrefix,
      metricsPrefix,
      initialQuerySelfHasRun,
      routingTable: this.routingTable,
      allowQueryWithZeroPeers: init.allowQueryWithZeroPeers
    });
    this.peerRouting = new PeerRouting(components, {
      routingTable: this.routingTable,
      network: this.network,
      validators: this.validators,
      queryManager: this.queryManager,
      logPrefix
    });
    this.contentFetching = new ContentFetching(components, {
      validators: this.validators,
      selectors: this.selectors,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      network: this.network,
      logPrefix,
      datastorePrefix
    });
    this.contentRouting = new ContentRouting(components, {
      network: this.network,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      providers: this.providers,
      logPrefix
    });
    this.routingTableRefresh = new RoutingTableRefresh(components, {
      peerRouting: this.peerRouting,
      routingTable: this.routingTable,
      logPrefix
    });
    this.rpc = new RPC3(components, {
      routingTable: this.routingTable,
      providers: this.providers,
      peerRouting: this.peerRouting,
      validators: this.validators,
      logPrefix,
      metricsPrefix,
      datastorePrefix,
      peerInfoMapper: this.peerInfoMapper
    });
    this.topologyListener = new TopologyListener(components, {
      protocol: this.protocol,
      logPrefix
    });
    this.querySelf = new QuerySelf(components, {
      peerRouting: this.peerRouting,
      interval: init.querySelfInterval,
      initialInterval: init.initialQuerySelfInterval,
      logPrefix,
      initialQuerySelfHasRun,
      operationMetrics
    });
    this.reprovider = new Reprovider(components, {
      ...init.reprovide,
      logPrefix,
      metricsPrefix,
      datastorePrefix,
      contentRouting: this.contentRouting,
      operationMetrics
    });
    this.network.addEventListener("peer", (evt) => {
      const peerData = evt.detail;
      this.onPeerConnect(peerData).catch((err) => {
        this.log.error("could not add %p to routing table - %e", peerData.id, err);
      });
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    this.topologyListener.addEventListener("peer", (evt) => {
      const peerId = evt.detail;
      Promise.resolve().then(async () => {
        const peer = await this.components.peerStore.get(peerId);
        const peerData = {
          id: peerId,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
          protocols: peer.protocols
        };
        await this.onPeerConnect(peerData);
      }).catch((err) => {
        this.log.error("could not add %p to routing table - %e", peerId, err);
      });
    });
    this.dhtPeerRouting = new DHTPeerRouting(this);
    this.dhtContentRouting = new DHTContentRouting(this);
    if (init.clientMode == null) {
      components.events.addEventListener("self:peer:update", (evt) => {
        this.log("received update of self-peer info");
        void Promise.resolve().then(async () => {
          const hasPublicAddress = evt.detail.peer.addresses.some(({ multiaddr: multiaddr2 }) => {
            return !isPrivate(multiaddr2) && !Circuit.exactMatch(multiaddr2);
          });
          const mode = this.getMode();
          if (hasPublicAddress && mode === "client") {
            await this.setMode("server");
          } else if (mode === "server" && !hasPublicAddress) {
            await this.setMode("client");
          }
        }).catch((err) => {
          this.log.error("error setting dht server mode - %e", err);
        });
      });
    }
    this.get = timeOperationGenerator(this.get.bind(this), operationMetrics, "GET_VALUE");
    this.findProviders = timeOperationGenerator(this.findProviders.bind(this), operationMetrics, "FIND_PROVIDERS");
    this.findPeer = timeOperationGenerator(this.findPeer.bind(this), operationMetrics, "FIND_PEER");
    this.getClosestPeers = timeOperationGenerator(this.getClosestPeers.bind(this), operationMetrics, "GET_CLOSEST_PEERS");
    this.provide = timeOperationGenerator(this.provide.bind(this), operationMetrics, "PROVIDE");
    this.put = timeOperationGenerator(this.put.bind(this), operationMetrics, "PUT_VALUE");
  }
  get [(_c8 = Symbol.toStringTag, _b16 = serviceCapabilities2, _a19 = serviceDependencies2, contentRoutingSymbol)]() {
    return this.dhtContentRouting;
  }
  get [peerRoutingSymbol]() {
    return this.dhtPeerRouting;
  }
  get [peerDiscoverySymbol]() {
    return this;
  }
  async onPeerConnect(peerData) {
    this.log.trace("peer %p connected", peerData.id, peerData.multiaddrs);
    peerData = this.peerInfoMapper(peerData);
    if (peerData.multiaddrs.length === 0) {
      this.log.trace("ignoring %p as there were no valid addresses in %s after filtering", peerData.id, peerData.multiaddrs.map((addr) => addr.toString()));
      return;
    }
    const signal = AbortSignal.timeout(this.onPeerConnectTimeout);
    setMaxListeners(Infinity, signal);
    try {
      await this.routingTable.add(peerData.id, {
        signal
      });
    } catch (err) {
      this.log.error("could not add %p to routing table - %e", peerData.id, err);
    }
  }
  /**
   * Is this DHT running.
   */
  isStarted() {
    return this.running;
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  getMode() {
    return this.clientMode ? "client" : "server";
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async setMode(mode, options2) {
    if (mode === this.getMode() && options2?.force !== true) {
      this.log("already in %s mode", mode);
      return;
    }
    await this.components.registrar.unhandle(this.protocol, options2);
    if (mode === this.getMode() && options2?.force !== true) {
      this.log("already in %s mode", mode);
      return;
    }
    if (mode === "client") {
      this.log("enabling client mode while in %s mode", this.getMode());
      this.clientMode = true;
    } else {
      this.log("enabling server mode while in %s mode", this.getMode());
      this.clientMode = false;
      await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
        signal: options2?.signal,
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams
      });
    }
  }
  /**
   * Start listening to incoming connections.
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    await this.setMode(this.clientMode ? "client" : "server", {
      force: true
    });
    await start(this.routingTable, this.queryManager, this.network, this.topologyListener, this.routingTableRefresh, this.reprovider);
    await start(this.querySelf);
  }
  /**
   * Stop accepting incoming connections and sending outgoing
   * messages.
   */
  async stop() {
    this.running = false;
    await stop(this.querySelf, this.queryManager, this.network, this.routingTable, this.routingTableRefresh, this.topologyListener, this.reprovider);
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value2, options2 = {}) {
    yield* this.contentFetching.put(key, value2, options2);
  }
  /**
   * Get the value that corresponds to the passed key
   */
  async *get(key, options2 = {}) {
    yield* this.contentFetching.get(key, options2);
  }
  // ----------- Content Routing
  /**
   * Announce to the network that we can provide given key's value
   */
  async *provide(key, options2 = {}) {
    yield* this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options2);
  }
  /**
   * Provider records must be re-published every 24 hours - pass a previously
   * provided CID here to not re-publish a record for it any more
   */
  async cancelReprovide(key, options2) {
    await this.providers.removeProvider(key, this.components.peerId, options2);
  }
  /**
   * Search the dht for providers of the given CID
   */
  async *findProviders(key, options2 = {}) {
    yield* this.contentRouting.findProviders(key, options2);
  }
  // ----------- Peer Routing -----------
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options2 = {}) {
    yield* this.peerRouting.findPeer(id, options2);
  }
  /**
   * Kademlia 'node lookup' operation
   */
  async *getClosestPeers(key, options2 = {}) {
    yield* this.peerRouting.getClosestPeers(key, options2);
  }
  async refreshRoutingTable(options2) {
    this.routingTableRefresh.refreshTable(true, options2);
  }
};

// ../../node_modules/@libp2p/kad-dht/dist/src/index.js
var EventTypes;
(function(EventTypes2) {
  EventTypes2[EventTypes2["SEND_QUERY"] = 0] = "SEND_QUERY";
  EventTypes2[EventTypes2["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
  EventTypes2[EventTypes2["FINAL_PEER"] = 2] = "FINAL_PEER";
  EventTypes2[EventTypes2["QUERY_ERROR"] = 3] = "QUERY_ERROR";
  EventTypes2[EventTypes2["PROVIDER"] = 4] = "PROVIDER";
  EventTypes2[EventTypes2["VALUE"] = 5] = "VALUE";
  EventTypes2[EventTypes2["ADD_PEER"] = 6] = "ADD_PEER";
  EventTypes2[EventTypes2["DIAL_PEER"] = 7] = "DIAL_PEER";
  EventTypes2[EventTypes2["PATH_ENDED"] = 8] = "PATH_ENDED";
})(EventTypes || (EventTypes = {}));
function kadDHT(init = {}) {
  return (components) => new KadDHT(components, init);
}

// ../../node_modules/it-queue/dist/src/errors.js
var QueueFullError2 = class extends Error {
  constructor(message2 = "The queue was full") {
    super(message2);
    this.name = "QueueFullError";
  }
};
__publicField(QueueFullError2, "name", "QueueFullError");

// ../../node_modules/it-queue/dist/src/recipient.js
var JobRecipient2 = class {
  constructor(signal) {
    __publicField(this, "deferred");
    __publicField(this, "signal");
    this.signal = signal;
    this.deferred = Promise.withResolvers();
    this.onAbort = this.onAbort.bind(this);
    this.signal?.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    this.deferred.reject(this.signal?.reason ?? new AbortError7());
  }
  cleanup() {
    this.signal?.removeEventListener("abort", this.onAbort);
  }
};

// ../../node_modules/it-queue/dist/src/job.js
function randomId2() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
var Job2 = class {
  constructor(fn, options2) {
    __publicField(this, "id");
    __publicField(this, "fn");
    __publicField(this, "options");
    __publicField(this, "recipients");
    __publicField(this, "status");
    __publicField(this, "timeline");
    __publicField(this, "controller");
    this.id = randomId2();
    this.status = "queued";
    this.fn = fn;
    this.options = options2;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      return acc && curr.signal?.aborted === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError7());
      this.cleanup();
    }
  }
  async join(options2 = {}) {
    const recipient = new JobRecipient2(options2.signal);
    this.recipients.push(recipient);
    options2.signal?.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      recipient.cleanup();
      recipient.signal?.removeEventListener("abort", this.onAbort);
    });
  }
};

// ../../node_modules/it-queue/dist/src/utils.js
function debounce2(func, wait) {
  let timeout;
  const output = function() {
    const later = function() {
      timeout = void 0;
      void func();
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
  output.start = () => {
  };
  output.stop = () => {
    clearTimeout(timeout);
  };
  return output;
}

// ../../node_modules/it-queue/dist/src/index.js
var Queue2 = class extends TypedEventEmitter {
  constructor(init = {}) {
    super();
    __publicField(this, "concurrency");
    __publicField(this, "maxSize");
    __publicField(this, "queue");
    __publicField(this, "pending");
    __publicField(this, "sort");
    __publicField(this, "autoStart");
    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    this.autoStart = init.autoStart ?? true;
    this.sort = init.sort;
    this.queue = [];
    this.emitEmpty = debounce2(this.emitEmpty.bind(this), 1);
    this.emitIdle = debounce2(this.emitIdle.bind(this), 1);
  }
  [Symbol.asyncIterator]() {
    return this.toGenerator();
  }
  emitEmpty() {
    if (this.size !== 0) {
      return;
    }
    this.safeDispatchEvent("empty");
  }
  emitIdle() {
    if (this.running !== 0) {
      return;
    }
    this.safeDispatchEvent("idle");
  }
  tryToStartAnother() {
    if (this.size === 0) {
      this.emitEmpty();
      if (this.running === 0) {
        this.emitIdle();
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
        this.pending--;
        this.safeDispatchEvent("next");
        if (this.autoStart) {
          this.tryToStartAnother();
        }
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Start the queue. If the `autoStart` parameter passed to the constructor was
   * not `false` this is a no-op
   */
  start() {
    if (this.autoStart !== false) {
      return;
    }
    this.autoStart = true;
    this.tryToStartAnother();
  }
  /**
   * Prevent further jobs from running - call `.start` to start the queue again
   */
  pause() {
    this.autoStart = false;
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options2) {
    options2?.signal?.throwIfAborted();
    if (this.size === this.maxSize) {
      throw new QueueFullError2();
    }
    const job = new Job2(fn, options2);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    if (this.autoStart) {
      this.tryToStartAnother();
    }
    return job.join(options2).then((result) => {
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i2 = 0; i2 < this.queue.length; i2++) {
          if (this.queue[i2] === job) {
            this.queue.splice(i2, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError7());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options2) {
    if (this.size === 0) {
      return;
    }
    await raceEvent(this, "empty", options2?.signal);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options2) {
    if (this.size < limit) {
      return;
    }
    await raceEvent(this, "next", options2?.signal, {
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options2) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await raceEvent(this, "idle", options2?.signal);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options2) {
    options2?.signal?.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail.result);
      }
    };
    const onQueueError = (evt) => {
      cleanup(evt.detail.error);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new AbortError7("Queue aborted"));
    };
    this.addEventListener("success", onQueueJobComplete);
    this.addEventListener("failure", onQueueError);
    this.addEventListener("idle", onQueueIdle);
    options2?.signal?.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("success", onQueueJobComplete);
      this.removeEventListener("failure", onQueueError);
      this.removeEventListener("idle", onQueueIdle);
      options2?.signal?.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};

// ../../node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_ABORT_READ_LOCK_REQUEST = "lock:worker:abort-read-request";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var MASTER_READ_LOCK_ERROR = "lock:master:error-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_ABORT_WRITE_LOCK_REQUEST = "lock:worker:abort-write-request";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
var MASTER_WRITE_LOCK_ERROR = "lock:master:error-write";
var WORKER_FINALIZE = "lock:worker:finalize";
var BROADCAST_CHANNEL_NAME = "mortice";
var defaultOptions = {
  singleProcess: false
};

// ../../node_modules/mortice/dist/src/main/channel.js
var handleChannelWorkerLockRequest = (emitter, channel, masterEvent, abortMasterEvent, requestType, abortType, errorType, releaseType, grantType) => {
  return (event) => {
    if (event.data == null) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    if (requestEvent.type === requestType) {
      emitter.safeDispatchEvent(masterEvent, {
        detail: {
          name: requestEvent.name,
          identifier: requestEvent.identifier,
          handler: async () => {
            channel.postMessage({
              type: grantType,
              name: requestEvent.name,
              identifier: requestEvent.identifier
            });
            await new Promise((resolve) => {
              const releaseEventListener = (event2) => {
                if (event2?.data == null) {
                  return;
                }
                const releaseEvent = {
                  type: event2.data.type,
                  name: event2.data.name,
                  identifier: event2.data.identifier
                };
                if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                  channel.removeEventListener("message", releaseEventListener);
                  resolve();
                }
              };
              channel.addEventListener("message", releaseEventListener);
            });
          },
          onError: (err) => {
            channel.postMessage({
              type: errorType,
              name: requestEvent.name,
              identifier: requestEvent.identifier,
              error: {
                message: err.message,
                name: err.name,
                stack: err.stack
              }
            });
          }
        }
      });
    }
    if (requestEvent.type === abortType) {
      emitter.safeDispatchEvent(abortMasterEvent, {
        detail: {
          name: requestEvent.name,
          identifier: requestEvent.identifier
        }
      });
    }
    if (requestEvent.type === WORKER_FINALIZE) {
      emitter.safeDispatchEvent("finalizeRequest", {
        detail: {
          name: requestEvent.name
        }
      });
    }
  };
};

// ../../node_modules/mortice/dist/src/utils.js
var nanoid2 = (size = 10) => {
  return Math.random().toString().substring(2, size + 2);
};

// ../../node_modules/mortice/dist/src/workers/channel.js
var MorticeChannelWorker = class {
  constructor(name5) {
    __publicField(this, "name");
    __publicField(this, "channel");
    this.name = name5;
    this.channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
  }
  readLock(options2) {
    return this.sendRequest(WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_GRANT_READ_LOCK, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, options2);
  }
  writeLock(options2) {
    return this.sendRequest(WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_GRANT_WRITE_LOCK, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, options2);
  }
  finalize() {
    this.channel.postMessage({
      type: WORKER_FINALIZE,
      name: this.name
    });
    this.channel.close();
  }
  async sendRequest(requestType, abortType, grantType, errorType, releaseType, options2) {
    options2?.signal?.throwIfAborted();
    const id = nanoid2();
    this.channel.postMessage({
      type: requestType,
      identifier: id,
      name: this.name
    });
    return new Promise((resolve, reject) => {
      const abortListener = () => {
        this.channel.postMessage({
          type: abortType,
          identifier: id,
          name: this.name
        });
      };
      options2?.signal?.addEventListener("abort", abortListener, {
        once: true
      });
      const listener = (event) => {
        if (event.data?.identifier !== id) {
          return;
        }
        if (event.data?.type === grantType) {
          this.channel.removeEventListener("message", listener);
          options2?.signal?.removeEventListener("abort", abortListener);
          resolve(() => {
            this.channel.postMessage({
              type: releaseType,
              identifier: id,
              name: this.name
            });
          });
        }
        if (event.data.type === errorType) {
          this.channel.removeEventListener("message", listener);
          options2?.signal?.removeEventListener("abort", abortListener);
          const err = new Error();
          if (event.data.error != null) {
            err.message = event.data.error.message;
            err.name = event.data.error.name;
            err.stack = event.data.error.stack;
          }
          reject(err);
        }
      };
      this.channel.addEventListener("message", listener);
    });
  }
};

// ../../node_modules/mortice/dist/src/browser.js
var browser_default2 = (options2) => {
  options2 = Object.assign({}, defaultOptions, options2);
  const isPrimary = Boolean(window.document) || options2.singleProcess;
  if (isPrimary) {
    const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
    const emitter = new TypedEventEmitter();
    channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestReadLock", "abortReadLockRequest", WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestWriteLock", "abortWriteLockRequest", WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return new MorticeChannelWorker(options2.name);
};

// ../../node_modules/mortice/dist/src/mortice.js
var mutexes = /* @__PURE__ */ new Map();
var implementation;
function isMortice(obj) {
  return typeof obj?.readLock === "function" && typeof obj?.writeLock === "function";
}
function getImplementation(opts) {
  if (implementation == null) {
    implementation = browser_default2(opts);
    if (!isMortice(implementation)) {
      const emitter = implementation;
      emitter.addEventListener("requestReadLock", (event) => {
        const mutexName = event.detail.name;
        const identifier = event.detail.identifier;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        const abortController = new AbortController();
        const abortListener = (event2) => {
          if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
            return;
          }
          abortController.abort();
        };
        emitter.addEventListener("abortReadLockRequest", abortListener);
        void mutex.readLock({
          signal: abortController.signal
        }).then(async (release) => {
          await event.detail.handler().finally(() => {
            release();
          });
        }).catch((err) => {
          event.detail.onError(err);
        }).finally(() => {
          emitter.removeEventListener("abortReadLockRequest", abortListener);
        });
      });
      emitter.addEventListener("requestWriteLock", (event) => {
        const mutexName = event.detail.name;
        const identifier = event.detail.identifier;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        const abortController = new AbortController();
        const abortListener = (event2) => {
          if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
            return;
          }
          abortController.abort();
        };
        emitter.addEventListener("abortWriteLockRequest", abortListener);
        void mutex.writeLock({
          signal: abortController.signal
        }).then(async (release) => {
          await event.detail.handler().finally(() => {
            release();
          });
        }).catch((err) => {
          event.detail.onError(err);
        }).finally(() => {
          emitter.removeEventListener("abortWriteLockRequest", abortListener);
        });
      });
      emitter.addEventListener("finalizeRequest", (event) => {
        const mutexName = event.detail.name;
        const mutex = mutexes.get(mutexName);
        if (mutex == null) {
          return;
        }
        mutex.finalize();
      });
    }
  }
  return implementation;
}
async function createReleasable(queue, options2) {
  let res;
  let rej;
  const p2 = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  const listener = () => {
    rej(new AbortError7());
  };
  options2?.signal?.addEventListener("abort", listener, {
    once: true
  });
  queue.add(async () => {
    await new Promise((resolve) => {
      res(() => {
        options2?.signal?.removeEventListener("abort", listener);
        resolve();
      });
    });
  }, {
    signal: options2?.signal
  }).catch((err) => {
    rej(err);
  });
  return p2;
}
var createMutex = (name5, options2) => {
  let mutex = mutexes.get(name5);
  if (mutex != null) {
    return mutex;
  }
  const implementation2 = getImplementation(options2);
  if (isMortice(implementation2)) {
    mutex = implementation2;
    mutexes.set(name5, mutex);
    return mutex;
  }
  const masterQueue = new Queue2({
    concurrency: 1
  });
  let readQueue;
  mutex = {
    async readLock(opts) {
      if (readQueue != null) {
        return createReleasable(readQueue, opts);
      }
      readQueue = new Queue2({
        concurrency: options2.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleasable(readQueue, opts);
      void masterQueue.add(async () => {
        localReadQueue.start();
        await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return readPromise;
    },
    async writeLock(opts) {
      readQueue = null;
      return createReleasable(masterQueue, opts);
    },
    finalize: () => {
      mutexes.delete(name5);
    },
    queue: masterQueue
  };
  mutexes.set(name5, mutex);
  if (options2.autoFinalize === true) {
    masterQueue.addEventListener("idle", () => {
      mutex.finalize();
    }, {
      once: true
    });
  }
  return mutex;
};

// ../../node_modules/mortice/dist/src/index.js
var defaultOptions2 = {
  name: "lock",
  concurrency: Infinity,
  singleProcess: false,
  autoFinalize: false
};
function createMortice(options2) {
  const opts = Object.assign({}, defaultOptions2, options2);
  return createMutex(opts.name, opts);
}

// ../../node_modules/@libp2p/peer-store/dist/src/constants.js
var MAX_ADDRESS_AGE = 36e5;
var MAX_PEER_AGE = 216e5;

// ../../node_modules/@libp2p/peer-store/dist/src/pb/peer.js
var Peer2;
(function(Peer4) {
  let Peer$metadataEntry;
  (function(Peer$metadataEntry2) {
    let _codec2;
    Peer$metadataEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.value);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            key: "",
            value: alloc(0)
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$metadataEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$metadataEntry2.codec());
    };
    Peer$metadataEntry2.decode = (buf2, opts) => {
      return decodeMessage(buf2, Peer$metadataEntry2.codec(), opts);
    };
  })(Peer$metadataEntry = Peer4.Peer$metadataEntry || (Peer4.Peer$metadataEntry = {}));
  let Peer$tagsEntry;
  (function(Peer$tagsEntry2) {
    let _codec2;
    Peer$tagsEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null) {
            w.uint32(18);
            Tag.codec().encode(obj.value, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            key: ""
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = Tag.codec().decode(reader, reader.uint32(), {
                  limits: opts.limits?.value
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$tagsEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$tagsEntry2.codec());
    };
    Peer$tagsEntry2.decode = (buf2, opts) => {
      return decodeMessage(buf2, Peer$tagsEntry2.codec(), opts);
    };
  })(Peer$tagsEntry = Peer4.Peer$tagsEntry || (Peer4.Peer$tagsEntry = {}));
  let _codec;
  Peer4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.addresses != null) {
          for (const value2 of obj.addresses) {
            w.uint32(10);
            Address.codec().encode(value2, w);
          }
        }
        if (obj.protocols != null) {
          for (const value2 of obj.protocols) {
            w.uint32(18);
            w.string(value2);
          }
        }
        if (obj.publicKey != null) {
          w.uint32(34);
          w.bytes(obj.publicKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w.uint32(42);
          w.bytes(obj.peerRecordEnvelope);
        }
        if (obj.metadata != null && obj.metadata.size !== 0) {
          for (const [key, value2] of obj.metadata.entries()) {
            w.uint32(50);
            Peer4.Peer$metadataEntry.codec().encode({ key, value: value2 }, w);
          }
        }
        if (obj.tags != null && obj.tags.size !== 0) {
          for (const [key, value2] of obj.tags.entries()) {
            w.uint32(58);
            Peer4.Peer$tagsEntry.codec().encode({ key, value: value2 }, w);
          }
        }
        if (obj.updated != null) {
          w.uint32(64);
          w.uint64Number(obj.updated);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          addresses: [],
          protocols: [],
          metadata: /* @__PURE__ */ new Map(),
          tags: /* @__PURE__ */ new Map()
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(Address.codec().decode(reader, reader.uint32(), {
                limits: opts.limits?.addresses$
              }));
              break;
            }
            case 2: {
              if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 4: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 5: {
              obj.peerRecordEnvelope = reader.bytes();
              break;
            }
            case 6: {
              if (opts.limits?.metadata != null && obj.metadata.size === opts.limits.metadata) {
                throw new MaxSizeError('Decode error - map field "metadata" had too many elements');
              }
              const entry = Peer4.Peer$metadataEntry.codec().decode(reader, reader.uint32());
              obj.metadata.set(entry.key, entry.value);
              break;
            }
            case 7: {
              if (opts.limits?.tags != null && obj.tags.size === opts.limits.tags) {
                throw new MaxSizeError('Decode error - map field "tags" had too many elements');
              }
              const entry = Peer4.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {
                limits: {
                  value: opts.limits?.tags$value
                }
              });
              obj.tags.set(entry.key, entry.value);
              break;
            }
            case 8: {
              obj.updated = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer4.encode = (obj) => {
    return encodeMessage(obj, Peer4.codec());
  };
  Peer4.decode = (buf2, opts) => {
    return decodeMessage(buf2, Peer4.codec(), opts);
  };
})(Peer2 || (Peer2 = {}));
var Address;
(function(Address2) {
  let _codec;
  Address2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w.uint32(16);
          w.bool(obj.isCertified);
        }
        if (obj.observed != null) {
          w.uint32(24);
          w.uint64Number(obj.observed);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          multiaddr: alloc(0)
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.multiaddr = reader.bytes();
              break;
            }
            case 2: {
              obj.isCertified = reader.bool();
              break;
            }
            case 3: {
              obj.observed = reader.uint64Number();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address2.encode = (obj) => {
    return encodeMessage(obj, Address2.codec());
  };
  Address2.decode = (buf2, opts) => {
    return decodeMessage(buf2, Address2.codec(), opts);
  };
})(Address || (Address = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.value != null && obj.value !== 0) {
          w.uint32(8);
          w.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w.uint32(16);
          w.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          value: 0
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.value = reader.uint32();
              break;
            }
            case 2: {
              obj.expiry = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf2, opts) => {
    return decodeMessage(buf2, Tag2.codec(), opts);
  };
})(Tag || (Tag = {}));

// ../../node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
function populatePublicKey(peerId, protobuf) {
  if (peerId.publicKey != null || protobuf.publicKey == null) {
    return peerId;
  }
  let digest2;
  if (peerId.type === "RSA") {
    digest2 = peerId.toMultihash();
  }
  const publicKey2 = publicKeyFromProtobuf(protobuf.publicKey, digest2);
  return peerIdFromPublicKey3(publicKey2);
}
function bytesToPeer(peerId, buf2, maxAddressAge) {
  const peer = Peer2.decode(buf2);
  return pbToPeer(peerId, peer, maxAddressAge);
}
function pbToPeer(peerId, peer, maxAddressAge) {
  const tags = /* @__PURE__ */ new Map();
  const now = BigInt(Date.now());
  for (const [key, tag] of peer.tags.entries()) {
    if (tag.expiry != null && tag.expiry < now) {
      continue;
    }
    tags.set(key, tag);
  }
  return {
    ...peer,
    id: populatePublicKey(peerId, peer),
    addresses: peer.addresses.filter(({ observed }) => observed != null && observed > Date.now() - maxAddressAge).map(({ multiaddr: ma, isCertified }) => {
      return {
        multiaddr: multiaddr(ma),
        isCertified: isCertified ?? false
      };
    }),
    metadata: peer.metadata,
    peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
    tags
  };
}

// ../../node_modules/@libp2p/peer-store/dist/src/utils/peer-equals.js
function peerEquals(peerA, peerB) {
  return addressesEqual(peerA.addresses, peerB.addresses) && protocolsEqual(peerA.protocols, peerB.protocols) && publicKeyEqual(peerA.publicKey, peerB.publicKey) && peerRecordEnvelope(peerA.peerRecordEnvelope, peerB.peerRecordEnvelope) && metadataEqual(peerA.metadata, peerB.metadata) && tagsEqual(peerA.tags, peerB.tags);
}
function addressesEqual(addressesA, addressesB) {
  return compareArrays(addressesA, addressesB, (a2, b) => {
    if (a2.isCertified !== b.isCertified) {
      return false;
    }
    if (!equals3(a2.multiaddr, b.multiaddr)) {
      return false;
    }
    return true;
  });
}
function protocolsEqual(protocolsA, protocolsB) {
  return compareArrays(protocolsA, protocolsB, (a2, b) => a2 === b);
}
function publicKeyEqual(publicKeyA, publicKeyB) {
  return compareOptionalUint8Arrays(publicKeyA, publicKeyB);
}
function peerRecordEnvelope(envelopeA, envelopeB) {
  return compareOptionalUint8Arrays(envelopeA, envelopeB);
}
function metadataEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a2, b) => equals3(a2, b));
}
function tagsEqual(metadataA, metadataB) {
  return compareMaps(metadataA, metadataB, (a2, b) => a2.value === b.value && a2.expiry === b.expiry);
}
function compareOptionalUint8Arrays(arrA, arrB) {
  if (arrA == null && arrB == null) {
    return true;
  }
  if (arrA != null && arrB != null) {
    return equals3(arrA, arrB);
  }
  return false;
}
function compareArrays(arrA, arrB, compare3) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  for (let i2 = 0; i2 < arrA.length; i2++) {
    if (!compare3(arrA[i2], arrB[i2])) {
      return false;
    }
  }
  return true;
}
function compareMaps(mapA, mapB, compare3) {
  if (mapA.size !== mapB.size) {
    return false;
  }
  for (const [key, value2] of mapA.entries()) {
    const valueB = mapB.get(key);
    if (valueB == null) {
      return false;
    }
    if (!compare3(value2, valueB)) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
var NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(peerId) {
  if (!isPeerId2(peerId) || peerId.type == null) {
    throw new InvalidParametersError2("Invalid PeerId");
  }
  const b32key = peerId.toCID().toString();
  return new Key(`${NAMESPACE_COMMON}${b32key}`);
}

// ../../node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
async function dedupeFilterAndSortAddresses(peerId, filter2, addresses, existingAddresses, options2) {
  const addressMap = /* @__PURE__ */ new Map();
  for (const addr of addresses) {
    if (addr == null) {
      continue;
    }
    if (addr.multiaddr instanceof Uint8Array) {
      addr.multiaddr = multiaddr(addr.multiaddr);
    }
    if (!isMultiaddr(addr.multiaddr)) {
      throw new InvalidParametersError2("Multiaddr was invalid");
    }
    if (!await filter2(peerId, addr.multiaddr, options2)) {
      continue;
    }
    const isCertified = addr.isCertified ?? false;
    const maStr = addr.multiaddr.toString();
    const existingAddr = addressMap.get(maStr);
    if (existingAddr != null) {
      addr.isCertified = existingAddr.isCertified || isCertified;
    } else {
      addressMap.set(maStr, {
        multiaddr: addr.multiaddr,
        isCertified
      });
    }
  }
  return [...addressMap.values()].sort((a2, b) => {
    return a2.multiaddr.toString().localeCompare(b.multiaddr.toString());
  }).map(({ isCertified, multiaddr: ma }) => {
    const addrPeer = ma.getComponents().find((c2) => c2.code === CODE_P2P2)?.value;
    if (peerId.equals(addrPeer)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId}`));
    }
    return {
      isCertified,
      multiaddr: ma.bytes
    };
  });
}

// ../../node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
async function toPeerPB(peerId, data, strategy, options2) {
  if (data == null) {
    throw new InvalidParametersError2("Invalid PeerData");
  }
  if (data.publicKey != null && peerId.publicKey != null && !data.publicKey.equals(peerId.publicKey)) {
    throw new InvalidParametersError2("publicKey bytes do not match peer id publicKey bytes");
  }
  const existingPeer = options2.existingPeer?.peer;
  if (existingPeer != null && !peerId.equals(existingPeer.id)) {
    throw new InvalidParametersError2("peer id did not match existing peer id");
  }
  let addresses = existingPeer?.addresses ?? [];
  let protocols = new Set(existingPeer?.protocols ?? []);
  let metadata = existingPeer?.metadata ?? /* @__PURE__ */ new Map();
  let tags = existingPeer?.tags ?? /* @__PURE__ */ new Map();
  let peerRecordEnvelope2 = existingPeer?.peerRecordEnvelope;
  if (strategy === "patch") {
    if (data.multiaddrs != null || data.addresses != null) {
      addresses = [];
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
    }
    if (data.protocols != null) {
      protocols = new Set(data.protocols);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      metadata = createSortedMap(metadataEntries, {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      tags = createSortedMap(tagsEntries, {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  if (strategy === "merge") {
    if (data.multiaddrs != null) {
      addresses.push(...data.multiaddrs.map((multiaddr2) => ({
        isCertified: false,
        multiaddr: multiaddr2
      })));
    }
    if (data.addresses != null) {
      addresses.push(...data.addresses);
    }
    if (data.protocols != null) {
      protocols = /* @__PURE__ */ new Set([...protocols, ...data.protocols]);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      for (const [key, value2] of metadataEntries) {
        if (value2 == null) {
          metadata.delete(key);
        } else {
          metadata.set(key, value2);
        }
      }
      metadata = createSortedMap([...metadata.entries()], {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      const mergedTags = new Map(tags);
      for (const [key, value2] of tagsEntries) {
        if (value2 == null) {
          mergedTags.delete(key);
        } else {
          mergedTags.set(key, value2);
        }
      }
      tags = createSortedMap([...mergedTags.entries()], {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope2 = data.peerRecordEnvelope;
    }
  }
  let publicKey2;
  if (existingPeer?.id.publicKey != null) {
    publicKey2 = publicKeyToProtobuf(existingPeer.id.publicKey);
  } else if (data.publicKey != null) {
    publicKey2 = publicKeyToProtobuf(data.publicKey);
  } else if (peerId.publicKey != null) {
    publicKey2 = publicKeyToProtobuf(peerId.publicKey);
  }
  const output = {
    addresses: await dedupeFilterAndSortAddresses(peerId, options2.addressFilter ?? (async () => true), addresses, options2.existingPeer?.peerPB.addresses, options2),
    protocols: [...protocols.values()].sort((a2, b) => {
      return a2.localeCompare(b);
    }),
    metadata,
    tags,
    publicKey: publicKey2,
    peerRecordEnvelope: peerRecordEnvelope2
  };
  output.addresses.forEach((addr) => {
    addr.observed = options2.existingPeer?.peerPB.addresses?.find((addr2) => equals3(addr2.multiaddr, addr2.multiaddr))?.observed ?? Date.now();
  });
  if (peerId.type !== "RSA") {
    delete output.publicKey;
  }
  return output;
}
function createSortedMap(entries, options2) {
  const output = /* @__PURE__ */ new Map();
  for (const [key, value2] of entries) {
    if (value2 == null) {
      continue;
    }
    options2.validate(key, value2);
  }
  for (const [key, value2] of entries.sort(([a2], [b]) => {
    return a2.localeCompare(b);
  })) {
    if (value2 != null) {
      output.set(key, options2.map?.(key, value2) ?? value2);
    }
  }
  return output;
}
function validateMetadata(key, value2) {
  if (typeof key !== "string") {
    throw new InvalidParametersError2("Metadata key must be a string");
  }
  if (!(value2 instanceof Uint8Array)) {
    throw new InvalidParametersError2("Metadata value must be a Uint8Array");
  }
}
function validateTag(key, tag) {
  if (typeof key !== "string") {
    throw new InvalidParametersError2("Tag name must be a string");
  }
  if (tag.value != null) {
    if (parseInt(`${tag.value}`, 10) !== tag.value) {
      throw new InvalidParametersError2("Tag value must be an integer");
    }
    if (tag.value < 0 || tag.value > 100) {
      throw new InvalidParametersError2("Tag value must be between 0-100");
    }
  }
  if (tag.ttl != null) {
    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
      throw new InvalidParametersError2("Tag ttl must be an integer");
    }
    if (tag.ttl < 0) {
      throw new InvalidParametersError2("Tag ttl must be between greater than 0");
    }
  }
}
function mapTag(key, tag) {
  let expiry;
  if (tag.expiry != null) {
    expiry = tag.expiry;
  }
  if (tag.ttl != null) {
    expiry = BigInt(Date.now() + Number(tag.ttl));
  }
  const output = {
    value: tag.value ?? 0
  };
  if (expiry != null) {
    output.expiry = expiry;
  }
  return output;
}

// ../../node_modules/@libp2p/peer-store/dist/src/store.js
var _PersistentStore_instances, findExistingPeer_fn, saveIfDifferent_fn, peerIsExpired_fn;
function keyToPeerId(key) {
  const base32Str = key.toString().split("/")[2];
  const buf2 = CID.parse(base32Str, base32);
  return peerIdFromCID3(buf2);
}
function decodePeer(key, value2, maxAddressAge) {
  const peerId = keyToPeerId(key);
  return bytesToPeer(peerId, value2, maxAddressAge);
}
function mapQuery(query, maxAddressAge) {
  return {
    prefix: NAMESPACE_COMMON,
    filters: (query.filters ?? []).map((fn) => ({ key, value: value2 }) => {
      return fn(decodePeer(key, value2, maxAddressAge));
    }),
    orders: (query.orders ?? []).map((fn) => (a2, b) => {
      return fn(decodePeer(a2.key, a2.value, maxAddressAge), decodePeer(b.key, b.value, maxAddressAge));
    })
  };
}
var PersistentStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _PersistentStore_instances);
    __publicField(this, "peerId");
    __publicField(this, "datastore");
    __publicField(this, "locks");
    __publicField(this, "addressFilter");
    __publicField(this, "log");
    __publicField(this, "maxAddressAge");
    __publicField(this, "maxPeerAge");
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.peerId = components.peerId;
    this.datastore = components.datastore;
    this.addressFilter = init.addressFilter;
    this.locks = trackedPeerMap({
      name: "libp2p_peer_store_locks",
      metrics: components.metrics
    });
    this.maxAddressAge = init.maxAddressAge ?? MAX_ADDRESS_AGE;
    this.maxPeerAge = init.maxPeerAge ?? MAX_PEER_AGE;
  }
  getLock(peerId) {
    let lock = this.locks.get(peerId);
    if (lock == null) {
      lock = {
        refs: 0,
        lock: createMortice({
          name: peerId.toString(),
          singleProcess: true
        })
      };
      this.locks.set(peerId, lock);
    }
    lock.refs++;
    return lock;
  }
  maybeRemoveLock(peerId, lock) {
    lock.refs--;
    if (lock.refs === 0) {
      lock.lock.finalize();
      this.locks.delete(peerId);
    }
  }
  async getReadLock(peerId, options2) {
    const lock = this.getLock(peerId);
    try {
      const release = await lock.lock.readLock(options2);
      return () => {
        release();
        this.maybeRemoveLock(peerId, lock);
      };
    } catch (err) {
      this.maybeRemoveLock(peerId, lock);
      throw err;
    }
  }
  async getWriteLock(peerId, options2) {
    const lock = this.getLock(peerId);
    try {
      const release = await lock.lock.writeLock(options2);
      return () => {
        release();
        this.maybeRemoveLock(peerId, lock);
      };
    } catch (err) {
      this.maybeRemoveLock(peerId, lock);
      throw err;
    }
  }
  async has(peerId, options2) {
    try {
      await this.load(peerId, options2);
      return true;
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    return false;
  }
  async delete(peerId, options2) {
    if (this.peerId.equals(peerId)) {
      return;
    }
    await this.datastore.delete(peerIdToDatastoreKey(peerId), options2);
  }
  async load(peerId, options2) {
    const key = peerIdToDatastoreKey(peerId);
    const buf2 = await this.datastore.get(key, options2);
    const peer = Peer2.decode(buf2);
    if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId, peer)) {
      await this.datastore.delete(key, options2);
      throw new NotFoundError2();
    }
    return pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge);
  }
  async save(peerId, data, options2) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId, options2);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      ...options2,
      addressFilter: this.addressFilter
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId, peerPb, existingPeer);
  }
  async patch(peerId, data, options2) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId, options2);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      ...options2,
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId, peerPb, existingPeer);
  }
  async merge(peerId, data, options2) {
    const existingPeer = await __privateMethod(this, _PersistentStore_instances, findExistingPeer_fn).call(this, peerId, options2);
    const peerPb = await toPeerPB(peerId, data, "merge", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _PersistentStore_instances, saveIfDifferent_fn).call(this, peerId, peerPb, existingPeer);
  }
  async *all(options2) {
    for await (const { key, value: value2 } of this.datastore.query(mapQuery(options2 ?? {}, this.maxAddressAge), options2)) {
      const peerId = keyToPeerId(key);
      if (peerId.equals(this.peerId)) {
        continue;
      }
      const peer = Peer2.decode(value2);
      if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId, peer)) {
        await this.datastore.delete(key, options2);
        continue;
      }
      yield pbToPeer(peerId, peer, this.peerId.equals(peerId) ? Infinity : this.maxAddressAge);
    }
  }
};
_PersistentStore_instances = new WeakSet();
findExistingPeer_fn = async function(peerId, options2) {
  try {
    const key = peerIdToDatastoreKey(peerId);
    const buf2 = await this.datastore.get(key, options2);
    const peerPB = Peer2.decode(buf2);
    if (__privateMethod(this, _PersistentStore_instances, peerIsExpired_fn).call(this, peerId, peerPB)) {
      await this.datastore.delete(key, options2);
      throw new NotFoundError2();
    }
    return {
      peerPB,
      peer: pbToPeer(peerId, peerPB, this.maxAddressAge)
    };
  } catch (err) {
    if (err.name !== "NotFoundError") {
      this.log.error("invalid peer data found in peer store - %e", err);
    }
  }
};
saveIfDifferent_fn = async function(peerId, peer, existingPeer, options2) {
  peer.updated = Date.now();
  const buf2 = Peer2.encode(peer);
  await this.datastore.put(peerIdToDatastoreKey(peerId), buf2, options2);
  return {
    peer: pbToPeer(peerId, peer, this.maxAddressAge),
    previous: existingPeer?.peer,
    updated: existingPeer == null || !peerEquals(peer, existingPeer.peerPB)
  };
};
peerIsExpired_fn = function(peerId, peer) {
  if (peer.updated == null) {
    return true;
  }
  if (this.peerId.equals(peerId)) {
    return false;
  }
  const expired = peer.updated < Date.now() - this.maxPeerAge;
  const minAddressObserved = Date.now() - this.maxAddressAge;
  const addrs = peer.addresses.filter((addr) => {
    return addr.observed != null && addr.observed > minAddressObserved;
  });
  return expired && addrs.length === 0;
};

// ../../node_modules/@libp2p/peer-store/dist/src/index.js
var _a20, _PersistentPeerStore_instances, emitIfUpdated_fn;
_a20 = Symbol.toStringTag;
var PersistentPeerStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _PersistentPeerStore_instances);
    __publicField(this, "store");
    __publicField(this, "events");
    __publicField(this, "peerId");
    __publicField(this, "log");
    __publicField(this, _a20, "@libp2p/peer-store");
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.events = components.events;
    this.peerId = components.peerId;
    this.store = new PersistentStore(components, init);
  }
  async forEach(fn, query) {
    for await (const peer of this.store.all(query)) {
      fn(peer);
    }
  }
  async all(query) {
    return src_default8(this.store.all(query));
  }
  async delete(peerId, options2) {
    const release = await this.store.getReadLock(peerId, options2);
    try {
      await this.store.delete(peerId, options2);
    } finally {
      release();
    }
  }
  async has(peerId, options2) {
    const release = await this.store.getReadLock(peerId, options2);
    try {
      return await this.store.has(peerId, options2);
    } finally {
      this.log.trace("has release read lock");
      release?.();
    }
  }
  async get(peerId, options2) {
    const release = await this.store.getReadLock(peerId, options2);
    try {
      return await this.store.load(peerId, options2);
    } finally {
      release?.();
    }
  }
  async getInfo(peerId, options2) {
    const peer = await this.get(peerId, options2);
    return {
      id: peer.id,
      multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
    };
  }
  async save(id, data, options2) {
    const release = await this.store.getWriteLock(id, options2);
    try {
      const result = await this.store.save(id, data, options2);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      release?.();
    }
  }
  async patch(id, data, options2) {
    const release = await this.store.getWriteLock(id, options2);
    try {
      const result = await this.store.patch(id, data, options2);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      release?.();
    }
  }
  async merge(id, data, options2) {
    const release = await this.store.getWriteLock(id, options2);
    try {
      const result = await this.store.merge(id, data, options2);
      __privateMethod(this, _PersistentPeerStore_instances, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      release?.();
    }
  }
  async consumePeerRecord(buf2, arg1, arg2) {
    const expectedPeer = isPeerId2(arg1) ? arg1 : isPeerId2(arg1?.expectedPeer) ? arg1.expectedPeer : void 0;
    const options2 = isPeerId2(arg1) ? arg2 : arg1 === void 0 ? arg2 : arg1;
    const envelope = await RecordEnvelope.openAndCertify(buf2, PeerRecord2.DOMAIN, options2);
    const peerId = peerIdFromCID3(envelope.publicKey.toCID());
    if (expectedPeer?.equals(peerId) === false) {
      this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, peerId);
      return false;
    }
    const peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    let peer;
    try {
      peer = await this.get(peerId, options2);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if (peer?.peerRecordEnvelope != null) {
      const storedEnvelope = RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
      const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
      if (storedRecord.seqNumber >= peerRecord.seqNumber) {
        this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
        return false;
      }
    }
    await this.patch(peerRecord.peerId, {
      peerRecordEnvelope: buf2,
      addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }))
    }, options2);
    return true;
  }
};
_PersistentPeerStore_instances = new WeakSet();
emitIfUpdated_fn = function(id, result) {
  if (!result.updated) {
    return;
  }
  if (this.peerId.equals(id)) {
    this.events.safeDispatchEvent("self:peer:update", { detail: result });
  } else {
    this.events.safeDispatchEvent("peer:update", { detail: result });
  }
};
function persistentPeerStore(components, init = {}) {
  return new PersistentPeerStore(components, init);
}

// ../../node_modules/@libp2p/ping/dist/src/constants.js
var PING_PROTOCOL = "/ipfs/ping/1.0.0";
var PING_LENGTH = 32;
var PROTOCOL_VERSION2 = "1.0.0";
var PROTOCOL_NAME = "ping";
var PROTOCOL_PREFIX = "ipfs";
var TIMEOUT = 1e4;
var MAX_INBOUND_STREAMS = 2;
var MAX_OUTBOUND_STREAMS = 1;

// ../../node_modules/@libp2p/ping/dist/src/ping.js
var _a21, _b17;
_b17 = Symbol.toStringTag, _a21 = serviceCapabilities2;
var Ping = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "runOnLimitedConnection");
    __publicField(this, _b17, "@libp2p/ping");
    __publicField(this, _a21, [
      "@libp2p/ping"
    ]);
    this.components = components;
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION2}`;
    this.timeout = init.timeout ?? TIMEOUT;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
    this.runOnLimitedConnection = init.runOnLimitedConnection ?? true;
    this.handlePing = this.handlePing.bind(this);
  }
  async start() {
    await this.components.registrar.handle(this.protocol, this.handlePing, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * A handler to register with Libp2p to process ping messages
   */
  async handlePing(stream, connection) {
    const log4 = stream.log.newScope("ping");
    log4.trace("ping from %p", connection.remotePeer);
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    signal.addEventListener("abort", () => {
      stream.abort(new TimeoutError2("Ping timed out"));
    });
    const start2 = Date.now();
    for await (const buf2 of stream) {
      if (stream.status !== "open") {
        log4("stream status changed to %s", stream.status);
        break;
      }
      if (!stream.send(buf2)) {
        log4("waiting for stream to drain");
        await pEvent(stream, "drain", {
          rejectionEvents: [
            "close"
          ],
          signal
        });
        log4("stream drained");
      }
    }
    log4("ping from %p complete in %dms", connection.remotePeer, Date.now() - start2);
    await stream.close({
      signal
    });
  }
  /**
   * Ping a given peer and wait for its response, getting the operation latency.
   */
  async ping(peer, options2 = {}) {
    const data = randomBytes2(PING_LENGTH);
    const stream = await this.components.connectionManager.openStream(peer, this.protocol, {
      runOnLimitedConnection: this.runOnLimitedConnection,
      ...options2
    });
    const log4 = stream.log.newScope("ping");
    try {
      const start2 = Date.now();
      const finished = Promise.withResolvers();
      const received = new Uint8ArrayList();
      const onPong = (evt) => {
        received.append(evt.data);
        if (received.byteLength === PING_LENGTH) {
          stream.removeEventListener("message", onPong);
          const rtt = Date.now() - start2;
          Promise.all([
            stream.closeRead(options2)
          ]).then(() => {
            if (!equals3(data, received.subarray())) {
              throw new ProtocolError2(`Received wrong ping ack after ${rtt}ms`);
            } else {
              finished.resolve(rtt);
            }
          }).catch((err) => {
            stream.abort(err);
            finished.reject(err);
          });
        }
      };
      stream.addEventListener("message", onPong);
      stream.send(data);
      await stream.close(options2);
      return await raceSignal(finished.promise, options2.signal);
    } catch (err) {
      log4.error("error while pinging %o - %e", peer, err);
      stream?.abort(err);
      throw err;
    } finally {
      stream?.close();
    }
  }
};

// ../../node_modules/@libp2p/ping/dist/src/index.js
function ping(init = {}) {
  return (components) => new Ping(components, init);
}

// ../../node_modules/@libp2p/pubsub-peer-discovery/dist/src/peer.js
var Peer3;
(function(Peer4) {
  let _codec;
  Peer4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.addrs != null) {
          for (const value2 of obj.addrs) {
            w.uint32(18);
            w.bytes(value2);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {
          publicKey: alloc(0),
          addrs: []
        };
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              if (opts.limits?.addrs != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer4.encode = (obj) => {
    return encodeMessage(obj, Peer4.codec());
  };
  Peer4.decode = (buf2, opts) => {
    return decodeMessage(buf2, Peer4.codec(), opts);
  };
})(Peer3 || (Peer3 = {}));

// ../../node_modules/@libp2p/pubsub-peer-discovery/dist/src/index.js
var _a22, _b18, _c9;
var TOPIC = "_peer-discovery._p2p._pubsub";
var PubSubPeerDiscovery = class extends (_c9 = TypedEventEmitter, _b18 = peerDiscoverySymbol, _a22 = Symbol.toStringTag, _c9) {
  constructor(components, init = {}) {
    super();
    __publicField(this, _b18, true);
    __publicField(this, _a22, "@libp2p/pubsub-peer-discovery");
    __publicField(this, "interval");
    __publicField(this, "listenOnly");
    __publicField(this, "topics");
    __publicField(this, "intervalId");
    __publicField(this, "components");
    __publicField(this, "log");
    const { interval, topics, listenOnly } = init;
    this.components = components;
    this.interval = interval ?? 1e4;
    this.listenOnly = listenOnly ?? false;
    this.log = components.logger.forComponent("libp2p:discovery:pubsub");
    if (Array.isArray(topics) && topics.length > 0) {
      this.topics = topics;
    } else {
      this.topics = [TOPIC];
    }
    this._onMessage = this._onMessage.bind(this);
  }
  isStarted() {
    return this.intervalId != null;
  }
  start() {
  }
  /**
   * Subscribes to the discovery topic on `libp2p.pubsub` and performs a broadcast
   * immediately, and every `this.interval`
   */
  afterStart() {
    if (this.intervalId != null) {
      return;
    }
    const pubsub = this.components.pubsub;
    if (pubsub == null) {
      throw new Error("PubSub not configured");
    }
    for (const topic of this.topics) {
      pubsub.subscribe(topic);
      pubsub.addEventListener("message", this._onMessage);
    }
    if (this.listenOnly) {
      return;
    }
    this._broadcast();
    this.intervalId = setInterval(() => {
      this._broadcast();
    }, this.interval);
  }
  beforeStop() {
    const pubsub = this.components.pubsub;
    if (pubsub == null) {
      throw new Error("PubSub not configured");
    }
    for (const topic of this.topics) {
      pubsub.unsubscribe(topic);
      pubsub.removeEventListener("message", this._onMessage);
    }
  }
  /**
   * Unsubscribes from the discovery topic
   */
  stop() {
    if (this.intervalId != null) {
      clearInterval(this.intervalId);
      this.intervalId = void 0;
    }
  }
  /**
   * Performs a broadcast via Pubsub publish
   */
  _broadcast() {
    const peerId = this.components.peerId;
    if (peerId.publicKey == null) {
      throw new Error("PeerId was missing public key");
    }
    const peer = {
      publicKey: publicKeyToProtobuf(peerId.publicKey),
      addrs: this.components.addressManager.getAddresses().map((ma) => ma.bytes)
    };
    const encodedPeer = Peer3.encode(peer);
    const pubsub = this.components.pubsub;
    if (pubsub == null) {
      throw new Error("PubSub not configured");
    }
    for (const topic of this.topics) {
      if (pubsub.getSubscribers(topic).length === 0) {
        this.log("skipping broadcasting our peer data on topic %s because there are no peers present", topic);
        continue;
      }
      this.log("broadcasting our peer data on topic %s", topic);
      void pubsub.publish(topic, encodedPeer);
    }
  }
  /**
   * Handles incoming pubsub messages for our discovery topic
   */
  _onMessage(event) {
    if (!this.isStarted()) {
      return;
    }
    const message2 = event.detail;
    if (!this.topics.includes(message2.topic)) {
      return;
    }
    try {
      const peer = Peer3.decode(message2.data);
      const publicKey2 = publicKeyFromProtobuf(peer.publicKey);
      const peerId = peerIdFromPublicKey3(publicKey2);
      if (peerId.equals(this.components.peerId)) {
        return;
      }
      this.log("discovered peer %p on %s", peerId, message2.topic);
      this.safeDispatchEvent("peer", {
        detail: {
          id: peerId,
          multiaddrs: peer.addrs.map((b) => multiaddr(b))
        }
      });
    } catch (err) {
      this.log.error("error handling incoming message", err);
    }
  }
};
function pubsubPeerDiscovery(init = {}) {
  return (components) => new PubSubPeerDiscovery(components, init);
}

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-public/pb/message.js
var Message2;
(function(Message4) {
  let Flag2;
  (function(Flag3) {
    Flag3["FIN"] = "FIN";
    Flag3["STOP_SENDING"] = "STOP_SENDING";
    Flag3["RESET"] = "RESET";
    Flag3["FIN_ACK"] = "FIN_ACK";
  })(Flag2 = Message4.Flag || (Message4.Flag = {}));
  let __FlagValues;
  (function(__FlagValues2) {
    __FlagValues2[__FlagValues2["FIN"] = 0] = "FIN";
    __FlagValues2[__FlagValues2["STOP_SENDING"] = 1] = "STOP_SENDING";
    __FlagValues2[__FlagValues2["RESET"] = 2] = "RESET";
    __FlagValues2[__FlagValues2["FIN_ACK"] = 3] = "FIN_ACK";
  })(__FlagValues || (__FlagValues = {}));
  (function(Flag3) {
    Flag3.codec = () => {
      return enumeration(__FlagValues);
    };
  })(Flag2 = Message4.Flag || (Message4.Flag = {}));
  let _codec;
  Message4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.flag != null) {
          w.uint32(8);
          Message4.Flag.codec().encode(obj.flag, w);
        }
        if (obj.message != null) {
          w.uint32(18);
          w.bytes(obj.message);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {};
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.flag = Message4.Flag.codec().decode(reader);
              break;
            }
            case 2: {
              obj.message = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message4.encode = (obj) => {
    return encodeMessage(obj, Message4.codec());
  };
  Message4.decode = (buf2, opts) => {
    return decodeMessage(buf2, Message4.codec(), opts);
  };
})(Message2 || (Message2 = {}));

// ../../node_modules/@libp2p/webrtc/dist/src/constants.js
var DEFAULT_ICE_SERVERS = [
  "stun:stun.l.google.com:19302",
  "stun:global.stun.twilio.com:3478",
  "stun:stun.cloudflare.com:3478",
  "stun:stun.services.mozilla.com:3478"
];
var UFRAG_ALPHABET = Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");
var UFRAG_PREFIX = "libp2p+webrtc+v1/";
var MAX_BUFFERED_AMOUNT = 2 * 1024 * 1024;
var MAX_MESSAGE_SIZE2 = 16 * 1024;
function calculateProtobufOverhead(maxMessageSize = MAX_MESSAGE_SIZE2) {
  const messageLength = encodingLength2(maxMessageSize - encodingLength2(maxMessageSize));
  const flagField = 1 + encodingLength2(Object.keys(Message2.Flag).length - 1);
  const messageFieldIdType = 1;
  const available = maxMessageSize - messageLength - flagField - messageFieldIdType;
  const messageFieldLengthLength = encodingLength2(available);
  return messageLength + flagField + messageFieldIdType + messageFieldLengthLength;
}
var PROTOBUF_OVERHEAD = calculateProtobufOverhead();
var DATA_CHANNEL_DRAIN_TIMEOUT = 3e4;
var DEFAULT_FIN_ACK_TIMEOUT = 1e4;
var MUXER_PROTOCOL = "/webrtc";
var SIGNALING_PROTOCOL = "/webrtc-signaling/0.0.1";
var DEFAULT_CERTIFICATE_DATASTORE_KEY = "/libp2p/webrtc-direct/certificate";
var DEFAULT_CERTIFICATE_PRIVATE_KEY_NAME = "webrtc-direct-certificate-private-key";
var DEFAULT_CERTIFICATE_PRIVATE_KEY_TYPE = "ECDSA";
var DEFAULT_CERTIFICATE_LIFESPAN = 12096e5;
var DEFAULT_CERTIFICATE_RENEWAL_THRESHOLD = 864e5;

// ../../node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/constants.js
var MAX_LENGTH_LENGTH3 = 8;
var MAX_DATA_LENGTH3 = 1024 * 1024 * 4;

// ../../node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/errors.js
var InvalidMessageLengthError4 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError4 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError4 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};
var UnexpectedEOFError4 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// ../../node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable10(thing) {
  return thing[Symbol.asyncIterator] != null;
}

// ../../node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/encode.js
function validateMaxDataLength2(chunk, maxDataLength) {
  if (chunk.byteLength > maxDataLength) {
    throw new InvalidDataLengthError4("Message length too long");
  }
}
var defaultEncoder3 = (length4) => {
  const lengthLength = encodingLength2(length4);
  const lengthBuf = allocUnsafe(lengthLength);
  encode7(length4, lengthBuf);
  defaultEncoder3.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder3.bytes = 0;
function encode11(source, options2) {
  options2 = options2 ?? {};
  const encodeLength2 = options2.lengthEncoder ?? defaultEncoder3;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH3;
  function* maybeYield(chunk) {
    validateMaxDataLength2(chunk, maxDataLength);
    const length4 = encodeLength2(chunk.byteLength);
    if (length4 instanceof Uint8Array) {
      yield length4;
    } else {
      yield* length4;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable10(source)) {
    return (async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    })();
  }
  return (function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  })();
}
encode11.single = (chunk, options2) => {
  options2 = options2 ?? {};
  const encodeLength2 = options2.lengthEncoder ?? defaultEncoder3;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH3;
  validateMaxDataLength2(chunk, maxDataLength);
  return new Uint8ArrayList(encodeLength2(chunk.byteLength), chunk);
};

// ../../node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/decode.js
var ReadMode3;
(function(ReadMode5) {
  ReadMode5[ReadMode5["LENGTH"] = 0] = "LENGTH";
  ReadMode5[ReadMode5["DATA"] = 1] = "DATA";
})(ReadMode3 || (ReadMode3 = {}));
var defaultDecoder3 = (buf2) => {
  const length4 = decode8(buf2);
  defaultDecoder3.bytes = encodingLength2(length4);
  return length4;
};
defaultDecoder3.bytes = 0;
function decode12(source, options2) {
  const buffer2 = new Uint8ArrayList();
  let mode = ReadMode3.LENGTH;
  let dataLength = -1;
  const lengthDecoder = options2?.lengthDecoder ?? defaultDecoder3;
  const maxLengthLength = options2?.maxLengthLength ?? MAX_LENGTH_LENGTH3;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH3;
  function* maybeYield() {
    while (buffer2.byteLength > 0) {
      if (mode === ReadMode3.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer2);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError4("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError4("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer2.consume(dataLengthLength);
          if (options2?.onLength != null) {
            options2.onLength(dataLength);
          }
          mode = ReadMode3.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer2.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError4("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode3.DATA) {
        if (buffer2.byteLength < dataLength) {
          break;
        }
        const data = buffer2.sublist(0, dataLength);
        buffer2.consume(dataLength);
        if (options2?.onData != null) {
          options2.onData(data);
        }
        yield data;
        mode = ReadMode3.LENGTH;
      }
    }
  }
  if (isAsyncIterable10(source)) {
    return (async function* () {
      for await (const buf2 of source) {
        buffer2.append(buf2);
        yield* maybeYield();
      }
      if (buffer2.byteLength > 0) {
        throw new UnexpectedEOFError4("Unexpected end of input");
      }
    })();
  }
  return (function* () {
    for (const buf2 of source) {
      buffer2.append(buf2);
      yield* maybeYield();
    }
    if (buffer2.byteLength > 0) {
      throw new UnexpectedEOFError4("Unexpected end of input");
    }
  })();
}
decode12.fromReader = (reader, options2) => {
  let byteLength = 1;
  const varByteSource = (async function* () {
    while (true) {
      try {
        const { done, value: value2 } = await reader.next(byteLength);
        if (done === true) {
          return;
        }
        if (value2 != null) {
          yield value2;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  })();
  const onLength = (l2) => {
    byteLength = l2;
  };
  return decode12(varByteSource, {
    ...options2 ?? {},
    onLength
  });
};

// ../../node_modules/detect-browser/es/index.js
var __spreadArray = function(to, from3, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from3.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from3)) {
      if (!ar) ar = Array.prototype.slice.call(from3, 0, i2);
      ar[i2] = from3[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from3));
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BrowserInfo2(name5, version2, os) {
      this.name = name5;
      this.version = version2;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  })()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function NodeInfo2(version2) {
      this.version = version2;
      this.type = "node";
      this.name = "node";
      this.os = "";
    }
    return NodeInfo2;
  })()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SearchBotDeviceInfo2(name5, version2, os, bot) {
      this.name = name5;
      this.version = version2;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  })()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  })()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  })()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent2) {
  if (!!userAgent2) {
    return parseUserAgent(userAgent2);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a37) {
    var browser2 = _a37[0], regex = _a37[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function browserName(ua) {
  var data = matchUserAgent(ua);
  return data ? data[0] : null;
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name5 = matchedRule[0], match = matchedRule[1];
  if (name5 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name5, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name5, version2, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a37 = operatingSystemRules[ii], os = _a37[0], regex = _a37[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && "";
  return isNode ? new NodeInfo("".slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}

// ../../node_modules/@libp2p/webrtc/dist/src/util.js
var browser = detect();
var isFirefox = browser != null && browser.name === "firefox";
var nopSource = async function* nop() {
};
var nopSink = async (_) => {
};
function inertDuplex() {
  return {
    source: {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            return new Promise(() => {
            });
          }
        };
      }
    },
    sink: async (source) => {
      return new Promise(() => {
      });
    }
  };
}
function drainAndClose(channel, direction, drainTimeout = DATA_CHANNEL_DRAIN_TIMEOUT, options2) {
  if (channel.readyState !== "open") {
    return;
  }
  void Promise.resolve().then(async () => {
    if (channel.bufferedAmount > 0) {
      options2.log("%s drain channel with %d buffered bytes", direction, channel.bufferedAmount);
      const deferred = pDefer();
      let drained = false;
      channel.bufferedAmountLowThreshold = 0;
      const closeListener = () => {
        if (!drained) {
          options2.log("%s drain channel closed before drain", direction);
          deferred.resolve();
        }
      };
      channel.addEventListener("close", closeListener, {
        once: true
      });
      channel.addEventListener("bufferedamountlow", () => {
        drained = true;
        channel.removeEventListener("close", closeListener);
        deferred.resolve();
      });
      await pTimeout2(deferred.promise, {
        milliseconds: drainTimeout
      });
    }
  }).then(async () => {
    if (channel.readyState === "open") {
      channel.close();
    }
  }).catch((err) => {
    options2.log.error("error closing outbound stream - %e", err);
  });
}
function isPeerConnection(obj) {
  return typeof obj.state === "function";
}
async function getRtcConfiguration(config) {
  config = config ?? {};
  if (typeof config === "function") {
    config = await config();
  }
  config.iceServers = config.iceServers ?? DEFAULT_ICE_SERVERS.map((url) => ({
    urls: [
      url
    ]
  }));
  return config;
}
var genUfrag = (len = 32) => {
  return UFRAG_PREFIX + [...Array(len)].map(() => UFRAG_ALPHABET.at(Math.floor(Math.random() * UFRAG_ALPHABET.length))).join("");
};

// ../../node_modules/@libp2p/webrtc/dist/src/stream.js
var WebRTCStream = class extends AbstractStream {
  constructor(init) {
    super({
      ...init,
      maxMessageSize: (init.maxMessageSize ?? MAX_MESSAGE_SIZE2) - PROTOBUF_OVERHEAD
    });
    /**
     * The data channel used to send and receive data
     */
    __publicField(this, "channel");
    /**
     * push data from the underlying datachannel to the length prefix decoder
     * and then the protobuf decoder.
     */
    __publicField(this, "incomingData");
    __publicField(this, "maxBufferedAmount");
    __publicField(this, "receivedFinAck");
    __publicField(this, "finAckTimeout");
    this.channel = init.channel;
    this.channel.binaryType = "arraybuffer";
    this.incomingData = pushable();
    this.maxBufferedAmount = init.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT;
    this.finAckTimeout = init.finAckTimeout ?? DEFAULT_FIN_ACK_TIMEOUT;
    this.channel.onclose = () => {
      this.log.trace("received datachannel close event");
      this.onRemoteCloseWrite();
      this.onTransportClosed();
    };
    this.channel.onerror = (evt) => {
      const err = evt.error;
      this.log.trace("received datachannel error event - %e", err);
      this.abort(err);
    };
    this.channel.onmessage = async (event) => {
      this.log("incoming message %d bytes", event.data.byteLength);
      const { data } = event;
      if (data === null || data.byteLength === 0) {
        return;
      }
      this.incomingData.push(new Uint8Array(data, 0, data.byteLength));
    };
    this.channel.bufferedAmountLowThreshold = 0;
    this.channel.onbufferedamountlow = () => {
      if (this.writableNeedsDrain) {
        this.safeDispatchEvent("drain");
      }
    };
    Promise.resolve().then(async () => {
      for await (const buf2 of decode12(this.incomingData)) {
        this.processIncomingProtobuf(buf2);
      }
    }).catch((err) => {
      this.log.error("error processing incoming data channel messages - %e", err);
    });
    const cleanUpDatachannelOnClose = () => {
      if (this.channel.readyState === "open") {
        this.log.trace("stream closed, closing underlying datachannel");
        this.channel.close();
      }
    };
    this.addEventListener("close", cleanUpDatachannelOnClose);
    if (this.channel.readyState !== "open") {
      this.log('channel ready state is "%s" and not "open", waiting for "open" event before sending data', this.channel.readyState);
      pEvent(this.channel, "open", {
        rejectionEvents: [
          "close",
          "error"
        ]
      }).then(() => {
        this.log('channel ready state is now "%s", dispatching drain', this.channel.readyState);
        this.safeDispatchEvent("drain");
      }).catch((err) => {
        this.abort(err.error ?? err);
      });
    }
  }
  sendNewStream() {
  }
  _sendMessage(data) {
    if (this.channel.readyState !== "open") {
      throw new StreamStateError2(`Invalid datachannel state - ${this.channel.readyState}`);
    }
    this.log.trace('sending message, channel state "%s"', this.channel.readyState);
    if (isFirefox) {
      this.channel.send(data.subarray());
      return;
    }
    for (const buf2 of data) {
      this.channel.send(buf2);
    }
  }
  sendData(data) {
    if (this.channel.readyState !== "open") {
      return {
        sentBytes: 0,
        canSendMore: false
      };
    }
    this._sendMessage(encode11.single(Message2.encode({
      message: data.subarray()
    })));
    return {
      sentBytes: data.byteLength,
      canSendMore: this.channel.bufferedAmount < this.maxBufferedAmount
    };
  }
  sendReset(err) {
    try {
      this.log.error("sending reset - %e", err);
      this._sendFlag(Message2.Flag.RESET);
      this.receivedFinAck?.reject(err);
    } catch (err2) {
      this.log.error("failed to send reset - %e", err2);
    }
  }
  async sendCloseWrite(options2) {
    this._sendFlag(Message2.Flag.FIN);
    options2?.signal?.throwIfAborted();
    this.receivedFinAck = Promise.withResolvers();
    const signal = options2?.signal ?? AbortSignal.timeout(this.finAckTimeout);
    const eventPromises = [
      pEvent(this.channel, "close", {
        signal
      }),
      pEvent(this.channel, "error", {
        signal
      })
    ];
    await Promise.any([
      raceSignal(this.receivedFinAck.promise, signal),
      ...eventPromises
    ]).finally(() => {
      eventPromises.forEach((p2) => p2.cancel());
    });
  }
  async sendCloseRead(options2) {
    this._sendFlag(Message2.Flag.STOP_SENDING);
    options2?.signal?.throwIfAborted();
  }
  /**
   * Handle incoming
   */
  processIncomingProtobuf(buffer2) {
    const message2 = Message2.decode(buffer2);
    if (message2.message != null && (this.readStatus === "readable" || this.readStatus === "paused")) {
      this.onData(new Uint8ArrayList(message2.message));
    }
    if (message2.flag !== void 0) {
      this.log.trace('incoming flag %s, write status "%s", read status "%s"', message2.flag, this.writeStatus, this.readStatus);
      if (message2.flag === Message2.Flag.FIN) {
        this._sendFlag(Message2.Flag.FIN_ACK);
        this.onRemoteCloseWrite();
      }
      if (message2.flag === Message2.Flag.RESET) {
        this.receivedFinAck?.reject(new StreamResetError2("The stream was reset"));
        this.onRemoteReset();
      }
      if (message2.flag === Message2.Flag.STOP_SENDING) {
        this.onRemoteCloseRead();
      }
      if (message2.flag === Message2.Flag.FIN_ACK) {
        this.receivedFinAck?.resolve();
      }
    }
  }
  _sendFlag(flag) {
    if (this.channel.readyState !== "open") {
      this.log.trace('not sending flag %s because channel is "%s" and not "open"', flag.toString(), this.channel.readyState);
      return false;
    }
    this.log.trace("sending flag %s", flag.toString());
    const messageBuf = Message2.encode({ flag });
    const prefixedBuf = encode11.single(messageBuf);
    try {
      this._sendMessage(prefixedBuf);
      return true;
    } catch (err) {
      this.log.error("could not send flag %s - %e", flag.toString(), err);
    }
    return false;
  }
  sendPause() {
  }
  sendResume() {
  }
};
function createStream(options2) {
  const { channel, direction, isHandshake } = options2;
  return new WebRTCStream({
    ...options2,
    id: `${channel.id}`,
    log: options2.log.newScope(`${isHandshake === true ? "handshake" : direction}:${channel.id}`),
    protocol: ""
  });
}

// ../../node_modules/@libp2p/webrtc/dist/src/muxer.js
var DataChannelMuxerFactory = class {
  constructor(init) {
    __publicField(this, "protocol");
    /**
     * WebRTC Peer Connection
     */
    __publicField(this, "peerConnection");
    __publicField(this, "metrics");
    __publicField(this, "dataChannelOptions");
    __publicField(this, "earlyDataChannels");
    this.onEarlyDataChannel = this.onEarlyDataChannel.bind(this);
    this.peerConnection = init.peerConnection;
    this.metrics = init.metrics;
    this.protocol = init.protocol ?? MUXER_PROTOCOL;
    this.dataChannelOptions = init.dataChannelOptions ?? {};
    this.peerConnection.addEventListener("datachannel", this.onEarlyDataChannel);
    this.earlyDataChannels = [];
  }
  onEarlyDataChannel(evt) {
    this.earlyDataChannels.push(evt.channel);
  }
  createStreamMuxer(maConn) {
    this.peerConnection.removeEventListener("datachannel", this.onEarlyDataChannel);
    return new DataChannelMuxer(maConn, {
      peerConnection: this.peerConnection,
      dataChannelOptions: this.dataChannelOptions,
      metrics: this.metrics,
      protocol: this.protocol,
      earlyDataChannels: this.earlyDataChannels
    });
  }
};
var DataChannelMuxer = class extends AbstractStreamMuxer {
  constructor(maConn, init) {
    super(maConn, {
      ...init,
      name: "muxer"
    });
    __publicField(this, "peerConnection");
    __publicField(this, "dataChannelOptions");
    this.peerConnection = init.peerConnection;
    this.protocol = init.protocol ?? MUXER_PROTOCOL;
    this.dataChannelOptions = init.dataChannelOptions ?? {};
    this.peerConnection.ondatachannel = ({ channel }) => {
      this.onDataChannel(channel);
    };
    queueMicrotask(() => {
      if (this.status !== "open") {
        init.earlyDataChannels.forEach((channel) => {
          channel.close();
        });
        return;
      }
      init.earlyDataChannels.forEach((channel) => {
        this.onDataChannel(channel);
      });
    });
  }
  onDataChannel(channel) {
    this.log("incoming datachannel with channel id %d, protocol %s and status %s", channel.id, channel.protocol, channel.readyState);
    if (channel.label === "init") {
      this.log.trace("closing init channel %d", channel.id);
      channel.close();
      return;
    }
    const stream = createStream({
      ...this.streamOptions,
      ...this.dataChannelOptions,
      channel,
      direction: "inbound",
      log: this.log
    });
    this.onRemoteStream(stream);
  }
  async onCreateStream(options2) {
    const channel = this.peerConnection.createDataChannel("", {
      // TODO: pre-negotiate stream protocol
      // protocol: options?.protocol
    });
    this.log("open channel %d for protocol %s", channel.id, options2?.protocol);
    const stream = createStream({
      ...options2,
      ...this.dataChannelOptions,
      channel,
      direction: "outbound",
      log: this.log
    });
    return stream;
  }
  onData() {
  }
};

// ../../node_modules/@libp2p/webrtc/dist/src/rtcpeerconnection-to-conn.js
var RTCPeerConnectionMultiaddrConnection = class extends AbstractMultiaddrConnection {
  constructor(init) {
    super(init);
    __publicField(this, "peerConnection");
    this.peerConnection = init.peerConnection;
    const initialState = init.peerConnection.connectionState;
    this.peerConnection.onconnectionstatechange = () => {
      this.log.trace("peer connection state change %s initial state %s", this.peerConnection.connectionState, initialState);
      if (this.peerConnection.connectionState === "disconnected" || this.peerConnection.connectionState === "failed" || this.peerConnection.connectionState === "closed") {
        this.onTransportClosed();
        this.peerConnection.close();
      }
    };
  }
  sendData(data) {
    return {
      sentBytes: data.byteLength,
      canSendMore: true
    };
  }
  async sendClose(options2) {
    this.peerConnection.close();
    options2?.signal?.throwIfAborted();
  }
  sendReset() {
    this.peerConnection.close();
  }
  sendPause() {
  }
  sendResume() {
  }
};
var toMultiaddrConnection = (init) => {
  return new RTCPeerConnectionMultiaddrConnection(init);
};

// ../../node_modules/@libp2p/webrtc/dist/src/webrtc/index.browser.js
var RTCPeerConnection2 = window.RTCPeerConnection;
var RTCSessionDescription = window.RTCSessionDescription;
var RTCIceCandidate = window.RTCIceCandidate;

// ../../node_modules/@libp2p/webrtc/dist/src/error.js
var WebRTCTransportError = class extends Error {
  constructor(msg) {
    super(`WebRTC transport error: ${msg}`);
    this.name = "WebRTCTransportError";
  }
};
var SDPHandshakeFailedError = class extends WebRTCTransportError {
  constructor(message2 = "SDP handshake failed") {
    super(message2);
    this.name = "SDPHandshakeFailedError";
  }
};
var ConnectionClosedError4 = class extends WebRTCTransportError {
  constructor(state, msg) {
    super(`peerconnection moved to state: ${state}: ${msg}`);
    this.name = "WebRTC/ConnectionClosed";
  }
};
var DataChannelError = class extends WebRTCTransportError {
  constructor(streamLabel, msg) {
    super(`[stream: ${streamLabel}] data channel error: ${msg}`);
    this.name = "WebRTC/DataChannelError";
  }
};
var InappropriateMultiaddrError = class extends WebRTCTransportError {
  constructor(msg) {
    super(`There was a problem with the Multiaddr which was passed in: ${msg}`);
    this.name = "WebRTC/InappropriateMultiaddrError";
  }
};
var InvalidArgumentError = class extends WebRTCTransportError {
  constructor(msg) {
    super(`There was a problem with a provided argument: ${msg}`);
    this.name = "WebRTC/InvalidArgumentError";
  }
};
var InvalidFingerprintError = class extends WebRTCTransportError {
  constructor(fingerprint, source) {
    super(`Invalid fingerprint "${fingerprint}" within ${source}`);
    this.name = "WebRTC/InvalidFingerprintError";
  }
};
var OperationAbortedError = class extends WebRTCTransportError {
  constructor(context, abortReason) {
    super(`Signalled to abort because (${abortReason}}) ${context}`);
    this.name = "WebRTC/OperationAbortedError";
  }
};
var OverStreamLimitError = class extends WebRTCTransportError {
  constructor(msg) {
    super(msg);
    this.name = "WebRTC/OverStreamLimitError";
  }
};
var UnimplementedError = class extends WebRTCTransportError {
  constructor(methodName) {
    super(`A method (${methodName}) was called though it has been intentionally left unimplemented.`);
    this.name = "WebRTC/UnimplementedError";
  }
};
var UnsupportedHashAlgorithmError = class extends WebRTCTransportError {
  constructor(algo) {
    super(`unsupported hash algorithm code: ${algo} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `);
    this.name = "WebRTC/UnsupportedHashAlgorithmError";
  }
};

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-private/pb/message.js
var Message3;
(function(Message4) {
  let Type2;
  (function(Type3) {
    Type3["SDP_OFFER"] = "SDP_OFFER";
    Type3["SDP_ANSWER"] = "SDP_ANSWER";
    Type3["ICE_CANDIDATE"] = "ICE_CANDIDATE";
  })(Type2 = Message4.Type || (Message4.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["SDP_OFFER"] = 0] = "SDP_OFFER";
    __TypeValues2[__TypeValues2["SDP_ANSWER"] = 1] = "SDP_ANSWER";
    __TypeValues2[__TypeValues2["ICE_CANDIDATE"] = 2] = "ICE_CANDIDATE";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type3) {
    Type3.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type2 = Message4.Type || (Message4.Type = {}));
  let _codec;
  Message4.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          Message4.Type.codec().encode(obj.type, w);
        }
        if (obj.data != null) {
          w.uint32(18);
          w.string(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length4, opts = {}) => {
        const obj = {};
        const end = length4 == null ? reader.len : reader.pos + length4;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = Message4.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.data = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message4.encode = (obj) => {
    return encodeMessage(obj, Message4.codec());
  };
  Message4.decode = (buf2, opts) => {
    return decodeMessage(buf2, Message4.codec(), opts);
  };
})(Message3 || (Message3 = {}));

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-private/util.js
var readCandidatesUntilConnected = async (pc, stream, options2) => {
  try {
    const connectedPromise = Promise.withResolvers();
    resolveOnConnected(pc, connectedPromise);
    while (true) {
      const message2 = await Promise.race([
        connectedPromise.promise,
        stream.read({
          signal: options2.signal
        })
      ]);
      if (message2 == null) {
        options2.signal?.throwIfAborted();
        break;
      }
      if (message2.type !== Message3.Type.ICE_CANDIDATE) {
        throw new InvalidMessageError2("ICE candidate message expected");
      }
      const candidateInit = JSON.parse(message2.data ?? "null");
      if (candidateInit === "" || candidateInit === null) {
        options2.onProgress?.(new CustomProgressEvent("webrtc:end-of-ice-candidates"));
        options2.log.trace("end-of-candidates received");
        continue;
      }
      const candidate = new RTCIceCandidate(candidateInit);
      options2.log.trace("%s received new ICE candidate %o", options2.direction, candidateInit);
      try {
        options2.onProgress?.(new CustomProgressEvent("webrtc:add-ice-candidate", candidate.candidate));
        await pc.addIceCandidate(candidate);
      } catch (err) {
        options2.log.error("%s bad candidate received %o - %e", options2.direction, candidateInit, err);
      }
    }
  } catch (err) {
    options2.log.error("%s error parsing ICE candidate - %e", options2.direction, err);
    if (options2.signal?.aborted === true && pc.connectionState !== "connected") {
      throw err;
    }
  }
};
function resolveOnConnected(pc, promise) {
  if (pc.connectionState === "connected") {
    promise.resolve();
    return;
  }
  pc.onconnectionstatechange = (_) => {
    switch (pc.connectionState) {
      case "connected":
        promise.resolve();
        break;
      case "failed":
      case "disconnected":
      case "closed":
        promise.reject(new ConnectionFailedError2(`RTCPeerConnection connection state became "${pc.connectionState}"`));
        break;
      default:
        break;
    }
  };
}
function getRemotePeer(ma) {
  let remotePeer;
  for (const component of ma.getComponents()) {
    if (component.name === "p2p") {
      remotePeer = peerIdFromString3(component.value ?? "");
    }
  }
  if (remotePeer == null) {
    throw new InvalidMultiaddrError2("Remote peerId must be present in multiaddr");
  }
  return remotePeer;
}

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-private/initiate-connection.js
async function initiateConnection({ rtcConfiguration, dataChannel, signal, metrics, multiaddr: ma, connectionManager, transportManager, log: log4, logger: logger2, onProgress }) {
  const { circuitAddress, targetPeer } = splitAddr(ma);
  metrics?.dialerEvents.increment({ open: true });
  log4.trace("dialing circuit address: %a", circuitAddress);
  const connections = connectionManager.getConnections(targetPeer);
  let connection;
  if (connections.length === 0) {
    onProgress?.(new CustomProgressEvent("webrtc:dial-relay"));
    connection = await transportManager.dial(circuitAddress, {
      signal,
      onProgress
    });
  } else {
    onProgress?.(new CustomProgressEvent("webrtc:reuse-relay-connection"));
    connection = connections[0];
  }
  onProgress?.(new CustomProgressEvent("webrtc:open-signaling-stream"));
  const stream = await connection.newStream(SIGNALING_PROTOCOL, {
    signal,
    runOnLimitedConnection: true
  });
  const messageStream = pbStream(stream).pb(Message3);
  const peerConnection = new RTCPeerConnection2(rtcConfiguration);
  peerConnection.addEventListener("connectionstatechange", () => {
    switch (peerConnection.connectionState) {
      case "closed":
        peerConnection.close();
        break;
      default:
        break;
    }
  });
  const muxerFactory = new DataChannelMuxerFactory({
    // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
    peerConnection,
    dataChannelOptions: dataChannel
  });
  try {
    const channel = peerConnection.createDataChannel("init");
    peerConnection.onicecandidate = ({ candidate }) => {
      if (peerConnection.connectionState === "connected") {
        log4.trace("ignore new ice candidate as peer connection is already connected");
        return;
      }
      if (candidate == null || candidate?.candidate === "") {
        log4.trace("initiator detected end of ICE candidates");
        return;
      }
      const data = JSON.stringify(candidate?.toJSON() ?? null);
      log4.trace("initiator sending ICE candidate %o", candidate);
      void messageStream.write({
        type: Message3.Type.ICE_CANDIDATE,
        data
      }, {
        signal
      }).catch((err) => {
        log4.error("error sending ICE candidate - %e", err);
      });
    };
    peerConnection.onicecandidateerror = (event) => {
      log4.error("initiator ICE candidate error", event);
    };
    const offerSdp = await peerConnection.createOffer().catch((err) => {
      log4.error("could not execute createOffer - %e", err);
      throw new SDPHandshakeFailedError("Failed to set createOffer");
    });
    log4.trace("initiator send SDP offer %s", offerSdp.sdp);
    onProgress?.(new CustomProgressEvent("webrtc:send-sdp-offer"));
    await messageStream.write({ type: Message3.Type.SDP_OFFER, data: offerSdp.sdp }, {
      signal
    });
    await peerConnection.setLocalDescription(offerSdp).catch((err) => {
      log4.error("could not execute setLocalDescription - %e", err);
      throw new SDPHandshakeFailedError("Failed to set localDescription");
    });
    onProgress?.(new CustomProgressEvent("webrtc:read-sdp-answer"));
    log4.trace("initiator read SDP answer");
    const answerMessage = await messageStream.read({
      signal
    });
    if (answerMessage.type !== Message3.Type.SDP_ANSWER) {
      throw new SDPHandshakeFailedError("Remote should send an SDP answer");
    }
    log4.trace("initiator received SDP answer %s", answerMessage.data);
    const answerSdp = new RTCSessionDescription({ type: "answer", sdp: answerMessage.data });
    await peerConnection.setRemoteDescription(answerSdp).catch((err) => {
      log4.error("could not execute setRemoteDescription - %e", err);
      throw new SDPHandshakeFailedError("Failed to set remoteDescription");
    });
    log4.trace("initiator read candidates until connected");
    onProgress?.(new CustomProgressEvent("webrtc:read-ice-candidates"));
    await readCandidatesUntilConnected(peerConnection, messageStream, {
      direction: "initiator",
      signal,
      log: log4,
      onProgress
    });
    log4.trace("initiator connected");
    if (channel.readyState !== "open") {
      log4.trace("wait for init channel to open");
      await pEvent(channel, "open", {
        signal
      });
    }
    log4.trace("closing init channel");
    channel.close();
    log4.trace("waiting for init channel to close");
    await pEvent(channel, "close", {
      signal
    });
    onProgress?.(new CustomProgressEvent("webrtc:close-signaling-stream"));
    log4.trace("closing signaling channel");
    await stream.close({
      signal
    });
    log4.trace("initiator connected to remote address %s", ma);
    return {
      remoteAddress: ma,
      // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
      peerConnection,
      muxerFactory
    };
  } catch (err) {
    log4.error("outgoing signaling error - %e", err);
    peerConnection.close();
    stream.abort(err);
    throw err;
  } finally {
    peerConnection.onicecandidate = null;
    peerConnection.onicecandidateerror = null;
  }
}

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-private/listener.js
var Circuit2 = fmt(P2P.matchers[0], code4(CODE_P2P_CIRCUIT2));
var WebRTCPeerListener = class _WebRTCPeerListener extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __publicField(this, "transportManager");
    __publicField(this, "shutdownController");
    __publicField(this, "events");
    this.transportManager = components.transportManager;
    this.events = components.events;
    this.shutdownController = init.shutdownController;
    this.onTransportListening = this.onTransportListening.bind(this);
  }
  async listen() {
    this.events.addEventListener("transport:listening", this.onTransportListening);
  }
  onTransportListening(event) {
    const circuitAddresses = event.detail.getAddrs().filter((ma) => Circuit2.exactMatch(ma)).map((ma) => {
      return ma.encapsulate("/webrtc");
    });
    if (circuitAddresses.length > 0) {
      this.safeDispatchEvent("listening");
    }
  }
  getAddrs() {
    return this.transportManager.getListeners().filter((l2) => !(l2 instanceof _WebRTCPeerListener)).map((l2) => l2.getAddrs().filter((ma) => Circuit2.exactMatch(ma)).map((ma) => {
      return ma.encapsulate("/webrtc");
    })).flat();
  }
  updateAnnounceAddrs() {
  }
  async close() {
    this.events.removeEventListener("transport:listening", this.onTransportListening);
    this.shutdownController.abort();
    queueMicrotask(() => {
      this.safeDispatchEvent("close");
    });
  }
};

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-private/signaling-stream-handler.js
async function handleIncomingStream(stream, connection, { peerConnection, signal, log: log4 }) {
  log4.trace("new inbound signaling stream");
  const messageStream = pbStream(stream).pb(Message3);
  try {
    peerConnection.onicecandidate = ({ candidate }) => {
      if (peerConnection.connectionState === "connected") {
        log4.trace("ignore new ice candidate as peer connection is already connected");
        return;
      }
      if (candidate == null || candidate?.candidate === "") {
        log4.trace("recipient detected end of ICE candidates");
        return;
      }
      const data = JSON.stringify(candidate?.toJSON() ?? null);
      log4.trace("recipient sending ICE candidate %s", data);
      messageStream.write({
        type: Message3.Type.ICE_CANDIDATE,
        data
      }, {
        signal
      }).catch((err) => {
        log4.error("error sending ICE candidate - %e", err);
      });
    };
    log4.trace("recipient read SDP offer");
    const pbOffer = await messageStream.read({
      signal
    });
    if (pbOffer.type !== Message3.Type.SDP_OFFER) {
      throw new SDPHandshakeFailedError(`expected message type SDP_OFFER, received: ${pbOffer.type ?? "undefined"} `);
    }
    log4.trace("recipient received SDP offer %s", pbOffer.data);
    const offer = new RTCSessionDescription({
      type: "offer",
      sdp: pbOffer.data
    });
    await peerConnection.setRemoteDescription(offer).catch((err) => {
      log4.error("could not execute setRemoteDescription - %e", err);
      throw new SDPHandshakeFailedError("Failed to set remoteDescription");
    });
    const answer = await peerConnection.createAnswer().catch((err) => {
      log4.error("could not execute createAnswer - %e", err);
      throw new SDPHandshakeFailedError("Failed to create answer");
    });
    log4.trace("recipient send SDP answer %s", answer.sdp);
    await messageStream.write({ type: Message3.Type.SDP_ANSWER, data: answer.sdp }, {
      signal
    });
    await peerConnection.setLocalDescription(answer).catch((err) => {
      log4.error("could not execute setLocalDescription - %e", err);
      throw new SDPHandshakeFailedError("Failed to set localDescription");
    });
    log4.trace("recipient read candidates until connected");
    await readCandidatesUntilConnected(peerConnection, messageStream, {
      direction: "recipient",
      signal,
      log: log4
    });
  } catch (err) {
    if (peerConnection.connectionState !== "connected") {
      log4.error("error while handling signaling stream from peer %a - %e", connection.remoteAddr, err);
      peerConnection.close();
      throw err;
    } else {
      log4("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected", connection.remoteAddr, err);
    }
  }
  const remotePeer = getRemotePeer(connection.remoteAddr);
  const remoteAddress = multiaddr(`/webrtc/p2p/${remotePeer}`);
  log4.trace("recipient connected to remote address %s", remoteAddress);
  return {
    remoteAddress,
    remotePeer
  };
}

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-private/transport.js
var _a23, _b19, _c10, _d5;
_d5 = transportSymbol, _c10 = Symbol.toStringTag, _b19 = serviceCapabilities2, _a23 = serviceDependencies2;
var WebRTCTransport = class {
  constructor(components, init = {}) {
    __publicField(this, "components");
    __publicField(this, "init");
    __publicField(this, "log");
    __publicField(this, "_started", false);
    __publicField(this, "metrics");
    __publicField(this, "shutdownController");
    __publicField(this, _d5, true);
    __publicField(this, _c10, "@libp2p/webrtc");
    __publicField(this, _b19, [
      "@libp2p/transport"
    ]);
    __publicField(this, _a23, [
      "@libp2p/identify",
      "@libp2p/circuit-relay-v2-transport"
    ]);
    this.components = components;
    this.init = init;
    this.log = components.logger.forComponent("libp2p:webrtc");
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total", {
          label: "event",
          help: "Total count of WebRTC dialer events by type"
        }),
        listenerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total", {
          label: "event",
          help: "Total count of WebRTC listener events by type"
        })
      };
    }
  }
  isStarted() {
    return this._started;
  }
  async start() {
    await this.components.registrar.handle(SIGNALING_PROTOCOL, (stream, connection) => {
      const signal = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
      this._onProtocol(stream, connection, signal).catch((err) => {
        this.log.error("failed to handle incoming connect from %p - %e", connection.remotePeer, err);
      }).finally(() => {
        signal.clear();
      });
    }, {
      runOnLimitedConnection: true
    });
    this._started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(SIGNALING_PROTOCOL);
    this._started = false;
  }
  createListener(options2) {
    return new WebRTCPeerListener(this.components, {
      shutdownController: this.shutdownController
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    return multiaddrs.filter(WebRTC.exactMatch);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
  /*
   * dial connects to a remote via the circuit relay or any other protocol
   * and proceeds to upgrade to a webrtc connection.
   * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>
   * For a circuit relay, this will be of the form
   * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>
  */
  async dial(ma, options2) {
    this.log.trace("dialing address: %a", ma);
    const { remoteAddress, peerConnection, muxerFactory } = await initiateConnection({
      rtcConfiguration: await getRtcConfiguration(this.init.rtcConfiguration),
      dataChannel: this.init.dataChannel,
      multiaddr: ma,
      dataChannelOptions: this.init.dataChannel,
      signal: options2.signal,
      connectionManager: this.components.connectionManager,
      transportManager: this.components.transportManager,
      log: this.log,
      logger: this.components.logger,
      onProgress: options2.onProgress
    });
    const webRTCConn = toMultiaddrConnection({
      peerConnection,
      remoteAddr: remoteAddress,
      metrics: this.metrics?.dialerEvents,
      direction: "outbound",
      log: this.components.logger.forComponent("libp2p:webrtc:connection")
    });
    const connection = await options2.upgrader.upgradeOutbound(webRTCConn, {
      skipProtection: true,
      skipEncryption: true,
      remotePeer: getRemotePeer(ma),
      muxerFactory,
      onProgress: options2.onProgress,
      signal: options2.signal
    });
    this._closeOnShutdown(peerConnection, webRTCConn);
    return connection;
  }
  async _onProtocol(stream, connection, signal) {
    const peerConnection = new RTCPeerConnection2(await getRtcConfiguration(this.init.rtcConfiguration));
    peerConnection.addEventListener("connectionstatechange", () => {
      switch (peerConnection.connectionState) {
        case "closed":
          peerConnection.close();
          break;
        default:
          break;
      }
    });
    const muxerFactory = new DataChannelMuxerFactory({
      // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
      peerConnection,
      dataChannelOptions: this.init.dataChannel
    });
    try {
      const { remoteAddress, remotePeer } = await handleIncomingStream(stream, connection, {
        peerConnection,
        signal,
        log: this.log
      });
      await stream.close({
        signal
      });
      const webRTCConn = toMultiaddrConnection({
        // @ts-expect-error https://github.com/murat-dogan/node-datachannel/pull/370
        peerConnection,
        remoteAddr: remoteAddress,
        metrics: this.metrics?.listenerEvents,
        direction: "inbound",
        log: this.components.logger.forComponent("libp2p:webrtc:connection")
      });
      await this.components.upgrader.upgradeInbound(webRTCConn, {
        skipEncryption: true,
        skipProtection: true,
        remotePeer,
        muxerFactory,
        signal
      });
      this._closeOnShutdown(peerConnection, webRTCConn);
    } catch (err) {
      this.log.error("incoming signaling error - %e", err);
      peerConnection.close();
      stream.abort(err);
      throw err;
    }
  }
  _closeOnShutdown(pc, webRTCConn) {
    const shutDownListener = () => {
      webRTCConn.close().catch((err) => {
        this.log.error("could not close WebRTCMultiaddrConnection - %e", err);
      });
    };
    this.shutdownController.signal.addEventListener("abort", shutDownListener);
    pc.addEventListener("close", () => {
      this.shutdownController.signal.removeEventListener("abort", shutDownListener);
    });
  }
};
function splitAddr(ma) {
  const target = ma.getComponents().filter(({ name: name5 }) => name5 === "p2p").map(({ value: value2 }) => value2).pop();
  if (target == null) {
    throw new InvalidParametersError2("Destination peer id was missing");
  }
  const circuitAddress = multiaddr(ma.getComponents().filter(({ name: name5 }) => name5 !== "webrtc"));
  return { circuitAddress, targetPeer: peerIdFromString3(target) };
}

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/sdp.js
var multibaseDecoder = Object.values(bases).map((b) => b.decoder).reduce((d2, b) => d2.or(b));
var fingerprintRegex = /^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;
function getFingerprintFromSdp(sdp) {
  if (sdp == null) {
    return void 0;
  }
  const searchResult = sdp.match(fingerprintRegex);
  return searchResult?.groups?.fingerprint;
}
function certhash(ma) {
  const components = ma.getComponents();
  const certhash2 = components.find((c2) => c2.code === CODE_CERTHASH2)?.value;
  if (certhash2 === void 0 || certhash2 === "") {
    throw new InvalidParametersError2(`Couldn't find a certhash component of multiaddr: ${ma.toString()}`);
  }
  return certhash2;
}
function decodeCerthash(certhash2) {
  return digest_exports.decode(multibaseDecoder.decode(certhash2));
}
function certhashToFingerprint(certhash2) {
  const multibaseDecoded = decodeCerthash(certhash2);
  return new Array(multibaseDecoded.bytes.length).fill(0).map((val, index) => {
    return multibaseDecoded.digest[index].toString(16).padStart(2, "0").toUpperCase();
  }).join(":");
}
function ma2Fingerprint(ma) {
  const multihashDecoded = decodeCerthash(certhash(ma));
  const prefix = toSupportedHashFunction(multihashDecoded.code);
  const fingerprint = multihashDecoded.digest.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
  const sdp = fingerprint.match(/.{1,2}/g);
  if (sdp == null) {
    throw new InvalidFingerprintError(fingerprint, ma.toString());
  }
  return `${prefix} ${sdp.join(":").toUpperCase()}`;
}
function fingerprint2Ma(fingerprint) {
  const output = fingerprint.split(":").map((str) => parseInt(str, 16));
  const encoded = Uint8Array.from(output);
  const digest2 = create(sha256.code, encoded);
  return multiaddr(`/certhash/${base64url.encode(digest2.bytes)}`);
}
function toSupportedHashFunction(code5) {
  switch (code5) {
    case 17:
      return "sha-1";
    case 18:
      return "sha-256";
    case 19:
      return "sha-512";
    default:
      throw new UnsupportedHashAlgorithmError(code5);
  }
}
function serverAnswerFromMultiaddr(ma, ufrag) {
  const { host, port, type } = getNetConfig(ma);
  if (type !== "ip4" && type !== "ip6") {
    throw new InvalidParametersError2(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
  }
  const fingerprint = ma2Fingerprint(ma);
  const sdp = `v=0
o=- 0 0 IN IP${type === "ip4" ? 4 : 6} ${host}
s=-
t=0 0
a=ice-lite
m=application ${port} UDP/DTLS/SCTP webrtc-datachannel
c=IN IP${type === "ip4" ? 4 : 6} ${host}
a=mid:0
a=ice-options:ice2
a=ice-ufrag:${ufrag}
a=ice-pwd:${ufrag}
a=fingerprint:${fingerprint}
a=setup:passive
a=sctp-port:5000
a=max-message-size:${MAX_MESSAGE_SIZE2}
a=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host
a=end-of-candidates
`;
  return {
    type: "answer",
    sdp
  };
}
function clientOfferFromMultiAddr(ma, ufrag) {
  const { host, port, type } = getNetConfig(ma);
  if (type !== "ip4" && type !== "ip6") {
    throw new InvalidParametersError2(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
  }
  const sdp = `v=0
o=- 0 0 IN IP${type === "ip4" ? 4 : 6} ${host}
s=-
c=IN IP${type === "ip4" ? 4 : 6} ${host}
t=0 0
a=ice-options:ice2,trickle
m=application ${port} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:active
a=ice-ufrag:${ufrag}
a=ice-pwd:${ufrag}
a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
a=sctp-port:5000
a=max-message-size:${MAX_MESSAGE_SIZE2}
a=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host
a=end-of-candidates
`;
  return {
    type: "offer",
    sdp
  };
}
function munge(desc, ufrag) {
  if (desc.sdp === void 0) {
    throw new InvalidParametersError2("Can't munge a missing SDP");
  }
  const lineBreak = desc.sdp.includes("\r\n") ? "\r\n" : "\n";
  try {
    desc.sdp = desc.sdp.replace(/\na=ice-ufrag:[^\n]*\n/, "\na=ice-ufrag:" + ufrag + lineBreak).replace(/\na=ice-pwd:[^\n]*\n/, "\na=ice-pwd:" + ufrag + lineBreak);
  } catch {
  }
  return desc;
}

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/generate-noise-prologue.js
var PREFIX = fromString2("libp2p-webrtc-noise:");
function generateNoisePrologue(localFingerprint, remoteAddr, role) {
  const localFpString = localFingerprint.trim().toLowerCase().replaceAll(":", "");
  const localFpArray = fromString2(localFpString, "hex");
  const local = create(sha256.code, localFpArray);
  const remote = multibaseDecoder.decode(certhash(remoteAddr));
  const byteLength = PREFIX.byteLength + local.bytes.byteLength + remote.byteLength;
  if (role === "server") {
    return concat([PREFIX, remote, local.bytes], byteLength);
  }
  return concat([PREFIX, local.bytes, remote], byteLength);
}

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/connect.js
var CONNECTION_STATE_CHANGE_EVENT = isFirefox ? "iceconnectionstatechange" : "connectionstatechange";
function isServer(options2, peerConnection) {
  return options2.role === "server";
}
async function connect(peerConnection, muxerFactory, ufrag, options2) {
  const handshakeDataChannel = peerConnection.createDataChannel("", { negotiated: true, id: 0 });
  try {
    if (options2.role === "client") {
      options2.log.trace("client creating local offer");
      const offerSdp = await peerConnection.createOffer();
      options2.log.trace("client created local offer %s", offerSdp.sdp);
      const mungedOfferSdp = munge(offerSdp, ufrag);
      options2.log.trace("client setting local offer %s", mungedOfferSdp.sdp);
      await peerConnection.setLocalDescription(mungedOfferSdp);
      const answerSdp = serverAnswerFromMultiaddr(options2.remoteAddr, ufrag);
      options2.log.trace("client setting server description %s", answerSdp.sdp);
      await peerConnection.setRemoteDescription(answerSdp);
    } else {
      const offerSdp = clientOfferFromMultiAddr(options2.remoteAddr, ufrag);
      options2.log.trace("server setting client %s %s", offerSdp.type, offerSdp.sdp);
      await peerConnection.setRemoteDescription(offerSdp);
      options2.log.trace("server creating local answer");
      const answerSdp = await peerConnection.createAnswer();
      options2.log.trace("server created local answer");
      const mungedAnswerSdp = munge(answerSdp, ufrag);
      options2.log.trace("server setting local description %s", answerSdp.sdp);
      await peerConnection.setLocalDescription(mungedAnswerSdp);
    }
    if (handshakeDataChannel.readyState !== "open") {
      options2.log.trace("%s wait for handshake channel to open, starting status %s", options2.role, handshakeDataChannel.readyState);
      await pEvent(handshakeDataChannel, "open", options2);
    }
    options2.log.trace("%s handshake channel opened", options2.role);
    if (isServer(options2, peerConnection)) {
      const remoteFingerprint = peerConnection.remoteFingerprint()?.value ?? "";
      options2.remoteAddr = options2.remoteAddr.encapsulate(fingerprint2Ma(remoteFingerprint));
    }
    const localFingerprint = getFingerprintFromSdp(peerConnection.localDescription?.sdp);
    if (localFingerprint == null) {
      throw new WebRTCTransportError("Could not get fingerprint from local description sdp");
    }
    options2.log.trace("%s performing noise handshake", options2.role);
    const noisePrologue = generateNoisePrologue(localFingerprint, options2.remoteAddr, options2.role);
    const connectionEncrypter = noise({ prologueBytes: noisePrologue })(options2);
    const handshakeStream = createStream({
      channel: handshakeDataChannel,
      direction: "outbound",
      isHandshake: true,
      log: options2.log,
      ...options2.dataChannel ?? {}
    });
    const maConn = toMultiaddrConnection({
      // @ts-expect-error types are broken
      peerConnection,
      remoteAddr: options2.remoteAddr,
      metrics: options2.events,
      direction: options2.role === "client" ? "outbound" : "inbound",
      log: options2.logger.forComponent("libp2p:webrtc-direct:connection")
    });
    peerConnection.addEventListener(CONNECTION_STATE_CHANGE_EVENT, () => {
      switch (peerConnection.connectionState) {
        case "failed":
        case "disconnected":
        case "closed":
          maConn.close().catch((err) => {
            options2.log.error("error closing connection - %e", err);
            maConn.abort(err);
          });
          break;
        default:
          break;
      }
    });
    options2.events?.increment({ peer_connection: true });
    if (options2.role === "client") {
      options2.log.trace("%s secure inbound", options2.role);
      const result2 = await connectionEncrypter.secureInbound(handshakeStream, {
        remotePeer: options2.remotePeer,
        signal: options2.signal,
        skipStreamMuxerNegotiation: true
      });
      options2.log.trace("%s upgrade outbound", options2.role);
      return await options2.upgrader.upgradeOutbound(maConn, {
        skipProtection: true,
        skipEncryption: true,
        remotePeer: result2.remotePeer,
        muxerFactory,
        signal: options2.signal
      });
    }
    options2.log.trace("%s secure outbound", options2.role);
    const result = await connectionEncrypter.secureOutbound(handshakeStream, {
      remotePeer: options2.remotePeer,
      signal: options2.signal,
      skipStreamMuxerNegotiation: true
    });
    maConn.remoteAddr = maConn.remoteAddr.encapsulate(`/p2p/${result.remotePeer}`);
    options2.log.trace("%s upgrade inbound", options2.role);
    await options2.upgrader.upgradeInbound(maConn, {
      skipProtection: true,
      skipEncryption: true,
      remotePeer: result.remotePeer,
      muxerFactory,
      signal: options2.signal
    });
  } catch (err) {
    handshakeDataChannel.close();
    peerConnection.close();
    throw err;
  }
}

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-public/utils/get-rtcpeerconnection.browser.js
async function createDialerRTCPeerConnection(role, ufrag, options2 = {}) {
  let certificate = options2.certificate;
  if (certificate == null) {
    certificate = await RTCPeerConnection.generateCertificate({
      name: "ECDSA",
      // @ts-expect-error missing from lib.dom.d.ts but required by chrome
      namedCurve: "P-256"
      // hash: sdp.toSupportedHashFunction(hashName)
    });
  }
  const rtcConfig = typeof options2.rtcConfiguration === "function" ? await options2.rtcConfiguration() : options2.rtcConfiguration;
  const peerConnection = new RTCPeerConnection({
    ...rtcConfig ?? {},
    certificates: [certificate]
  });
  const muxerFactory = new DataChannelMuxerFactory({
    peerConnection,
    metrics: options2.events,
    dataChannelOptions: options2.dataChannel
  });
  return {
    peerConnection,
    muxerFactory
  };
}

// ../../node_modules/@libp2p/webrtc/dist/src/private-to-public/transport.browser.js
var _a24, _b20, _c11;
_c11 = transportSymbol, _b20 = Symbol.toStringTag, _a24 = serviceCapabilities2;
var WebRTCDirectTransport = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "metrics");
    __publicField(this, "components");
    __publicField(this, "init");
    __publicField(this, _c11, true);
    __publicField(this, _b20, "@libp2p/webrtc-direct");
    __publicField(this, _a24, [
      "@libp2p/transport"
    ]);
    this.log = components.logger.forComponent("libp2p:webrtc-direct");
    this.components = components;
    this.init = init;
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total", {
          label: "event",
          help: "Total count of WebRTC-direct dial events by type"
        })
      };
    }
  }
  /**
   * Dial a given multiaddr
   */
  async dial(ma, options2) {
    this.log("dial %a", ma);
    options2.signal.throwIfAborted();
    let theirPeerId;
    const remotePeerString = ma.getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value;
    if (remotePeerString != null) {
      theirPeerId = peerIdFromString3(remotePeerString);
    }
    const ufrag = genUfrag();
    const { peerConnection, muxerFactory } = await createDialerRTCPeerConnection("client", ufrag, {
      rtcConfiguration: typeof this.init.rtcConfiguration === "function" ? await this.init.rtcConfiguration() : this.init.rtcConfiguration ?? {},
      dataChannel: this.init.dataChannel
    });
    try {
      return await connect(peerConnection, muxerFactory, ufrag, {
        role: "client",
        log: this.log,
        logger: this.components.logger,
        events: this.metrics?.dialerEvents,
        signal: options2.signal,
        remoteAddr: ma,
        dataChannel: this.init.dataChannel,
        upgrader: options2.upgrader,
        peerId: this.components.peerId,
        remotePeer: theirPeerId,
        privateKey: this.components.privateKey
      });
    } catch (err) {
      peerConnection.close();
      throw err;
    }
  }
  /**
   * Create a transport listener - this will throw in browsers
   */
  createListener(options2) {
    throw new UnimplementedError("WebRTCDirectTransport.createListener");
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    return [];
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return multiaddrs.filter(WebRTCDirect.exactMatch);
  }
};

// ../../node_modules/@libp2p/webrtc/dist/src/index.js
function webRTCDirect(init) {
  return (components) => new WebRTCDirectTransport(components, init);
}
function webRTC(init) {
  return (components) => new WebRTCTransport(components, init);
}

// ../../node_modules/@libp2p/websockets/dist/src/listener.browser.js
function createListener2() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}

// ../../node_modules/@libp2p/websockets/dist/src/websocket-to-conn.js
var DEFAULT_MAX_BUFFERED_AMOUNT = 1024 * 1024 * 4;
var DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL = 10;
var WebSocketMultiaddrConnection = class extends AbstractMultiaddrConnection {
  constructor(init) {
    super(init);
    __publicField(this, "websocket");
    __publicField(this, "maxBufferedAmount");
    __publicField(this, "checkBufferedAmountTask");
    this.websocket = init.websocket;
    this.maxBufferedAmount = init.maxBufferedAmount ?? DEFAULT_MAX_BUFFERED_AMOUNT;
    this.checkBufferedAmountTask = repeatingTask(this.checkBufferedAmount.bind(this), init.bufferedAmountPollInterval ?? DEFAULT_BUFFERED_AMOUNT_POLL_INTERVAL);
    this.websocket.addEventListener("close", (evt) => {
      this.log('closed - code %d, reason "%s", wasClean %s', evt.code, evt.reason, evt.wasClean);
      this.checkBufferedAmountTask.stop();
      if (!evt.wasClean) {
        this.onRemoteReset();
        return;
      }
      this.onTransportClosed();
    }, { once: true });
    this.websocket.addEventListener("message", (evt) => {
      try {
        let buf2;
        if (typeof evt.data === "string") {
          buf2 = fromString2(evt.data);
        } else if (evt.data instanceof ArrayBuffer) {
          buf2 = new Uint8Array(evt.data, 0, evt.data.byteLength);
        } else {
          this.abort(new Error("Incorrect binary type"));
          return;
        }
        this.onData(buf2);
      } catch (err) {
        this.log.error("error receiving data - %e", err);
      }
    });
  }
  sendData(data) {
    for (const buf2 of data) {
      this.websocket.send(buf2);
    }
    const canSendMore = this.websocket.bufferedAmount < this.maxBufferedAmount;
    if (!canSendMore) {
      this.checkBufferedAmountTask.start();
    }
    return {
      sentBytes: data.byteLength,
      canSendMore
    };
  }
  sendReset() {
    this.websocket.close(1006);
  }
  async sendClose(options2) {
    this.websocket.close();
    options2?.signal?.throwIfAborted();
  }
  sendPause() {
  }
  sendResume() {
  }
  checkBufferedAmount() {
    this.log("buffered amount now %d", this.websocket.bufferedAmount);
    if (this.websocket.bufferedAmount === 0) {
      this.checkBufferedAmountTask.stop();
      this.safeDispatchEvent("drain");
    }
  }
};
function webSocketToMaConn(init) {
  return new WebSocketMultiaddrConnection(init);
}

// ../../node_modules/@libp2p/websockets/dist/src/index.js
var _a25, _b21, _c12;
_c12 = transportSymbol, _b21 = Symbol.toStringTag, _a25 = serviceCapabilities2;
var WebSockets2 = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "init");
    __publicField(this, "logger");
    __publicField(this, "metrics");
    __publicField(this, "components");
    __publicField(this, _c12, true);
    __publicField(this, _b21, "@libp2p/websockets");
    __publicField(this, _a25, [
      "@libp2p/transport"
    ]);
    this.log = components.logger.forComponent("libp2p:websockets");
    this.logger = components.logger;
    this.components = components;
    this.init = init;
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total", {
          label: "event",
          help: "Total count of WebSockets dialer events by type"
        })
      };
    }
  }
  async dial(ma, options2) {
    this.log("dialing %s", ma);
    options2 = options2 ?? {};
    const maConn = webSocketToMaConn({
      websocket: await this._connect(ma, options2),
      remoteAddr: ma,
      metrics: this.metrics?.dialerEvents,
      direction: "outbound",
      log: this.components.logger.forComponent("libp2p:websockets:connection"),
      maxBufferedAmount: this.init.maxBufferedAmount,
      bufferedAmountPollInterval: this.init.bufferedAmountPollInterval
    });
    this.log("new outbound connection %s", maConn.remoteAddr);
    const conn = await options2.upgrader.upgradeOutbound(maConn, options2);
    this.log("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options2) {
    options2?.signal?.throwIfAborted();
    const uri = multiaddrToUri(ma);
    this.log("create websocket connection to %s", uri);
    const websocket = new WebSocket(uri);
    websocket.binaryType = "arraybuffer";
    try {
      options2.onProgress?.(new CustomProgressEvent("websockets:open-connection"));
      await pEvent(websocket, "open", options2);
    } catch (err) {
      if (options2.signal?.aborted) {
        this.metrics?.dialerEvents.increment({ abort: true });
        throw new ConnectionFailedError2(`Could not connect to ${uri}`);
      } else {
        this.metrics?.dialerEvents.increment({ error: true });
      }
      try {
        websocket.close();
      } catch {
      }
      throw err;
    }
    this.log("connected %s", ma);
    this.metrics?.dialerEvents.increment({ connect: true });
    return websocket;
  }
  /**
   * Creates a WebSockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`
   */
  createListener(options2) {
    return createListener2({
      logger: this.logger,
      events: this.components.events,
      metrics: this.components.metrics
    }, {
      ...this.init,
      ...options2
    });
  }
  listenFilter(multiaddrs) {
    return multiaddrs.filter((ma) => WebSockets.exactMatch(ma) || WebSocketsSecure.exactMatch(ma));
  }
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
};
function webSockets(init = {}) {
  return (components) => {
    return new WebSockets2(components, init);
  };
}

// ../../node_modules/@libp2p/webtransport/dist/src/listener.browser.js
function createListener3(options2) {
  throw new Error("Not implemented");
}

// ../../node_modules/@libp2p/webtransport/dist/src/stream.js
var WebTransportStream = class extends AbstractStream {
  constructor(init) {
    super(init);
    __publicField(this, "writer");
    __publicField(this, "reader");
    this.writer = init.stream.writable.getWriter();
    this.reader = init.stream.readable.getReader();
    void this.writer.closed.then(() => {
      this.log("writer closed gracefully");
    }).catch((err) => {
      if (err.message.includes("STOP_SENDING") || err.message.includes("StopSending")) {
        this.onRemoteCloseRead();
      } else if (err.message.includes("RESET_STREAM") || err.message.includes("Reset")) {
        this.onRemoteReset();
      } else {
        this.log("writer close promise rejected - %e", err);
      }
    });
    this.readData();
  }
  readData() {
    Promise.resolve().then(async () => {
      while (true) {
        const result = await this.reader.read();
        if (result.value != null) {
          this.onData(result.value);
        }
        if (result.done) {
          this.log("remote closed write");
          this.onRemoteCloseWrite();
          return;
        }
        if (this.readStatus === "paused") {
          break;
        }
      }
    }).catch((err) => {
      this.abort(err);
    }).finally(() => {
      this.reader.releaseLock();
    });
  }
  sendData(data) {
    for (const buf2 of data) {
      this.writer.write(buf2).catch((err) => {
        this.abort(err);
      });
    }
    this.log.trace("desired size after sending %d bytes is %d bytes", data.byteLength, this.writer.desiredSize);
    if (this.writer.desiredSize == null) {
      return {
        sentBytes: data.byteLength,
        canSendMore: false
      };
    }
    const canSendMore = this.writer.desiredSize > 0;
    if (!canSendMore) {
      this.writer.ready.then(() => {
        this.safeDispatchEvent("drain");
      }, (err) => {
        this.abort(err);
      });
    }
    return {
      sentBytes: data.byteLength,
      canSendMore
    };
  }
  sendReset(err) {
    this.writer.abort(err).catch((err2) => {
      this.log.error("error aborting writer - %e", err2);
    });
  }
  async sendCloseWrite(options2) {
    this.log("sendCloseWrite closing writer");
    await raceSignal(this.writer.close().catch(() => {
    }), options2?.signal);
    this.log("sendCloseWrite closed writer");
  }
  async sendCloseRead(options2) {
    this.log("sendCloseRead cancelling reader");
    await raceSignal(this.reader.cancel(), options2?.signal);
    this.log("sendCloseRead cancelled reader");
  }
  sendPause() {
  }
  sendResume() {
    this.readData();
  }
};
function webtransportBiDiStreamToStream(stream, streamId2, direction, log4, options2) {
  return new WebTransportStream({
    ...options2,
    stream,
    id: streamId2,
    direction,
    log: log4.newScope(`${direction}:${streamId2}`),
    protocol: ""
  });
}

// ../../node_modules/@libp2p/webtransport/dist/src/muxer.js
var PROTOCOL2 = "/webtransport";
var WebTransportStreamMuxer = class extends AbstractStreamMuxer {
  constructor(webTransport2, maConn) {
    super(maConn, {
      protocol: PROTOCOL2,
      name: "muxer"
    });
    __publicField(this, "webTransport");
    __publicField(this, "streamIDCounter");
    __publicField(this, "reader");
    this.webTransport = webTransport2;
    this.streamIDCounter = 0;
    this.reader = this.webTransport.incomingBidirectionalStreams.getReader();
    Promise.resolve().then(async () => {
      while (true) {
        const { done, value: value2 } = await this.reader.read();
        if (done || value2 == null) {
          break;
        }
        this.onRemoteStream(webtransportBiDiStreamToStream(value2, String(this.streamIDCounter++), "inbound", this.log, this.streamOptions));
      }
    }).catch((err) => {
      this.log.error("could not create a new stream - %e", err);
    });
  }
  async onCreateStream(options2) {
    const wtStream = await this.webTransport.createBidirectionalStream();
    options2?.signal?.throwIfAborted();
    return webtransportBiDiStreamToStream(wtStream, String(this.streamIDCounter++), "outbound", this.log, options2);
  }
  onData() {
  }
  sendReset() {
    this.webTransport.close();
  }
};
function webtransportMuxer(webTransport2) {
  return {
    protocol: PROTOCOL2,
    createStreamMuxer(maConn) {
      return new WebTransportStreamMuxer(webTransport2, maConn);
    }
  };
}

// ../../node_modules/@libp2p/webtransport/dist/src/session-to-conn.js
var WebTransportSessionMultiaddrConnection = class extends AbstractMultiaddrConnection {
  constructor(init) {
    super(init);
    __publicField(this, "cleanUpWTSession");
    this.cleanUpWTSession = init.cleanUpWTSession;
  }
  sendData(data) {
    return {
      sentBytes: data.byteLength,
      canSendMore: true
    };
  }
  sendReset() {
    this.cleanUpWTSession("abort");
  }
  async sendClose(options2) {
    this.cleanUpWTSession("close");
    options2?.signal?.throwIfAborted();
  }
  sendPause() {
  }
  sendResume() {
  }
};
var toMultiaddrConnection2 = (init) => {
  return new WebTransportSessionMultiaddrConnection(init);
};

// ../../node_modules/@libp2p/webtransport/dist/src/utils/is-subset.js
function isSubset(set, maybeSubset) {
  const intersection = maybeSubset.filter((byteArray) => {
    return Boolean(set.find((otherByteArray) => equals3(byteArray, otherByteArray)));
  });
  return intersection.length === maybeSubset.length;
}

// ../../node_modules/@libp2p/webtransport/dist/src/utils/parse-multiaddr.js
var multibaseDecoder2 = Object.values(bases).map((b) => b.decoder).reduce((d2, b) => d2.or(b));
function decodeCerthashStr(s2) {
  return digest_exports.decode(multibaseDecoder2.decode(s2));
}
function parseMultiaddr(ma) {
  if (!WebTransport.matches(ma)) {
    throw new InvalidMultiaddrError2("Invalid multiaddr, was not a WebTransport address");
  }
  const certhashes = [];
  let remotePeer;
  for (const components of ma.getComponents()) {
    if (components.name === "certhash") {
      certhashes.push(decodeCerthashStr(components.value ?? ""));
    }
    if (components.name === "p2p" && remotePeer == null) {
      remotePeer = peerIdFromString3(components.value ?? "");
    }
  }
  if (remotePeer == null) {
    throw new InvalidMultiaddrError2("Remote peer must be present in multiaddr");
  }
  const opts = getNetConfig(ma);
  let host = opts.host;
  if (opts.type === "ip6" && host.includes(":")) {
    host = `[${host}]`;
  }
  return {
    // All webtransport urls are https
    url: `https://${host}:${opts.port}`,
    certhashes,
    remotePeer
  };
}

// ../../node_modules/@libp2p/webtransport/dist/src/utils/webtransport-message-stream.js
var WebTransportMessageStream = class extends AbstractMessageStream {
  constructor(init) {
    super(init);
    __publicField(this, "writer");
    __publicField(this, "reader");
    this.writer = init.stream.writable.getWriter();
    this.reader = init.stream.readable.getReader();
    Promise.resolve().then(async () => {
      while (true) {
        const { done, value: value2 } = await this.reader.read();
        if (value2 != null) {
          this.onData(value2);
        }
        if (done) {
          break;
        }
      }
    }).catch((err) => {
      this.abort(err);
    });
  }
  async close(options2) {
    await raceSignal(this.writer.close(), options2?.signal);
  }
  sendData(data) {
    this.writer.write(data.subarray()).catch((err) => {
      this.abort(err);
    });
    return {
      sentBytes: data.byteLength,
      canSendMore: true
    };
  }
  sendReset(err) {
    this.writer.abort(err).catch((err2) => {
      this.log.error("could not send reset - %e", err2);
    });
  }
  sendPause() {
  }
  sendResume() {
  }
};

// ../../node_modules/@libp2p/webtransport/dist/src/webtransport.browser.js
var webtransport_browser_default = window.WebTransport;

// ../../node_modules/@libp2p/webtransport/dist/src/index.js
var _a26, _b22, _c13;
_c13 = Symbol.toStringTag, _b22 = transportSymbol, _a26 = serviceCapabilities2;
var WebTransportTransport = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "config");
    __publicField(this, "metrics");
    __publicField(this, _c13, "@libp2p/webtransport");
    __publicField(this, _b22, true);
    __publicField(this, _a26, [
      "@libp2p/transport"
    ]);
    this.log = components.logger.forComponent("libp2p:webtransport");
    this.components = components;
    this.config = {
      ...init,
      certificates: init.certificates ?? []
    };
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webtransport_dialer_events_total", {
          label: "event",
          help: "Total count of WebTransport dialer events by type"
        })
      };
    }
  }
  async dial(ma, options2) {
    options2.signal.throwIfAborted();
    this.log("dialing %s", ma);
    options2 = options2 ?? {};
    const { url, certhashes, remotePeer } = parseMultiaddr(ma);
    let abortListener;
    let maConn;
    let cleanUpWTSession = () => {
    };
    let closed = false;
    let ready = false;
    let authenticated = false;
    try {
      this.metrics?.dialerEvents.increment({ pending: true });
      const wt = new webtransport_browser_default(`${url}/.well-known/libp2p-webtransport?type=noise`, {
        serverCertificateHashes: certhashes.map((certhash2) => ({
          algorithm: "sha-256",
          value: certhash2.digest
        }))
      });
      cleanUpWTSession = (metric) => {
        if (closed) {
          return;
        }
        try {
          this.metrics?.dialerEvents.increment({ [metric]: true });
          wt.close();
        } catch (err) {
          this.log.error("error closing wt session - %e", err);
        } finally {
          if (maConn != null) {
            maConn.timeline.close = Date.now();
          }
          closed = true;
        }
      };
      abortListener = () => {
        if (ready) {
          cleanUpWTSession("noise_timeout");
        } else {
          cleanUpWTSession("ready_timeout");
        }
      };
      options2.signal.addEventListener("abort", abortListener, {
        once: true
      });
      this.log("wait for session to be ready");
      options2.onProgress?.(new CustomProgressEvent("webtransport:wait-for-session"));
      await Promise.race([
        wt.closed,
        wt.ready
      ]);
      this.log("session became ready");
      ready = true;
      this.metrics?.dialerEvents.increment({ ready: true });
      wt.closed.catch((err) => {
        this.log.error("error on remote wt session close - %e", err);
      }).finally(() => {
        cleanUpWTSession("remote_close");
      });
      this.metrics?.dialerEvents.increment({ open: true });
      maConn = toMultiaddrConnection2({
        remoteAddr: ma,
        cleanUpWTSession,
        direction: "outbound",
        log: this.components.logger.forComponent("libp2p:webtransport:connection")
      });
      authenticated = await this.authenticateWebTransport({
        wt,
        maConn,
        remotePeer,
        certhashes,
        ...options2
      });
      if (!authenticated) {
        throw new InvalidCryptoExchangeError2("Failed to authenticate webtransport");
      }
      return await options2.upgrader.upgradeOutbound(maConn, {
        ...options2,
        skipEncryption: true,
        remotePeer,
        muxerFactory: webtransportMuxer(wt),
        skipProtection: true
      });
    } catch (err) {
      this.log.error("caught wt session err - %e", err);
      if (authenticated) {
        cleanUpWTSession("upgrade_error");
      } else if (ready) {
        cleanUpWTSession("noise_error");
      } else {
        cleanUpWTSession("ready_error");
      }
      throw err;
    } finally {
      if (abortListener != null) {
        options2.signal?.removeEventListener("abort", abortListener);
      }
    }
  }
  async authenticateWebTransport({ wt, maConn, remotePeer, certhashes, onProgress, signal }) {
    onProgress?.(new CustomProgressEvent("webtransport:open-authentication-stream"));
    const stream = await wt.createBidirectionalStream();
    signal?.throwIfAborted();
    const messages2 = new WebTransportMessageStream({
      stream,
      log: maConn.log.newScope("muxer")
    });
    const n2 = noise()(this.components);
    onProgress?.(new CustomProgressEvent("webtransport:secure-outbound-connection"));
    const { remoteExtensions } = await n2.secureOutbound(messages2, {
      signal,
      remotePeer,
      skipStreamMuxerNegotiation: true
    });
    onProgress?.(new CustomProgressEvent("webtransport:close-authentication-stream"));
    await messages2.close({
      signal
    });
    if (!isSubset(remoteExtensions?.webtransportCerthashes ?? [], certhashes.map((ch) => ch.bytes))) {
      throw new InvalidParametersError2("Our certhashes are not a subset of the remote's reported certhashes");
    }
    return true;
  }
  createListener(options2) {
    return createListener3(this.components, {
      ...options2,
      certificates: this.config.certificates
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter() {
    return [];
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    if (window.WebTransport == null) {
      return [];
    }
    return multiaddrs.filter((ma) => {
      if (!WebTransport.exactMatch(ma)) {
        return false;
      }
      const { url, certhashes } = parseMultiaddr(ma);
      return url != null && certhashes.length > 0;
    });
  }
};
function webTransport(init = {}) {
  return (components) => new WebTransportTransport(components, init);
}

// ../../node_modules/blockstore-core/dist/src/base.js
var BaseBlockstore = class {
  has(key, options2) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  put(key, val, options2) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  async *putMany(source, options2) {
    for await (const { cid, bytes } of source) {
      await this.put(cid, bytes, options2);
      yield cid;
    }
  }
  get(key, options2) {
    throw new Error(".get is not implemented");
  }
  async *getMany(source, options2) {
    for await (const key of source) {
      yield {
        cid: key,
        bytes: this.get(key, options2)
      };
    }
  }
  delete(key, options2) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *deleteMany(source, options2) {
    for await (const key of source) {
      await this.delete(key, options2);
      yield key;
    }
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  async *getAll(options2) {
    throw new Error(".getAll is not implemented");
  }
};

// ../../node_modules/interface-store/dist/src/errors.js
var _OpenFailedError = class _OpenFailedError extends Error {
  constructor(message2 = "Open failed") {
    super(message2);
    __publicField(this, "name", _OpenFailedError.name);
    __publicField(this, "code", _OpenFailedError.code);
  }
};
__publicField(_OpenFailedError, "name", "OpenFailedError");
__publicField(_OpenFailedError, "code", "ERR_OPEN_FAILED");
var OpenFailedError = _OpenFailedError;
var _CloseFailedError = class _CloseFailedError extends Error {
  constructor(message2 = "Close failed") {
    super(message2);
    __publicField(this, "name", _CloseFailedError.name);
    __publicField(this, "code", _CloseFailedError.code);
  }
};
__publicField(_CloseFailedError, "name", "CloseFailedError");
__publicField(_CloseFailedError, "code", "ERR_CLOSE_FAILED");
var CloseFailedError = _CloseFailedError;
var _PutFailedError = class _PutFailedError extends Error {
  constructor(message2 = "Put failed") {
    super(message2);
    __publicField(this, "name", _PutFailedError.name);
    __publicField(this, "code", _PutFailedError.code);
  }
};
__publicField(_PutFailedError, "name", "PutFailedError");
__publicField(_PutFailedError, "code", "ERR_PUT_FAILED");
var PutFailedError = _PutFailedError;
var _GetFailedError = class _GetFailedError extends Error {
  constructor(message2 = "Get failed") {
    super(message2);
    __publicField(this, "name", _GetFailedError.name);
    __publicField(this, "code", _GetFailedError.code);
  }
};
__publicField(_GetFailedError, "name", "GetFailedError");
__publicField(_GetFailedError, "code", "ERR_GET_FAILED");
var GetFailedError = _GetFailedError;
var _DeleteFailedError = class _DeleteFailedError extends Error {
  constructor(message2 = "Delete failed") {
    super(message2);
    __publicField(this, "name", _DeleteFailedError.name);
    __publicField(this, "code", _DeleteFailedError.code);
  }
};
__publicField(_DeleteFailedError, "name", "DeleteFailedError");
__publicField(_DeleteFailedError, "code", "ERR_DELETE_FAILED");
var DeleteFailedError = _DeleteFailedError;
var _HasFailedError = class _HasFailedError extends Error {
  constructor(message2 = "Has failed") {
    super(message2);
    __publicField(this, "name", _HasFailedError.name);
    __publicField(this, "code", _HasFailedError.code);
  }
};
__publicField(_HasFailedError, "name", "HasFailedError");
__publicField(_HasFailedError, "code", "ERR_HAS_FAILED");
var HasFailedError = _HasFailedError;
var _NotFoundError = class _NotFoundError extends Error {
  constructor(message2 = "Not Found") {
    super(message2);
    __publicField(this, "name", _NotFoundError.name);
    __publicField(this, "code", _NotFoundError.code);
  }
};
__publicField(_NotFoundError, "name", "NotFoundError");
__publicField(_NotFoundError, "code", "ERR_NOT_FOUND");
var NotFoundError4 = _NotFoundError;
var _AbortError = class _AbortError extends Error {
  constructor(message2 = "Aborted") {
    super(message2);
    __publicField(this, "name", _AbortError.name);
    __publicField(this, "code", _AbortError.code);
  }
};
__publicField(_AbortError, "name", "AbortError");
__publicField(_AbortError, "code", "ERR_ABORTED");
var AbortError8 = _AbortError;

// ../../node_modules/blockstore-core/dist/src/memory.js
function isPromise3(p2) {
  return typeof p2?.then === "function";
}
var MemoryBlockstore = class extends BaseBlockstore {
  constructor() {
    super();
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val, options2) {
    options2?.signal?.throwIfAborted();
    let buf2;
    if (val instanceof Uint8Array) {
      buf2 = [val];
    } else {
      const result = src_default8(val);
      if (isPromise3(result)) {
        return result.then((val2) => {
          return this._put(key, val2, options2);
        });
      } else {
        buf2 = result;
      }
    }
    return this._put(key, buf2, options2);
  }
  _put(key, val, options2) {
    options2?.signal?.throwIfAborted();
    this.data.set(base32.encode(key.multihash.bytes), val);
    return key;
  }
  *get(key, options2) {
    options2?.signal?.throwIfAborted();
    const buf2 = this.data.get(base32.encode(key.multihash.bytes));
    if (buf2 == null) {
      throw new NotFoundError4();
    }
    yield* buf2;
  }
  has(key, options2) {
    options2?.signal?.throwIfAborted();
    return this.data.has(base32.encode(key.multihash.bytes));
  }
  async delete(key, options2) {
    options2?.signal?.throwIfAborted();
    this.data.delete(base32.encode(key.multihash.bytes));
  }
  *getAll(options2) {
    options2?.signal?.throwIfAborted();
    for (const [key, value2] of this.data.entries()) {
      yield {
        cid: CID.createV1(code3, decode4(base32.decode(key))),
        bytes: (async function* () {
          yield* value2;
        })()
      };
      options2?.signal?.throwIfAborted();
    }
  }
};

// ../../node_modules/blockstore-core/dist/src/black-hole.js
var BlackHoleBlockstore = class extends BaseBlockstore {
  put(key, value2, options2) {
    options2?.signal?.throwIfAborted();
    return key;
  }
  get(key, options2) {
    options2?.signal?.throwIfAborted();
    throw new NotFoundError4();
  }
  has(key, options2) {
    options2?.signal?.throwIfAborted();
    return false;
  }
  async delete(cid, options2) {
    options2?.signal?.throwIfAborted();
  }
  // eslint-disable-next-line require-yield
  async *getAll(options2) {
    options2?.signal?.throwIfAborted();
  }
};

// ../../node_modules/it-filter/dist/src/index.js
function isAsyncIterable11(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function filter(source, fn) {
  let index = 0;
  if (isAsyncIterable11(source)) {
    return (async function* () {
      for await (const entry of source) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    })();
  }
  const peekable2 = src_default4(source);
  const { value: value2, done } = peekable2.next();
  if (done === true) {
    return (function* () {
    })();
  }
  const res = fn(value2, index++);
  if (typeof res.then === "function") {
    return (async function* () {
      if (await res) {
        yield value2;
      }
      for (const entry of peekable2) {
        if (await fn(entry, index++)) {
          yield entry;
        }
      }
    })();
  }
  const func = fn;
  return (function* () {
    if (res === true) {
      yield value2;
    }
    for (const entry of peekable2) {
      if (func(entry, index++)) {
        yield entry;
      }
    }
  })();
}
var src_default9 = filter;

// ../../node_modules/blockstore-core/dist/src/tiered.js
var log2 = logger("blockstore:core:tiered");
var TieredBlockstore = class extends BaseBlockstore {
  constructor(stores) {
    super();
    __publicField(this, "stores");
    this.stores = stores.slice();
  }
  async put(key, value2, options2) {
    await Promise.all(this.stores.map(async (store) => {
      await store.put(key, value2, options2);
    }));
    return key;
  }
  async *get(key, options2) {
    let error;
    for (const store of this.stores) {
      try {
        yield* store.get(key, options2);
        return;
      } catch (err) {
        error = err;
        log2.error(err);
      }
    }
    throw error ?? new NotFoundError4();
  }
  async has(key, options2) {
    for (const s2 of this.stores) {
      if (await s2.has(key, options2)) {
        return true;
      }
    }
    return false;
  }
  async delete(key, options2) {
    await Promise.all(this.stores.map(async (store) => {
      await store.delete(key, options2);
    }));
  }
  async *putMany(source, options2 = {}) {
    for await (const pair of source) {
      await this.put(pair.cid, pair.bytes, options2);
      yield pair.cid;
    }
  }
  async *deleteMany(source, options2 = {}) {
    for await (const cid of source) {
      await this.delete(cid, options2);
      yield cid;
    }
  }
  async *getAll(options2) {
    const seen = /* @__PURE__ */ new Set();
    yield* src_default9(src_default(...this.stores.map((s2) => s2.getAll(options2))), (pair) => {
      const cidStr = pair.cid.toString();
      if (seen.has(cidStr)) {
        return false;
      }
      seen.add(cidStr);
      return true;
    });
  }
};

// ../../node_modules/datastore-core/dist/src/shard.js
var shard_exports = {};
__export(shard_exports, {
  NextToLast: () => NextToLast,
  PREFIX: () => PREFIX2,
  Prefix: () => Prefix,
  SHARDING_FN: () => SHARDING_FN,
  ShardBase: () => ShardBase,
  Suffix: () => Suffix,
  parseShardFun: () => parseShardFun,
  readShardFun: () => readShardFun
});
var PREFIX2 = "/repo/flatfs/shard/";
var SHARDING_FN = "SHARDING";
var ShardBase = class {
  constructor(param) {
    __publicField(this, "param");
    __publicField(this, "name");
    __publicField(this, "_padding");
    this.param = param;
    this.name = "base";
    this._padding = "";
  }
  fun(s2) {
    return "implement me";
  }
  toString() {
    return `${PREFIX2}v1/${this.name}/${this.param}`;
  }
};
var Prefix = class extends ShardBase {
  constructor(prefixLen) {
    super(prefixLen);
    this._padding = "".padStart(prefixLen, "_");
    this.name = "prefix";
  }
  fun(noslash) {
    return (noslash + this._padding).slice(0, this.param);
  }
};
var Suffix = class extends ShardBase {
  constructor(suffixLen) {
    super(suffixLen);
    this._padding = "".padStart(suffixLen, "_");
    this.name = "suffix";
  }
  fun(noslash) {
    const s2 = this._padding + noslash;
    return s2.slice(s2.length - this.param);
  }
};
var NextToLast = class extends ShardBase {
  constructor(suffixLen) {
    super(suffixLen);
    this._padding = "".padStart(suffixLen + 1, "_");
    this.name = "next-to-last";
  }
  fun(noslash) {
    const s2 = this._padding + noslash;
    const offset = s2.length - this.param - 1;
    return s2.slice(offset, offset + this.param);
  }
};
function parseShardFun(str) {
  str = str.trim();
  if (str.length === 0) {
    throw new Error("empty shard string");
  }
  if (!str.startsWith(PREFIX2)) {
    throw new Error(`invalid or no path prefix: ${str}`);
  }
  const parts = str.slice(PREFIX2.length).split("/");
  const version2 = parts[0];
  if (version2 !== "v1") {
    throw new Error(`expect 'v1' version, got '${version2}'`);
  }
  const name5 = parts[1];
  if (parts[2] == null || parts[2] === "") {
    throw new Error("missing param");
  }
  const param = parseInt(parts[2], 10);
  switch (name5) {
    case "prefix":
      return new Prefix(param);
    case "suffix":
      return new Suffix(param);
    case "next-to-last":
      return new NextToLast(param);
    default:
      throw new Error(`unkown sharding function: ${name5}`);
  }
}
var readShardFun = async (path, store) => {
  const key = new Key(path).child(new Key(SHARDING_FN));
  const get = typeof store.getRaw === "function" ? store.getRaw.bind(store) : store.get.bind(store);
  const res = await get(key);
  return parseShardFun(new TextDecoder().decode(res ?? "").trim());
};

// ../../node_modules/it-sort/dist/src/index.js
function isAsyncIterable12(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
  if (isAsyncIterable12(source)) {
    return (async function* () {
      const arr = await src_default8(source);
      yield* arr.sort(sorter);
    })();
  }
  return (function* () {
    const arr = src_default8(source);
    yield* arr.sort(sorter);
  })();
}
var src_default10 = sort;

// ../../node_modules/datastore-core/dist/src/base.js
var BaseDatastore = class {
  put(key, val, options2) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options2) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options2) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options2) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options2 = {}) {
    for await (const { key, value: value2 } of source) {
      await this.put(key, value2, options2);
      yield key;
    }
  }
  async *getMany(source, options2 = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options2)
      };
    }
  }
  async *deleteMany(source, options2 = {}) {
    for await (const key of source) {
      await this.delete(key, options2);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value2) {
        puts.push({ key, value: value2 });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options2) => {
        await src_default3(this.putMany(puts, options2));
        puts = [];
        await src_default3(this.deleteMany(dels, options2));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options2) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options2) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options2) {
    let it = this._all(q, options2);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default9(it, (e2) => e2.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f2) => src_default9(it2, f2), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f2) => src_default10(it2, f2), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      const offset = q.offset;
      it = src_default9(it, () => i2++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options2) {
    let it = this._allKeys(q, options2);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default9(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f2) => src_default9(it2, f2), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f2) => src_default10(it2, f2), it);
    }
    if (q.offset != null) {
      const offset = q.offset;
      let i2 = 0;
      it = src_default9(it, () => i2++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
};

// ../../node_modules/datastore-core/dist/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val, options2) {
    options2?.signal?.throwIfAborted();
    this.data.set(key.toString(), val);
    return key;
  }
  get(key, options2) {
    options2?.signal?.throwIfAborted();
    const result = this.data.get(key.toString());
    if (result == null) {
      throw new NotFoundError4();
    }
    return result;
  }
  has(key, options2) {
    options2?.signal?.throwIfAborted();
    return this.data.has(key.toString());
  }
  delete(key, options2) {
    options2?.signal?.throwIfAborted();
    this.data.delete(key.toString());
  }
  *_all(q, options2) {
    options2?.signal?.throwIfAborted();
    for (const [key, value2] of this.data.entries()) {
      yield { key: new Key(key), value: value2 };
      options2?.signal?.throwIfAborted();
    }
  }
  *_allKeys(q, options2) {
    options2?.signal?.throwIfAborted();
    for (const key of this.data.keys()) {
      yield new Key(key);
      options2?.signal?.throwIfAborted();
    }
  }
};

// ../../node_modules/datastore-core/dist/src/keytransform.js
var KeyTransformDatastore = class extends BaseDatastore {
  constructor(child, transform) {
    super();
    __publicField(this, "child");
    __publicField(this, "transform");
    this.child = child;
    this.transform = transform;
  }
  async put(key, val, options2) {
    await this.child.put(this.transform.convert(key), val, options2);
    return key;
  }
  async get(key, options2) {
    return this.child.get(this.transform.convert(key), options2);
  }
  async has(key, options2) {
    return this.child.has(this.transform.convert(key), options2);
  }
  async delete(key, options2) {
    await this.child.delete(this.transform.convert(key), options2);
  }
  async *putMany(source, options2 = {}) {
    const transform = this.transform;
    const child = this.child;
    yield* pipe(source, async function* (source2) {
      yield* src_default5(source2, ({ key, value: value2 }) => ({
        key: transform.convert(key),
        value: value2
      }));
    }, async function* (source2) {
      yield* child.putMany(source2, options2);
    }, async function* (source2) {
      yield* src_default5(source2, (key) => transform.invert(key));
    });
  }
  async *getMany(source, options2 = {}) {
    const transform = this.transform;
    const child = this.child;
    yield* pipe(source, async function* (source2) {
      yield* src_default5(source2, (key) => transform.convert(key));
    }, async function* (source2) {
      yield* child.getMany(source2, options2);
    }, async function* (source2) {
      yield* src_default5(source2, ({ key, value: value2 }) => ({
        key: transform.invert(key),
        value: value2
      }));
    });
  }
  async *deleteMany(source, options2 = {}) {
    const transform = this.transform;
    const child = this.child;
    yield* pipe(source, async function* (source2) {
      yield* src_default5(source2, (key) => transform.convert(key));
    }, async function* (source2) {
      yield* child.deleteMany(source2, options2);
    }, async function* (source2) {
      yield* src_default5(source2, (key) => transform.invert(key));
    });
  }
  batch() {
    const b = this.child.batch();
    return {
      put: (key, value2) => {
        b.put(this.transform.convert(key), value2);
      },
      delete: (key) => {
        b.delete(this.transform.convert(key));
      },
      commit: async (options2) => {
        await b.commit(options2);
      }
    };
  }
  query(q, options2) {
    const query = {
      ...q
    };
    query.filters = (query.filters ?? []).map((filter2) => {
      return ({ key, value: value2 }) => filter2({ key: this.transform.convert(key), value: value2 });
    });
    const { prefix } = q;
    if (prefix != null && prefix !== "/") {
      delete query.prefix;
      query.filters.push(({ key }) => {
        return this.transform.invert(key).toString().startsWith(prefix);
      });
    }
    if (query.orders != null) {
      query.orders = query.orders.map((order) => {
        return (a2, b) => order({ key: this.transform.invert(a2.key), value: a2.value }, { key: this.transform.invert(b.key), value: b.value });
      });
    }
    return src_default5(this.child.query(query, options2), ({ key, value: value2 }) => {
      return {
        key: this.transform.invert(key),
        value: value2
      };
    });
  }
  queryKeys(q, options2) {
    const query = {
      ...q
    };
    query.filters = (query.filters ?? []).map((filter2) => {
      return (key) => filter2(this.transform.convert(key));
    });
    const { prefix } = q;
    if (prefix != null && prefix !== "/") {
      delete query.prefix;
      query.filters.push((key) => {
        return this.transform.invert(key).toString().startsWith(prefix);
      });
    }
    if (query.orders != null) {
      query.orders = query.orders.map((order) => {
        return (a2, b) => order(this.transform.invert(a2), this.transform.invert(b));
      });
    }
    return src_default5(this.child.queryKeys(query, options2), (key) => {
      return this.transform.invert(key);
    });
  }
};

// ../../node_modules/datastore-core/dist/src/sharding.js
var shardKey = new Key(SHARDING_FN);
var ShardingDatastore = class _ShardingDatastore extends BaseDatastore {
  constructor(store, shard) {
    super();
    __publicField(this, "child");
    __publicField(this, "shard");
    this.child = new KeyTransformDatastore(store, {
      convert: this._convertKey.bind(this),
      invert: this._invertKey.bind(this)
    });
    this.shard = shard;
  }
  async open() {
    this.shard = await _ShardingDatastore.create(this.child, this.shard);
  }
  _convertKey(key) {
    const s2 = key.toString();
    if (s2 === shardKey.toString()) {
      return key;
    }
    const parent = new Key(this.shard.fun(s2));
    return parent.child(key);
  }
  _invertKey(key) {
    const s2 = key.toString();
    if (s2 === shardKey.toString()) {
      return key;
    }
    return Key.withNamespaces(key.list().slice(1));
  }
  static async create(store, shard) {
    const hasShard = await store.has(shardKey);
    if (!hasShard) {
      if (shard == null) {
        throw new OpenFailedError("Shard is required when datastore doesn't have a shard key already");
      }
      await store.put(shardKey, new TextEncoder().encode(shard.toString() + "\n"));
    }
    if (shard == null) {
      shard = await readShardFun("/", store);
    }
    const diskShard = await readShardFun("/", store);
    const a2 = diskShard.toString();
    const b = shard.toString();
    if (a2 !== b) {
      throw new Error(`specified fun ${b} does not match repo shard fun ${a2}`);
    }
    return diskShard;
  }
  async put(key, val, options2) {
    await this.child.put(key, val, options2);
    return key;
  }
  async get(key, options2) {
    return this.child.get(key, options2);
  }
  async has(key, options2) {
    return this.child.has(key, options2);
  }
  async delete(key, options2) {
    await this.child.delete(key, options2);
  }
  async *putMany(source, options2 = {}) {
    yield* this.child.putMany(source, options2);
  }
  async *getMany(source, options2 = {}) {
    yield* this.child.getMany(source, options2);
  }
  async *deleteMany(source, options2 = {}) {
    yield* this.child.deleteMany(source, options2);
  }
  batch() {
    return this.child.batch();
  }
  query(q, options2) {
    const omitShard = ({ key }) => key.toString() !== shardKey.toString();
    const tq = {
      ...q,
      filters: [
        omitShard
      ].concat(q.filters ?? [])
    };
    return this.child.query(tq, options2);
  }
  queryKeys(q, options2) {
    const omitShard = (key) => key.toString() !== shardKey.toString();
    const tq = {
      ...q,
      filters: [
        omitShard
      ].concat(q.filters ?? [])
    };
    return this.child.queryKeys(tq, options2);
  }
};

// ../../node_modules/datastore-core/dist/src/mount.js
var MountDatastore = class extends BaseDatastore {
  constructor(mounts) {
    super();
    __publicField(this, "mounts");
    this.mounts = mounts.slice();
  }
  /**
   * Lookup the matching datastore for the given key
   */
  _lookup(key) {
    for (const mount of this.mounts) {
      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {
        return {
          datastore: mount.datastore,
          mountpoint: mount.prefix
        };
      }
    }
  }
  async put(key, value2, options2) {
    const match = this._lookup(key);
    if (match == null) {
      throw new PutFailedError("No datastore mounted for this key");
    }
    await match.datastore.put(key, value2, options2);
    return key;
  }
  /**
   * @param {Key} key
   * @param {Options} [options]
   */
  async get(key, options2 = {}) {
    const match = this._lookup(key);
    if (match == null) {
      throw new NotFoundError4("No datastore mounted for this key");
    }
    return match.datastore.get(key, options2);
  }
  async has(key, options2) {
    const match = this._lookup(key);
    if (match == null) {
      return Promise.resolve(false);
    }
    return match.datastore.has(key, options2);
  }
  async delete(key, options2) {
    const match = this._lookup(key);
    if (match == null) {
      throw new DeleteFailedError("No datastore mounted for this key");
    }
    await match.datastore.delete(key, options2);
  }
  batch() {
    const batchMounts = {};
    const lookup = (key) => {
      const match = this._lookup(key);
      if (match == null) {
        throw new Error("No datastore mounted for this key");
      }
      const m2 = match.mountpoint.toString();
      if (batchMounts[m2] == null) {
        batchMounts[m2] = match.datastore.batch();
      }
      return {
        batch: batchMounts[m2]
      };
    };
    return {
      put: (key, value2) => {
        const match = lookup(key);
        match.batch.put(key, value2);
      },
      delete: (key) => {
        const match = lookup(key);
        match.batch.delete(key);
      },
      commit: async (options2) => {
        await Promise.all(Object.keys(batchMounts).map(async (p2) => {
          await batchMounts[p2].commit(options2);
        }));
      }
    };
  }
  query(q, options2) {
    const qs = this.mounts.map((m2) => {
      return m2.datastore.query({
        prefix: q.prefix,
        filters: q.filters
      }, options2);
    });
    let it = src_default(...qs);
    if (q.filters != null) {
      q.filters.forEach((f2) => {
        it = src_default9(it, f2);
      });
    }
    if (q.orders != null) {
      q.orders.forEach((o2) => {
        it = src_default10(it, o2);
      });
    }
    if (q.offset != null) {
      let i2 = 0;
      const offset = q.offset;
      it = src_default9(it, () => i2++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options2) {
    const qs = this.mounts.map((m2) => {
      return m2.datastore.queryKeys({
        prefix: q.prefix,
        filters: q.filters
      }, options2);
    });
    let it = src_default(...qs);
    if (q.filters != null) {
      q.filters.forEach((f2) => {
        it = src_default9(it, f2);
      });
    }
    if (q.orders != null) {
      q.orders.forEach((o2) => {
        it = src_default10(it, o2);
      });
    }
    if (q.offset != null) {
      let i2 = 0;
      const offset = q.offset;
      it = src_default9(it, () => i2++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
};

// ../../node_modules/datastore-core/dist/src/tiered.js
var log3 = logger("datastore:core:tiered");
var TieredDatastore = class extends BaseDatastore {
  constructor(stores) {
    super();
    __publicField(this, "stores");
    this.stores = stores.slice();
  }
  async put(key, value2, options2) {
    await Promise.all(this.stores.map(async (store) => {
      await store.put(key, value2, options2);
    }));
    return key;
  }
  async get(key, options2) {
    let error;
    for (const store of this.stores) {
      try {
        const res = await store.get(key, options2);
        if (res != null) {
          return res;
        }
      } catch (err) {
        error = err;
        log3.error(err);
      }
    }
    throw error ?? new NotFoundError4();
  }
  async has(key, options2) {
    for (const s2 of this.stores) {
      if (await s2.has(key, options2)) {
        return true;
      }
    }
    return false;
  }
  async delete(key, options2) {
    await Promise.all(this.stores.map(async (store) => {
      await store.delete(key, options2);
    }));
  }
  async *putMany(source, options2 = {}) {
    for await (const pair of source) {
      await this.put(pair.key, pair.value, options2);
      yield pair.key;
    }
  }
  async *deleteMany(source, options2 = {}) {
    for await (const key of source) {
      await this.delete(key, options2);
      yield key;
    }
  }
  batch() {
    const batches = this.stores.map((store) => store.batch());
    return {
      put: (key, value2) => {
        batches.forEach((b) => {
          b.put(key, value2);
        });
      },
      delete: (key) => {
        batches.forEach((b) => {
          b.delete(key);
        });
      },
      commit: async (options2) => {
        for (const batch of batches) {
          await batch.commit(options2);
        }
      }
    };
  }
  query(q, options2) {
    return this.stores[this.stores.length - 1].query(q, options2);
  }
  queryKeys(q, options2) {
    return this.stores[this.stores.length - 1].queryKeys(q, options2);
  }
};

// ../../node_modules/datastore-core/dist/src/namespace.js
var NamespaceDatastore = class extends KeyTransformDatastore {
  constructor(child, prefix) {
    super(child, {
      convert(key) {
        return prefix.child(key);
      },
      invert(key) {
        if (prefix.toString() === "/") {
          return key;
        }
        if (!prefix.isAncestorOf(key)) {
          throw new Error(`Expected prefix: (${prefix.toString()}) in key: ${key.toString()}`);
        }
        return new Key(key.toString().slice(prefix.toString().length), false);
      }
    });
    __publicField(this, "iChild");
    __publicField(this, "iKey");
    this.iChild = child;
    this.iKey = prefix;
  }
  query(q, options2) {
    const query = {
      ...q
    };
    query.filters = (query.filters ?? []).map((filter2) => {
      return ({ key, value: value2 }) => filter2({ key: this.transform.invert(key), value: value2 });
    });
    const { prefix } = q;
    if (prefix != null && prefix !== "/") {
      delete query.prefix;
      query.filters.push(({ key }) => {
        return this.transform.invert(key).toString().startsWith(prefix);
      });
    }
    if (query.orders != null) {
      query.orders = query.orders.map((order) => {
        return (a2, b) => order({ key: this.transform.invert(a2.key), value: a2.value }, { key: this.transform.invert(b.key), value: b.value });
      });
    }
    query.filters.unshift(({ key }) => this.iKey.isAncestorOf(key));
    return src_default5(this.iChild.query(query, options2), ({ key, value: value2 }) => {
      return {
        key: this.transform.invert(key),
        value: value2
      };
    });
  }
  queryKeys(q, options2) {
    const query = {
      ...q
    };
    query.filters = (query.filters ?? []).map((filter2) => {
      return (key) => filter2(this.transform.invert(key));
    });
    const { prefix } = q;
    if (prefix != null && prefix !== "/") {
      delete query.prefix;
      query.filters.push((key) => {
        return this.transform.invert(key).toString().startsWith(prefix);
      });
    }
    if (query.orders != null) {
      query.orders = query.orders.map((order) => {
        return (a2, b) => order(this.transform.invert(a2), this.transform.invert(b));
      });
    }
    query.filters.unshift((key) => this.iKey.isAncestorOf(key));
    return src_default5(this.iChild.queryKeys(query, options2), (key) => {
      return this.transform.invert(key);
    });
  }
};

// ../../node_modules/idb/build/index.js
var instanceOfAny = (object, constructors) => constructors.some((c2) => object instanceof c2);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var transactionDoneMap = /* @__PURE__ */ new WeakMap();
var transformCache = /* @__PURE__ */ new WeakMap();
var reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value2) {
    target[prop] = value2;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(this.request);
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value2) {
  if (typeof value2 === "function")
    return wrapFunction(value2);
  if (value2 instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value2);
  if (instanceOfAny(value2, getIdbProxyableTypes()))
    return new Proxy(value2, idbProxyTraps);
  return value2;
}
function wrap(value2) {
  if (value2 instanceof IDBRequest)
    return promisifyRequest(value2);
  if (transformCache.has(value2))
    return transformCache.get(value2);
  const newValue = transformCachableValue(value2);
  if (newValue !== value2) {
    transformCache.set(value2, newValue);
    reverseTransformCache.set(newValue, value2);
  }
  return newValue;
}
var unwrap = (value2) => reverseTransformCache.get(value2);
function openDB(name5, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name5, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
function deleteDB(name5, { blocked } = {}) {
  const request = indexedDB.deleteDatabase(name5);
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event
    ));
  }
  return wrap(request).then(() => void 0);
}
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
var advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
var methodMap = {};
var advanceResults = /* @__PURE__ */ new WeakMap();
var ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
var cursorIteratorTraps = {
  get(target, prop) {
    if (!advanceMethodProps.includes(prop))
      return target[prop];
    let cachedFunc = methodMap[prop];
    if (!cachedFunc) {
      cachedFunc = methodMap[prop] = function(...args) {
        advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
      };
    }
    return cachedFunc;
  }
};
async function* iterate(...args) {
  let cursor = this;
  if (!(cursor instanceof IDBCursor)) {
    cursor = await cursor.openCursor(...args);
  }
  if (!cursor)
    return;
  cursor = cursor;
  const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
  ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
  reverseTransformCache.set(proxiedCursor, unwrap(cursor));
  while (cursor) {
    yield proxiedCursor;
    cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
    advanceResults.delete(proxiedCursor);
  }
}
function isIteratorProp(target, prop) {
  return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get(target, prop, receiver) {
    if (isIteratorProp(target, prop))
      return iterate;
    return oldTraps.get(target, prop, receiver);
  },
  has(target, prop) {
    return isIteratorProp(target, prop) || oldTraps.has(target, prop);
  }
}));

// ../../node_modules/datastore-idb/dist/src/index.js
var _IDBDatastore_instances, queryIt_fn;
var IDBDatastore = class extends BaseDatastore {
  constructor(location, init = {}) {
    super();
    __privateAdd(this, _IDBDatastore_instances);
    __publicField(this, "location");
    __publicField(this, "version");
    __publicField(this, "db");
    this.location = `${init.prefix ?? ""}${location}`;
    this.version = init.version ?? 1;
  }
  async open() {
    try {
      const location = this.location;
      this.db = await openDB(location, this.version, {
        upgrade(db) {
          db.createObjectStore(location);
        }
      });
    } catch (err) {
      throw new OpenFailedError(String(err));
    }
  }
  async close() {
    this.db?.close();
  }
  async put(key, val, options2) {
    if (this.db == null) {
      throw new Error("Datastore needs to be opened.");
    }
    try {
      options2?.signal?.throwIfAborted();
      await raceSignal(this.db.put(this.location, val, key.toString()), options2?.signal);
    } catch (err) {
      throw new PutFailedError(String(err));
    }
    return key;
  }
  async get(key, options2) {
    if (this.db == null) {
      throw new Error("Datastore needs to be opened.");
    }
    let val;
    try {
      options2?.signal?.throwIfAborted();
      val = await raceSignal(this.db.get(this.location, key.toString()), options2?.signal);
    } catch (err) {
      throw new GetFailedError(String(err));
    }
    if (val === void 0) {
      throw new NotFoundError4();
    }
    return val;
  }
  async has(key, options2) {
    if (this.db == null) {
      throw new Error("Datastore needs to be opened.");
    }
    try {
      options2?.signal?.throwIfAborted();
      const result = await raceSignal(this.db.getKey(this.location, key.toString()));
      return Boolean(result);
    } catch (err) {
      throw new GetFailedError(String(err));
    }
  }
  async delete(key, options2) {
    if (this.db == null) {
      throw new Error("Datastore needs to be opened.");
    }
    try {
      options2?.signal?.throwIfAborted();
      await raceSignal(this.db.delete(this.location, key.toString()), options2?.signal);
    } catch (err) {
      throw new DeleteFailedError(String(err));
    }
  }
  batch() {
    const puts = [];
    const dels = [];
    return {
      put(key, value2) {
        puts.push({ key, value: value2 });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options2) => {
        if (this.db == null) {
          throw new Error("Datastore needs to be opened.");
        }
        options2?.signal?.throwIfAborted();
        const tx = this.db.transaction(this.location, "readwrite");
        try {
          const ops = puts.filter(({ key }) => {
            return dels.find((delKey) => delKey.toString() === key.toString()) == null;
          }).map((put) => {
            return async () => {
              await tx.store.put(put.value, put.key.toString());
            };
          }).concat(dels.map((key) => {
            return async () => {
              await tx.store.delete(key.toString());
            };
          })).concat(async () => {
            await tx.done;
          });
          options2?.signal?.throwIfAborted();
          await raceSignal(Promise.all(ops.map(async (op) => {
            await op();
          })), options2?.signal);
        } catch {
          tx.abort();
        }
      }
    };
  }
  async *query(q, options2) {
    let it = __privateMethod(this, _IDBDatastore_instances, queryIt_fn).call(this, q, (key, value2) => {
      return { key, value: value2 };
    }, options2);
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f2) => src_default9(it2, f2), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f2) => src_default10(it2, f2), it);
    }
    yield* it;
  }
  async *queryKeys(q, options2) {
    let it = __privateMethod(this, _IDBDatastore_instances, queryIt_fn).call(this, q, (key) => key, options2);
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f2) => src_default9(it2, f2), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f2) => src_default10(it2, f2), it);
    }
    yield* it;
  }
  async destroy() {
    await deleteDB(this.location);
  }
};
_IDBDatastore_instances = new WeakSet();
queryIt_fn = async function* (q, transform, options2) {
  if (this.db == null) {
    throw new Error("Datastore needs to be opened.");
  }
  let yielded = 0;
  let index = -1;
  options2?.signal?.throwIfAborted();
  for (const key of await this.db.getAllKeys(this.location)) {
    options2?.signal?.throwIfAborted();
    if (q.prefix != null && !key.toString().startsWith(q.prefix)) {
      continue;
    }
    if (q.limit != null && yielded === q.limit) {
      return;
    }
    index++;
    if (q.offset != null && index < q.offset) {
      continue;
    }
    const k = new Key(key.toString());
    let value2;
    try {
      value2 = await this.get(k, options2);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
      continue;
    }
    if (value2 == null) {
      continue;
    }
    yield transform(k, value2);
    options2?.signal?.throwIfAborted();
    yielded++;
  }
};

// ../../node_modules/libp2p/dist/src/config.js
async function validateConfig(opts) {
  if (opts.connectionProtector === null && window.process?.env?.LIBP2P_FORCE_PNET != null) {
    throw new InvalidParametersError2("Private network is enforced, but no protector was provided");
  }
  return opts;
}

// ../../node_modules/libp2p/dist/src/address-manager/dns-mappings.js
var MAX_DATE = 864e13;
var defaultValues3 = {
  maxObservedAddresses: 10
};
var DNSMappings = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "mappings");
    this.log = components.logger.forComponent("libp2p:address-manager:dns-mappings");
    this.mappings = trackedMap({
      name: "libp2p_address_manager_dns_mappings",
      metrics: components.metrics
    });
  }
  has(ma) {
    const config = getNetConfig(ma);
    let host = config.host;
    if ((config.type === "ip4" || config.type === "ip6") && config.sni != null) {
      host = config.sni;
    }
    for (const mapping of this.mappings.values()) {
      if (mapping.domain === host) {
        return true;
      }
    }
    return false;
  }
  add(domain, addresses) {
    addresses.forEach((ip) => {
      this.log("add DNS mapping %s to %s", ip, domain);
      const verified = isPrivateIp(ip) === true;
      this.mappings.set(ip, {
        domain,
        verified,
        expires: verified ? MAX_DATE - Date.now() : 0,
        lastVerified: verified ? MAX_DATE - Date.now() : void 0
      });
    });
  }
  remove(ma) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === config.sni) {
        this.log("removing %s to %s DNS mapping %e", ip, mapping.domain);
        this.mappings.delete(ip);
        wasConfident = wasConfident || mapping.verified;
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const dnsMappedAddresses = [];
    for (let i2 = 0; i2 < addresses.length; i2++) {
      const address = addresses[i2].multiaddr;
      if (!isNetworkAddress(address)) {
        continue;
      }
      const config = getNetConfig(address);
      for (const [ip, mapping] of this.mappings.entries()) {
        if (config.host !== ip) {
          continue;
        }
        const maWithSni = this.maybeAddSNIComponent(address, mapping.domain);
        if (maWithSni != null) {
          addresses.splice(i2, 1);
          i2--;
          dnsMappedAddresses.push({
            multiaddr: maWithSni,
            verified: mapping.verified,
            type: "dns-mapping",
            expires: mapping.expires,
            lastVerified: mapping.lastVerified
          });
        }
      }
    }
    return dnsMappedAddresses;
  }
  maybeAddSNIComponent(ma, domain) {
    const components = ma.getComponents();
    for (let j = 0; j < components.length; j++) {
      if (components[j].code === CODE_TLS2 && components[j + 1]?.code !== CODE_SNI2) {
        components.splice(j + 1, 0, {
          name: "sni",
          code: CODE_SNI2,
          value: domain
        });
        return multiaddr(components);
      }
    }
  }
  confirm(ma, ttl) {
    const config = getNetConfig(ma);
    let host = config.host;
    if ((config.type === "ip4" || config.type === "ip6") && config.sni != null) {
      host = config.sni;
    }
    let startingConfidence = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("marking %s to %s DNS mapping as verified", ip, mapping.domain);
        startingConfidence = mapping.verified;
        mapping.verified = true;
        mapping.expires = Date.now() + ttl;
        mapping.lastVerified = Date.now();
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    const host = config.sni ?? config.host;
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("removing verification of %s to %s DNS mapping", ip, mapping.domain);
        wasConfident = wasConfident || mapping.verified;
        mapping.verified = false;
        mapping.expires = Date.now() + ttl;
      }
    }
    return wasConfident;
  }
};

// ../../node_modules/libp2p/dist/src/address-manager/ip-mappings.js
var defaultValues4 = {
  maxObservedAddresses: 10
};
var IPMappings = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "mappings");
    this.log = components.logger.forComponent("libp2p:address-manager:ip-mappings");
    this.mappings = trackedMap({
      name: "libp2p_address_manager_ip_mappings",
      metrics: components.metrics
    });
  }
  has(ma) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === config.host) {
          return true;
        }
      }
    }
    return false;
  }
  add(internalIp, internalPort, externalIp, externalPort = internalPort, protocol2 = "tcp") {
    const key = `${internalIp}-${internalPort}-${protocol2}`;
    const mappings = this.mappings.get(key) ?? [];
    const mapping = {
      internalIp,
      internalPort,
      externalIp,
      externalPort,
      externalFamily: isIPv4(externalIp) ? 4 : 6,
      protocol: protocol2,
      verified: false,
      expires: 0
    };
    mappings.push(mapping);
    this.mappings.set(key, mappings);
  }
  remove(ma) {
    const config = getNetConfig(ma);
    if (config.type !== "ip4" && config.type !== "ip6") {
      return false;
    }
    let wasConfident = false;
    for (const [key, mappings] of this.mappings.entries()) {
      for (let i2 = 0; i2 < mappings.length; i2++) {
        const mapping = mappings[i2];
        if (mapping.externalIp === config.host && mapping.externalPort === config.port && mapping.protocol === config.protocol) {
          this.log("removing %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, config.host, config.port, config.protocol);
          wasConfident = wasConfident || mapping.verified;
          mappings.splice(i2, 1);
          i2--;
        }
      }
      if (mappings.length === 0) {
        this.mappings.delete(key);
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const ipMappedAddresses = [];
    for (const { multiaddr: ma } of addresses) {
      if (!isNetworkAddress(ma)) {
        continue;
      }
      const config = getNetConfig(ma);
      if (config.type !== "ip4" && config.type !== "ip6") {
        continue;
      }
      let key;
      if (config.protocol === "tcp") {
        key = `${config.host}-${config.port}-tcp`;
      } else if (config.protocol === "udp") {
        key = `${config.host}-${config.port}-udp`;
      }
      if (key == null) {
        continue;
      }
      const mappings = this.mappings.get(key);
      if (mappings == null) {
        continue;
      }
      for (const mapping of mappings) {
        ipMappedAddresses.push({
          multiaddr: this.maybeOverrideIp(ma, mapping.externalIp, mapping.externalFamily, mapping.protocol, mapping.externalPort),
          verified: mapping.verified,
          type: "ip-mapping",
          expires: mapping.expires,
          lastVerified: mapping.lastVerified
        });
      }
    }
    return ipMappedAddresses;
  }
  maybeOverrideIp(ma, externalIp, externalFamily, protocol2, externalPort) {
    const components = ma.getComponents();
    const ipIndex = components.findIndex((c2) => c2.code === CODE_IP42 || c2.code === CODE_IP62);
    const portIndex = components.findIndex((c2) => c2.name === protocol2);
    if (ipIndex > -1 && portIndex > -1) {
      components[ipIndex].value = externalIp;
      components[ipIndex].code = externalFamily === 4 ? CODE_IP42 : CODE_IP62;
      components[portIndex].value = `${externalPort}`;
      return multiaddr(components);
    }
    return ma;
  }
  confirm(ma, ttl) {
    if (!isNetworkAddress(ma)) {
      return false;
    }
    const config = getNetConfig(ma);
    let startingConfidence = false;
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === config.host) {
          this.log("marking %s to %s IP mapping as verified", mapping.internalIp, mapping.externalIp);
          startingConfidence = mapping.verified;
          mapping.verified = true;
          mapping.expires = Date.now() + ttl;
          mapping.lastVerified = Date.now();
        }
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    if (!isNetworkAddress(ma)) {
      return false;
    }
    const config = getNetConfig(ma);
    let wasConfident = false;
    for (const mappings of this.mappings.values()) {
      for (let i2 = 0; i2 < mappings.length; i2++) {
        const mapping = mappings[i2];
        if (mapping.externalIp === config.host && mapping.externalPort === config.port && mapping.protocol === config.protocol) {
          this.log("removing verification of %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, config.host, config.port, config.protocol);
          wasConfident = wasConfident || mapping.verified;
          mapping.verified = false;
          mapping.expires = Date.now() + ttl;
        }
      }
    }
    return wasConfident;
  }
};

// ../../node_modules/libp2p/dist/src/address-manager/observed-addresses.js
var defaultValues5 = {
  maxObservedAddresses: 10
};
var ObservedAddresses = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "addresses");
    __publicField(this, "maxObservedAddresses");
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = trackedMap({
      name: "libp2p_address_manager_observed_addresses",
      metrics: components.metrics
    });
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues5.maxObservedAddresses;
  }
  has(ma) {
    return this.addresses.has(ma.toString());
  }
  removePrefixed(prefix) {
    for (const key of this.addresses.keys()) {
      if (key.toString().startsWith(prefix)) {
        this.addresses.delete(key);
      }
    }
  }
  add(ma) {
    if (this.addresses.size === this.maxObservedAddresses) {
      return;
    }
    if (isPrivate(ma) || isLinkLocal(ma)) {
      return;
    }
    this.log("adding observed address %a", ma);
    this.addresses.set(ma.toString(), {
      verified: false,
      expires: 0
    });
  }
  getAll() {
    return Array.from(this.addresses).map(([ma, metadata]) => ({
      multiaddr: multiaddr(ma),
      verified: metadata.verified,
      type: "observed",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    }));
  }
  remove(ma) {
    const startingConfidence = this.addresses.get(ma.toString())?.verified ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(ma.toString());
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const addrString = ma.toString();
    const metadata = this.addresses.get(addrString) ?? {
      verified: false,
      expires: Date.now() + ttl,
      lastVerified: Date.now()
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.log("marking observed address %a as verified", addrString);
    this.addresses.set(addrString, metadata);
    return startingConfidence;
  }
};

// ../../node_modules/libp2p/dist/src/address-manager/transport-addresses.js
var defaultValues6 = {
  maxObservedAddresses: 10
};
var TransportAddresses = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "addresses");
    __publicField(this, "maxObservedAddresses");
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = trackedMap({
      name: "libp2p_address_manager_transport_addresses",
      metrics: components.metrics
    });
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues6.maxObservedAddresses;
  }
  get(multiaddr2, ttl) {
    if (isPrivate(multiaddr2)) {
      return {
        multiaddr: multiaddr2,
        verified: true,
        type: "transport",
        expires: Date.now() + ttl,
        lastVerified: Date.now()
      };
    }
    const key = this.toKey(multiaddr2);
    let metadata = this.addresses.get(key);
    if (metadata == null) {
      metadata = {
        verified: !isNetworkAddress(multiaddr2),
        expires: 0
      };
      this.addresses.set(key, metadata);
    }
    return {
      multiaddr: multiaddr2,
      verified: metadata.verified,
      type: "transport",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    };
  }
  has(ma) {
    const key = this.toKey(ma);
    return this.addresses.has(key);
  }
  remove(ma) {
    const key = this.toKey(ma);
    const startingConfidence = this.addresses.get(key)?.verified ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(key);
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0,
      lastVerified: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = false;
    metadata.expires = Date.now() + ttl;
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  toKey(ma) {
    if (!isNetworkAddress(ma)) {
      return ma.toString();
    }
    const config = getNetConfig(ma);
    return `${config.host}-${config.port}-${config.protocol}`;
  }
};

// ../../node_modules/libp2p/dist/src/address-manager/index.js
var _a27;
var ONE_MINUTE = 6e4;
var defaultValues7 = {
  maxObservedAddresses: 10,
  addressVerificationTTL: ONE_MINUTE * 10,
  addressVerificationRetry: ONE_MINUTE * 5
};
var defaultAddressFilter = (addrs) => addrs;
function stripPeerId(ma, peerId) {
  const observedPeerIdStr = ma.getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value;
  if (observedPeerIdStr != null) {
    const observedPeerId = peerIdFromString3(observedPeerIdStr);
    if (observedPeerId.equals(peerId)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`));
    }
  }
  return ma;
}
_a27 = Symbol.toStringTag;
var AddressManager = class {
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
    __publicField(this, "listen");
    __publicField(this, "announce");
    __publicField(this, "appendAnnounce");
    __publicField(this, "announceFilter");
    __publicField(this, "observed");
    __publicField(this, "dnsMappings");
    __publicField(this, "ipMappings");
    __publicField(this, "transportAddresses");
    __publicField(this, "observedAddressFilter");
    __publicField(this, "addressVerificationTTL");
    __publicField(this, "addressVerificationRetry");
    __publicField(this, _a27, "@libp2p/address-manager");
    const { listen = [], announce = [], appendAnnounce = [] } = init;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:address-manager");
    this.listen = listen.map((ma) => ma.toString());
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.appendAnnounce = new Set(appendAnnounce.map((ma) => ma.toString()));
    this.observed = new ObservedAddresses(components, init);
    this.dnsMappings = new DNSMappings(components, init);
    this.ipMappings = new IPMappings(components, init);
    this.transportAddresses = new TransportAddresses(components, init);
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
    this.observedAddressFilter = createScalableCuckooFilter(1024);
    this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues7.addressVerificationTTL;
    this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues7.addressVerificationRetry;
    this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1e3);
    components.events.addEventListener("transport:listening", () => {
      this._updatePeerStoreAddresses();
    });
    components.events.addEventListener("transport:close", () => {
      this._updatePeerStoreAddresses();
    });
  }
  _updatePeerStoreAddresses() {
    const addrs = this.getAddresses().map((ma) => {
      if (ma.getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value === this.components.peerId.toString()) {
        return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
      }
      return ma;
    });
    this.components.peerStore.patch(this.components.peerId, {
      multiaddrs: addrs
    }).catch((err) => {
      this.log.error("error updating addresses - %e", err);
    });
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((a2) => multiaddr(a2));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a2) => multiaddr(a2));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAppendAnnounceAddrs() {
    return Array.from(this.appendAnnounce).map((a2) => multiaddr(a2));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return this.observed.getAll().map((addr) => addr.multiaddr);
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(addr) {
    const config = getNetConfig(addr);
    let socketAddress;
    switch (config.type) {
      case "ip4": {
        socketAddress = `${config.host}:${config.port}`;
        break;
      }
      case "ip6": {
        socketAddress = `[${config.host}]:${config.port}`;
        break;
      }
      default: {
        return;
      }
    }
    if (this.observedAddressFilter.has(socketAddress)) {
      return;
    }
    this.observedAddressFilter.add(socketAddress);
    addr = stripPeerId(addr, this.components.peerId);
    if (this.ipMappings.has(addr)) {
      return;
    }
    if (this.dnsMappings.has(addr)) {
      return;
    }
    this.observed.add(addr);
  }
  confirmObservedAddr(addr, options2) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = true;
    if (options2?.type === "transport" || this.transportAddresses.has(addr)) {
      const transportStartingConfidence = this.transportAddresses.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
      if (!transportStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (options2?.type === "dns-mapping" || this.dnsMappings.has(addr)) {
      const dnsMappingStartingConfidence = this.dnsMappings.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
      if (!dnsMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (options2?.type === "ip-mapping" || this.ipMappings.has(addr)) {
      const ipMappingStartingConfidence = this.ipMappings.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
      if (!ipMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (options2?.type === "observed" || this.observed.has(addr)) {
      if (this.maybeUpgradeToIPMapping(addr)) {
        this.ipMappings.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
        startingConfidence = false;
      } else {
        const observedStartingConfidence = this.observed.confirm(addr, options2?.ttl ?? this.addressVerificationTTL);
        if (!observedStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
    }
    if (!startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  removeObservedAddr(addr, options2) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = false;
    if (this.observed.has(addr)) {
      const observedStartingConfidence = this.observed.remove(addr);
      if (!observedStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.transportAddresses.has(addr)) {
      const transportStartingConfidence = this.transportAddresses.unconfirm(addr, options2?.ttl ?? this.addressVerificationRetry);
      if (!transportStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.dnsMappings.has(addr)) {
      const dnsMappingStartingConfidence = this.dnsMappings.unconfirm(addr, options2?.ttl ?? this.addressVerificationRetry);
      if (!dnsMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (this.ipMappings.has(addr)) {
      const ipMappingStartingConfidence = this.ipMappings.unconfirm(addr, options2?.ttl ?? this.addressVerificationRetry);
      if (!ipMappingStartingConfidence && startingConfidence) {
        startingConfidence = false;
      }
    }
    if (startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  getAddresses() {
    const addresses = /* @__PURE__ */ new Set();
    const multiaddrs = this.getAddressesWithMetadata().filter((addr) => {
      if (!addr.verified) {
        return false;
      }
      const maStr = addr.multiaddr.toString();
      if (addresses.has(maStr)) {
        return false;
      }
      addresses.add(maStr);
      return true;
    }).map((address) => address.multiaddr);
    return this.announceFilter(multiaddrs.map((str) => {
      const ma = multiaddr(str);
      const lastComponent = ma.getComponents().pop();
      if (lastComponent?.value === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    }));
  }
  getAddressesWithMetadata() {
    const announceMultiaddrs = this.getAnnounceAddrs();
    if (announceMultiaddrs.length > 0) {
      this.components.transportManager.getListeners().forEach((listener) => {
        listener.updateAnnounceAddrs(announceMultiaddrs);
      });
      return announceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      }));
    }
    let addresses = [];
    addresses = addresses.concat(this.components.transportManager.getAddrs().map((multiaddr2) => this.transportAddresses.get(multiaddr2, this.addressVerificationTTL)));
    const appendAnnounceMultiaddrs = this.getAppendAnnounceAddrs();
    if (appendAnnounceMultiaddrs.length > 0) {
      this.components.transportManager.getListeners().forEach((listener) => {
        listener.updateAnnounceAddrs(appendAnnounceMultiaddrs);
      });
      addresses = addresses.concat(appendAnnounceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      })));
    }
    addresses = addresses.concat(this.observed.getAll());
    addresses = addresses.concat(this.ipMappings.getAll(addresses));
    addresses = addresses.concat(this.dnsMappings.getAll(addresses));
    return addresses;
  }
  addDNSMapping(domain, addresses) {
    this.dnsMappings.add(domain, addresses);
  }
  removeDNSMapping(domain) {
    if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  addPublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol2 = "tcp") {
    this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol2);
    this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol2}/${externalPort}`);
  }
  removePublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol2 = "tcp") {
    if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol2}/${externalPort}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  /**
   * Where an external service (router, gateway, etc) is forwarding traffic to
   * us, attempt to add an IP mapping for the external address - this will
   * include the observed mapping in the address list where we also have a DNS
   * mapping for the external IP.
   *
   * Returns true if we added a new mapping
   */
  maybeUpgradeToIPMapping(ma) {
    if (this.ipMappings.has(ma)) {
      return false;
    }
    if (!isNetworkAddress(ma)) {
      return false;
    }
    const config = getNetConfig(ma);
    if (config.type !== "ip4" || isPrivateIp(config.host) === true) {
      return false;
    }
    const listeners = this.components.transportManager.getListeners();
    const transportMatchers = [
      (ma2) => WebSockets.exactMatch(ma2) || WebSocketsSecure.exactMatch(ma2),
      (ma2) => TCP.exactMatch(ma2),
      (ma2) => QUIC_V1.exactMatch(ma2)
    ];
    for (const matcher of transportMatchers) {
      if (!matcher(ma)) {
        continue;
      }
      const transportListeners = listeners.filter((listener) => {
        return listener.getAddrs().filter((ma2) => {
          return getNetConfig(ma2).type === "ip4" && matcher(ma2);
        }).length > 0;
      });
      if (transportListeners.length !== 1) {
        continue;
      }
      const linkLocalAddr = transportListeners[0].getAddrs().filter((ma2) => {
        return !isLoopback(ma2);
      }).pop();
      if (linkLocalAddr == null) {
        continue;
      }
      const linkLocalOptions = getNetConfig(linkLocalAddr);
      if (linkLocalOptions.port == null) {
        return false;
      }
      this.observed.remove(ma);
      this.ipMappings.add(linkLocalOptions.host, linkLocalOptions.port, config.host, config.port, config.protocol);
      return true;
    }
    return false;
  }
};

// ../../node_modules/libp2p/dist/src/errors.js
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var MissingServiceError = class extends Error {
  constructor(message2 = "Missing service") {
    super(message2);
    this.name = "MissingServiceError";
  }
};
var UnmetServiceDependenciesError = class extends Error {
  constructor(message2 = "Unmet service dependencies") {
    super(message2);
    this.name = "UnmetServiceDependenciesError";
  }
};
var NoContentRoutersError = class extends Error {
  constructor(message2 = "No content routers available") {
    super(message2);
    this.name = "NoContentRoutersError";
  }
};
var NoPeerRoutersError = class extends Error {
  constructor(message2 = "No peer routers available") {
    super(message2);
    this.name = "NoPeerRoutersError";
  }
};
var QueriedForSelfError = class extends Error {
  constructor(message2 = "Should not try to find self") {
    super(message2);
    this.name = "QueriedForSelfError";
  }
};
var UnhandledProtocolError = class extends Error {
  constructor(message2 = "Unhandled protocol error") {
    super(message2);
    this.name = "UnhandledProtocolError";
  }
};
var DuplicateProtocolHandlerError = class extends Error {
  constructor(message2 = "Duplicate protocol handler error") {
    super(message2);
    this.name = "DuplicateProtocolHandlerError";
  }
};
var DialDeniedError = class extends Error {
  constructor(message2 = "Dial denied error") {
    super(message2);
    this.name = "DialDeniedError";
  }
};
var UnsupportedListenAddressError = class extends Error {
  constructor(message2 = "No transport was configured to listen on this address") {
    super(message2);
    this.name = "UnsupportedListenAddressError";
  }
};
var UnsupportedListenAddressesError = class extends Error {
  constructor(message2 = "Configured listen addresses could not be listened on") {
    super(message2);
    this.name = "UnsupportedListenAddressesError";
  }
};
var NoValidAddressesError = class extends Error {
  constructor(message2 = "No valid addresses") {
    super(message2);
    this.name = "NoValidAddressesError";
  }
};
var ConnectionInterceptedError = class extends Error {
  constructor(message2 = "Connection intercepted") {
    super(message2);
    this.name = "ConnectionInterceptedError";
  }
};
var ConnectionDeniedError = class extends Error {
  constructor(message2 = "Connection denied") {
    super(message2);
    this.name = "ConnectionDeniedError";
  }
};
var MuxerUnavailableError = class extends Error {
  constructor(message2 = "Stream is not multiplexed") {
    super(message2);
    this.name = "MuxerUnavailableError";
  }
};
var EncryptionFailedError = class extends Error {
  constructor(message2 = "Encryption failed") {
    super(message2);
    this.name = "EncryptionFailedError";
  }
};
var TransportUnavailableError = class extends Error {
  constructor(message2 = "Transport unavailable") {
    super(message2);
    this.name = "TransportUnavailableError";
  }
};
var RecursionLimitError = class extends Error {
  constructor(message2 = "Max recursive depth reached") {
    super(message2);
    this.name = "RecursionLimitError";
  }
};

// ../../node_modules/libp2p/dist/src/components.js
var DefaultComponents = class {
  constructor(init = {}) {
    __publicField(this, "components", {});
    __publicField(this, "_started", false);
    this.components = {};
    for (const [key, value2] of Object.entries(init)) {
      this.components[key] = value2;
    }
    if (this.components.logger == null) {
      this.components.logger = defaultLogger();
    }
  }
  isStarted() {
    return this._started;
  }
  async _invokeStartableMethod(methodName) {
    await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable[methodName]?.();
    }));
  }
  async beforeStart() {
    await this._invokeStartableMethod("beforeStart");
  }
  async start() {
    await this._invokeStartableMethod("start");
    this._started = true;
  }
  async afterStart() {
    await this._invokeStartableMethod("afterStart");
  }
  async beforeStop() {
    await this._invokeStartableMethod("beforeStop");
  }
  async stop() {
    await this._invokeStartableMethod("stop");
    this._started = false;
  }
  async afterStop() {
    await this._invokeStartableMethod("afterStop");
  }
};
var OPTIONAL_SERVICES = [
  "metrics",
  "connectionProtector",
  "dns"
];
var NON_SERVICE_PROPERTIES = [
  "components",
  "isStarted",
  "beforeStart",
  "start",
  "afterStart",
  "beforeStop",
  "stop",
  "afterStop",
  "then",
  "_invokeStartableMethod"
];
function defaultComponents(init = {}) {
  const components = new DefaultComponents(init);
  const proxy = new Proxy(components, {
    get(target, prop, receiver) {
      if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
        const service = components.components[prop];
        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
          throw new MissingServiceError(`${prop} not set`);
        }
        return service;
      }
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value2) {
      if (typeof prop === "string") {
        components.components[prop] = value2;
      } else {
        Reflect.set(target, prop, value2);
      }
      return true;
    }
  });
  return proxy;
}
function checkServiceDependencies(components) {
  const serviceCapabilities3 = {};
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceCapabilities(service)) {
      serviceCapabilities3[capability] = true;
    }
  }
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceDependencies(service)) {
      if (serviceCapabilities3[capability] !== true) {
        throw new UnmetServiceDependenciesError(`Service "${getServiceName(service)}" required capability "${capability}" but it was not provided by any component, you may need to add additional configuration when creating your node.`);
      }
    }
  }
}
function getServiceCapabilities(service) {
  if (Array.isArray(service?.[serviceCapabilities2])) {
    return service[serviceCapabilities2];
  }
  return [];
}
function getServiceDependencies(service) {
  if (Array.isArray(service?.[serviceDependencies2])) {
    return service[serviceDependencies2];
  }
  return [];
}
function getServiceName(service) {
  return service?.[Symbol.toStringTag] ?? service?.toString() ?? "unknown";
}

// ../../node_modules/libp2p/dist/src/config/connection-gater.browser.js
function connectionGater(gater = {}) {
  if (gater.denyDialMultiaddr == null) {
    gater.denyDialMultiaddr = (multiaddr2) => {
      if (WebSockets.matches(multiaddr2)) {
        return true;
      }
      return isPrivate(multiaddr2);
    };
  }
  return gater;
}

// ../../node_modules/libp2p/dist/src/get-peer.js
function getPeerAddress(peer) {
  if (isPeerId2(peer)) {
    return { peerId: peer, multiaddrs: [] };
  }
  let multiaddrs = Array.isArray(peer) ? peer : [peer];
  let peerId;
  if (multiaddrs.length > 0) {
    const peerIdStr = multiaddrs[0].getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value;
    peerId = peerIdStr == null ? void 0 : peerIdFromString3(peerIdStr);
    multiaddrs.forEach((ma) => {
      if (!isMultiaddr(ma)) {
        throw new InvalidMultiaddrError2("Invalid multiaddr");
      }
      const maPeerIdStr = ma.getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value;
      if (maPeerIdStr == null) {
        if (peerId != null) {
          throw new InvalidParametersError2("Multiaddrs must all have the same peer id or have no peer id");
        }
      } else {
        const maPeerId = peerIdFromString3(maPeerIdStr);
        if (peerId?.equals(maPeerId) !== true) {
          throw new InvalidParametersError2("Multiaddrs must all have the same peer id or have no peer id");
        }
      }
    });
  }
  multiaddrs = multiaddrs.filter((ma) => {
    return !PEER_ID.exactMatch(ma);
  });
  return {
    peerId,
    multiaddrs
  };
}

// ../../node_modules/libp2p/dist/src/connection-manager/utils.js
var DEFAULT_CLOSABLE_PROTOCOLS = [
  // identify
  "/ipfs/id/1.0.0",
  // identify-push
  "/ipfs/id/push/1.0.0",
  // autonat
  "/libp2p/autonat/1.0.0",
  // dcutr
  "/libp2p/dcutr"
];
async function safelyCloseConnectionIfUnused(connection, options2) {
  const streamProtocols = connection?.streams?.map((stream) => stream.protocol) ?? [];
  const closableProtocols = options2?.closableProtocols ?? DEFAULT_CLOSABLE_PROTOCOLS;
  if (streamProtocols.filter((proto) => proto != null && !closableProtocols.includes(proto)).length > 0) {
    return;
  }
  try {
    await connection?.close(options2);
  } catch (err) {
    connection?.abort(err);
  }
}
function multiaddrToIpNet(ma) {
  const config = getNetConfig(ma);
  let mask = config.cidr;
  if (config.type !== "ip4" && config.type !== "ip6") {
    throw new InvalidParametersError2(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
  }
  if (mask == null) {
    switch (config.type) {
      case "ip4": {
        mask = 32;
        break;
      }
      case "ip6": {
        mask = 128;
        break;
      }
      default: {
        throw new InvalidParametersError2(`Multiaddr ${ma} was not an IPv4 or IPv6 address`);
      }
    }
  }
  return new IpNet(config.host, mask);
}
function isDirect(ma) {
  return !Circuit.exactMatch(ma);
}
function findExistingConnection(peerId, connections, dialAddresses) {
  if (peerId == null || connections == null) {
    return;
  }
  const existingConnection = connections.sort((a2, b) => {
    if (a2.direct) {
      return -1;
    }
    if (b.direct) {
      return 1;
    }
    return 0;
  }).find((con) => con.limits == null);
  if (existingConnection == null || existingConnection.direct || dialAddresses == null) {
    return existingConnection;
  }
  const wouldUpgradeToDirect = dialAddresses.some((ma) => isDirect(ma));
  if (wouldUpgradeToDirect) {
    return;
  }
  return existingConnection;
}

// ../../node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
var ConnectionPruner = class {
  constructor(components, init = {}) {
    __publicField(this, "connectionManager");
    __publicField(this, "peerStore");
    __publicField(this, "allow");
    __publicField(this, "events");
    __publicField(this, "log");
    this.allow = (init.allow ?? []).map((ma) => multiaddrToIpNet(ma));
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
    this.maybePruneConnections = this.maybePruneConnections.bind(this);
  }
  start() {
    this.events.addEventListener("connection:open", this.maybePruneConnections);
  }
  stop() {
    this.events.removeEventListener("connection:open", this.maybePruneConnections);
  }
  maybePruneConnections() {
    this._maybePruneConnections().catch((err) => {
      this.log.error("error while pruning connections - %e", err);
    });
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async _maybePruneConnections() {
    const connections = this.connectionManager.getConnections();
    const numConnections = connections.length;
    const maxConnections = this.connectionManager.getMaxConnections();
    this.log("checking max connections limit %d/%d", numConnections, maxConnections);
    if (numConnections <= maxConnections) {
      return;
    }
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      peerValues.set(remotePeer, 0);
      try {
        const peer = await this.peerStore.get(remotePeer);
        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
          return acc + curr.value;
        }, 0));
      } catch (err) {
        if (err.name !== "NotFoundError") {
          this.log.error("error loading peer tags - %e", err);
        }
      }
    }
    const sortedConnections = this.sortConnections(connections, peerValues);
    const toPrune = Math.max(numConnections - maxConnections, 0);
    const toClose = [];
    for (const connection of sortedConnections) {
      this.log("too many connections open - closing a connection to %p", connection.remotePeer);
      const connectionInAllowList = this.allow.some((ipNet) => {
        if (isNetworkAddress(connection.remoteAddr)) {
          const config = getNetConfig(connection.remoteAddr);
          return ipNet.contains(config.host);
        }
        return true;
      });
      if (!connectionInAllowList) {
        toClose.push(connection);
      }
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      await safelyCloseConnectionIfUnused(connection, {
        signal: AbortSignal.timeout(1e3)
      });
    }));
    this.events.safeDispatchEvent("connection:prune", { detail: toClose });
  }
  sortConnections(connections, peerValues) {
    return connections.sort((a2, b) => {
      const connectionALifespan = a2.timeline.open;
      const connectionBLifespan = b.timeline.open;
      if (connectionALifespan < connectionBLifespan) {
        return 1;
      }
      if (connectionALifespan > connectionBLifespan) {
        return -1;
      }
      return 0;
    }).sort((a2, b) => {
      if (a2.direction === "outbound" && b.direction === "inbound") {
        return 1;
      }
      if (a2.direction === "inbound" && b.direction === "outbound") {
        return -1;
      }
      return 0;
    }).sort((a2, b) => {
      if (a2.streams.length > b.streams.length) {
        return 1;
      }
      if (a2.streams.length < b.streams.length) {
        return -1;
      }
      return 0;
    }).sort((a2, b) => {
      const peerAValue = peerValues.get(a2.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
  }
};

// ../../node_modules/libp2p/dist/src/connection-manager/constants.defaults.js
var DIAL_TIMEOUT = 1e4;
var CONNECTION_CLOSE_TIMEOUT = 1e3;
var INBOUND_UPGRADE_TIMEOUT = 1e4;
var PROTOCOL_NEGOTIATION_TIMEOUT = 1e4;
var MAX_PEER_ADDRS_TO_DIAL = 25;
var INBOUND_CONNECTION_THRESHOLD = 5;
var MAX_INCOMING_PENDING_CONNECTIONS = 10;
var MAX_PARALLEL_RECONNECTS = 5;
var LAST_DIAL_FAILURE_KEY = "last-dial-failure";
var LAST_DIAL_SUCCESS_KEY = "last-dial-success";
var MAX_DIAL_QUEUE_LENGTH = 500;
var MAX_RECURSIVE_DEPTH = 32;

// ../../node_modules/libp2p/dist/src/connection-manager/constants.browser.js
var MAX_CONNECTIONS2 = 100;
var MAX_PARALLEL_DIALS = 50;

// ../../node_modules/libp2p/dist/src/connection-manager/address-sorter.js
function reliableTransportsFirst(a2, b) {
  const isATcp = TCP.exactMatch(a2.multiaddr);
  const isBTcp = TCP.exactMatch(b.multiaddr);
  if (isATcp && !isBTcp) {
    return -1;
  }
  if (!isATcp && isBTcp) {
    return 1;
  }
  const isAWebSocketSecure = WebSocketsSecure.exactMatch(a2.multiaddr);
  const isBWebSocketSecure = WebSocketsSecure.exactMatch(b.multiaddr);
  if (isAWebSocketSecure && !isBWebSocketSecure) {
    return -1;
  }
  if (!isAWebSocketSecure && isBWebSocketSecure) {
    return 1;
  }
  const isAWebSocket = WebSockets.exactMatch(a2.multiaddr);
  const isBWebSocket = WebSockets.exactMatch(b.multiaddr);
  if (isAWebSocket && !isBWebSocket) {
    return -1;
  }
  if (!isAWebSocket && isBWebSocket) {
    return 1;
  }
  const isAWebRTC = WebRTC.exactMatch(a2.multiaddr);
  const isBWebRTC = WebRTC.exactMatch(b.multiaddr);
  if (isAWebRTC && !isBWebRTC) {
    return -1;
  }
  if (!isAWebRTC && isBWebRTC) {
    return 1;
  }
  const isAWebRTCDirect = WebRTCDirect.exactMatch(a2.multiaddr);
  const isBWebRTCDirect = WebRTCDirect.exactMatch(b.multiaddr);
  if (isAWebRTCDirect && !isBWebRTCDirect) {
    return -1;
  }
  if (!isAWebRTCDirect && isBWebRTCDirect) {
    return 1;
  }
  const isAWebTransport = WebTransport.exactMatch(a2.multiaddr);
  const isBWebTransport = WebTransport.exactMatch(b.multiaddr);
  if (isAWebTransport && !isBWebTransport) {
    return -1;
  }
  if (!isAWebTransport && isBWebTransport) {
    return 1;
  }
  return 0;
}
function loopbackAddressLast(a2, b) {
  const isALoopback = isLoopback(a2.multiaddr);
  const isBLoopback = isLoopback(b.multiaddr);
  if (isALoopback && !isBLoopback) {
    return 1;
  } else if (!isALoopback && isBLoopback) {
    return -1;
  }
  return 0;
}
function publicAddressesFirst(a2, b) {
  const isAPrivate = isPrivate(a2.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  return 0;
}
function certifiedAddressesFirst(a2, b) {
  if (a2.isCertified && !b.isCertified) {
    return -1;
  } else if (!a2.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}
function circuitRelayAddressesLast(a2, b) {
  const isACircuit = Circuit.exactMatch(a2.multiaddr);
  const isBCircuit = Circuit.exactMatch(b.multiaddr);
  if (isACircuit && !isBCircuit) {
    return 1;
  } else if (!isACircuit && isBCircuit) {
    return -1;
  }
  return 0;
}
function defaultAddressSorter(addresses) {
  return addresses.sort(reliableTransportsFirst).sort(certifiedAddressesFirst).sort(circuitRelayAddressesLast).sort(publicAddressesFirst).sort(loopbackAddressLast);
}

// ../../node_modules/@multiformats/dns/dist/src/errors.js
var DNSQueryFailedError = class extends AggregateError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "DNSQueryFailedError");
  }
};
__publicField(DNSQueryFailedError, "name", "DNSQueryFailedError");

// ../../node_modules/@multiformats/dns/dist/src/utils/get-types.js
function getTypes(types) {
  const DEFAULT_TYPES = [
    RecordType.A
  ];
  if (types == null) {
    return DEFAULT_TYPES;
  }
  if (Array.isArray(types)) {
    if (types.length === 0) {
      return DEFAULT_TYPES;
    }
    return types;
  }
  return [
    types
  ];
}

// ../../node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js
var DEFAULT_TTL = 60;
function toDNSResponse(obj) {
  return {
    Status: obj.Status ?? 0,
    TC: obj.TC ?? obj.flag_tc ?? false,
    RD: obj.RD ?? obj.flag_rd ?? false,
    RA: obj.RA ?? obj.flag_ra ?? false,
    AD: obj.AD ?? obj.flag_ad ?? false,
    CD: obj.CD ?? obj.flag_cd ?? false,
    Question: (obj.Question ?? obj.questions ?? []).map((question) => {
      return {
        name: question.name,
        type: RecordType[question.type]
      };
    }),
    Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
      return {
        name: answer.name,
        type: RecordType[answer.type],
        TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
        data: answer.data instanceof Uint8Array ? toString2(answer.data) : answer.data
      };
    })
  };
}

// ../../node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
var DEFAULT_QUERY_CONCURRENCY = 4;
function dnsJsonOverHttps(url, init = {}) {
  const httpQueue = new PQueue({
    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
  });
  return async (fqdn, options2 = {}) => {
    const searchParams = new URLSearchParams();
    searchParams.set("name", fqdn);
    getTypes(options2.types).forEach((type) => {
      searchParams.append("type", RecordType[type]);
    });
    options2.onProgress?.(new CustomProgressEvent("dns:query", fqdn));
    const response = await httpQueue.add(async () => {
      const res = await fetch(`${url}?${searchParams}`, {
        headers: {
          accept: "application/dns-json"
        },
        signal: options2?.signal
      });
      if (res.status !== 200) {
        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
      }
      const response2 = toDNSResponse(await res.json());
      options2.onProgress?.(new CustomProgressEvent("dns:response", response2));
      return response2;
    }, {
      signal: options2.signal
    });
    if (response == null) {
      throw new Error("No DNS response received");
    }
    return response;
  };
}

// ../../node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
function defaultResolver() {
  return [
    dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
    dnsJsonOverHttps("https://dns.google/resolve")
  ];
}

// ../../node_modules/@multiformats/dns/dist/src/utils/cache.js
var import_hashlru = __toESM(require_hashlru(), 1);
var CachedAnswers = class {
  constructor(maxSize) {
    __publicField(this, "lru");
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  get(fqdn, types) {
    let foundAllAnswers = true;
    const answers = [];
    for (const type of types) {
      const cached = this.getAnswers(fqdn, type);
      if (cached.length === 0) {
        foundAllAnswers = false;
        break;
      }
      answers.push(...cached);
    }
    if (foundAllAnswers) {
      return toDNSResponse({ answers });
    }
  }
  getAnswers(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    const answers = this.lru.get(key);
    if (answers != null) {
      const cachedAnswers = answers.filter((entry) => {
        return entry.expires > Date.now();
      }).map(({ expires, value: value2 }) => ({
        ...value2,
        TTL: Math.round((expires - Date.now()) / 1e3),
        type: RecordType[value2.type]
      }));
      if (cachedAnswers.length === 0) {
        this.lru.remove(key);
      }
      return cachedAnswers;
    }
    return [];
  }
  add(domain, answer) {
    const key = `${domain.toLowerCase()}-${answer.type}`;
    const answers = this.lru.get(key) ?? [];
    answers.push({
      expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
      value: answer
    });
    this.lru.set(key, answers);
  }
  remove(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};
function cache2(size) {
  return new CachedAnswers(size);
}

// ../../node_modules/@multiformats/dns/dist/src/dns.js
var DEFAULT_ANSWER_CACHE_SIZE = 1e3;
var DNS2 = class {
  constructor(init) {
    __publicField(this, "resolvers");
    __publicField(this, "cache");
    this.resolvers = {};
    this.cache = cache2(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
      if (!Array.isArray(resolver)) {
        resolver = [resolver];
      }
      if (!tld.endsWith(".")) {
        tld = `${tld}.`;
      }
      this.resolvers[tld] = resolver;
    });
    if (this.resolvers["."] == null) {
      this.resolvers["."] = defaultResolver();
    }
  }
  /**
   * Queries DNS resolvers for the passed record types for the passed domain.
   *
   * If cached records exist for all desired types they will be returned
   * instead.
   *
   * Any new responses will be added to the cache for subsequent requests.
   */
  async query(domain, options2 = {}) {
    const types = getTypes(options2.types);
    const cached = options2.cached !== false ? this.cache.get(domain, types) : void 0;
    if (cached != null) {
      options2.onProgress?.(new CustomProgressEvent("dns:cache", cached));
      return cached;
    }
    const tld = `${domain.split(".").pop()}.`;
    const resolvers = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
      return Math.random() > 0.5 ? -1 : 1;
    });
    const errors = [];
    for (const resolver of resolvers) {
      if (options2.signal?.aborted === true) {
        break;
      }
      try {
        const result = await resolver(domain, {
          ...options2,
          types
        });
        for (const answer of result.Answer) {
          this.cache.add(domain, answer);
        }
        return result;
      } catch (err) {
        errors.push(err);
        options2.onProgress?.(new CustomProgressEvent("dns:error", err));
      }
    }
    throw new DNSQueryFailedError(errors, `DNS lookup of ${domain} ${types} failed`);
  }
};

// ../../node_modules/@multiformats/dns/dist/src/index.js
var RecordType;
(function(RecordType2) {
  RecordType2[RecordType2["A"] = 1] = "A";
  RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
  RecordType2[RecordType2["TXT"] = 16] = "TXT";
  RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
})(RecordType || (RecordType = {}));
var MAX_RECURSIVE_DEPTH2 = 32;
function dns(init = {}) {
  return new DNS2(init);
}

// ../../node_modules/libp2p/dist/src/connection-manager/resolvers/dnsaddr.js
var DNSAddrResolver = class {
  constructor() {
    __publicField(this, "dns");
  }
  canResolve(ma) {
    return ma.getComponents().some(({ name: name5 }) => name5 === "dnsaddr");
  }
  async resolve(ma, options2) {
    const hostname = ma.getComponents().find((component) => component.name === "dnsaddr")?.value;
    if (hostname == null) {
      return [ma];
    }
    const resolver = this.getDNS(options2);
    const result = await resolver.query(`_dnsaddr.${hostname}`, {
      signal: options2?.signal,
      types: [
        RecordType.TXT
      ]
    });
    const peerId = ma.getComponents().find((component) => component.name === "p2p")?.value;
    const output = [];
    for (const answer of result.Answer) {
      const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
      if (addr == null) {
        continue;
      }
      if (peerId != null && !addr.includes(peerId)) {
        continue;
      }
      output.push(multiaddr(addr));
    }
    return output;
  }
  getDNS(options2) {
    if (options2.dns != null) {
      return options2.dns;
    }
    if (this.dns == null) {
      this.dns = dns();
    }
    return this.dns;
  }
};
var dnsaddrResolver = new DNSAddrResolver();

// ../../node_modules/libp2p/dist/src/connection-manager/resolvers/index.js
async function resolveMultiaddr(address, resolvers, options2) {
  const depth = options2.depth ?? 0;
  if (depth > (options2.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH)) {
    throw new RecursionLimitError("Max recursive depth reached");
  }
  let resolved = false;
  const output = [];
  for (const resolver of Object.values(resolvers)) {
    if (resolver.canResolve(address)) {
      resolved = true;
      const addresses = await resolver.resolve(address, options2);
      for (const address2 of addresses) {
        output.push(...await resolveMultiaddr(address2, resolvers, {
          ...options2,
          depth: depth + 1
        }));
      }
    }
  }
  if (resolved === false) {
    output.push(address);
  }
  return output;
}

// ../../node_modules/libp2p/dist/src/connection-manager/dial-queue.js
var defaultOptions3 = {
  maxParallelDials: MAX_PARALLEL_DIALS,
  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,
  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
  dialTimeout: DIAL_TIMEOUT,
  resolvers: {
    dnsaddr: dnsaddrResolver
  }
};
var DialQueue = class {
  constructor(components, init = {}) {
    __publicField(this, "queue");
    __publicField(this, "components");
    __publicField(this, "addressSorter");
    __publicField(this, "maxPeerAddrsToDial");
    __publicField(this, "maxDialQueueLength");
    __publicField(this, "dialTimeout");
    __publicField(this, "shutDownController");
    __publicField(this, "connections");
    __publicField(this, "log");
    __publicField(this, "resolvers");
    this.addressSorter = init.addressSorter;
    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions3.maxPeerAddrsToDial;
    this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions3.maxDialQueueLength;
    this.dialTimeout = init.dialTimeout ?? defaultOptions3.dialTimeout;
    this.connections = init.connections ?? new PeerMap();
    this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
    this.components = components;
    this.resolvers = init.resolvers ?? defaultOptions3.resolvers;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    this.queue = new PriorityQueue({
      concurrency: init.maxParallelDials ?? defaultOptions3.maxParallelDials,
      metricName: "libp2p_dial_queue",
      metrics: components.metrics
    });
    this.queue.addEventListener("failure", (event) => {
      if (event.detail?.error.name !== AbortError2.name) {
        this.log.error("error in dial queue - %e", event.detail.error);
      }
    });
  }
  start() {
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
  }
  /**
   * Clears any pending dials
   */
  stop() {
    this.shutDownController.abort();
    this.queue.abort();
  }
  /**
   * Connects to a given peer, multiaddr or list of multiaddrs.
   *
   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
   * multiaddrs are passed only those will be dialled.
   *
   * Where a list of multiaddrs is passed, if any contain a peer id then all
   * multiaddrs in the list must contain the same peer id.
   *
   * The dial to the first address that is successfully able to upgrade a
   * connection will be used, all other dials will be aborted when that happens.
   */
  async dial(peerIdOrMultiaddr, options2 = {}) {
    const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
    if (peerId != null && options2.force !== true) {
      const existingConnection = findExistingConnection(peerId, this.connections.get(peerId), multiaddrs);
      if (existingConnection != null) {
        this.log("already connected to %a", existingConnection.remoteAddr);
        options2.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
        return existingConnection;
      }
    }
    const existingDial = this.queue.queue.find((job) => {
      if (peerId?.equals(job.options.peerId) === true) {
        return true;
      }
      const addresses = job.options.multiaddrs;
      if (addresses == null) {
        return false;
      }
      for (const multiaddr2 of multiaddrs) {
        if (addresses.has(multiaddr2.toString())) {
          return true;
        }
      }
      return false;
    });
    if (existingDial != null) {
      this.log("joining existing dial target for %p", peerId);
      for (const multiaddr2 of multiaddrs) {
        existingDial.options.multiaddrs.add(multiaddr2.toString());
      }
      options2.onProgress?.(new CustomProgressEvent("dial-queue:already-in-dial-queue"));
      return existingDial.join(options2);
    }
    if (this.queue.size >= this.maxDialQueueLength) {
      throw new DialError2("Dial queue is full");
    }
    this.log("creating dial target for %p", peerId, multiaddrs.map((ma) => ma.toString()));
    options2.onProgress?.(new CustomProgressEvent("dial-queue:add-to-dial-queue"));
    return this.queue.add(async (options3) => {
      options3.onProgress?.(new CustomProgressEvent("dial-queue:start-dial"));
      const signal = anySignal([
        this.shutDownController.signal,
        options3.signal
      ]);
      setMaxListeners(Infinity, signal);
      try {
        return await this.dialPeer(options3, signal);
      } finally {
        signal.clear();
      }
    }, {
      peerId,
      priority: options2.priority ?? DEFAULT_DIAL_PRIORITY,
      multiaddrs: new Set(multiaddrs.map((ma) => ma.toString())),
      signal: options2.signal ?? AbortSignal.timeout(this.dialTimeout),
      onProgress: options2.onProgress
    });
  }
  async dialPeer(options2, signal) {
    const peerId = options2.peerId;
    const multiaddrs = options2.multiaddrs;
    const failedMultiaddrs = /* @__PURE__ */ new Set();
    let forcePeerLookup = options2.multiaddrs.size === 0;
    let dialed = 0;
    let dialIteration = 0;
    const errors = [];
    this.log("starting dial to %p", peerId);
    while (forcePeerLookup || multiaddrs.size > 0) {
      dialIteration++;
      forcePeerLookup = false;
      const addrsToDial = [];
      const addrs = new Set(options2.multiaddrs);
      multiaddrs.clear();
      this.log("calculating addrs to dial %p from %s", peerId, [...addrs]);
      const calculatedAddrs = await this.calculateMultiaddrs(peerId, addrs, {
        ...options2,
        signal
      });
      for (const addr of calculatedAddrs) {
        if (failedMultiaddrs.has(addr.multiaddr.toString())) {
          this.log.trace("skipping previously failed multiaddr %a while dialing %p", addr.multiaddr, peerId);
          continue;
        }
        addrsToDial.push(addr);
      }
      this.log("%s dial to %p with %s", dialIteration === 1 ? "starting" : "continuing", peerId, addrsToDial.map((ma) => ma.multiaddr.toString()));
      options2?.onProgress?.(new CustomProgressEvent("dial-queue:calculated-addresses", addrsToDial));
      for (const address of addrsToDial) {
        if (dialed === this.maxPeerAddrsToDial) {
          this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, options2.peerId);
          throw new DialError2("Peer had more than maxPeerAddrsToDial");
        }
        dialed++;
        try {
          const conn = await this.components.transportManager.dial(address.multiaddr, {
            ...options2,
            signal
          });
          this.log("dial to %a succeeded", address.multiaddr);
          try {
            await this.components.peerStore.merge(conn.remotePeer, {
              multiaddrs: [
                conn.remoteAddr
              ],
              metadata: {
                [LAST_DIAL_SUCCESS_KEY]: fromString2(Date.now().toString())
              }
            });
          } catch (err) {
            this.log.error("could not update last dial failure key for %p - %e", peerId, err);
          }
          return conn;
        } catch (err) {
          this.log.error("dial failed to %a - %e", address.multiaddr, err);
          failedMultiaddrs.add(address.multiaddr.toString());
          if (peerId != null) {
            try {
              await this.components.peerStore.merge(peerId, {
                metadata: {
                  [LAST_DIAL_FAILURE_KEY]: fromString2(Date.now().toString())
                }
              });
            } catch (err2) {
              this.log.error("could not update last dial failure key for %p - %e", peerId, err2);
            }
          }
          if (signal.aborted) {
            throw new TimeoutError2(err.message);
          }
          errors.push(err);
        }
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, "All multiaddr dials failed");
  }
  // eslint-disable-next-line complexity
  async calculateMultiaddrs(peerId, multiaddrs = /* @__PURE__ */ new Set(), options2 = {}) {
    const addrs = [...multiaddrs].map((ma) => ({
      multiaddr: multiaddr(ma),
      isCertified: false
    }));
    if (peerId != null) {
      if (this.components.peerId.equals(peerId)) {
        throw new DialError2("Tried to dial self");
      }
      if (await this.components.connectionGater.denyDialPeer?.(peerId) === true) {
        throw new DialDeniedError("The dial request is blocked by gater.allowDialPeer");
      }
      if (addrs.length === 0) {
        this.log("loading multiaddrs for %p", peerId);
        try {
          const peer = await this.components.peerStore.get(peerId);
          addrs.push(...peer.addresses);
          this.log("loaded multiaddrs for %p", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
      }
      if (addrs.length === 0) {
        this.log("looking up multiaddrs for %p in the peer routing", peerId);
        try {
          const peerInfo = await this.components.peerRouting.findPeer(peerId, options2);
          this.log("found multiaddrs for %p in the peer routing", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          addrs.push(...peerInfo.multiaddrs.map((multiaddr2) => ({
            multiaddr: multiaddr2,
            isCertified: false
          })));
        } catch (err) {
          if (err.name === "NoPeerRoutersError") {
            this.log("no peer routers configured", peerId);
          } else {
            this.log.error("looking up multiaddrs for %p in the peer routing failed - %e", peerId, err);
          }
        }
      }
    }
    let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
      const result = await resolveMultiaddr(addr.multiaddr, this.resolvers, {
        dns: this.components.dns,
        log: this.log,
        ...options2
      });
      if (result.length === 1 && result[0].equals(addr.multiaddr)) {
        return addr;
      }
      return result.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        isCertified: false
      }));
    }))).flat();
    if (peerId != null) {
      const peerIdMultiaddr = `/p2p/${peerId.toString()}`;
      resolvedAddresses = resolvedAddresses.map((addr) => {
        const lastComponent = addr.multiaddr.getComponents().pop();
        if (lastComponent?.name !== "p2p") {
          return {
            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
            isCertified: addr.isCertified
          };
        }
        return addr;
      });
    }
    const filteredAddrs = resolvedAddresses.filter((addr) => {
      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {
        return false;
      }
      const addrPeerId = addr.multiaddr.getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value;
      if (peerId != null && addrPeerId != null) {
        return peerId.equals(addrPeerId);
      }
      return true;
    });
    const dedupedAddrs = /* @__PURE__ */ new Map();
    for (const addr of filteredAddrs) {
      const maStr = addr.multiaddr.toString();
      const existing = dedupedAddrs.get(maStr);
      if (existing != null) {
        existing.isCertified = existing.isCertified || addr.isCertified || false;
        continue;
      }
      dedupedAddrs.set(maStr, addr);
    }
    const dedupedMultiaddrs = [...dedupedAddrs.values()];
    if (dedupedMultiaddrs.length === 0) {
      throw new NoValidAddressesError("The dial request has no valid addresses");
    }
    const gatedAddrs = [];
    for (const addr of dedupedMultiaddrs) {
      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
        continue;
      }
      gatedAddrs.push(addr);
    }
    const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAddrs) : gatedAddrs.sort(this.addressSorter);
    if (sortedGatedAddrs.length === 0) {
      throw new DialDeniedError("The connection gater denied all addresses in the dial request");
    }
    this.log.trace("addresses for %p before filtering", peerId ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    this.log.trace("addresses for %p after filtering", peerId ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    return sortedGatedAddrs;
  }
  async isDialable(multiaddr2, options2 = {}) {
    if (!Array.isArray(multiaddr2)) {
      multiaddr2 = [multiaddr2];
    }
    try {
      const addresses = await this.calculateMultiaddrs(void 0, new Set(multiaddr2.map((ma) => ma.toString())), options2);
      if (options2.runOnLimitedConnection === false) {
        return addresses.find((addr) => {
          return !Circuit.matches(addr.multiaddr);
        }) != null;
      }
      return true;
    } catch {
    }
    return false;
  }
};

// ../../node_modules/is-network-error/index.js
var objectToString = Object.prototype.toString;
var isError = (value2) => objectToString.call(value2) === "[object Error]";
var errorMessages = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated",
  // Undici (Node.js)
  " A network error occurred.",
  // Bun (WebKit)
  "Network connection lost"
  // Cloudflare Workers (fetch)
]);
function isNetworkError(error) {
  const isValid2 = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid2) {
    return false;
  }
  const { message: message2, stack } = error;
  if (message2 === "Load failed") {
    return stack === void 0 || "__sentry_captured__" in error;
  }
  if (message2.startsWith("error sending request for url")) {
    return true;
  }
  return errorMessages.has(message2);
}

// ../../node_modules/p-retry/index.js
function validateRetries(retries) {
  if (typeof retries === "number") {
    if (retries < 0) {
      throw new TypeError("Expected `retries` to be a non-negative number.");
    }
    if (Number.isNaN(retries)) {
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
    }
  } else if (retries !== void 0) {
    throw new TypeError("Expected `retries` to be a number or Infinity.");
  }
}
function validateNumberOption(name5, value2, { min = 0, allowInfinity = false } = {}) {
  if (value2 === void 0) {
    return;
  }
  if (typeof value2 !== "number" || Number.isNaN(value2)) {
    throw new TypeError(`Expected \`${name5}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
  }
  if (!allowInfinity && !Number.isFinite(value2)) {
    throw new TypeError(`Expected \`${name5}\` to be a finite number.`);
  }
  if (value2 < min) {
    throw new TypeError(`Expected \`${name5}\` to be  ${min}.`);
  }
}
var AbortError9 = class extends Error {
  constructor(message2) {
    super();
    if (message2 instanceof Error) {
      this.originalError = message2;
      ({ message: message2 } = message2);
    } else {
      this.originalError = new Error(message2);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message2;
  }
};
function calculateDelay(retriesConsumed, options2) {
  const attempt = Math.max(1, retriesConsumed + 1);
  const random2 = options2.randomize ? Math.random() + 1 : 1;
  let timeout = Math.round(random2 * options2.minTimeout * options2.factor ** (attempt - 1));
  timeout = Math.min(timeout, options2.maxTimeout);
  return timeout;
}
function calculateRemainingTime(start2, max) {
  if (!Number.isFinite(max)) {
    return max;
  }
  return max - (performance.now() - start2);
}
async function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime, options: options2 }) {
  const normalizedError = error instanceof Error ? error : new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
  if (normalizedError instanceof AbortError9) {
    throw normalizedError.originalError;
  }
  const retriesLeft = Number.isFinite(options2.retries) ? Math.max(0, options2.retries - retriesConsumed) : options2.retries;
  const maxRetryTime = options2.maxRetryTime ?? Number.POSITIVE_INFINITY;
  const context = Object.freeze({
    error: normalizedError,
    attemptNumber,
    retriesLeft,
    retriesConsumed
  });
  await options2.onFailedAttempt(context);
  if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {
    throw normalizedError;
  }
  const consumeRetry = await options2.shouldConsumeRetry(context);
  const remainingTime = calculateRemainingTime(startTime, maxRetryTime);
  if (remainingTime <= 0 || retriesLeft <= 0) {
    throw normalizedError;
  }
  if (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {
    if (consumeRetry) {
      throw normalizedError;
    }
    options2.signal?.throwIfAborted();
    return false;
  }
  if (!await options2.shouldRetry(context)) {
    throw normalizedError;
  }
  if (!consumeRetry) {
    options2.signal?.throwIfAborted();
    return false;
  }
  const delayTime = calculateDelay(retriesConsumed, options2);
  const finalDelay = Math.min(delayTime, remainingTime);
  options2.signal?.throwIfAborted();
  if (finalDelay > 0) {
    await new Promise((resolve, reject) => {
      const onAbort = () => {
        clearTimeout(timeoutToken);
        options2.signal?.removeEventListener("abort", onAbort);
        reject(options2.signal.reason);
      };
      const timeoutToken = setTimeout(() => {
        options2.signal?.removeEventListener("abort", onAbort);
        resolve();
      }, finalDelay);
      if (options2.unref) {
        timeoutToken.unref?.();
      }
      options2.signal?.addEventListener("abort", onAbort, { once: true });
    });
  }
  options2.signal?.throwIfAborted();
  return true;
}
async function pRetry(input, options2 = {}) {
  options2 = { ...options2 };
  validateRetries(options2.retries);
  if (Object.hasOwn(options2, "forever")) {
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  }
  options2.retries ?? (options2.retries = 10);
  options2.factor ?? (options2.factor = 2);
  options2.minTimeout ?? (options2.minTimeout = 1e3);
  options2.maxTimeout ?? (options2.maxTimeout = Number.POSITIVE_INFINITY);
  options2.maxRetryTime ?? (options2.maxRetryTime = Number.POSITIVE_INFINITY);
  options2.randomize ?? (options2.randomize = false);
  options2.onFailedAttempt ?? (options2.onFailedAttempt = () => {
  });
  options2.shouldRetry ?? (options2.shouldRetry = () => true);
  options2.shouldConsumeRetry ?? (options2.shouldConsumeRetry = () => true);
  validateNumberOption("factor", options2.factor, { min: 0, allowInfinity: false });
  validateNumberOption("minTimeout", options2.minTimeout, { min: 0, allowInfinity: false });
  validateNumberOption("maxTimeout", options2.maxTimeout, { min: 0, allowInfinity: true });
  validateNumberOption("maxRetryTime", options2.maxRetryTime, { min: 0, allowInfinity: true });
  if (!(options2.factor > 0)) {
    options2.factor = 1;
  }
  options2.signal?.throwIfAborted();
  let attemptNumber = 0;
  let retriesConsumed = 0;
  const startTime = performance.now();
  while (Number.isFinite(options2.retries) ? retriesConsumed <= options2.retries : true) {
    attemptNumber++;
    try {
      options2.signal?.throwIfAborted();
      const result = await input(attemptNumber);
      options2.signal?.throwIfAborted();
      return result;
    } catch (error) {
      if (await onAttemptFailure({
        error,
        attemptNumber,
        retriesConsumed,
        startTime,
        options: options2
      })) {
        retriesConsumed++;
      }
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}
function makeRetriable(function_, options2) {
  return function(...arguments_) {
    return pRetry(() => function_.apply(this, arguments_), options2);
  };
}

// ../../node_modules/libp2p/dist/src/connection-manager/reconnect-queue.js
var ReconnectQueue = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "queue");
    __publicField(this, "started");
    __publicField(this, "peerStore");
    __publicField(this, "retries");
    __publicField(this, "retryInterval");
    __publicField(this, "backoffFactor");
    __publicField(this, "connectionManager");
    __publicField(this, "events");
    this.log = components.logger.forComponent("libp2p:reconnect-queue");
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.queue = new PeerQueue({
      concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,
      metricName: "libp2p_reconnect_queue",
      metrics: components.metrics
    });
    this.started = false;
    this.retries = init.retries ?? 5;
    this.backoffFactor = init.backoffFactor;
    this.retryInterval = init.retryInterval;
    this.events = components.events;
    components.events.addEventListener("peer:disconnect", (evt) => {
      this.maybeReconnect(evt.detail).catch((err) => {
        this.log.error("failed to maybe reconnect to %p - %e", evt.detail, err);
      });
    });
  }
  async maybeReconnect(peerId) {
    if (!this.started) {
      return;
    }
    const peer = await this.peerStore.get(peerId);
    if (!hasKeepAliveTag(peer)) {
      return;
    }
    if (this.queue.has(peerId)) {
      return;
    }
    this.queue.add(async (options2) => {
      await pRetry(async (attempt) => {
        if (!this.started) {
          return;
        }
        try {
          await this.connectionManager.openConnection(peerId, {
            signal: options2?.signal
          });
        } catch (err) {
          this.log("reconnecting to %p attempt %d of %d failed - %e", peerId, attempt, this.retries, err);
          throw err;
        }
      }, {
        signal: options2?.signal,
        retries: this.retries,
        factor: this.backoffFactor,
        minTimeout: this.retryInterval
      });
    }, {
      peerId
    }).catch(async (err) => {
      this.log.error("failed to reconnect to %p - %e", peerId, err);
      const tags = {};
      [...peer.tags.keys()].forEach((key) => {
        if (key.startsWith(KEEP_ALIVE)) {
          tags[key] = void 0;
        }
      });
      await this.peerStore.merge(peerId, {
        tags
      });
      this.events.safeDispatchEvent("peer:reconnect-failure", {
        detail: peerId
      });
    }).catch(async (err) => {
      this.log.error("failed to remove keep-alive tag from %p - %e", peerId, err);
    });
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    void Promise.resolve().then(async () => {
      const keepAlivePeers = await this.peerStore.all({
        filters: [
          (peer) => hasKeepAliveTag(peer)
        ]
      });
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.connectionManager.openConnection(peer.id).catch((err) => {
          this.log.error("could not open connection to keepalive peer - %e", err);
        });
      }));
    }).catch((err) => {
      this.log.error("error reconnect to peers after start - %e", err);
    });
  }
  stop() {
    this.started = false;
    this.queue.abort();
  }
};
function hasKeepAliveTag(peer) {
  for (const tag of peer.tags.keys()) {
    if (tag.startsWith(KEEP_ALIVE)) {
      return true;
    }
  }
  return false;
}

// ../../node_modules/libp2p/dist/src/connection-manager/index.js
var _a28;
var DEFAULT_DIAL_PRIORITY = 50;
var defaultOptions4 = {
  maxConnections: MAX_CONNECTIONS2,
  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS
};
_a28 = Symbol.toStringTag;
var DefaultConnectionManager = class {
  constructor(components, init = {}) {
    __publicField(this, "started");
    __publicField(this, "connections");
    __publicField(this, "allow");
    __publicField(this, "deny");
    __publicField(this, "maxIncomingPendingConnections");
    __publicField(this, "incomingPendingConnections");
    __publicField(this, "outboundPendingConnections");
    __publicField(this, "maxConnections");
    __publicField(this, "dialQueue");
    __publicField(this, "reconnectQueue");
    __publicField(this, "connectionPruner");
    __publicField(this, "inboundConnectionRateLimiter");
    __publicField(this, "peerStore");
    __publicField(this, "metrics");
    __publicField(this, "events");
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, _a28, "@libp2p/connection-manager");
    this.maxConnections = init.maxConnections ?? defaultOptions4.maxConnections;
    if (this.maxConnections < 1) {
      throw new InvalidParametersError2("Connection Manager maxConnections must be greater than 0");
    }
    this.connections = new PeerMap();
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.metrics = components.metrics;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager");
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.allow = (init.allow ?? []).map((str) => multiaddrToIpNet(multiaddr(str)));
    this.deny = (init.deny ?? []).map((str) => multiaddrToIpNet(multiaddr(str)));
    this.incomingPendingConnections = 0;
    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions4.maxIncomingPendingConnections;
    this.outboundPendingConnections = 0;
    this.inboundConnectionRateLimiter = new RateLimiter({
      points: init.inboundConnectionThreshold ?? defaultOptions4.inboundConnectionThreshold,
      duration: 1
    });
    this.connectionPruner = new ConnectionPruner({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events,
      logger: components.logger
    }, {
      allow: init.allow?.map((a2) => multiaddr(a2))
    });
    this.dialQueue = new DialQueue(components, {
      addressSorter: init.addressSorter,
      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
      maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,
      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
      resolvers: init.resolvers ?? {
        dnsaddr: dnsaddrResolver
      },
      connections: this.connections
    });
    this.reconnectQueue = new ReconnectQueue({
      events: components.events,
      peerStore: components.peerStore,
      logger: components.logger,
      connectionManager: this
    }, {
      retries: init.reconnectRetries,
      retryInterval: init.reconnectRetryInterval,
      backoffFactor: init.reconnectBackoffFactor,
      maxParallelReconnects: init.maxParallelReconnects
    });
  }
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    this.metrics?.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const metric = {
          inbound: 0,
          "inbound pending": this.incomingPendingConnections,
          outbound: 0,
          "outbound pending": this.outboundPendingConnections
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            metric[conn.direction]++;
          }
        }
        return metric;
      }
    });
    this.metrics?.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol2, count] of Object.entries(streams)) {
              allStreams[protocol2] = allStreams[protocol2] ?? [];
              allStreams[protocol2].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol2, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a2, b) => a2 - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol2] = counts[index];
        }
        return metric;
      }
    });
    this.events.addEventListener("connection:open", this.onConnect);
    this.events.addEventListener("connection:close", this.onDisconnect);
    await start(this.dialQueue, this.reconnectQueue, this.connectionPruner);
    this.started = true;
    this.log("started");
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.events.removeEventListener("connection:open", this.onConnect);
    this.events.removeEventListener("connection:close", this.onDisconnect);
    await stop(this.reconnectQueue, this.dialQueue, this.connectionPruner);
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push(Promise.all([
          pEvent(connection, "close", {
            signal: AbortSignal.timeout(500)
          }),
          connection.close({
            signal: AbortSignal.timeout(500)
          })
        ]).catch((err) => {
          connection.abort(err);
        }));
      }
    }
    this.log("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
    this.log("stopped");
  }
  getMaxConnections() {
    return this.maxConnections;
  }
  setMaxConnections(maxConnections) {
    if (this.maxConnections < 1) {
      throw new InvalidParametersError2("Connection Manager maxConnections must be greater than 0");
    }
    let needsPrune = false;
    if (maxConnections < this.maxConnections) {
      needsPrune = true;
    }
    this.maxConnections = maxConnections;
    if (needsPrune) {
      this.connectionPruner.maybePruneConnections();
    }
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err) => {
      this.log.error("could not connect - %e", err);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    if (connection.status !== "open") {
      return;
    }
    const peerId = connection.remotePeer;
    const isNewPeer = !this.connections.has(peerId);
    const storedConns = this.connections.get(peerId) ?? [];
    storedConns.push(connection);
    this.connections.set(peerId, storedConns);
    if (peerId.publicKey != null && peerId.type === "RSA") {
      await this.peerStore.patch(peerId, {
        publicKey: peerId.publicKey
      });
    }
    if (isNewPeer) {
      this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
    }
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(evt) {
    const { detail: connection } = evt;
    const peerId = connection.remotePeer;
    const peerConns = this.connections.get(peerId) ?? [];
    const filteredPeerConns = peerConns.filter((conn) => conn.id !== connection.id);
    this.connections.set(peerId, filteredPeerConns);
    if (filteredPeerConns.length === 0) {
      this.log.trace("peer %p disconnected, removing connection map entry", peerId);
      this.connections.delete(peerId);
      this.events.safeDispatchEvent("peer:disconnect", { detail: peerId });
    }
  }
  getConnections(peerId) {
    if (peerId != null) {
      return this.connections.get(peerId) ?? [];
    }
    let conns = [];
    for (const c2 of this.connections.values()) {
      conns = conns.concat(c2);
    }
    return conns;
  }
  getConnectionsMap() {
    return this.connections;
  }
  async openConnection(peerIdOrMultiaddr, options2 = {}) {
    if (!this.started) {
      throw new NotStartedError2("Not started");
    }
    this.outboundPendingConnections++;
    try {
      options2.signal?.throwIfAborted();
      const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
      if (this.peerId.equals(peerId)) {
        throw new InvalidPeerIdError2("Can not dial self");
      }
      if (peerId != null && options2.force !== true) {
        this.log("dial %p", peerId);
        const existingConnection = findExistingConnection(peerId, this.getConnections(peerId), multiaddrs);
        if (existingConnection != null) {
          this.log("had an existing connection to %p as %a", peerId, existingConnection.remoteAddr);
          options2.onProgress?.(new CustomProgressEvent("dial-queue:already-connected"));
          return existingConnection;
        }
      }
      const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
        ...options2,
        priority: options2.priority ?? DEFAULT_DIAL_PRIORITY
      });
      if (connection.status !== "open") {
        throw new ConnectionClosedError2("Remote closed connection during opening");
      }
      let peerConnections = this.connections.get(connection.remotePeer);
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(connection.remotePeer, peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
        if (options2.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {
          connection.abort(new InvalidMultiaddrError2("Duplicate multiaddr connection"));
          return conn;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      this.outboundPendingConnections--;
    }
  }
  async openStream(peerIdOrMultiaddr, protocol2, options2 = {}) {
    const connection = await this.openConnection(peerIdOrMultiaddr, options2);
    return connection.newStream(protocol2, options2);
  }
  async closeConnections(peerId, options2 = {}) {
    const connections = this.connections.get(peerId) ?? [];
    await Promise.all(connections.map(async (connection) => {
      try {
        await Promise.all([
          pEvent(connection, "close", options2),
          connection.close(options2)
        ]);
      } catch (err) {
        connection.abort(err);
      }
    }));
  }
  acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ipNet) => {
      if (isNetworkAddress(maConn.remoteAddr)) {
        const config = getNetConfig(maConn.remoteAddr);
        return ipNet.contains(config.host);
      }
      return false;
    });
    if (denyConnection) {
      this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ipNet) => {
      if (isNetworkAddress(maConn.remoteAddr)) {
        const config = getNetConfig(maConn.remoteAddr);
        return ipNet.contains(config.host);
      }
      return true;
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
      this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
      return false;
    }
    if (isNetworkAddress(maConn.remoteAddr)) {
      const config = getNetConfig(maConn.remoteAddr);
      try {
        this.inboundConnectionRateLimiter.consume(config.host, 1);
      } catch {
        this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, config.host);
        return false;
      }
    }
    if (this.getConnections().length < this.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
  getDialQueue() {
    const statusMap = {
      queued: "queued",
      running: "active",
      errored: "error",
      complete: "success"
    };
    return this.dialQueue.queue.queue.map((job) => {
      return {
        id: job.id,
        status: statusMap[job.status],
        peerId: job.options.peerId,
        multiaddrs: [...job.options.multiaddrs].map((ma) => multiaddr(ma))
      };
    });
  }
  async isDialable(multiaddr2, options2 = {}) {
    return this.dialQueue.isDialable(multiaddr2, options2);
  }
};

// ../../node_modules/libp2p/dist/src/connection-monitor.js
var _a29, _b23;
var DEFAULT_PING_INTERVAL_MS = 1e4;
var PROTOCOL_VERSION3 = "1.0.0";
var PROTOCOL_NAME2 = "ping";
var PROTOCOL_PREFIX2 = "ipfs";
var PING_LENGTH2 = 32;
var DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true;
_b23 = Symbol.toStringTag, _a29 = serviceCapabilities2;
var ConnectionMonitor = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "log");
    __publicField(this, "heartbeatInterval");
    __publicField(this, "pingIntervalMs");
    __publicField(this, "abortController");
    __publicField(this, "timeout");
    __publicField(this, "abortConnectionOnPingFailure");
    __publicField(this, _b23, "@libp2p/connection-monitor");
    __publicField(this, _a29, [
      "@libp2p/connection-monitor"
    ]);
    this.components = components;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX2}/${PROTOCOL_NAME2}/${PROTOCOL_VERSION3}`;
    this.log = components.logger.forComponent("libp2p:connection-monitor");
    this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS;
    this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE;
    this.timeout = new AdaptiveTimeout({
      ...init.pingTimeout ?? {},
      metrics: components.metrics,
      metricName: "libp2p_connection_monitor_ping_time_milliseconds"
    });
  }
  start() {
    this.abortController = new AbortController();
    setMaxListeners(Infinity, this.abortController.signal);
    this.heartbeatInterval = setInterval(() => {
      this.components.connectionManager.getConnections().forEach((conn) => {
        Promise.resolve().then(async () => {
          let start2 = Date.now();
          try {
            const signal = this.timeout.getTimeoutSignal({
              signal: this.abortController?.signal
            });
            const stream = await conn.newStream(this.protocol, {
              signal,
              runOnLimitedConnection: true
            });
            const bs = byteStream(stream);
            start2 = Date.now();
            await Promise.all([
              bs.write(randomBytes2(PING_LENGTH2), {
                signal
              }),
              bs.read({
                bytes: PING_LENGTH2,
                signal
              })
            ]);
            conn.rtt = Date.now() - start2;
            await stream.close({
              signal
            });
          } catch (err) {
            if (err.name !== "UnsupportedProtocolError") {
              throw err;
            }
            conn.rtt = (Date.now() - start2) / 2;
          }
        }).catch((err) => {
          this.log.error("error during heartbeat - %e", err);
          if (this.abortConnectionOnPingFailure) {
            this.log.error("aborting connection due to ping failure");
            conn.abort(err);
          } else {
            this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag");
          }
        });
      });
    }, this.pingIntervalMs);
  }
  stop() {
    this.abortController?.abort();
    if (this.heartbeatInterval != null) {
      clearInterval(this.heartbeatInterval);
    }
  }
};

// ../../node_modules/libp2p/dist/src/content-routing.js
var _a30;
_a30 = Symbol.toStringTag;
var CompoundContentRouting = class {
  constructor(components, init) {
    __publicField(this, "routers");
    __publicField(this, "started");
    __publicField(this, "components");
    __publicField(this, _a30, "@libp2p/content-routing");
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
    this.findProviders = components.metrics?.traceFunction("libp2p.contentRouting.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      },
      getAttributesFromYieldedValue: (value2, attrs) => {
        return {
          ...attrs,
          providers: [...Array.isArray(attrs.providers) ? attrs.providers : [], value2.id.toString()]
        };
      }
    }) ?? this.findProviders;
    this.provide = components.metrics?.traceFunction("libp2p.contentRouting.provide", this.provide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    }) ?? this.provide;
    this.cancelReprovide = components.metrics?.traceFunction("libp2p.contentRouting.cancelReprovide", this.cancelReprovide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    }) ?? this.cancelReprovide;
    this.put = components.metrics?.traceFunction("libp2p.contentRouting.put", this.put.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString2(key, "base36")
        };
      }
    }) ?? this.put;
    this.get = components.metrics?.traceFunction("libp2p.contentRouting.get", this.get.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString2(key, "base36")
        };
      }
    }) ?? this.get;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    const self2 = this;
    const seen = new PeerSet();
    for await (const peer of src_default(...self2.routers.filter((router) => router.findProviders instanceof Function).map((router) => router.findProviders(key, options2)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.components.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options2);
      }
      if (seen.has(peer.id)) {
        continue;
      }
      seen.add(peer.id);
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.filter((router) => router.provide instanceof Function).map(async (router) => {
      await router.provide(key, options2);
    }));
  }
  async cancelReprovide(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.filter((router) => router.cancelReprovide instanceof Function).map(async (router) => {
      await router.cancelReprovide(key, options2);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value2, options2) {
    if (!this.isStarted()) {
      throw new NotStartedError2();
    }
    await Promise.all(this.routers.filter((router) => router.put instanceof Function).map(async (router) => {
      await router.put(key, value2, options2);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options2) {
    if (!this.isStarted()) {
      throw new NotStartedError2();
    }
    return Promise.any(this.routers.filter((router) => router.get instanceof Function).map(async (router) => {
      return router.get(key, options2);
    }));
  }
};

// ../../node_modules/libp2p/dist/src/peer-routing.js
var _a31;
_a31 = Symbol.toStringTag;
var DefaultPeerRouting = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "routers");
    __publicField(this, _a31, "@libp2p/peer-routing");
    this.log = components.logger.forComponent("libp2p:peer-routing");
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.routers = init.routers ?? [];
    this.findPeer = components.metrics?.traceFunction("libp2p.peerRouting.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([peer], attrs) => {
        return {
          ...attrs,
          peer: peer.toString()
        };
      }
    }) ?? this.findPeer;
    this.getClosestPeers = components.metrics?.traceFunction("libp2p.peerRouting.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key], attrs) => {
        return {
          ...attrs,
          key: toString2(key, "base36")
        };
      },
      getAttributesFromYieldedValue: (value2, attrs) => {
        return {
          ...attrs,
          peers: [...Array.isArray(attrs.peers) ? attrs.peers : [], value2.id.toString()]
        };
      }
    }) ?? this.getClosestPeers;
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options2) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    if (id.toString() === this.peerId.toString()) {
      throw new QueriedForSelfError("Should not try to find self");
    }
    const self2 = this;
    const source = src_default(...this.routers.filter((router) => router.findPeer instanceof Function).map((router) => (async function* () {
      try {
        yield await router.findPeer(id, options2);
      } catch (err) {
        self2.log.error("router failed to find peer - %e", err);
      }
    })()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options2);
      }
      return peer;
    }
    throw new NotFoundError2();
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    const self2 = this;
    const seen = createScalableCuckooFilter(1024);
    for await (const peer of parallel((async function* () {
      const source = src_default(...self2.routers.filter((router) => router.getClosestPeers instanceof Function).map((router) => router.getClosestPeers(key, options2)));
      for await (let peer2 of source) {
        yield async () => {
          if (peer2.multiaddrs.length === 0) {
            try {
              peer2 = await self2.findPeer(peer2.id, {
                ...options2,
                useCache: false
              });
            } catch (err) {
              self2.log.error("could not find peer multiaddrs - %e", err);
              return;
            }
          }
          return peer2;
        };
      }
    })())) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        }, options2);
      }
      if (seen.has(peer.id.toMultihash().bytes)) {
        continue;
      }
      seen.add(peer.id.toMultihash().bytes);
      yield peer;
    }
  }
};

// ../../node_modules/libp2p/dist/src/random-walk.js
var _a32, _b24;
var RandomWalk = class extends (_b24 = TypedEventEmitter, _a32 = Symbol.toStringTag, _b24) {
  constructor(components) {
    super();
    __publicField(this, "peerRouting");
    __publicField(this, "log");
    __publicField(this, "walking");
    __publicField(this, "walkers");
    __publicField(this, "shutdownController");
    __publicField(this, "walkController");
    __publicField(this, "needNext");
    __publicField(this, _a32, "@libp2p/random-walk");
    this.log = components.logger.forComponent("libp2p:random-walk");
    this.peerRouting = components.peerRouting;
    this.walkers = 0;
    this.walking = false;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  start() {
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  stop() {
    this.shutdownController.abort();
  }
  async *walk(options2) {
    if (!this.walking) {
      this.startWalk();
    }
    this.walkers++;
    const signal = anySignal([this.shutdownController.signal, options2?.signal]);
    setMaxListeners(Infinity, signal);
    try {
      while (true) {
        this.needNext?.resolve();
        this.needNext = pDefer();
        const event = await pEvent(this, "walk:peer", {
          signal,
          rejectionEvents: [
            "walk:error"
          ]
        });
        yield event.detail;
      }
    } catch (err) {
      if (err.detail != null) {
        throw err.detail;
      }
      throw err;
    } finally {
      signal.clear();
      this.walkers--;
      if (this.walkers === 0) {
        this.walkController?.abort();
        this.walkController = void 0;
      }
    }
  }
  startWalk() {
    this.walking = true;
    this.walkController = new AbortController();
    setMaxListeners(Infinity, this.walkController.signal);
    const signal = anySignal([this.walkController.signal, this.shutdownController.signal]);
    setMaxListeners(Infinity, signal);
    const start2 = Date.now();
    let found = 0;
    Promise.resolve().then(async () => {
      this.log("start walk");
      while (this.walkers > 0) {
        try {
          const data = randomBytes2(32);
          let s2 = Date.now();
          for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {
            if (signal.aborted) {
              this.log("aborting walk");
            }
            signal.throwIfAborted();
            this.log("found peer %p after %dms for %d walkers", peer.id, Date.now() - s2, this.walkers);
            found++;
            this.safeDispatchEvent("walk:peer", {
              detail: peer
            });
            if (this.walkers === 1 && this.needNext != null) {
              this.log("wait for need next");
              await raceSignal(this.needNext.promise, signal);
            }
            s2 = Date.now();
          }
          this.log("walk iteration for %b and %d walkers finished, found %d peers", data, this.walkers, found);
        } catch (err) {
          this.log.error("random walk errored - %e", err);
          this.safeDispatchEvent("walk:error", {
            detail: err
          });
        }
      }
      this.log("no walkers left, ended walk");
    }).catch((err) => {
      this.log.error("random walk errored - %e", err);
    }).finally(() => {
      this.log("finished walk, found %d peers after %dms", found, Date.now() - start2);
      this.walking = false;
    });
  }
};

// ../../node_modules/libp2p/dist/src/registrar.js
var _a33;
var DEFAULT_MAX_INBOUND_STREAMS2 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS2 = 64;
_a33 = Symbol.toStringTag;
var Registrar = class {
  constructor(components) {
    __publicField(this, "log");
    __publicField(this, "topologies");
    __publicField(this, "handlers");
    __publicField(this, "components");
    __publicField(this, "middleware");
    __publicField(this, _a33, "@libp2p/registrar");
    this.components = components;
    this.log = components.logger.forComponent("libp2p:registrar");
    this.middleware = /* @__PURE__ */ new Map();
    this.topologies = /* @__PURE__ */ new Map();
    components.metrics?.registerMetricGroup("libp2p_registrar_topologies", {
      calculate: () => {
        const output = {};
        for (const [key, value2] of this.topologies) {
          output[key] = value2.size;
        }
        return output;
      }
    });
    this.handlers = trackedMap({
      name: "libp2p_registrar_protocol_handlers",
      metrics: components.metrics
    });
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onPeerUpdate = this._onPeerUpdate.bind(this);
    this._onPeerIdentify = this._onPeerIdentify.bind(this);
    this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.events.addEventListener("peer:update", this._onPeerUpdate);
    this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol2) {
    const handler = this.handlers.get(protocol2);
    if (handler == null) {
      throw new UnhandledProtocolError(`No handler registered for protocol ${protocol2}`);
    }
    return handler;
  }
  getTopologies(protocol2) {
    const topologies = this.topologies.get(protocol2);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(protocol2, handler, opts) {
    if (this.handlers.has(protocol2) && opts?.force !== true) {
      throw new DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol2}`);
    }
    this.handlers.set(protocol2, {
      handler,
      options: {
        maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS2,
        maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS2,
        ...opts
      }
    });
    await this.components.peerStore.merge(this.components.peerId, {
      protocols: [protocol2]
    }, opts);
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(protocols, options2) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol2) => {
      this.handlers.delete(protocol2);
    });
    await this.components.peerStore.patch(this.components.peerId, {
      protocols: this.getProtocols()
    }, options2);
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(protocol2, topology) {
    if (topology == null) {
      throw new InvalidParametersError2("invalid topology");
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol2);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol2, topologies);
    }
    topologies.set(id, topology);
    return id;
  }
  /**
   * Unregister topology
   */
  unregister(id) {
    for (const [protocol2, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol2);
        }
      }
    }
  }
  use(protocol2, middleware) {
    this.middleware.set(protocol2, middleware);
  }
  unuse(protocol2) {
    this.middleware.delete(protocol2);
  }
  getMiddleware(protocol2) {
    return this.middleware.get(protocol2) ?? [];
  }
  /**
   * Remove a disconnected peer from the record
   */
  async _onDisconnect(evt) {
    const remotePeer = evt.detail;
    const options2 = {
      signal: AbortSignal.timeout(5e3)
    };
    try {
      const peer = await this.components.peerStore.get(remotePeer, options2);
      for (const protocol2 of peer.protocols) {
        const topologies = this.topologies.get(protocol2);
        if (topologies == null) {
          continue;
        }
        await Promise.all([...topologies.values()].map(async (topology) => {
          if (topology.filter?.has(remotePeer) === false) {
            return;
          }
          topology.filter?.remove(remotePeer);
          await topology.onDisconnect?.(remotePeer);
        }));
      }
    } catch (err) {
      if (err.name === "NotFoundError") {
        return;
      }
      this.log.error("could not inform topologies of disconnecting peer %p - %e", remotePeer, err);
    }
  }
  /**
   * When a peer is updated, if they have removed supported protocols notify any
   * topologies interested in the removed protocols.
   */
  async _onPeerUpdate(evt) {
    const { peer, previous } = evt.detail;
    const removed = (previous?.protocols ?? []).filter((protocol2) => !peer.protocols.includes(protocol2));
    try {
      for (const protocol2 of removed) {
        const topologies = this.topologies.get(protocol2);
        if (topologies == null) {
          continue;
        }
        await Promise.all([...topologies.values()].map(async (topology) => {
          if (topology.filter?.has(peer.id) === false) {
            return;
          }
          topology.filter?.remove(peer.id);
          await topology.onDisconnect?.(peer.id);
        }));
      }
    } catch (err) {
      this.log.error("could not inform topologies of updated peer %p - %e", peer.id, err);
    }
  }
  /**
   * After identify has completed and we have received the list of supported
   * protocols, notify any topologies interested in those protocols.
   */
  async _onPeerIdentify(evt) {
    const protocols = evt.detail.protocols;
    const connection = evt.detail.connection;
    const peerId = evt.detail.peerId;
    try {
      for (const protocol2 of protocols) {
        const topologies = this.topologies.get(protocol2);
        if (topologies == null) {
          continue;
        }
        await Promise.all([...topologies.values()].map(async (topology) => {
          if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {
            return;
          }
          if (topology.filter?.has(peerId) === true) {
            return;
          }
          topology.filter?.add(peerId);
          await topology.onConnect?.(peerId, connection);
        }));
      }
    } catch (err) {
      this.log.error("could not inform topologies of updated peer after identify %p - %e", peerId, err);
    }
  }
};

// ../../node_modules/libp2p/dist/src/transport-manager.js
var _a34;
_a34 = Symbol.toStringTag;
var DefaultTransportManager = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "transports");
    __publicField(this, "listeners");
    __publicField(this, "faultTolerance");
    __publicField(this, "started");
    __publicField(this, _a34, "@libp2p/transport-manager");
    this.log = components.logger.forComponent("libp2p:transports");
    this.components = components;
    this.started = false;
    this.transports = trackedMap({
      name: "libp2p_transport_manager_transports",
      metrics: this.components.metrics
    });
    this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  /**
   * Adds a `Transport` to the manager
   */
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw new InvalidParametersError2("Transport must have a valid tag");
    }
    if (this.transports.has(tag)) {
      throw new InvalidParametersError2(`There is already a transport with the tag ${tag}`);
    }
    this.log("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      this.log("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    this.log("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(ma, options2) {
    const transport = this.dialTransportForMultiaddr(ma);
    if (transport == null) {
      throw new TransportUnavailableError(`No transport available for address ${String(ma)}`);
    }
    options2?.onProgress?.(new CustomProgressEvent("transport-manager:selected-transport", transport[Symbol.toStringTag]));
    return transport.dial(ma, {
      ...options2,
      upgrader: this.components.upgrader
    });
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Returns all the listener instances
   */
  getListeners() {
    return Array.of(...this.listeners.values()).flat();
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  dialTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.dialFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  listenTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.listenFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(addrs) {
    if (!this.isStarted()) {
      throw new NotStartedError2("Not started");
    }
    if (addrs == null || addrs.length === 0) {
      this.log("no addresses were provided for listening, this node is dial only");
      return;
    }
    const listenStats = {
      errors: /* @__PURE__ */ new Map(),
      ipv4: {
        success: 0,
        attempts: 0
      },
      ipv6: {
        success: 0,
        attempts: 0
      }
    };
    addrs.forEach((ma) => {
      listenStats.errors.set(ma.toString(), new UnsupportedListenAddressError());
    });
    const tasks = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.listenFilter(addrs);
      for (const addr of supportedAddrs) {
        this.log("creating listener for %s on %a", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key) ?? [];
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.components.events.safeDispatchEvent("transport:listening", {
            detail: listener
          });
        });
        listener.addEventListener("close", () => {
          const index = listeners.findIndex((l2) => l2 === listener);
          listeners.splice(index, 1);
          this.components.events.safeDispatchEvent("transport:close", {
            detail: listener
          });
        });
        if (IP4.matches(addr)) {
          listenStats.ipv4.attempts++;
        } else if (IP6.matches(addr)) {
          listenStats.ipv6.attempts++;
        }
        tasks.push(listener.listen(addr).then(() => {
          listenStats.errors.delete(addr.toString());
          if (IP4.matches(addr)) {
            listenStats.ipv4.success++;
          }
          if (IP6.matches(addr)) {
            listenStats.ipv6.success++;
          }
        }, (err) => {
          this.log.error("transport %s could not listen on address %a - %e", key, addr, err);
          listenStats.errors.set(addr.toString(), err);
          throw err;
        }));
      }
    }
    const results = await Promise.allSettled(tasks);
    if (results.length > 0 && results.every((res) => res.status === "fulfilled")) {
      return;
    }
    if (this.ipv6Unsupported(listenStats)) {
      this.log("all IPv4 addresses succeed but all IPv6 failed");
      return;
    }
    if (this.faultTolerance === FaultTolerance.NO_FATAL) {
      this.log("failed to listen on any address but fault tolerance allows this");
      return;
    }
    throw new UnsupportedListenAddressesError(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...listenStats.errors.entries()].map(([addr, err]) => {
      return `
  ${addr}: ${`${getErrorMessage(err)}`.split("\n").join("\n  ")}
`;
    }).join("")}`);
  }
  ipv6Unsupported(listenStats) {
    if (listenStats.ipv4.attempts === 0 || listenStats.ipv6.attempts === 0) {
      return false;
    }
    const allIpv4Succeeded = listenStats.ipv4.attempts === listenStats.ipv4.success;
    const allIpv6Failed = listenStats.ipv6.success === 0;
    return allIpv4Succeeded && allIpv6Failed;
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(key) {
    const listeners = this.listeners.get(key) ?? [];
    this.log.trace("removing transport %s", key);
    const tasks = [];
    this.log.trace("closing listeners for %s", key);
    while (listeners.length > 0) {
      const listener = listeners.pop();
      if (listener == null) {
        continue;
      }
      tasks.push(listener.close());
    }
    await Promise.all(tasks);
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};
function getErrorMessage(err) {
  if (err.stack != null && err.stack.trim() !== "") {
    return err.stack;
  }
  if (err.message != null) {
    return err.message;
  }
  return err.toString();
}

// ../../node_modules/@libp2p/multistream-select/dist/src/constants.js
var PROTOCOL_ID = "/multistream/1.0.0";
var MAX_PROTOCOL_LENGTH = 1024;

// ../../node_modules/@libp2p/multistream-select/dist/src/multistream.js
var NewLine = fromString2("\n");
async function readString(reader, options2) {
  const buf2 = await reader.read(options2);
  const arr = buf2.subarray();
  if (arr.byteLength === 0 || arr[arr.length - 1] !== NewLine[0]) {
    throw new InvalidMessageError2("Missing newline");
  }
  return toString2(arr).trimEnd();
}

// ../../node_modules/@libp2p/multistream-select/dist/src/select.js
async function select(stream, protocols, options2 = {}) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  if (protocols.length === 0) {
    throw new Error("At least one protocol must be specified");
  }
  const log4 = stream.log.newScope("mss:select");
  const lp = lpStream(stream, {
    ...options2,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  for (let i2 = 0; i2 < protocols.length; i2++) {
    const protocol2 = protocols[i2];
    let response;
    if (i2 === 0) {
      log4.trace('write ["%s", "%s"]', PROTOCOL_ID, protocol2);
      const p1 = fromString2(`${PROTOCOL_ID}
`);
      const p2 = fromString2(`${protocol2}
`);
      await lp.writeV([p1, p2], options2);
      log4.trace("reading multistream-select header");
      response = await readString(lp, options2);
      log4.trace('read "%s"', response);
      if (response !== PROTOCOL_ID) {
        log4.error("did not read multistream-select header from response");
        break;
      }
    } else {
      log4.trace('write "%s"', protocol2);
      await lp.write(fromString2(`${protocol2}
`), options2);
    }
    log4.trace("reading protocol response");
    response = await readString(lp, options2);
    log4.trace('read "%s"', response);
    if (response === protocol2) {
      log4.trace('selected "%s" after negotiation', response);
      lp.unwrap();
      return protocol2;
    }
  }
  throw new UnsupportedProtocolError2(`Protocol selection failed - could not negotiate ${protocols}`);
}

// ../../node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/constants.js
var MAX_LENGTH_LENGTH4 = 8;
var MAX_DATA_LENGTH4 = 1024 * 1024 * 4;

// ../../node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/errors.js
var InvalidMessageLengthError5 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError5 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError5 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};
var UnexpectedEOFError5 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// ../../node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable13(thing) {
  return thing[Symbol.asyncIterator] != null;
}

// ../../node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/encode.js
function validateMaxDataLength3(chunk, maxDataLength) {
  if (chunk.byteLength > maxDataLength) {
    throw new InvalidDataLengthError5("Message length too long");
  }
}
var defaultEncoder4 = (length4) => {
  const lengthLength = encodingLength2(length4);
  const lengthBuf = allocUnsafe(lengthLength);
  encode7(length4, lengthBuf);
  defaultEncoder4.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder4.bytes = 0;
function encode12(source, options2) {
  options2 = options2 ?? {};
  const encodeLength2 = options2.lengthEncoder ?? defaultEncoder4;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH4;
  function* maybeYield(chunk) {
    validateMaxDataLength3(chunk, maxDataLength);
    const length4 = encodeLength2(chunk.byteLength);
    if (length4 instanceof Uint8Array) {
      yield length4;
    } else {
      yield* length4;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable13(source)) {
    return (async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    })();
  }
  return (function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  })();
}
encode12.single = (chunk, options2) => {
  options2 = options2 ?? {};
  const encodeLength2 = options2.lengthEncoder ?? defaultEncoder4;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH4;
  validateMaxDataLength3(chunk, maxDataLength);
  return new Uint8ArrayList(encodeLength2(chunk.byteLength), chunk);
};

// ../../node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/decode.js
var ReadMode4;
(function(ReadMode5) {
  ReadMode5[ReadMode5["LENGTH"] = 0] = "LENGTH";
  ReadMode5[ReadMode5["DATA"] = 1] = "DATA";
})(ReadMode4 || (ReadMode4 = {}));
var defaultDecoder4 = (buf2) => {
  const length4 = decode8(buf2);
  defaultDecoder4.bytes = encodingLength2(length4);
  return length4;
};
defaultDecoder4.bytes = 0;
function decode13(source, options2) {
  const buffer2 = new Uint8ArrayList();
  let mode = ReadMode4.LENGTH;
  let dataLength = -1;
  const lengthDecoder = options2?.lengthDecoder ?? defaultDecoder4;
  const maxLengthLength = options2?.maxLengthLength ?? MAX_LENGTH_LENGTH4;
  const maxDataLength = options2?.maxDataLength ?? MAX_DATA_LENGTH4;
  function* maybeYield() {
    while (buffer2.byteLength > 0) {
      if (mode === ReadMode4.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer2);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError5("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError5("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer2.consume(dataLengthLength);
          if (options2?.onLength != null) {
            options2.onLength(dataLength);
          }
          mode = ReadMode4.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer2.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError5("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode4.DATA) {
        if (buffer2.byteLength < dataLength) {
          break;
        }
        const data = buffer2.sublist(0, dataLength);
        buffer2.consume(dataLength);
        if (options2?.onData != null) {
          options2.onData(data);
        }
        yield data;
        mode = ReadMode4.LENGTH;
      }
    }
  }
  if (isAsyncIterable13(source)) {
    return (async function* () {
      for await (const buf2 of source) {
        buffer2.append(buf2);
        yield* maybeYield();
      }
      if (buffer2.byteLength > 0) {
        throw new UnexpectedEOFError5("Unexpected end of input");
      }
    })();
  }
  return (function* () {
    for (const buf2 of source) {
      buffer2.append(buf2);
      yield* maybeYield();
    }
    if (buffer2.byteLength > 0) {
      throw new UnexpectedEOFError5("Unexpected end of input");
    }
  })();
}
decode13.fromReader = (reader, options2) => {
  let byteLength = 1;
  const varByteSource = (async function* () {
    while (true) {
      try {
        const { done, value: value2 } = await reader.next(byteLength);
        if (done === true) {
          return;
        }
        if (value2 != null) {
          yield value2;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  })();
  const onLength = (l2) => {
    byteLength = l2;
  };
  return decode13(varByteSource, {
    ...options2 ?? {},
    onLength
  });
};

// ../../node_modules/@libp2p/multistream-select/dist/src/handle.js
async function handle(stream, protocols, options2 = {}) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  const log4 = stream.log.newScope("mss:handle");
  const lp = lpStream(stream, {
    ...options2,
    maxDataLength: MAX_PROTOCOL_LENGTH,
    maxLengthLength: 2
    // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
  });
  while (true) {
    log4.trace("reading incoming string");
    const protocol2 = await readString(lp, options2);
    log4.trace('read "%s"', protocol2);
    if (protocol2 === PROTOCOL_ID) {
      log4.trace('respond with "%s" for "%s"', PROTOCOL_ID, protocol2);
      await lp.write(fromString2(`${PROTOCOL_ID}
`), options2);
      log4.trace('responded with "%s" for "%s"', PROTOCOL_ID, protocol2);
      continue;
    }
    if (protocols.includes(protocol2)) {
      log4.trace('respond with "%s" for "%s"', protocol2, protocol2);
      await lp.write(fromString2(`${protocol2}
`), options2);
      log4.trace('responded with "%s" for "%s"', protocol2, protocol2);
      lp.unwrap();
      return protocol2;
    }
    if (protocol2 === "ls") {
      const protos = new Uint8ArrayList(...protocols.map((p2) => encode12.single(fromString2(`${p2}
`))), fromString2("\n"));
      log4.trace('respond with "%s" for %s', protocols, protocol2);
      await lp.write(protos, options2);
      log4.trace('responded with "%s" for %s', protocols, protocol2);
      continue;
    }
    log4.trace('respond with "na" for "%s"', protocol2);
    await lp.write(fromString2("na\n"), options2);
    log4('responded with "na" for "%s"', protocol2);
  }
}

// ../../node_modules/libp2p/dist/src/connection.js
var _a35, _b25, _c14;
var Connection = class extends (_c14 = TypedEventEmitter, _b25 = Symbol.toStringTag, _a35 = connectionSymbol, _c14) {
  constructor(components, init) {
    super();
    __publicField(this, "id");
    __publicField(this, "remoteAddr");
    __publicField(this, "remotePeer");
    __publicField(this, "direction");
    __publicField(this, "timeline");
    __publicField(this, "direct");
    __publicField(this, "multiplexer");
    __publicField(this, "encryption");
    __publicField(this, "limits");
    __publicField(this, "log");
    __publicField(this, "maConn");
    __publicField(this, "muxer");
    __publicField(this, "components");
    __publicField(this, "outboundStreamProtocolNegotiationTimeout");
    __publicField(this, "inboundStreamProtocolNegotiationTimeout");
    __publicField(this, "closeTimeout");
    __publicField(this, _b25, "Connection");
    __publicField(this, _a35, true);
    /**
     * Create a new stream over this connection
     */
    __publicField(this, "newStream", async (protocols, options2 = {}) => {
      if (this.muxer == null) {
        throw new MuxerUnavailableError("Connection is not multiplexed");
      }
      if (this.muxer.status !== "open") {
        throw new ConnectionClosedError2(`The connection muxer is "${this.muxer.status}" and not "open"`);
      }
      if (this.maConn.status !== "open") {
        throw new ConnectionClosedError2(`The connection is "${this.status}" and not "open"`);
      }
      if (this.limits != null && options2?.runOnLimitedConnection !== true) {
        throw new LimitedConnectionError2("Cannot open protocol stream on limited connection");
      }
      if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }
      this.log.trace("starting new stream for protocols %s", protocols);
      const muxedStream = await this.muxer.createStream({
        ...options2,
        // most underlying transports only support negotiating a single protocol
        // so only pass the early protocol if a single protocol has been requested
        // otherwise fall back to mss
        protocol: protocols.length === 1 ? protocols[0] : void 0
      });
      this.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols);
      try {
        if (options2.signal == null) {
          muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
          const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);
          setMaxListeners(Infinity, signal);
          options2 = {
            ...options2,
            signal
          };
        }
        if (muxedStream.protocol === "") {
          muxedStream.log.trace("selecting protocol from protocols %s", protocols);
          muxedStream.protocol = await select(muxedStream, protocols, options2);
          muxedStream.log("negotiated protocol %s", muxedStream.protocol);
        } else {
          muxedStream.log("pre-negotiated protocol %s", muxedStream.protocol);
        }
        const outgoingLimit = findOutgoingStreamLimit(muxedStream.protocol, this.components.registrar, options2);
        const streamCount = countStreams(muxedStream.protocol, "outbound", this);
        if (streamCount > outgoingLimit) {
          const err = new TooManyOutboundProtocolStreamsError2(`Too many outbound protocol streams for protocol "${muxedStream.protocol}" - ${streamCount}/${outgoingLimit}`);
          muxedStream.abort(err);
          throw err;
        }
        await this.components.peerStore.merge(this.remotePeer, {
          protocols: [muxedStream.protocol]
        });
        this.components.metrics?.trackProtocolStream(muxedStream);
        const middleware = this.components.registrar.getMiddleware(muxedStream.protocol);
        return await this.runMiddlewareChain(muxedStream, this, middleware);
      } catch (err) {
        if (muxedStream.status === "open") {
          muxedStream.abort(err);
        } else {
          this.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e", this.direction === "inbound" ? "from" : "to", this.remoteAddr, protocols, err);
        }
        throw err;
      }
    });
    this.components = components;
    this.id = init.id;
    this.remoteAddr = init.maConn.remoteAddr;
    this.remotePeer = init.remotePeer;
    this.direction = init.direction ?? "outbound";
    this.timeline = init.maConn.timeline;
    this.encryption = init.cryptoProtocol;
    this.limits = init.limits;
    this.maConn = init.maConn;
    this.log = init.maConn.log;
    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.closeTimeout = init.closeTimeout ?? CONNECTION_CLOSE_TIMEOUT;
    this.direct = isDirect(init.maConn.remoteAddr);
    this.onIncomingStream = this.onIncomingStream.bind(this);
    if (this.remoteAddr.getComponents().find((component) => component.code === CODE_P2P2) == null) {
      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
    }
    if (init.muxer != null) {
      this.multiplexer = init.muxer.protocol;
      this.muxer = init.muxer;
      this.muxer.addEventListener("stream", this.onIncomingStream);
    }
    this.maConn.addEventListener("close", (evt) => {
      this.dispatchEvent(new StreamCloseEvent(evt.local, evt.error));
    });
  }
  get streams() {
    return this.muxer?.streams ?? [];
  }
  get status() {
    return this.maConn.status;
  }
  async onIncomingStream(evt) {
    const muxedStream = evt.detail;
    const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);
    setMaxListeners(Infinity, signal);
    muxedStream.log("start protocol negotiation, timing out after %dms", this.inboundStreamProtocolNegotiationTimeout);
    try {
      if (muxedStream.protocol === "") {
        const protocols = this.components.registrar.getProtocols();
        muxedStream.log.trace("selecting protocol from protocols %s", protocols);
        muxedStream.protocol = await handle(muxedStream, protocols, {
          signal
        });
        muxedStream.log("negotiated protocol %s", muxedStream.protocol);
      } else {
        muxedStream.log("pre-negotiated protocol %s", muxedStream.protocol);
      }
      const incomingLimit = findIncomingStreamLimit(muxedStream.protocol, this.components.registrar);
      const streamCount = countStreams(muxedStream.protocol, "inbound", this);
      if (streamCount > incomingLimit) {
        throw new TooManyInboundProtocolStreamsError2(`Too many inbound protocol streams for protocol "${muxedStream.protocol}" - limit ${incomingLimit}`);
      }
      await this.components.peerStore.merge(this.remotePeer, {
        protocols: [muxedStream.protocol]
      }, {
        signal
      });
      this.components.metrics?.trackProtocolStream(muxedStream);
      const { handler, options: options2 } = this.components.registrar.getHandler(muxedStream.protocol);
      if (this.limits != null && options2.runOnLimitedConnection !== true) {
        throw new LimitedConnectionError2("Cannot open protocol stream on limited connection");
      }
      const middleware = this.components.registrar.getMiddleware(muxedStream.protocol);
      middleware.push(async (stream, connection, next) => {
        await handler(stream, connection);
        next(stream, connection);
      });
      await this.runMiddlewareChain(muxedStream, this, middleware);
    } catch (err) {
      muxedStream.abort(err);
    }
  }
  async runMiddlewareChain(stream, connection, middleware) {
    for (let i2 = 0; i2 < middleware.length; i2++) {
      const mw = middleware[i2];
      stream.log.trace("running middleware", i2, mw);
      await new Promise((resolve, reject) => {
        try {
          const result = mw(stream, connection, (s2, c2) => {
            stream = s2;
            connection = c2;
            resolve();
          });
          if (result instanceof Promise) {
            result.catch(reject);
          }
        } catch (err) {
          reject(err);
        }
      });
      stream.log.trace("ran middleware", i2, mw);
    }
    return stream;
  }
  /**
   * Close the connection
   */
  async close(options2 = {}) {
    this.log("closing connection to %a", this.remoteAddr);
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(this.closeTimeout);
      setMaxListeners(Infinity, signal);
      options2 = {
        ...options2,
        signal
      };
    }
    await this.muxer?.close(options2);
    await this.maConn.close(options2);
  }
  abort(err) {
    this.muxer?.abort(err);
    this.maConn.abort(err);
  }
};
function createConnection(components, init) {
  return new Connection(components, init);
}
function findIncomingStreamLimit(protocol2, registrar) {
  try {
    const { options: options2 } = registrar.getHandler(protocol2);
    if (options2.maxInboundStreams != null) {
      return options2.maxInboundStreams;
    }
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS2;
}
function findOutgoingStreamLimit(protocol2, registrar, options2 = {}) {
  try {
    const { options: options3 } = registrar.getHandler(protocol2);
    if (options3.maxOutboundStreams != null) {
      return options3.maxOutboundStreams;
    }
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return options2.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS2;
}
function countStreams(protocol2, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.direction === direction && stream.protocol === protocol2) {
      streamCount++;
    }
  });
  return streamCount;
}

// ../../node_modules/libp2p/dist/src/upgrader.js
var _a36;
_a36 = Symbol.toStringTag;
var Upgrader = class {
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "connectionEncrypters");
    __publicField(this, "streamMuxers");
    __publicField(this, "inboundUpgradeTimeout");
    __publicField(this, "inboundStreamProtocolNegotiationTimeout");
    __publicField(this, "outboundStreamProtocolNegotiationTimeout");
    __publicField(this, "events");
    __publicField(this, "metrics");
    __publicField(this, "connectionCloseTimeout");
    __publicField(this, _a36, "@libp2p/upgrader");
    this.components = components;
    this.connectionEncrypters = trackedMap({
      name: "libp2p_upgrader_connection_encrypters",
      metrics: this.components.metrics
    });
    init.connectionEncrypters.forEach((encrypter) => {
      this.connectionEncrypters.set(encrypter.protocol, encrypter);
    });
    this.streamMuxers = trackedMap({
      name: "libp2p_upgrader_stream_multiplexers",
      metrics: this.components.metrics
    });
    init.streamMuxers.forEach((muxer) => {
      this.streamMuxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.connectionCloseTimeout = init.connectionCloseTimeout ?? CONNECTION_CLOSE_TIMEOUT;
    this.events = components.events;
    this.metrics = {
      dials: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_total"),
      errors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),
      inboundErrors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),
      outboundErrors: components.metrics?.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")
    };
  }
  async shouldBlockConnection(method, ...args) {
    const denyOperation = this.components.connectionGater[method];
    if (denyOperation == null) {
      return;
    }
    const result = await denyOperation.apply(this.components.connectionGater, args);
    if (result === true) {
      throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`);
    }
  }
  createInboundAbortSignal(signal) {
    const output = anySignal([
      AbortSignal.timeout(this.inboundUpgradeTimeout),
      signal
    ]);
    setMaxListeners(Infinity, output);
    return output;
  }
  async upgradeInbound(maConn, opts) {
    let accepted = false;
    const signal = this.createInboundAbortSignal(opts.signal);
    try {
      this.metrics.dials?.increment({
        inbound: true
      });
      accepted = this.components.connectionManager.acceptIncomingConnection(maConn);
      if (!accepted) {
        throw new ConnectionDeniedError("Connection denied");
      }
      await raceSignal(this.shouldBlockConnection("denyInboundConnection", maConn), signal);
      await this._performUpgrade(maConn, "inbound", {
        ...opts,
        signal
      });
    } catch (err) {
      this.metrics.errors?.increment({
        inbound: true
      });
      this.metrics.inboundErrors?.increment({
        [err.name ?? "Error"]: true
      });
      throw err;
    } finally {
      signal.clear();
      if (accepted) {
        this.components.connectionManager.afterUpgradeInbound();
      }
    }
  }
  async upgradeOutbound(maConn, opts) {
    try {
      this.metrics.dials?.increment({
        outbound: true
      });
      const idStr = maConn.remoteAddr.getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value;
      let remotePeerId;
      if (idStr != null) {
        remotePeerId = peerIdFromString3(idStr);
        await raceSignal(this.shouldBlockConnection("denyOutboundConnection", remotePeerId, maConn), opts.signal);
      }
      let direction = "outbound";
      if (opts.initiator === false) {
        direction = "inbound";
      }
      return await this._performUpgrade(maConn, direction, opts);
    } catch (err) {
      this.metrics.errors?.increment({
        outbound: true
      });
      this.metrics.outboundErrors?.increment({
        [err.name ?? "Error"]: true
      });
      throw err;
    }
  }
  async _performUpgrade(maConn, direction, opts) {
    let stream = maConn;
    let remotePeer;
    let muxerFactory;
    let muxer;
    let cryptoProtocol;
    const id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    maConn.log = maConn.log.newScope(`${direction}:${id}`);
    this.components.metrics?.trackMultiaddrConnection(maConn);
    maConn.log.trace("starting the %s connection upgrade", direction);
    if (opts?.skipProtection !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        maConn.log("protecting the %s connection", direction);
        stream = await protector.protect(stream, opts);
      }
    }
    try {
      if (isEncryptionSkipped(opts)) {
        if (opts.remotePeer == null) {
          throw new InvalidMultiaddrError2(`${direction} connection that skipped encryption must have a peer id`);
        }
        cryptoProtocol = "native";
        remotePeer = opts.remotePeer;
      } else {
        const peerIdString = maConn.remoteAddr.getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value;
        let remotePeerFromMultiaddr;
        if (peerIdString != null) {
          remotePeerFromMultiaddr = peerIdFromString3(peerIdString);
        }
        opts?.onProgress?.(new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));
        ({
          connection: stream,
          remotePeer,
          protocol: cryptoProtocol,
          streamMuxer: muxerFactory
        } = await (direction === "inbound" ? this._encryptInbound(stream, {
          ...opts,
          remotePeer: remotePeerFromMultiaddr
        }) : this._encryptOutbound(stream, {
          ...opts,
          remotePeer: remotePeerFromMultiaddr
        })));
      }
      if (remotePeer.equals(this.components.peerId)) {
        const err = new InvalidPeerIdError2("Can not dial self");
        maConn.abort(err);
        throw err;
      }
      await this.shouldBlockConnection(direction === "inbound" ? "denyInboundEncryptedConnection" : "denyOutboundEncryptedConnection", remotePeer, maConn);
      if (opts?.muxerFactory != null) {
        muxerFactory = opts.muxerFactory;
      } else if (muxerFactory == null && this.streamMuxers.size > 0) {
        opts?.onProgress?.(new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`));
        muxerFactory = await (direction === "inbound" ? this._multiplexInbound(stream, this.streamMuxers, opts) : this._multiplexOutbound(stream, this.streamMuxers, opts));
      }
    } catch (err) {
      maConn.log.error("failed to upgrade %s connection %s %a - %e", direction, direction === "inbound" ? "from" : "to", maConn.remoteAddr, err);
      throw err;
    }
    if (muxerFactory != null) {
      maConn.log("create muxer %s", muxerFactory.protocol);
      muxer = muxerFactory.createStreamMuxer(stream);
    }
    await this.shouldBlockConnection(direction === "inbound" ? "denyInboundUpgradedConnection" : "denyOutboundUpgradedConnection", remotePeer, maConn);
    const conn = this._createConnection({
      id,
      cryptoProtocol,
      direction,
      maConn,
      stream,
      muxer,
      remotePeer,
      limits: opts?.limits,
      closeTimeout: this.connectionCloseTimeout
    });
    conn.log("successfully upgraded connection");
    return conn;
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(opts) {
    const connection = createConnection(this.components, {
      ...opts,
      outboundStreamProtocolNegotiationTimeout: this.outboundStreamProtocolNegotiationTimeout,
      inboundStreamProtocolNegotiationTimeout: this.inboundStreamProtocolNegotiationTimeout
    });
    connection.addEventListener("close", () => {
      this.events.safeDispatchEvent("connection:close", {
        detail: connection
      });
    });
    this.events.safeDispatchEvent("connection:open", {
      detail: connection
    });
    return connection;
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(connection, options2) {
    const protocols = Array.from(this.connectionEncrypters.keys());
    try {
      const protocol2 = await handle(connection, protocols, options2);
      const encrypter = this.connectionEncrypters.get(protocol2);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol2}`);
      }
      connection.log("encrypting inbound connection using %s", protocol2);
      return {
        ...await encrypter.secureInbound(connection, options2),
        protocol: protocol2
      };
    } catch (err) {
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(connection, options2) {
    const protocols = Array.from(this.connectionEncrypters.keys());
    try {
      connection.log.trace("selecting encrypter from %s", protocols);
      const protocol2 = await select(connection, protocols, options2);
      const encrypter = this.connectionEncrypters.get(protocol2);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol2}`);
      }
      connection.log("encrypting outbound connection using %s", protocol2);
      return {
        ...await encrypter.secureOutbound(connection, options2),
        protocol: protocol2
      };
    } catch (err) {
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(maConn, muxers, options2) {
    const protocols = Array.from(muxers.keys());
    maConn.log("outbound selecting muxer %s", protocols);
    try {
      maConn.log.trace("selecting stream muxer from %s", protocols);
      const protocol2 = await select(maConn, protocols, options2);
      const muxerFactory = muxers.get(protocol2);
      if (muxerFactory == null) {
        throw new MuxerUnavailableError(`No muxer configured for protocol "${protocol2}"`);
      }
      maConn.log("selected %s as muxer protocol", protocol2);
      return muxerFactory;
    } catch (err) {
      maConn.log.error("error multiplexing outbound connection - %e", err);
      throw new MuxerUnavailableError(String(err));
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(maConn, muxers, options2) {
    const protocols = Array.from(muxers.keys());
    maConn.log("inbound handling muxers %s", protocols);
    try {
      maConn.log.trace("selecting stream muxer from %s", protocols);
      const protocol2 = await handle(maConn, protocols, options2);
      const muxerFactory = muxers.get(protocol2);
      if (muxerFactory == null) {
        throw new MuxerUnavailableError(`No muxer configured for protocol "${protocol2}"`);
      }
      maConn.log("selected %s as muxer protocol", protocol2);
      return muxerFactory;
    } catch (err) {
      maConn.log.error("error multiplexing inbound connection - %e", err);
      throw err;
    }
  }
  getConnectionEncrypters() {
    return this.connectionEncrypters;
  }
  getStreamMuxers() {
    return this.streamMuxers;
  }
};
function isEncryptionSkipped(opts) {
  return opts.skipEncryption === true;
}

// ../../node_modules/libp2p/dist/src/version.js
var version = "3.1.3";
var name4 = "js-libp2p";

// ../../node_modules/libp2p/dist/src/user-agent.browser.js
function userAgent(name5, version2) {
  return `${name5 ?? name4}/${version2 ?? version} browser/${window.navigator.userAgent}`;
}

// ../../node_modules/libp2p/dist/src/libp2p.js
var _Libp2p_instances, onDiscoveryPeer_fn;
var Libp2p = class extends TypedEventEmitter {
  // eslint-disable-next-line complexity
  constructor(init) {
    super();
    __privateAdd(this, _Libp2p_instances);
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "contentRouting");
    __publicField(this, "peerRouting");
    __publicField(this, "metrics");
    __publicField(this, "services");
    __publicField(this, "logger");
    __publicField(this, "status");
    __publicField(this, "components");
    __publicField(this, "log");
    this.status = "stopped";
    const events = new TypedEventEmitter();
    const originalDispatch = events.dispatchEvent.bind(events);
    events.dispatchEvent = (evt) => {
      const internalResult = originalDispatch(evt);
      const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
      return internalResult || externalResult;
    };
    setMaxListeners(Infinity, events);
    this.peerId = init.peerId;
    this.logger = init.logger ?? defaultLogger();
    this.log = this.logger.forComponent("libp2p");
    this.services = {};
    const nodeInfoName = init.nodeInfo?.name ?? name4;
    const nodeInfoVersion = init.nodeInfo?.version ?? version;
    const components = this.components = defaultComponents({
      peerId: init.peerId,
      privateKey: init.privateKey,
      nodeInfo: {
        name: nodeInfoName,
        version: nodeInfoVersion,
        userAgent: init.nodeInfo?.userAgent ?? userAgent(nodeInfoName, nodeInfoVersion)
      },
      logger: this.logger,
      events,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: connectionGater(init.connectionGater),
      dns: init.dns
    });
    if (init.metrics != null) {
      this.metrics = this.configureComponent("metrics", init.metrics(this.components));
    }
    this.peerStore = this.configureComponent("peerStore", persistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init.peerStore
    }));
    components.events.addEventListener("peer:update", (evt) => {
      if (evt.detail.previous == null) {
        const peerInfo = {
          id: evt.detail.peer.id,
          multiaddrs: evt.detail.peer.addresses.map((a2) => a2.multiaddr)
        };
        components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
      }
    });
    if (init.connectionProtector != null) {
      this.configureComponent("connectionProtector", init.connectionProtector(components));
    }
    this.components.upgrader = new Upgrader(this.components, {
      connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
      streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
      inboundUpgradeTimeout: init.connectionManager?.inboundUpgradeTimeout,
      inboundStreamProtocolNegotiationTimeout: init.connectionManager?.inboundStreamProtocolNegotiationTimeout,
      outboundStreamProtocolNegotiationTimeout: init.connectionManager?.outboundStreamProtocolNegotiationTimeout,
      connectionCloseTimeout: init.connectionManager?.connectionCloseTimeout
    });
    this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
    this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
    if (init.connectionMonitor?.enabled !== false) {
      this.configureComponent("connectionMonitor", new ConnectionMonitor(this.components, init.connectionMonitor));
    }
    this.configureComponent("registrar", new Registrar(this.components));
    this.configureComponent("addressManager", new AddressManager(this.components, init.addresses));
    const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
    this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
      routers: peerRouters
    }));
    const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
    this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    this.configureComponent("randomWalk", new RandomWalk(this.components));
    (init.peerDiscovery ?? []).forEach((fn, index) => {
      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
      service.addEventListener("peer", (evt) => {
        __privateMethod(this, _Libp2p_instances, onDiscoveryPeer_fn).call(this, evt);
      });
    });
    init.transports?.forEach((fn, index) => {
      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
    });
    if (init.services != null) {
      for (const name5 of Object.keys(init.services)) {
        const createService = init.services[name5];
        const service = createService(this.components);
        if (service == null) {
          this.log.error("service factory %s returned null or undefined instance", name5);
          continue;
        }
        this.services[name5] = service;
        this.configureComponent(name5, service);
        if (service[contentRoutingSymbol] != null) {
          this.log("registering service %s for content routing", name5);
          contentRouters.push(service[contentRoutingSymbol]);
        }
        if (service[peerRoutingSymbol] != null) {
          this.log("registering service %s for peer routing", name5);
          peerRouters.push(service[peerRoutingSymbol]);
        }
        if (service[peerDiscoverySymbol] != null) {
          this.log("registering service %s for peer discovery", name5);
          service[peerDiscoverySymbol].addEventListener?.("peer", (evt) => {
            __privateMethod(this, _Libp2p_instances, onDiscoveryPeer_fn).call(this, evt);
          });
        }
      }
    }
    checkServiceDependencies(components);
  }
  configureComponent(name5, component) {
    if (component == null) {
      this.log.error("component %s was null or undefined", name5);
    }
    this.components[name5] = component;
    return component;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    if (this.status !== "stopped") {
      return;
    }
    this.status = "starting";
    this.log("libp2p is starting");
    try {
      await this.components.beforeStart?.();
      await this.components.start();
      await this.components.afterStart?.();
      this.status = "started";
      this.safeDispatchEvent("start", { detail: this });
      this.log("libp2p has started with peer id %p", this.peerId);
    } catch (err) {
      this.log.error("an error occurred starting libp2p - %e", err);
      this.status = "started";
      await this.stop();
      throw err;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    if (this.status !== "started") {
      return;
    }
    this.log("libp2p is stopping");
    this.status = "stopping";
    await this.components.beforeStop?.();
    await this.components.stop();
    await this.components.afterStop?.();
    this.status = "stopped";
    this.safeDispatchEvent("stop", { detail: this });
    this.log("libp2p has stopped");
  }
  getConnections(peerId) {
    return this.components.connectionManager.getConnections(peerId);
  }
  getDialQueue() {
    return this.components.connectionManager.getDialQueue();
  }
  getPeers() {
    const peerSet2 = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet2.add(conn.remotePeer);
    }
    return Array.from(peerSet2);
  }
  async dial(peer, options2 = {}) {
    return this.components.connectionManager.openConnection(peer, {
      // ensure any userland dials take top priority in the queue
      priority: 75,
      ...options2
    });
  }
  async dialProtocol(peer, protocols, options2 = {}) {
    if (protocols == null) {
      throw new InvalidParametersError2("no protocols were provided to open a stream");
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw new InvalidParametersError2("no protocols were provided to open a stream");
    }
    return this.components.connectionManager.openStream(peer, protocols, options2);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(peer, options2 = {}) {
    if (isMultiaddr(peer)) {
      peer = peerIdFromString3(peer.getComponents().findLast((c2) => c2.code === CODE_P2P2)?.value ?? "");
    }
    await this.components.connectionManager.closeConnections(peer, options2);
  }
  async getPublicKey(peer, options2 = {}) {
    this.log("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    try {
      const peerInfo = await this.peerStore.get(peer, options2);
      if (peerInfo.id.publicKey != null) {
        return peerInfo.id.publicKey;
      }
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    const peerKey = concat([
      fromString2("/pk/"),
      peer.toMultihash().bytes
    ]);
    const bytes = await this.contentRouting.get(peerKey, options2);
    const publicKey2 = publicKeyFromProtobuf(bytes);
    await this.peerStore.patch(peer, {
      publicKey: publicKey2
    }, options2);
    return publicKey2;
  }
  async handle(protocols, handler, options2) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol2) => {
      await this.components.registrar.handle(protocol2, handler, options2);
    }));
  }
  async unhandle(protocols, options2) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol2) => {
      await this.components.registrar.unhandle(protocol2, options2);
    }));
  }
  async register(protocol2, topology, options2) {
    return this.components.registrar.register(protocol2, topology, options2);
  }
  unregister(id) {
    this.components.registrar.unregister(id);
  }
  use(protocol2, middleware) {
    this.components.registrar.use(protocol2, Array.isArray(middleware) ? middleware : [middleware]);
  }
  unuse(protocol2) {
    this.components.registrar.unuse(protocol2);
  }
  async isDialable(multiaddr2, options2 = {}) {
    return this.components.connectionManager.isDialable(multiaddr2, options2);
  }
};
_Libp2p_instances = new WeakSet();
/**
 * Called whenever peer discovery services emit `peer` events and adds peers
 * to the peer store.
 */
onDiscoveryPeer_fn = function(evt) {
  const { detail: peer } = evt;
  if (peer.id.toString() === this.peerId.toString()) {
    this.log.error("peer discovery mechanism discovered self");
    return;
  }
  void this.components.peerStore.merge(peer.id, {
    multiaddrs: peer.multiaddrs
  }).catch((err) => {
    this.log.error("could not update multiaddrs of discovered peer - %e", err);
  });
};

// ../../node_modules/libp2p/dist/src/index.js
async function createLibp2p(options2 = {}) {
  options2.privateKey ?? (options2.privateKey = await generateKeyPair("Ed25519"));
  const node = new Libp2p({
    ...await validateConfig(options2),
    peerId: peerIdFromPrivateKey3(options2.privateKey)
  });
  if (options2.start !== false) {
    await node.start();
  }
  return node;
}
var LIBP2P_METHODS = ["dial", "dialProtocol", "hangUp", "handle", "unhandle", "getMultiaddrs", "getProtocols"];
function isLibp2p(obj) {
  if (obj == null) {
    return false;
  }
  if (obj instanceof Libp2p) {
    return true;
  }
  return LIBP2P_METHODS.every((m2) => typeof obj[m2] === "function");
}

// dist/vendor/index.js
__reExport(index_exports, __toESM(require_Reflect(), 1));
var VENDOR_INFO = {
  generatedAt: "2026-01-18T16:47:32.590Z",
  dependencies: ["@chainsafe/libp2p-gossipsub", "@chainsafe/libp2p-noise", "@chainsafe/libp2p-yamux", "@libp2p/bootstrap", "@libp2p/circuit-relay-v2", "@libp2p/crypto", "@libp2p/dcutr", "@libp2p/floodsub", "@libp2p/http", "@libp2p/http-fetch", "@libp2p/http-ping", "@libp2p/identify", "@libp2p/interface", "@libp2p/interface-transport", "@libp2p/kad-dht", "@libp2p/logger", "@libp2p/peer-id", "@libp2p/peer-store", "@libp2p/ping", "@libp2p/pubsub-peer-discovery", "@libp2p/utils", "@libp2p/webrtc", "@libp2p/websockets", "@libp2p/webtransport", "@multiformats/multiaddr", "@multiformats/multiaddr-matcher", "blockstore-core", "datastore-core", "datastore-idb", "libp2p", "protons-runtime", "reflect-metadata"],
  totalDependencies: 32,
  buildType: "vendor-bundle",
  platform: "browser"
};
function hasDependency(name5) {
  return VENDOR_INFO.dependencies.includes(name5);
}
var VENDOR_STATUS = {
  initialized: true,
  timestamp: Date.now(),
  dependenciesLoaded: 32
};
console.log(" Vendor index loaded with 32 dependencies:", VENDOR_INFO.dependencies);
var index_default = {
  VENDOR_INFO,
  VENDOR_STATUS,
  hasDependency
};
export {
  AbortError2 as AbortError,
  AbstractMessageStream,
  AbstractMultiaddrConnection,
  AbstractStream,
  AbstractStreamMuxer,
  AdaptiveTimeout,
  AlreadyStartedError2 as AlreadyStartedError,
  BaseBlockstore,
  BaseDatastore,
  BlackHoleBlockstore,
  BloomFilter,
  CODE_CERTHASH2 as CODE_CERTHASH,
  CODE_DCCP2 as CODE_DCCP,
  CODE_DNS2 as CODE_DNS,
  CODE_DNS42 as CODE_DNS4,
  CODE_DNS62 as CODE_DNS6,
  CODE_DNSADDR2 as CODE_DNSADDR,
  CODE_GARLIC322 as CODE_GARLIC32,
  CODE_GARLIC642 as CODE_GARLIC64,
  CODE_HTTP2 as CODE_HTTP,
  CODE_HTTPS2 as CODE_HTTPS,
  CODE_HTTP_PATH2 as CODE_HTTP_PATH,
  CODE_IP42 as CODE_IP4,
  CODE_IP62 as CODE_IP6,
  CODE_IP6ZONE2 as CODE_IP6ZONE,
  CODE_IPCIDR2 as CODE_IPCIDR,
  CODE_MEMORY2 as CODE_MEMORY,
  CODE_NOISE2 as CODE_NOISE,
  CODE_ONION2 as CODE_ONION,
  CODE_ONION32 as CODE_ONION3,
  CODE_P2P2 as CODE_P2P,
  CODE_P2P_CIRCUIT2 as CODE_P2P_CIRCUIT,
  CODE_P2P_STARDUST2 as CODE_P2P_STARDUST,
  CODE_P2P_WEBRTC_DIRECT2 as CODE_P2P_WEBRTC_DIRECT,
  CODE_P2P_WEBRTC_STAR2 as CODE_P2P_WEBRTC_STAR,
  CODE_P2P_WEBSOCKET_STAR2 as CODE_P2P_WEBSOCKET_STAR,
  CODE_QUIC2 as CODE_QUIC,
  CODE_QUIC_V12 as CODE_QUIC_V1,
  CODE_SCTP2 as CODE_SCTP,
  CODE_SNI2 as CODE_SNI,
  CODE_TCP2 as CODE_TCP,
  CODE_TLS2 as CODE_TLS,
  CODE_UDP2 as CODE_UDP,
  CODE_UDT2 as CODE_UDT,
  CODE_UNIX2 as CODE_UNIX,
  CODE_UTP2 as CODE_UTP,
  CODE_WEBRTC2 as CODE_WEBRTC,
  CODE_WEBRTC_DIRECT2 as CODE_WEBRTC_DIRECT,
  CODE_WEBTRANSPORT2 as CODE_WEBTRANSPORT,
  CODE_WS2 as CODE_WS,
  CODE_WSS2 as CODE_WSS,
  Circuit,
  CodeError,
  ConnectionClosedError2 as ConnectionClosedError,
  ConnectionClosingError2 as ConnectionClosingError,
  ConnectionFailedError2 as ConnectionFailedError,
  CuckooFilter,
  DEFAULT_FAILURE_MULTIPLIER,
  DEFAULT_INTERVAL,
  DEFAULT_MAX_TIMEOUT,
  DEFAULT_MIN_TIMEOUT,
  DEFAULT_TIMEOUT_MULTIPLIER,
  DNS,
  DNS4,
  DNS6,
  DNSADDR,
  DialError2 as DialError,
  EventTypes,
  GoAwayCode,
  GossipSub,
  HTTP,
  HTTPS,
  HTTP_PING_PROTOCOL,
  HTTP_PROTOCOL2 as HTTP_PROTOCOL,
  IDBDatastore,
  IP,
  IP4,
  IP6,
  IP_OR_DOMAIN,
  InvalidCIDError2 as InvalidCIDError,
  InvalidCryptoExchangeError2 as InvalidCryptoExchangeError,
  InvalidDataLengthError2 as InvalidDataLengthError,
  InvalidDataLengthLengthError2 as InvalidDataLengthLengthError,
  InvalidMessageError2 as InvalidMessageError,
  InvalidMessageLengthError2 as InvalidMessageLengthError,
  InvalidMultiaddrError2 as InvalidMultiaddrError,
  InvalidMultihashError2 as InvalidMultihashError,
  InvalidParametersError2 as InvalidParametersError,
  InvalidPeerIdError2 as InvalidPeerIdError,
  InvalidPrivateKeyError2 as InvalidPrivateKeyError,
  InvalidPublicKeyError2 as InvalidPublicKeyError,
  KEEP_ALIVE,
  KeyTransformDatastore,
  LengthPrefixedDecoder,
  LimitedConnectionError2 as LimitedConnectionError,
  ListenError2 as ListenError,
  MaxEarlyStreamsError,
  MaxLengthError,
  MaxSizeError,
  Memory,
  MemoryBlockstore,
  MemoryDatastore,
  MemoryStorage,
  MessageType,
  MockStream,
  MountDatastore,
  MovingAverage,
  MuxerClosedError2 as MuxerClosedError,
  NamespaceDatastore,
  NoMessagesFoundError,
  NotFoundError2 as NotFoundError,
  NotImplementedError2 as NotImplementedError,
  NotStartedError2 as NotStartedError,
  P2P,
  PEER_ID,
  PING_PROTOCOL,
  ParseError,
  PeerQueue,
  PriorityQueue,
  ProtocolError2 as ProtocolError,
  PubSubPeerDiscovery,
  QUIC,
  QUIC_V1,
  Queue,
  QueueFullError,
  RELAY_V2_HOP_CODEC,
  RELAY_V2_STOP_CODEC,
  RateLimitError,
  RateLimiter,
  Libp2pRecord as Record,
  ScalableCuckooFilter,
  ShardingDatastore,
  StreamAbortEvent,
  StreamAbortedError,
  StreamBufferError,
  StreamCloseEvent,
  StreamClosedError,
  StreamMessageEvent,
  StreamResetError2 as StreamResetError,
  StreamResetEvent,
  StreamStateError2 as StreamStateError,
  StrictNoSign2 as StrictNoSign,
  StrictSign2 as StrictSign,
  TCP,
  TOPIC,
  TieredBlockstore,
  TieredDatastore,
  TimeoutError2 as TimeoutError,
  TooManyInboundProtocolStreamsError2 as TooManyInboundProtocolStreamsError,
  TooManyOutboundProtocolStreamsError2 as TooManyOutboundProtocolStreamsError,
  TopicValidatorResult2 as TopicValidatorResult,
  TypedEventEmitter,
  UDP,
  UnexpectedEOFError2 as UnexpectedEOFError,
  UnexpectedPeerError2 as UnexpectedPeerError,
  Unix,
  UnsupportedKeyTypeError2 as UnsupportedKeyTypeError,
  UnsupportedOperationError2 as UnsupportedOperationError,
  UnsupportedProtocolError2 as UnsupportedProtocolError,
  UnwrappedError,
  V2 as V,
  VENDOR_INFO,
  VENDOR_STATUS,
  WELL_KNOWN_PROTOCOLS_PATH,
  WebRTC,
  WebRTCDirect,
  WebSockets,
  WebSocketsSecure,
  WebTransport,
  authenticatedRoute,
  authenticatedWebSocketRoute,
  bootstrap,
  byteStream,
  circuitRelayServer,
  circuitRelayTransport,
  connectionSymbol,
  contentRoutingSymbol,
  createBloomFilter,
  createCuckooFilter,
  createLibp2p,
  createScalableCuckooFilter,
  dcutr,
  debounce,
  decodeMessage,
  index_default as default,
  defaultLogger,
  disable,
  dnsaddrResolver,
  echo,
  echoStream,
  enable,
  enabled,
  encodeMessage,
  enumeration,
  fetch2 as fetch,
  floodsub,
  getNetConfig,
  getThinWaistAddresses,
  gossipsub,
  hasDependency,
  index_browser_exports2 as hmac,
  http,
  identify,
  identifyPush,
  ipPortToMultiaddr,
  isAsyncGenerator,
  isConnection,
  isGenerator,
  isGlobalUnicast,
  isGlobalUnicastIp,
  isLibp2p,
  isLinkLocal,
  isLinkLocalIp,
  isLoopback,
  isMultiaddr,
  isNetworkAddress,
  isPeerId2 as isPeerId,
  isPrivate,
  isPrivateIp,
  isPrivateKey,
  isPromise2 as isPromise,
  isPubSub2 as isPubSub,
  isPublicKey,
  isStartable,
  kadDHT,
  keys_exports2 as keys,
  logger,
  lpStream,
  message,
  messageStreamToDuplex,
  mockMuxer,
  multiaddr,
  multiaddrConnectionPair,
  noise,
  passthroughMapper,
  pbStream,
  pbkdf22 as pbkdf2,
  peerDiscoverySymbol,
  peerIdFromCID3 as peerIdFromCID,
  peerIdFromMultihash3 as peerIdFromMultihash,
  peerIdFromPrivateKey3 as peerIdFromPrivateKey,
  peerIdFromPublicKey3 as peerIdFromPublicKey,
  peerIdFromString3 as peerIdFromString,
  peerIdSymbol2 as peerIdSymbol,
  peerLogger,
  peerRoutingSymbol,
  persistentPeerStore,
  ping,
  pingHTTP,
  pipe2 as pipe,
  prefixLogger,
  protocol,
  pubSubSymbol2 as pubSubSymbol,
  pubsubPeerDiscovery,
  pureJsCrypto,
  randomBytes2 as randomBytes,
  createReader as reader,
  registry2 as registry,
  removePrivateAddressesMapper,
  removePublicAddressesMapper,
  repeatingTask,
  serviceCapabilities2 as serviceCapabilities,
  serviceDependencies2 as serviceDependencies,
  setMaxListeners,
  shard_exports as shard,
  start,
  stop,
  streamPair,
  symbol3 as symbol,
  trackedList,
  trackedMap,
  transportSymbol,
  webRTC,
  webRTCDirect,
  webSocketRoute,
  webSockets,
  webTransport,
  createWriter as writer,
  yamux
};
//# sourceMappingURL=vendor.bundle.mjs.map
